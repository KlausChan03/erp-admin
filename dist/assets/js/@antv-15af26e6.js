import { _ as __spreadArrays, a as __extends$2, b as __spreadArray, c as __assign$1, d as __rest } from "./tslib-ca86d7fb.js";
import { d as detect } from "./detect-browser-3458fdcd.js";
import { m as multiply, f as fromRotation, a as angle, b as fromTranslation, c as fromScaling, e as exactEquals, n as normalize, d as dot$1, g as min$2, h as max$2, s as sub, i as scale$2, j as distance$6, k as add, t as transformMat3, l as invert$2, o as subtract, p as length, q as transformMat3$1 } from "./gl-matrix-41ea8061.js";
import { d as d3Ease } from "./d3-ease-a82c91a3.js";
import { i as interpolate, a as interpolateArray } from "./d3-interpolate-d19ec80d.js";
import { t as timer } from "./d3-timer-29ea6e13.js";
import { f as fecha1, a as fecha } from "./fecha-7b6e87e1.js";
import { b as bind_1 } from "./size-sensor-ba076d7e.js";
import { e as exponential, l as linear$1, a as loess, b as logarithmic, p as polynomial, c as power, q as quad } from "./d3-regression-e5d6f1c6.js";
import { p as pdf } from "./pdfast-e3a16ab3.js";
import { n as nelderMead, a as norm2, z as zeros, c as conjugateGradient, s as scale$3, b as bisect, d as zerosM } from "./fmin-29e03d32.js";
import { p as partition$1, h as hierarchy, d as d3Hierarchy, i as index, a as index$1 } from "./d3-hierarchy-82895eaf.js";
var Shape$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get Base() {
    return ShapeBase$3;
  },
  get Circle() {
    return Circle$4;
  },
  get Ellipse() {
    return Ellipse$3;
  },
  get Image() {
    return ImageShape$1;
  },
  get Line() {
    return Line$5;
  },
  get Marker() {
    return Marker$3;
  },
  get Path() {
    return Path$4;
  },
  get Polygon() {
    return Polygon$4;
  },
  get Polyline() {
    return PolyLine$1;
  },
  get Rect() {
    return Rect$4;
  },
  get Text() {
    return Text$3;
  }
});
var Shape = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get Base() {
    return ShapeBase$1;
  },
  get Circle() {
    return Circle$2;
  },
  get Dom() {
    return Dom$1;
  },
  get Ellipse() {
    return Ellipse$1;
  },
  get Image() {
    return Image$2;
  },
  get Line() {
    return Line$3;
  },
  get Marker() {
    return Marker$1;
  },
  get Path() {
    return Path$2;
  },
  get Polygon() {
    return Polygon$2;
  },
  get Polyline() {
    return Polyline$1;
  },
  get Rect() {
    return Rect$2;
  },
  get Text() {
    return Text$1;
  }
});
var isArrayLike = function(value2) {
  return value2 !== null && typeof value2 !== "function" && isFinite(value2.length);
};
var contains = function(arr, value2) {
  if (!isArrayLike(arr)) {
    return false;
  }
  return arr.indexOf(value2) > -1;
};
var filter = function(arr, func) {
  if (!isArrayLike(arr)) {
    return arr;
  }
  var result = [];
  for (var index2 = 0; index2 < arr.length; index2++) {
    var value2 = arr[index2];
    if (func(value2, index2)) {
      result.push(value2);
    }
  }
  return result;
};
var difference = function(arr, values2) {
  if (values2 === void 0) {
    values2 = [];
  }
  return filter(arr, function(value2) {
    return !contains(values2, value2);
  });
};
var toString$3 = {}.toString;
var isType$1 = function(value2, type) {
  return toString$3.call(value2) === "[object " + type + "]";
};
var isFunction = function(value2) {
  return isType$1(value2, "Function");
};
var isNil = function(value2) {
  return value2 === null || value2 === void 0;
};
var isArray$1 = function(value2) {
  return Array.isArray ? Array.isArray(value2) : isType$1(value2, "Array");
};
var isObject = function(value2) {
  var type = typeof value2;
  return value2 !== null && type === "object" || type === "function";
};
function each$1(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (isArray$1(elements)) {
    for (var i = 0, len = elements.length; i < len; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if (isObject(elements)) {
    for (var k in elements) {
      if (elements.hasOwnProperty(k)) {
        rst = func(elements[k], k);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var keys = Object.keys ? function(obj) {
  return Object.keys(obj);
} : function(obj) {
  var result = [];
  each$1(obj, function(value2, key) {
    if (!(isFunction(obj) && key === "prototype")) {
      result.push(key);
    }
  });
  return result;
};
function isMatch(obj, attrs) {
  var _keys = keys(attrs);
  var length2 = _keys.length;
  if (isNil(obj))
    return !length2;
  for (var i = 0; i < length2; i += 1) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) {
      return false;
    }
  }
  return true;
}
var isObjectLike$1 = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var isPlainObject$1 = function(value2) {
  if (!isObjectLike$1(value2) || !isType$1(value2, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value2) === null) {
    return true;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
function find$1(arr, predicate) {
  if (!isArray$1(arr))
    return null;
  var _predicate;
  if (isFunction(predicate)) {
    _predicate = predicate;
  }
  if (isPlainObject$1(predicate)) {
    _predicate = function(a) {
      return isMatch(a, predicate);
    };
  }
  if (_predicate) {
    for (var i = 0; i < arr.length; i += 1) {
      if (_predicate(arr[i])) {
        return arr[i];
      }
    }
  }
  return null;
}
function findIndex(arr, predicate, fromIndex) {
  if (fromIndex === void 0) {
    fromIndex = 0;
  }
  for (var i = fromIndex; i < arr.length; i++) {
    if (predicate(arr[i], i)) {
      return i;
    }
  }
  return -1;
}
var firstValue = function(data2, name) {
  var rst = null;
  for (var i = 0; i < data2.length; i++) {
    var obj = data2[i];
    var value2 = obj[name];
    if (!isNil(value2)) {
      if (isArray$1(value2)) {
        rst = value2[0];
      } else {
        rst = value2;
      }
      break;
    }
  }
  return rst;
};
var flatten = function(arr) {
  if (!isArray$1(arr)) {
    return [];
  }
  var rst = [];
  for (var i = 0; i < arr.length; i++) {
    rst = rst.concat(arr[i]);
  }
  return rst;
};
var max$1 = function(arr) {
  if (!isArray$1(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.max(prev, curr);
  }, arr[0]);
};
var min$1 = function(arr) {
  if (!isArray$1(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.min(prev, curr);
  }, arr[0]);
};
var getRange = function(values2) {
  var filterValues = values2.filter(function(v) {
    return !isNaN(v);
  });
  if (!filterValues.length) {
    return {
      min: 0,
      max: 0
    };
  }
  if (isArray$1(values2[0])) {
    var tmp = [];
    for (var i = 0; i < values2.length; i++) {
      tmp = tmp.concat(values2[i]);
    }
    filterValues = tmp;
  }
  var max2 = max$1(filterValues);
  var min2 = min$1(filterValues);
  return {
    min: min2,
    max: max2
  };
};
var splice = Array.prototype.splice;
var pullAt = function pullAt2(arr, indexes) {
  if (!isArrayLike(arr)) {
    return [];
  }
  var length2 = arr ? indexes.length : 0;
  var last2 = length2 - 1;
  while (length2--) {
    var previous = void 0;
    var index2 = indexes[length2];
    if (length2 === last2 || index2 !== previous) {
      previous = index2;
      splice.call(arr, index2, 1);
    }
  }
  return arr;
};
var reduce = function(arr, fn, init) {
  if (!isArray$1(arr) && !isPlainObject$1(arr)) {
    return arr;
  }
  var result = init;
  each$1(arr, function(data2, i) {
    result = fn(result, data2, i);
  });
  return result;
};
var remove = function(arr, predicate) {
  var result = [];
  if (!isArrayLike(arr)) {
    return result;
  }
  var i = -1;
  var indexes = [];
  var length2 = arr.length;
  while (++i < length2) {
    var value2 = arr[i];
    if (predicate(value2, i, arr)) {
      result.push(value2);
      indexes.push(i);
    }
  }
  pullAt(arr, indexes);
  return result;
};
var isString = function(str) {
  return isType$1(str, "String");
};
function sortBy(arr, key) {
  var comparer;
  if (isFunction(key)) {
    comparer = function(a, b) {
      return key(a) - key(b);
    };
  } else {
    var keys_1 = [];
    if (isString(key)) {
      keys_1.push(key);
    } else if (isArray$1(key)) {
      keys_1 = key;
    }
    comparer = function(a, b) {
      for (var i = 0; i < keys_1.length; i += 1) {
        var prop = keys_1[i];
        if (a[prop] > b[prop]) {
          return 1;
        }
        if (a[prop] < b[prop]) {
          return -1;
        }
      }
      return 0;
    };
  }
  arr.sort(comparer);
  return arr;
}
function uniq$2(arr, cache2) {
  if (cache2 === void 0) {
    cache2 = new Map();
  }
  var r = [];
  if (Array.isArray(arr)) {
    for (var i = 0, len = arr.length; i < len; i++) {
      var item = arr[i];
      if (!cache2.has(item)) {
        r.push(item);
        cache2.set(item, true);
      }
    }
  }
  return r;
}
var valuesOfKey = function(data2, name) {
  var rst = [];
  var tmpMap = {};
  for (var i = 0; i < data2.length; i++) {
    var obj = data2[i];
    var value2 = obj[name];
    if (!isNil(value2)) {
      if (!isArray$1(value2)) {
        value2 = [value2];
      }
      for (var j = 0; j < value2.length; j++) {
        var val = value2[j];
        if (!tmpMap[val]) {
          rst.push(val);
          tmpMap[val] = true;
        }
      }
    }
  }
  return rst;
};
function head(o) {
  if (isArrayLike(o)) {
    return o[0];
  }
  return void 0;
}
function last(o) {
  if (isArrayLike(o)) {
    var arr = o;
    return arr[arr.length - 1];
  }
  return void 0;
}
var every = function(arr, func) {
  for (var i = 0; i < arr.length; i++) {
    if (!func(arr[i], i))
      return false;
  }
  return true;
};
var some = function(arr, func) {
  for (var i = 0; i < arr.length; i++) {
    if (func(arr[i], i))
      return true;
  }
  return false;
};
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function groupBy(data2, condition) {
  if (!condition || !isArray$1(data2)) {
    return {};
  }
  var result = {};
  var predicate = isFunction(condition) ? condition : function(item2) {
    return item2[condition];
  };
  var key;
  for (var i = 0; i < data2.length; i++) {
    var item = data2[i];
    key = predicate(item);
    if (hasOwnProperty$2.call(result, key)) {
      result[key].push(item);
    } else {
      result[key] = [item];
    }
  }
  return result;
}
function groupToMap(data2, condition) {
  if (!condition) {
    return {
      0: data2
    };
  }
  if (!isFunction(condition)) {
    var paramscondition_1 = isArray$1(condition) ? condition : condition.replace(/\s+/g, "").split("*");
    condition = function(row) {
      var unique = "_";
      for (var i = 0, l = paramscondition_1.length; i < l; i++) {
        unique += row[paramscondition_1[i]] && row[paramscondition_1[i]].toString();
      }
      return unique;
    };
  }
  return groupBy(data2, condition);
}
var group$1 = function(data2, condition) {
  if (!condition) {
    return [data2];
  }
  var groups = groupToMap(data2, condition);
  var array = [];
  for (var i in groups) {
    array.push(groups[i]);
  }
  return array;
};
var clamp = function(a, min2, max2) {
  if (a < min2) {
    return min2;
  } else if (a > max2) {
    return max2;
  }
  return a;
};
var fixedBase = function(v, base) {
  var str = base.toString();
  var index2 = str.indexOf(".");
  if (index2 === -1) {
    return Math.round(v);
  }
  var length2 = str.substr(index2 + 1).length;
  if (length2 > 20) {
    length2 = 20;
  }
  return parseFloat(v.toFixed(length2));
};
var isNumber$1 = function(value2) {
  return isType$1(value2, "Number");
};
var PRECISION = 1e-5;
function isNumberEqual$1(a, b, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return Math.abs(a - b) < precision;
}
var maxBy = function(arr, fn) {
  if (!isArray$1(arr)) {
    return void 0;
  }
  var maxItem;
  var max2 = -Infinity;
  for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    var v = isFunction(fn) ? fn(item) : item[fn];
    if (v > max2) {
      maxItem = item;
      max2 = v;
    }
  }
  return maxItem;
};
var minBy = function(arr, fn) {
  if (!isArray$1(arr)) {
    return void 0;
  }
  var minItem;
  var min2 = Infinity;
  for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    var v = isFunction(fn) ? fn(item) : item[fn];
    if (v < min2) {
      minItem = item;
      min2 = v;
    }
  }
  return minItem;
};
var mod$1 = function(n, m) {
  return (n % m + m) % m;
};
var RADIAN = Math.PI / 180;
var toRadian = function(degree) {
  return RADIAN * degree;
};
var has = function(obj, key) {
  return obj.hasOwnProperty(key);
};
var values = Object.values ? function(obj) {
  return Object.values(obj);
} : function(obj) {
  var result = [];
  each$1(obj, function(value2, key) {
    if (!(isFunction(obj) && key === "prototype")) {
      result.push(value2);
    }
  });
  return result;
};
var toString$2 = function(value2) {
  if (isNil(value2))
    return "";
  return value2.toString();
};
var lowerCase = function(str) {
  return toString$2(str).toLowerCase();
};
function substitute(str, o) {
  if (!str || !o) {
    return str;
  }
  return str.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
    if (match.charAt(0) === "\\") {
      return match.slice(1);
    }
    return o[name] === void 0 ? "" : o[name];
  });
}
var upperFirst = function(value2) {
  var str = toString$2(value2);
  return str.charAt(0).toUpperCase() + str.substring(1);
};
var toString$1 = {}.toString;
var getType = function(value2) {
  return toString$1.call(value2).replace(/^\[object /, "").replace(/]$/, "");
};
var isBoolean = function(value2) {
  return isType$1(value2, "Boolean");
};
var isDate = function(value2) {
  return isType$1(value2, "Date");
};
var isNull = function(value2) {
  return value2 === null;
};
var objectProto = Object.prototype;
var isPrototype = function(value2) {
  var Ctor = value2 && value2.constructor;
  var proto = typeof Ctor === "function" && Ctor.prototype || objectProto;
  return value2 === proto;
};
var isUndefined = function(value2) {
  return value2 === void 0;
};
var isElement = function(o) {
  return o instanceof Element || o instanceof HTMLDocument;
};
function requestAnimationFrame(fn) {
  var method = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(f) {
    return setTimeout(f, 16);
  };
  return method(fn);
}
function cancelAnimationFrame(handler) {
  var method = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame || clearTimeout;
  method(handler);
}
function _mix(dist, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
      dist[key] = obj[key];
    }
  }
}
function mix(dist, src1, src2, src3) {
  if (src1)
    _mix(dist, src1);
  if (src2)
    _mix(dist, src2);
  if (src3)
    _mix(dist, src3);
  return dist;
}
var clone = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  var rst;
  if (isArray$1(obj)) {
    rst = [];
    for (var i = 0, l = obj.length; i < l; i++) {
      if (typeof obj[i] === "object" && obj[i] != null) {
        rst[i] = clone(obj[i]);
      } else {
        rst[i] = obj[i];
      }
    }
  } else {
    rst = {};
    for (var k in obj) {
      if (typeof obj[k] === "object" && obj[k] != null) {
        rst[k] = clone(obj[k]);
      } else {
        rst[k] = obj[k];
      }
    }
  }
  return rst;
};
function debounce(func, wait, immediate) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
var memoize = function(f, resolver) {
  if (!isFunction(f)) {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = f.apply(this, args);
    cache2.set(key, result);
    return result;
  };
  memoized.cache = new Map();
  return memoized;
};
var MAX_MIX_LEVEL$1 = 5;
function _deepMix(dist, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL$1;
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      var value2 = src[key];
      if (value2 !== null && isPlainObject$1(value2)) {
        if (!isPlainObject$1(dist[key])) {
          dist[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist[key], value2, level + 1, maxLevel);
        } else {
          dist[key] = src[key];
        }
      } else if (isArray$1(value2)) {
        dist[key] = [];
        dist[key] = dist[key].concat(value2);
      } else if (value2 !== void 0) {
        dist[key] = value2;
      }
    }
  }
}
var deepMix = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    _deepMix(rst, args[i]);
  }
  return rst;
};
var indexOf = function(arr, obj) {
  if (!isArrayLike(arr)) {
    return -1;
  }
  var m = Array.prototype.indexOf;
  if (m) {
    return m.call(arr, obj);
  }
  var index2 = -1;
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === obj) {
      index2 = i;
      break;
    }
  }
  return index2;
};
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
function isEmpty(value2) {
  if (isNil(value2)) {
    return true;
  }
  if (isArrayLike(value2)) {
    return !value2.length;
  }
  var type = getType(value2);
  if (type === "Map" || type === "Set") {
    return !value2.size;
  }
  if (isPrototype(value2)) {
    return !Object.keys(value2).length;
  }
  for (var key in value2) {
    if (hasOwnProperty$1.call(value2, key)) {
      return false;
    }
  }
  return true;
}
var isEqual$2 = function(value2, other2) {
  if (value2 === other2) {
    return true;
  }
  if (!value2 || !other2) {
    return false;
  }
  if (isString(value2) || isString(other2)) {
    return false;
  }
  if (isArrayLike(value2) || isArrayLike(other2)) {
    if (value2.length !== other2.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < value2.length; i++) {
      rst = isEqual$2(value2[i], other2[i]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  if (isObjectLike$1(value2) || isObjectLike$1(other2)) {
    var valueKeys = Object.keys(value2);
    var otherKeys = Object.keys(other2);
    if (valueKeys.length !== otherKeys.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < valueKeys.length; i++) {
      rst = isEqual$2(value2[valueKeys[i]], other2[valueKeys[i]]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  return false;
};
var map$2 = function(arr, func) {
  if (!isArrayLike(arr)) {
    return arr;
  }
  var result = [];
  for (var index2 = 0; index2 < arr.length; index2++) {
    var value2 = arr[index2];
    result.push(func(value2, index2));
  }
  return result;
};
var identity = function(v) {
  return v;
};
var mapValues = function(object, func) {
  if (func === void 0) {
    func = identity;
  }
  var r = {};
  if (isObject(object) && !isNil(object)) {
    Object.keys(object).forEach(function(key) {
      r[key] = func(object[key], key);
    });
  }
  return r;
};
var get = function(obj, key, defaultValue) {
  var p = 0;
  var keyArr = isString(key) ? key.split(".") : key;
  while (obj && p < keyArr.length) {
    obj = obj[keyArr[p++]];
  }
  return obj === void 0 || p < keyArr.length ? defaultValue : obj;
};
var set = function(obj, path2, value2) {
  var o = obj;
  var keyArr = isString(path2) ? path2.split(".") : path2;
  keyArr.forEach(function(key, idx) {
    if (idx < keyArr.length - 1) {
      if (!isObject(o[key])) {
        o[key] = isNumber$1(keyArr[idx + 1]) ? [] : {};
      }
      o = o[key];
    } else {
      o[key] = value2;
    }
  });
  return obj;
};
var hasOwnProperty = Object.prototype.hasOwnProperty;
var pick$1 = function(object, keys2) {
  if (object === null || !isPlainObject$1(object)) {
    return {};
  }
  var result = {};
  each$1(keys2, function(key) {
    if (hasOwnProperty.call(object, key)) {
      result[key] = object[key];
    }
  });
  return result;
};
var omit$1 = function(obj, keys2) {
  return reduce(obj, function(r, curr, key) {
    if (!keys2.includes(key)) {
      r[key] = curr;
    }
    return r;
  }, {});
};
var throttle = function(func, wait, options) {
  var timeout, context, args, result;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : Date.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout)
      context = args = null;
  };
  var throttled = function() {
    var now = Date.now();
    if (!previous && options.leading === false)
      previous = now;
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout)
        context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled;
};
var toArray = function(value2) {
  return isArrayLike(value2) ? Array.prototype.slice.call(value2) : [];
};
var map$1 = {};
var uniqueId = function(prefix) {
  prefix = prefix || "g";
  if (!map$1[prefix]) {
    map$1[prefix] = 1;
  } else {
    map$1[prefix] += 1;
  }
  return prefix + map$1[prefix];
};
var noop = function() {
};
function size(o) {
  if (isNil(o)) {
    return 0;
  }
  if (isArrayLike(o)) {
    return o.length;
  }
  return Object.keys(o).length;
}
var ctx$2;
var measureTextWidth$2 = memoize(function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (!ctx$2) {
    ctx$2 = document.createElement("canvas").getContext("2d");
  }
  ctx$2.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
  return ctx$2.measureText(isString(text2) ? text2 : "").width;
}, function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text2], values(font)).join("");
});
var getEllipsisText$1 = function(text2, maxWidth, font, str) {
  if (str === void 0) {
    str = "...";
  }
  var STEP = 16;
  var PLACEHOLDER_WIDTH = measureTextWidth$2(str, font);
  var leftText = !isString(text2) ? toString$2(text2) : text2;
  var leftWidth = maxWidth;
  var r = [];
  var currentText;
  var currentWidth;
  if (measureTextWidth$2(text2, font) <= maxWidth) {
    return text2;
  }
  while (true) {
    currentText = leftText.substr(0, STEP);
    currentWidth = measureTextWidth$2(currentText, font);
    if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
      if (currentWidth > leftWidth) {
        break;
      }
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(STEP);
    if (!leftText) {
      return r.join("");
    }
  }
  while (true) {
    currentText = leftText.substr(0, 1);
    currentWidth = measureTextWidth$2(currentText, font);
    if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
      break;
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(1);
    if (!leftText) {
      return r.join("");
    }
  }
  return "" + r.join("") + str;
};
var default_1 = function() {
  function default_12() {
    this.map = {};
  }
  default_12.prototype.has = function(key) {
    return this.map[key] !== void 0;
  };
  default_12.prototype.get = function(key, def) {
    var v = this.map[key];
    return v === void 0 ? def : v;
  };
  default_12.prototype.set = function(key, value2) {
    this.map[key] = value2;
  };
  default_12.prototype.clear = function() {
    this.map = {};
  };
  default_12.prototype.delete = function(key) {
    delete this.map[key];
  };
  default_12.prototype.size = function() {
    return Object.keys(this.map).length;
  };
  return default_12;
}();
var LAYER;
(function(LAYER2) {
  LAYER2["FORE"] = "fore";
  LAYER2["MID"] = "mid";
  LAYER2["BG"] = "bg";
})(LAYER || (LAYER = {}));
var DIRECTION;
(function(DIRECTION2) {
  DIRECTION2["TOP"] = "top";
  DIRECTION2["TOP_LEFT"] = "top-left";
  DIRECTION2["TOP_RIGHT"] = "top-right";
  DIRECTION2["RIGHT"] = "right";
  DIRECTION2["RIGHT_TOP"] = "right-top";
  DIRECTION2["RIGHT_BOTTOM"] = "right-bottom";
  DIRECTION2["LEFT"] = "left";
  DIRECTION2["LEFT_TOP"] = "left-top";
  DIRECTION2["LEFT_BOTTOM"] = "left-bottom";
  DIRECTION2["BOTTOM"] = "bottom";
  DIRECTION2["BOTTOM_LEFT"] = "bottom-left";
  DIRECTION2["BOTTOM_RIGHT"] = "bottom-right";
  DIRECTION2["RADIUS"] = "radius";
  DIRECTION2["CIRCLE"] = "circle";
  DIRECTION2["NONE"] = "none";
})(DIRECTION || (DIRECTION = {}));
var COMPONENT_TYPE;
(function(COMPONENT_TYPE2) {
  COMPONENT_TYPE2["AXIS"] = "axis";
  COMPONENT_TYPE2["GRID"] = "grid";
  COMPONENT_TYPE2["LEGEND"] = "legend";
  COMPONENT_TYPE2["TOOLTIP"] = "tooltip";
  COMPONENT_TYPE2["ANNOTATION"] = "annotation";
  COMPONENT_TYPE2["SLIDER"] = "slider";
  COMPONENT_TYPE2["SCROLLBAR"] = "scrollbar";
  COMPONENT_TYPE2["OTHER"] = "other";
})(COMPONENT_TYPE || (COMPONENT_TYPE = {}));
var GROUP_Z_INDEX = {
  FORE: 3,
  MID: 2,
  BG: 1
};
var VIEW_LIFE_CIRCLE;
(function(VIEW_LIFE_CIRCLE2) {
  VIEW_LIFE_CIRCLE2["BEFORE_RENDER"] = "beforerender";
  VIEW_LIFE_CIRCLE2["AFTER_RENDER"] = "afterrender";
  VIEW_LIFE_CIRCLE2["BEFORE_PAINT"] = "beforepaint";
  VIEW_LIFE_CIRCLE2["AFTER_PAINT"] = "afterpaint";
  VIEW_LIFE_CIRCLE2["BEFORE_CHANGE_DATA"] = "beforechangedata";
  VIEW_LIFE_CIRCLE2["AFTER_CHANGE_DATA"] = "afterchangedata";
  VIEW_LIFE_CIRCLE2["BEFORE_CLEAR"] = "beforeclear";
  VIEW_LIFE_CIRCLE2["AFTER_CLEAR"] = "afterclear";
  VIEW_LIFE_CIRCLE2["BEFORE_DESTROY"] = "beforedestroy";
  VIEW_LIFE_CIRCLE2["BEFORE_CHANGE_SIZE"] = "beforechangesize";
  VIEW_LIFE_CIRCLE2["AFTER_CHANGE_SIZE"] = "afterchangesize";
})(VIEW_LIFE_CIRCLE || (VIEW_LIFE_CIRCLE = {}));
var GEOMETRY_LIFE_CIRCLE;
(function(GEOMETRY_LIFE_CIRCLE2) {
  GEOMETRY_LIFE_CIRCLE2["BEFORE_DRAW_ANIMATE"] = "beforeanimate";
  GEOMETRY_LIFE_CIRCLE2["AFTER_DRAW_ANIMATE"] = "afteranimate";
})(GEOMETRY_LIFE_CIRCLE || (GEOMETRY_LIFE_CIRCLE = {}));
var PLOT_EVENTS;
(function(PLOT_EVENTS2) {
  PLOT_EVENTS2["MOUSE_ENTER"] = "plot:mouseenter";
  PLOT_EVENTS2["MOUSE_DOWN"] = "plot:mousedown";
  PLOT_EVENTS2["MOUSE_MOVE"] = "plot:mousemove";
  PLOT_EVENTS2["MOUSE_UP"] = "plot:mouseup";
  PLOT_EVENTS2["MOUSE_LEAVE"] = "plot:mouseleave";
  PLOT_EVENTS2["TOUCH_START"] = "plot:touchstart";
  PLOT_EVENTS2["TOUCH_MOVE"] = "plot:touchmove";
  PLOT_EVENTS2["TOUCH_END"] = "plot:touchend";
  PLOT_EVENTS2["TOUCH_CANCEL"] = "plot:touchcancel";
  PLOT_EVENTS2["CLICK"] = "plot:click";
  PLOT_EVENTS2["DBLCLICK"] = "plot:dblclick";
  PLOT_EVENTS2["CONTEXTMENU"] = "plot:contextmenu";
  PLOT_EVENTS2["LEAVE"] = "plot:leave";
  PLOT_EVENTS2["ENTER"] = "plot:enter";
})(PLOT_EVENTS || (PLOT_EVENTS = {}));
var ELEMENT_STATE;
(function(ELEMENT_STATE2) {
  ELEMENT_STATE2["ACTIVE"] = "active";
  ELEMENT_STATE2["INACTIVE"] = "inactive";
  ELEMENT_STATE2["SELECTED"] = "selected";
  ELEMENT_STATE2["DEFAULT"] = "default";
})(ELEMENT_STATE || (ELEMENT_STATE = {}));
var GROUP_ATTRS = ["color", "shape", "size"];
var FIELD_ORIGIN = "_origin";
var MIN_CHART_WIDTH = 1;
var MIN_CHART_HEIGHT = 1;
var COMPONENT_MAX_VIEW_PERCENTAGE = 0.25;
var ENGINES = {};
function getEngine(name) {
  var G = ENGINES[name];
  if (!G) {
    throw new Error("G engine '" + name + "' is not exist, please register it at first.");
  }
  return G;
}
function registerEngine(name, engine) {
  ENGINES[name] = engine;
}
function addEventListener(target, eventType, callback) {
  if (target) {
    if (typeof target.addEventListener === "function") {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    }
    if (typeof target.attachEvent === "function") {
      target.attachEvent("on" + eventType, callback);
      return {
        remove: function() {
          target.detachEvent("on" + eventType, callback);
        }
      };
    }
  }
}
var TABLE;
var TABLE_TR;
var FRAGMENT_REG;
var CONTAINERS;
function initConstants() {
  TABLE = document.createElement("table");
  TABLE_TR = document.createElement("tr");
  FRAGMENT_REG = /^\s*<(\w+|!)[^>]*>/;
  CONTAINERS = {
    tr: document.createElement("tbody"),
    tbody: TABLE,
    thead: TABLE,
    tfoot: TABLE,
    td: TABLE_TR,
    th: TABLE_TR,
    "*": document.createElement("div")
  };
}
function createDom$1(str) {
  if (!TABLE) {
    initConstants();
  }
  var name = FRAGMENT_REG.test(str) && RegExp.$1;
  if (!name || !(name in CONTAINERS)) {
    name = "*";
  }
  var container = CONTAINERS[name];
  str = str.replace(/(^\s*)|(\s*$)/g, "");
  container.innerHTML = "" + str;
  var dom = container.childNodes[0];
  container.removeChild(dom);
  return dom;
}
function getStyle$1(dom, name, defaultValue) {
  var v;
  try {
    v = window.getComputedStyle ? window.getComputedStyle(dom, null)[name] : dom.style[name];
  } catch (e) {
  } finally {
    v = v === void 0 ? defaultValue : v;
  }
  return v;
}
function getHeight$1(el, defaultValue) {
  var height = getStyle$1(el, "height", defaultValue);
  if (height === "auto") {
    height = el.offsetHeight;
  }
  return parseFloat(height);
}
function getOuterHeight(el, defaultValue) {
  var height = getHeight$1(el, defaultValue);
  var bTop = parseFloat(getStyle$1(el, "borderTopWidth")) || 0;
  var pTop = parseFloat(getStyle$1(el, "paddingTop")) || 0;
  var pBottom = parseFloat(getStyle$1(el, "paddingBottom")) || 0;
  var bBottom = parseFloat(getStyle$1(el, "borderBottomWidth")) || 0;
  var mTop = parseFloat(getStyle$1(el, "marginTop")) || 0;
  var mBottom = parseFloat(getStyle$1(el, "marginBottom")) || 0;
  return height + bTop + bBottom + pTop + pBottom + mTop + mBottom;
}
function getHeight(el, defaultValue) {
  var width = getStyle$1(el, "width", defaultValue);
  if (width === "auto") {
    width = el.offsetWidth;
  }
  return parseFloat(width);
}
function getOuterWidth(el, defaultValue) {
  var width = getHeight(el, defaultValue);
  var bLeft = parseFloat(getStyle$1(el, "borderLeftWidth")) || 0;
  var pLeft = parseFloat(getStyle$1(el, "paddingLeft")) || 0;
  var pRight = parseFloat(getStyle$1(el, "paddingRight")) || 0;
  var bRight = parseFloat(getStyle$1(el, "borderRightWidth")) || 0;
  var mRight = parseFloat(getStyle$1(el, "marginRight")) || 0;
  var mLeft = parseFloat(getStyle$1(el, "marginLeft")) || 0;
  return width + bLeft + bRight + pLeft + pRight + mLeft + mRight;
}
function modifyCSS(dom, css) {
  if (dom) {
    for (var key in css) {
      if (css.hasOwnProperty(key)) {
        dom.style[key] = css[key];
      }
    }
  }
  return dom;
}
function getElementSize(ele) {
  var style = getComputedStyle(ele);
  return {
    width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
    height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
  };
}
function isNumber(v) {
  return typeof v === "number" && !isNaN(v);
}
function getChartSize(ele, autoFit, width, height) {
  var w = width;
  var h = height;
  if (autoFit) {
    var size2 = getElementSize(ele);
    w = size2.width ? size2.width : w;
    h = size2.height ? size2.height : h;
  }
  return {
    width: Math.max(isNumber(w) ? w : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
    height: Math.max(isNumber(h) ? h : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT)
  };
}
function removeDom(dom) {
  var parent = dom.parentNode;
  if (parent) {
    parent.removeChild(dom);
  }
}
var WILDCARD$2 = "*";
var EventEmitter = function() {
  function EventEmitter2() {
    this._events = {};
  }
  EventEmitter2.prototype.on = function(evt, callback, once) {
    if (!this._events[evt]) {
      this._events[evt] = [];
    }
    this._events[evt].push({
      callback,
      once: !!once
    });
    return this;
  };
  EventEmitter2.prototype.once = function(evt, callback) {
    this.on(evt, callback, true);
    return this;
  };
  EventEmitter2.prototype.emit = function(evt) {
    var _this = this;
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var events = this._events[evt] || [];
    var wildcardEvents = this._events[WILDCARD$2] || [];
    var doEmit = function(es) {
      var length2 = es.length;
      for (var i = 0; i < length2; i++) {
        if (!es[i]) {
          continue;
        }
        var _a2 = es[i], callback = _a2.callback, once = _a2.once;
        if (once) {
          es.splice(i, 1);
          if (es.length === 0) {
            delete _this._events[evt];
          }
          length2--;
          i--;
        }
        callback.apply(_this, args);
      }
    };
    doEmit(events);
    doEmit(wildcardEvents);
  };
  EventEmitter2.prototype.off = function(evt, callback) {
    if (!evt) {
      this._events = {};
    } else {
      if (!callback) {
        delete this._events[evt];
      } else {
        var events = this._events[evt] || [];
        var length_1 = events.length;
        for (var i = 0; i < length_1; i++) {
          if (events[i].callback === callback) {
            events.splice(i, 1);
            length_1--;
            i--;
          }
        }
        if (events.length === 0) {
          delete this._events[evt];
        }
      }
    }
    return this;
  };
  EventEmitter2.prototype.getEvents = function() {
    return this._events;
  };
  return EventEmitter2;
}();
var Base$2 = function(_super) {
  __extends$2(Base2, _super);
  function Base2(cfg) {
    var _this = _super.call(this) || this;
    _this.destroyed = false;
    var _a2 = cfg.visible, visible = _a2 === void 0 ? true : _a2;
    _this.visible = visible;
    return _this;
  }
  Base2.prototype.show = function() {
    var visible = this.visible;
    if (!visible) {
      this.changeVisible(true);
    }
  };
  Base2.prototype.hide = function() {
    var visible = this.visible;
    if (visible) {
      this.changeVisible(false);
    }
  };
  Base2.prototype.destroy = function() {
    this.off();
    this.destroyed = true;
  };
  Base2.prototype.changeVisible = function(visible) {
    if (this.visible === visible) {
      return;
    }
    this.visible = visible;
  };
  return Base2;
}(EventEmitter);
var SPACES$2 = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND$2 = new RegExp("([a-z])[" + SPACES$2 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES$2 + "]*,?[" + SPACES$2 + "]*)+)", "ig");
var PATH_VALUES$2 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES$2 + "]*,?[" + SPACES$2 + "]*", "ig");
var parsePathString$2 = function(pathString) {
  if (!pathString) {
    return null;
  }
  if (isArray$1(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data2 = [];
  String(pathString).replace(PATH_COMMAND$2, function(a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES$2, function(a2, b2) {
      b2 && params.push(+b2);
    });
    if (name === "m" && params.length > 2) {
      data2.push([b].concat(params.splice(0, 2)));
      name = "l";
      b = b === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data2.push([b, params[0]]);
    }
    if (name === "r") {
      data2.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data2.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return pathString;
  });
  return data2;
};
var catmullRomToBezier = function(crp, z) {
  var d = [];
  for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
    var p = [
      {
        x: +crp[i - 2],
        y: +crp[i - 1]
      },
      {
        x: +crp[i],
        y: +crp[i + 1]
      },
      {
        x: +crp[i + 2],
        y: +crp[i + 3]
      },
      {
        x: +crp[i + 4],
        y: +crp[i + 5]
      }
    ];
    if (z) {
      if (!i) {
        p[0] = {
          x: +crp[iLen - 2],
          y: +crp[iLen - 1]
        };
      } else if (iLen - 4 === i) {
        p[3] = {
          x: +crp[0],
          y: +crp[1]
        };
      } else if (iLen - 2 === i) {
        p[2] = {
          x: +crp[0],
          y: +crp[1]
        };
        p[3] = {
          x: +crp[2],
          y: +crp[3]
        };
      }
    } else {
      if (iLen - 4 === i) {
        p[3] = p[2];
      } else if (!i) {
        p[0] = {
          x: +crp[i],
          y: +crp[i + 1]
        };
      }
    }
    d.push([
      "C",
      (-p[0].x + 6 * p[1].x + p[2].x) / 6,
      (-p[0].y + 6 * p[1].y + p[2].y) / 6,
      (p[1].x + 6 * p[2].x - p[3].x) / 6,
      (p[1].y + 6 * p[2].y - p[3].y) / 6,
      p[2].x,
      p[2].y
    ]);
  }
  return d;
};
var ellipsePath = function(x, y, rx, ry, a) {
  var res = [];
  if (a === null && ry === null) {
    ry = rx;
  }
  x = +x;
  y = +y;
  rx = +rx;
  ry = +ry;
  if (a !== null) {
    var rad = Math.PI / 180;
    var x1 = x + rx * Math.cos(-ry * rad);
    var x2 = x + rx * Math.cos(-a * rad);
    var y1 = y + rx * Math.sin(-ry * rad);
    var y2 = y + rx * Math.sin(-a * rad);
    res = [
      ["M", x1, y1],
      ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]
    ];
  } else {
    res = [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
  }
  return res;
};
var pathToAbsolute$1 = function(pathArray) {
  pathArray = parsePathString$2(pathArray);
  if (!pathArray || !pathArray.length) {
    return [["M", 0, 0]];
  }
  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  if (pathArray[0][0] === "M") {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res[0] = ["M", x, y];
  }
  var crz = pathArray.length === 3 && pathArray[0][0] === "M" && pathArray[1][0].toUpperCase() === "R" && pathArray[2][0].toUpperCase() === "Z";
  for (var r = void 0, pa = void 0, i = start, ii = pathArray.length; i < ii; i++) {
    res.push(r = []);
    pa = pathArray[i];
    pa0 = pa[0];
    if (pa0 !== pa0.toUpperCase()) {
      r[0] = pa0.toUpperCase();
      switch (r[0]) {
        case "A":
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;
        case "V":
          r[1] = +pa[1] + y;
          break;
        case "H":
          r[1] = +pa[1] + x;
          break;
        case "R":
          dots = [x, y].concat(pa.slice(1));
          for (var j = 2, jj = dots.length; j < jj; j++) {
            dots[j] = +dots[j] + x;
            dots[++j] = +dots[j] + y;
          }
          res.pop();
          res = res.concat(catmullRomToBezier(dots, crz));
          break;
        case "O":
          res.pop();
          dots = ellipsePath(x, y, pa[1], pa[2]);
          dots.push(dots[0]);
          res = res.concat(dots);
          break;
        case "U":
          res.pop();
          res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
          r = ["U"].concat(res[res.length - 1].slice(-2));
          break;
        case "M":
          mx = +pa[1] + x;
          my = +pa[2] + y;
          break;
        default:
          for (var j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }
      }
    } else if (pa0 === "R") {
      dots = [x, y].concat(pa.slice(1));
      res.pop();
      res = res.concat(catmullRomToBezier(dots, crz));
      r = ["R"].concat(pa.slice(-2));
    } else if (pa0 === "O") {
      res.pop();
      dots = ellipsePath(x, y, pa[1], pa[2]);
      dots.push(dots[0]);
      res = res.concat(dots);
    } else if (pa0 === "U") {
      res.pop();
      res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
      r = ["U"].concat(res[res.length - 1].slice(-2));
    } else {
      for (var k = 0, kk = pa.length; k < kk; k++) {
        r[k] = pa[k];
      }
    }
    pa0 = pa0.toUpperCase();
    if (pa0 !== "O") {
      switch (r[0]) {
        case "Z":
          x = +mx;
          y = +my;
          break;
        case "H":
          x = r[1];
          break;
        case "V":
          y = r[1];
          break;
        case "M":
          mx = r[r.length - 2];
          my = r[r.length - 1];
          break;
        default:
          x = r[r.length - 2];
          y = r[r.length - 1];
      }
    }
  }
  return res;
};
var l2c = function(x1, y1, x2, y2) {
  return [x1, y1, x2, y2, x2, y2];
};
var q2c = function(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3;
  var _23 = 2 / 3;
  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
};
var a2c = function(x1, y1, rx, ry, angle2, large_arc_flag, sweep_flag, x2, y2, recursive) {
  if (rx === ry) {
    rx += 1;
  }
  var _120 = Math.PI * 120 / 180;
  var rad = Math.PI / 180 * (+angle2 || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  var rotate2 = function(x3, y3, rad2) {
    var X = x3 * Math.cos(rad2) - y3 * Math.sin(rad2);
    var Y = x3 * Math.sin(rad2) + y3 * Math.cos(rad2);
    return {
      x: X,
      y: Y
    };
  };
  if (!recursive) {
    xy = rotate2(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate2(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    if (x1 === x2 && y1 === y2) {
      x2 += 1;
      y2 += 1;
    }
    var x = (x1 - x2) / 2;
    var y = (y1 - y2) / 2;
    var h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
    f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > _120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle2, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s2, y2 - hy * c2];
  var m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  }
  res = [m2, m3, m4].concat(res).join().split(",");
  var newres = [];
  for (var i = 0, ii = res.length; i < ii; i++) {
    newres[i] = i % 2 ? rotate2(res[i - 1], res[i], rad).y : rotate2(res[i], res[i + 1], rad).x;
  }
  return newres;
};
var pathToCurve = function(path2, path22) {
  var p = pathToAbsolute$1(path2);
  var p2 = path22 && pathToAbsolute$1(path22);
  var attrs = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var attrs2 = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var pcoms1 = [];
  var pcoms2 = [];
  var pfirst = "";
  var pcom = "";
  var ii;
  var processPath = function(path3, d, pcom2) {
    var nx;
    var ny;
    if (!path3) {
      return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
    }
    !(path3[0] in {
      T: 1,
      Q: 1
    }) && (d.qx = d.qy = null);
    switch (path3[0]) {
      case "M":
        d.X = path3[1];
        d.Y = path3[2];
        break;
      case "A":
        path3 = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path3.slice(1))));
        break;
      case "S":
        if (pcom2 === "C" || pcom2 === "S") {
          nx = d.x * 2 - d.bx;
          ny = d.y * 2 - d.by;
        } else {
          nx = d.x;
          ny = d.y;
        }
        path3 = ["C", nx, ny].concat(path3.slice(1));
        break;
      case "T":
        if (pcom2 === "Q" || pcom2 === "T") {
          d.qx = d.x * 2 - d.qx;
          d.qy = d.y * 2 - d.qy;
        } else {
          d.qx = d.x;
          d.qy = d.y;
        }
        path3 = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path3[1], path3[2]));
        break;
      case "Q":
        d.qx = path3[1];
        d.qy = path3[2];
        path3 = ["C"].concat(q2c(d.x, d.y, path3[1], path3[2], path3[3], path3[4]));
        break;
      case "L":
        path3 = ["C"].concat(l2c(d.x, d.y, path3[1], path3[2]));
        break;
      case "H":
        path3 = ["C"].concat(l2c(d.x, d.y, path3[1], d.y));
        break;
      case "V":
        path3 = ["C"].concat(l2c(d.x, d.y, d.x, path3[1]));
        break;
      case "Z":
        path3 = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
        break;
    }
    return path3;
  };
  var fixArc = function(pp, i2) {
    if (pp[i2].length > 7) {
      pp[i2].shift();
      var pi = pp[i2];
      while (pi.length) {
        pcoms1[i2] = "A";
        p2 && (pcoms2[i2] = "A");
        pp.splice(i2++, 0, ["C"].concat(pi.splice(0, 6)));
      }
      pp.splice(i2, 1);
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };
  var fixM = function(path1, path23, a1, a2, i2) {
    if (path1 && path23 && path1[i2][0] === "M" && path23[i2][0] !== "M") {
      path23.splice(i2, 0, ["M", a2.x, a2.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i2][1];
      a1.y = path1[i2][2];
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };
  ii = Math.max(p.length, p2 && p2.length || 0);
  for (var i = 0; i < ii; i++) {
    p[i] && (pfirst = p[i][0]);
    if (pfirst !== "C") {
      pcoms1[i] = pfirst;
      i && (pcom = pcoms1[i - 1]);
    }
    p[i] = processPath(p[i], attrs, pcom);
    if (pcoms1[i] !== "A" && pfirst === "C")
      pcoms1[i] = "C";
    fixArc(p, i);
    if (p2) {
      p2[i] && (pfirst = p2[i][0]);
      if (pfirst !== "C") {
        pcoms2[i] = pfirst;
        i && (pcom = pcoms2[i - 1]);
      }
      p2[i] = processPath(p2[i], attrs2, pcom);
      if (pcoms2[i] !== "A" && pfirst === "C") {
        pcoms2[i] = "C";
      }
      fixArc(p2, i);
    }
    fixM(p, p2, attrs, attrs2, i);
    fixM(p2, p, attrs2, attrs, i);
    var seg = p[i];
    var seg2 = p2 && p2[i];
    var seglen = seg.length;
    var seg2len = p2 && seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
    attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
    attrs2.x = p2 && seg2[seg2len - 2];
    attrs2.y = p2 && seg2[seg2len - 1];
  }
  return p2 ? [p, p2] : p;
};
var p2s = /,?([a-z]),?/gi;
var parsePathArray = function(path2) {
  return path2.join(",").replace(p2s, "$1");
};
var base3 = function(t, p1, p2, p3, p4) {
  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
  var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
  return t * t2 - 3 * p1 + 3 * p2;
};
var bezlen = function(x1, y1, x2, y2, x3, y3, x4, y4, z) {
  if (z === null) {
    z = 1;
  }
  z = z > 1 ? 1 : z < 0 ? 0 : z;
  var z2 = z / 2;
  var n = 12;
  var Tvalues = [
    -0.1252,
    0.1252,
    -0.3678,
    0.3678,
    -0.5873,
    0.5873,
    -0.7699,
    0.7699,
    -0.9041,
    0.9041,
    -0.9816,
    0.9816
  ];
  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
  var sum = 0;
  for (var i = 0; i < n; i++) {
    var ct = z2 * Tvalues[i] + z2;
    var xbase = base3(ct, x1, x2, x3, x4);
    var ybase = base3(ct, y1, y2, y3, y4);
    var comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i] * Math.sqrt(comb);
  }
  return z2 * sum;
};
var curveDim = function(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [];
  var bounds = [[], []];
  var a;
  var b;
  var c;
  var t;
  for (var i = 0; i < 2; ++i) {
    if (i === 0) {
      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;
    } else {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }
    if (Math.abs(a) < 1e-12) {
      if (Math.abs(b) < 1e-12) {
        continue;
      }
      t = -c / b;
      if (t > 0 && t < 1) {
        tvalues.push(t);
      }
      continue;
    }
    var b2ac = b * b - 4 * c * a;
    var sqrtb2ac = Math.sqrt(b2ac);
    if (b2ac < 0) {
      continue;
    }
    var t1 = (-b + sqrtb2ac) / (2 * a);
    if (t1 > 0 && t1 < 1) {
      tvalues.push(t1);
    }
    var t2 = (-b - sqrtb2ac) / (2 * a);
    if (t2 > 0 && t2 < 1) {
      tvalues.push(t2);
    }
  }
  var j = tvalues.length;
  var jlen = j;
  var mt;
  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
  }
  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;
  return {
    min: {
      x: Math.min.apply(0, bounds[0]),
      y: Math.min.apply(0, bounds[1])
    },
    max: {
      x: Math.max.apply(0, bounds[0]),
      y: Math.max.apply(0, bounds[1])
    }
  };
};
var intersect = function(x1, y1, x2, y2, x3, y3, x4, y4) {
  if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
    return;
  }
  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
  var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  if (!denominator) {
    return;
  }
  var px = nx / denominator;
  var py = ny / denominator;
  var px2 = +px.toFixed(2);
  var py2 = +py.toFixed(2);
  if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
    return;
  }
  return {
    x: px,
    y: py
  };
};
var isPointInsideBBox = function(bbox, x, y) {
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
};
var rectPath = function(x, y, w, h, r) {
  if (r) {
    return [
      ["M", +x + +r, y],
      ["l", w - r * 2, 0],
      ["a", r, r, 0, 0, 1, r, r],
      ["l", 0, h - r * 2],
      ["a", r, r, 0, 0, 1, -r, r],
      ["l", r * 2 - w, 0],
      ["a", r, r, 0, 0, 1, -r, -r],
      ["l", 0, r * 2 - h],
      ["a", r, r, 0, 0, 1, r, -r],
      ["z"]
    ];
  }
  var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
  res.parsePathArray = parsePathArray;
  return res;
};
var box = function(x, y, width, height) {
  if (x === null) {
    x = y = width = height = 0;
  }
  if (y === null) {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }
  return {
    x,
    y,
    width,
    w: width,
    height,
    h: height,
    x2: x + width,
    y2: y + height,
    cx: x + width / 2,
    cy: y + height / 2,
    r1: Math.min(width, height) / 2,
    r2: Math.max(width, height) / 2,
    r0: Math.sqrt(width * width + height * height) / 2,
    path: rectPath(x, y, width, height),
    vb: [x, y, width, height].join(" ")
  };
};
var isBBoxIntersect = function(bbox1, bbox2) {
  bbox1 = box(bbox1);
  bbox2 = box(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};
var bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  if (!isArray$1(p1x)) {
    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
  }
  var bbox = curveDim.apply(null, p1x);
  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};
var findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t1 = 1 - t;
  var t13 = Math.pow(t1, 3);
  var t12 = Math.pow(t1, 2);
  var t2 = t * t;
  var t3 = t2 * t;
  var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
  var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
  var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
  var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
  var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
  var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
  var ax = t1 * p1x + t * c1x;
  var ay = t1 * p1y + t * c1y;
  var cx = t1 * c2x + t * p2x;
  var cy = t1 * c2y + t * p2y;
  var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;
  return {
    x,
    y,
    m: {
      x: mx,
      y: my
    },
    n: {
      x: nx,
      y: ny
    },
    start: {
      x: ax,
      y: ay
    },
    end: {
      x: cx,
      y: cy
    },
    alpha
  };
};
var interHelper = function(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1);
  var bbox2 = bezierBBox(bez2);
  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }
  var l1 = bezlen.apply(0, bez1);
  var l2 = bezlen.apply(0, bez2);
  var n1 = ~~(l1 / 8);
  var n2 = ~~(l2 / 8);
  var dots1 = [];
  var dots2 = [];
  var xy = {};
  var res = justCount ? 0 : [];
  for (var i = 0; i < n1 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
    dots1.push({
      x: d.x,
      y: d.y,
      t: i / n1
    });
  }
  for (var i = 0; i < n2 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));
    dots2.push({
      x: d.x,
      y: d.y,
      t: i / n2
    });
  }
  for (var i = 0; i < n1; i++) {
    for (var j = 0; j < n2; j++) {
      var di = dots1[i];
      var di1 = dots1[i + 1];
      var dj = dots2[j];
      var dj1 = dots2[j + 1];
      var ci = Math.abs(di1.x - di.x) < 1e-3 ? "y" : "x";
      var cj = Math.abs(dj1.x - dj.x) < 1e-3 ? "y" : "x";
      var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
      if (is) {
        if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
          continue;
        }
        xy[is.x.toFixed(4)] = is.y.toFixed(4);
        var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
        var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
          if (justCount) {
            res += 1;
          } else {
            res.push({
              x: is.x,
              y: is.y,
              t1,
              t2
            });
          }
        }
      }
    }
  }
  return res;
};
var interPathHelper = function(path1, path2, justCount) {
  path1 = pathToCurve(path1);
  path2 = pathToCurve(path2);
  var x1;
  var y1;
  var x2;
  var y2;
  var x1m;
  var y1m;
  var x2m;
  var y2m;
  var bez1;
  var bez2;
  var res = justCount ? 0 : [];
  for (var i = 0, ii = path1.length; i < ii; i++) {
    var pi = path1[i];
    if (pi[0] === "M") {
      x1 = x1m = pi[1];
      y1 = y1m = pi[2];
    } else {
      if (pi[0] === "C") {
        bez1 = [x1, y1].concat(pi.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }
      for (var j = 0, jj = path2.length; j < jj; j++) {
        var pj = path2[j];
        if (pj[0] === "M") {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {
          if (pj[0] === "C") {
            bez2 = [x2, y2].concat(pj.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }
          var intr = interHelper(bez1, bez2, justCount);
          if (justCount) {
            res += intr;
          } else {
            for (var k = 0, kk = intr.length; k < kk; k++) {
              intr[k].segment1 = i;
              intr[k].segment2 = j;
              intr[k].bez1 = bez1;
              intr[k].bez2 = bez2;
            }
            res = res.concat(intr);
          }
        }
      }
    }
  }
  return res;
};
var intersection = function(path1, path2) {
  return interPathHelper(path1, path2);
};
function decasteljau(points, t) {
  var left2 = [];
  var right2 = [];
  function recurse(points2, t2) {
    if (points2.length === 1) {
      left2.push(points2[0]);
      right2.push(points2[0]);
    } else {
      var middlePoints = [];
      for (var i = 0; i < points2.length - 1; i++) {
        if (i === 0) {
          left2.push(points2[0]);
        }
        if (i === points2.length - 2) {
          right2.push(points2[i + 1]);
        }
        middlePoints[i] = [
          (1 - t2) * points2[i][0] + t2 * points2[i + 1][0],
          (1 - t2) * points2[i][1] + t2 * points2[i + 1][1]
        ];
      }
      recurse(middlePoints, t2);
    }
  }
  if (points.length) {
    recurse(points, t);
  }
  return { left: left2, right: right2.reverse() };
}
function splitCurve(start, end, count) {
  var points = [[start[1], start[2]]];
  count = count || 2;
  var segments = [];
  if (end[0] === "A") {
    points.push(end[6]);
    points.push(end[7]);
  } else if (end[0] === "C") {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
    points.push([end[5], end[6]]);
  } else if (end[0] === "S" || end[0] === "Q") {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
  } else {
    points.push([end[1], end[2]]);
  }
  var leftSegments = points;
  var t = 1 / count;
  for (var i = 0; i < count - 1; i++) {
    var rt = t / (1 - t * i);
    var split = decasteljau(leftSegments, rt);
    segments.push(split.left);
    leftSegments = split.right;
  }
  segments.push(leftSegments);
  var result = segments.map(function(segment) {
    var cmd = [];
    if (segment.length === 4) {
      cmd.push("C");
      cmd = cmd.concat(segment[2]);
    }
    if (segment.length >= 3) {
      if (segment.length === 3) {
        cmd.push("Q");
      }
      cmd = cmd.concat(segment[1]);
    }
    if (segment.length === 2) {
      cmd.push("L");
    }
    cmd = cmd.concat(segment[segment.length - 1]);
    return cmd;
  });
  return result;
}
var splitSegment = function(start, end, count) {
  if (count === 1) {
    return [[].concat(start)];
  }
  var segments = [];
  if (end[0] === "L" || end[0] === "C" || end[0] === "Q") {
    segments = segments.concat(splitCurve(start, end, count));
  } else {
    var temp = [].concat(start);
    if (temp[0] === "M") {
      temp[0] = "L";
    }
    for (var i = 0; i <= count - 1; i++) {
      segments.push(temp);
    }
  }
  return segments;
};
var fillPath = function(source, target) {
  if (source.length === 1) {
    return source;
  }
  var sourceLen = source.length - 1;
  var targetLen = target.length - 1;
  var ratio = sourceLen / targetLen;
  var segmentsToFill = [];
  if (source.length === 1 && source[0][0] === "M") {
    for (var i = 0; i < targetLen - sourceLen; i++) {
      source.push(source[0]);
    }
    return source;
  }
  for (var i = 0; i < targetLen; i++) {
    var index2 = Math.floor(ratio * i);
    segmentsToFill[index2] = (segmentsToFill[index2] || 0) + 1;
  }
  var filled = segmentsToFill.reduce(function(filled2, count, i2) {
    if (i2 === sourceLen) {
      return filled2.concat(source[sourceLen]);
    }
    return filled2.concat(splitSegment(source[i2], source[i2 + 1], count));
  }, []);
  filled.unshift(source[0]);
  if (target[targetLen] === "Z" || target[targetLen] === "z") {
    filled.push("Z");
  }
  return filled;
};
var isEqual$1 = function(obj1, obj2) {
  if (obj1.length !== obj2.length) {
    return false;
  }
  var result = true;
  each$1(obj1, function(item, i) {
    if (item !== obj2[i]) {
      result = false;
      return false;
    }
  });
  return result;
};
function getMinDiff$1(del, add2, modify) {
  var type = null;
  var min2 = modify;
  if (add2 < min2) {
    min2 = add2;
    type = "add";
  }
  if (del < min2) {
    min2 = del;
    type = "del";
  }
  return {
    type,
    min: min2
  };
}
var levenshteinDistance$1 = function(source, target) {
  var sourceLen = source.length;
  var targetLen = target.length;
  var sourceSegment;
  var targetSegment;
  var temp = 0;
  if (sourceLen === 0 || targetLen === 0) {
    return null;
  }
  var dist = [];
  for (var i = 0; i <= sourceLen; i++) {
    dist[i] = [];
    dist[i][0] = { min: i };
  }
  for (var j = 0; j <= targetLen; j++) {
    dist[0][j] = { min: j };
  }
  for (var i = 1; i <= sourceLen; i++) {
    sourceSegment = source[i - 1];
    for (var j = 1; j <= targetLen; j++) {
      targetSegment = target[j - 1];
      if (isEqual$1(sourceSegment, targetSegment)) {
        temp = 0;
      } else {
        temp = 1;
      }
      var del = dist[i - 1][j].min + 1;
      var add2 = dist[i][j - 1].min + 1;
      var modify = dist[i - 1][j - 1].min + temp;
      dist[i][j] = getMinDiff$1(del, add2, modify);
    }
  }
  return dist;
};
var fillPathByDiff$1 = function(source, target) {
  var diffMatrix = levenshteinDistance$1(source, target);
  var sourceLen = source.length;
  var targetLen = target.length;
  var changes = [];
  var index2 = 1;
  var minPos = 1;
  if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
    for (var i = 1; i <= sourceLen; i++) {
      var min2 = diffMatrix[i][i].min;
      minPos = i;
      for (var j = index2; j <= targetLen; j++) {
        if (diffMatrix[i][j].min < min2) {
          min2 = diffMatrix[i][j].min;
          minPos = j;
        }
      }
      index2 = minPos;
      if (diffMatrix[i][index2].type) {
        changes.push({ index: i - 1, type: diffMatrix[i][index2].type });
      }
    }
    for (var i = changes.length - 1; i >= 0; i--) {
      index2 = changes[i].index;
      if (changes[i].type === "add") {
        source.splice(index2, 0, [].concat(source[index2]));
      } else {
        source.splice(index2, 1);
      }
    }
  }
  sourceLen = source.length;
  var diff2 = targetLen - sourceLen;
  if (sourceLen < targetLen) {
    for (var i = 0; i < diff2; i++) {
      if (source[sourceLen - 1][0] === "z" || source[sourceLen - 1][0] === "Z") {
        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
      } else {
        source.push(source[sourceLen - 1]);
      }
      sourceLen += 1;
    }
  }
  return source;
};
function _splitPoints$1(points, former, count) {
  var result = [].concat(points);
  var index2;
  var t = 1 / (count + 1);
  var formerEnd = _getSegmentPoints$1(former)[0];
  for (var i = 1; i <= count; i++) {
    t *= i;
    index2 = Math.floor(points.length * t);
    if (index2 === 0) {
      result.unshift([formerEnd[0] * t + points[index2][0] * (1 - t), formerEnd[1] * t + points[index2][1] * (1 - t)]);
    } else {
      result.splice(index2, 0, [
        formerEnd[0] * t + points[index2][0] * (1 - t),
        formerEnd[1] * t + points[index2][1] * (1 - t)
      ]);
    }
  }
  return result;
}
function _getSegmentPoints$1(segment) {
  var points = [];
  switch (segment[0]) {
    case "M":
      points.push([segment[1], segment[2]]);
      break;
    case "L":
      points.push([segment[1], segment[2]]);
      break;
    case "A":
      points.push([segment[6], segment[7]]);
      break;
    case "Q":
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case "T":
      points.push([segment[1], segment[2]]);
      break;
    case "C":
      points.push([segment[5], segment[6]]);
      points.push([segment[1], segment[2]]);
      points.push([segment[3], segment[4]]);
      break;
    case "S":
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case "H":
      points.push([segment[1], segment[1]]);
      break;
    case "V":
      points.push([segment[1], segment[1]]);
      break;
  }
  return points;
}
var formatPath$1 = function(fromPath, toPath) {
  if (fromPath.length <= 1) {
    return fromPath;
  }
  var points;
  for (var i = 0; i < toPath.length; i++) {
    if (fromPath[i][0] !== toPath[i][0]) {
      points = _getSegmentPoints$1(fromPath[i]);
      switch (toPath[i][0]) {
        case "M":
          fromPath[i] = ["M"].concat(points[0]);
          break;
        case "L":
          fromPath[i] = ["L"].concat(points[0]);
          break;
        case "A":
          fromPath[i] = [].concat(toPath[i]);
          fromPath[i][6] = points[0][0];
          fromPath[i][7] = points[0][1];
          break;
        case "Q":
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints$1(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ["Q"].concat(points.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        case "T":
          fromPath[i] = ["T"].concat(points[0]);
          break;
        case "C":
          if (points.length < 3) {
            if (i > 0) {
              points = _splitPoints$1(points, fromPath[i - 1], 2);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ["C"].concat(points.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        case "S":
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints$1(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ["S"].concat(points.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        default:
          fromPath[i] = toPath[i];
      }
    }
  }
  return fromPath;
};
var PathUtil$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  catmullRomToBezier,
  fillPath,
  fillPathByDiff: fillPathByDiff$1,
  formatPath: formatPath$1,
  intersection,
  parsePathArray,
  parsePathString: parsePathString$2,
  pathToAbsolute: pathToAbsolute$1,
  pathToCurve,
  rectPath
});
var GraphEvent$1 = function() {
  function GraphEvent2(type, event) {
    this.bubbles = true;
    this.target = null;
    this.currentTarget = null;
    this.delegateTarget = null;
    this.delegateObject = null;
    this.defaultPrevented = false;
    this.propagationStopped = false;
    this.shape = null;
    this.fromShape = null;
    this.toShape = null;
    this.propagationPath = [];
    this.type = type;
    this.name = type;
    this.originalEvent = event;
    this.timeStamp = event.timeStamp;
  }
  GraphEvent2.prototype.preventDefault = function() {
    this.defaultPrevented = true;
    if (this.originalEvent.preventDefault) {
      this.originalEvent.preventDefault();
    }
  };
  GraphEvent2.prototype.stopPropagation = function() {
    this.propagationStopped = true;
  };
  GraphEvent2.prototype.toString = function() {
    var type = this.type;
    return "[Event (type=" + type + ")]";
  };
  GraphEvent2.prototype.save = function() {
  };
  GraphEvent2.prototype.restore = function() {
  };
  return GraphEvent2;
}();
function removeFromArray$1(arr, obj) {
  var index2 = arr.indexOf(obj);
  if (index2 !== -1) {
    arr.splice(index2, 1);
  }
}
var isBrowser$1 = typeof window !== "undefined" && typeof window.document !== "undefined";
function isParent$1(container, shape) {
  if (container.isCanvas()) {
    return true;
  }
  var parent = shape.getParent();
  var isParent2 = false;
  while (parent) {
    if (parent === container) {
      isParent2 = true;
      break;
    }
    parent = parent.getParent();
  }
  return isParent2;
}
function isAllowCapture$1(element) {
  return element.cfg.visible && element.cfg.capture;
}
var Base$1 = function(_super) {
  __extends$2(Base2, _super);
  function Base2(cfg) {
    var _this = _super.call(this) || this;
    _this.destroyed = false;
    var defaultCfg = _this.getDefaultCfg();
    _this.cfg = mix(defaultCfg, cfg);
    return _this;
  }
  Base2.prototype.getDefaultCfg = function() {
    return {};
  };
  Base2.prototype.get = function(name) {
    return this.cfg[name];
  };
  Base2.prototype.set = function(name, value2) {
    this.cfg[name] = value2;
  };
  Base2.prototype.destroy = function() {
    this.cfg = {
      destroyed: true
    };
    this.off();
    this.destroyed = true;
  };
  return Base2;
}(EventEmitter);
function leftTranslate(out, a, v) {
  var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  fromTranslation(transMat, v);
  return multiply(out, transMat, a);
}
function leftRotate(out, a, rad) {
  var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  fromRotation(rotateMat, rad);
  return multiply(out, rotateMat, a);
}
function leftScale(out, a, v) {
  var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  fromScaling(scaleMat, v);
  return multiply(out, scaleMat, a);
}
function leftMultiply(out, a, a1) {
  return multiply(out, a1, a);
}
function transform$7(m, actions) {
  var matrix = m ? [].concat(m) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
  for (var i = 0, len = actions.length; i < len; i++) {
    var action = actions[i];
    switch (action[0]) {
      case "t":
        leftTranslate(matrix, matrix, [action[1], action[2]]);
        break;
      case "s":
        leftScale(matrix, matrix, [action[1], action[2]]);
        break;
      case "r":
        leftRotate(matrix, matrix, action[1]);
        break;
      case "m":
        leftMultiply(matrix, matrix, action[1]);
        break;
    }
  }
  return matrix;
}
function direction(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
function angleTo(v1, v2, direct) {
  var ang = angle(v1, v2);
  var angleLargeThanPI = direction(v1, v2) >= 0;
  if (direct) {
    if (angleLargeThanPI) {
      return Math.PI * 2 - ang;
    }
    return ang;
  }
  if (angleLargeThanPI) {
    return ang;
  }
  return Math.PI * 2 - ang;
}
function multiplyMatrix$1(a, b) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b00 = b[0];
  var b01 = b[1];
  var b02 = b[2];
  var b10 = b[3];
  var b11 = b[4];
  var b12 = b[5];
  var b20 = b[6];
  var b21 = b[7];
  var b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function multiplyVec2$2(m, v) {
  var out = [];
  var x = v[0];
  var y = v[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function invert$1(a) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
var transform$6 = transform$7;
var MATRIX$1 = "matrix";
var CLONE_CFGS$1 = ["zIndex", "capture", "visible", "type"];
var RESERVED_PORPS$1 = ["repeat"];
var DELEGATION_SPLIT$1 = ":";
var WILDCARD$1 = "*";
function _cloneArrayAttr$1(arr) {
  var result = [];
  for (var i = 0; i < arr.length; i++) {
    if (isArray$1(arr[i])) {
      result.push([].concat(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}
function getFormatFromAttrs$1(toAttrs, shape) {
  var fromAttrs = {};
  var attrs = shape.attrs;
  for (var k in toAttrs) {
    fromAttrs[k] = attrs[k];
  }
  return fromAttrs;
}
function getFormatToAttrs$1(props, shape) {
  var toAttrs = {};
  var attrs = shape.attr();
  each$1(props, function(v, k) {
    if (RESERVED_PORPS$1.indexOf(k) === -1 && !isEqual$2(attrs[k], v)) {
      toAttrs[k] = v;
    }
  });
  return toAttrs;
}
function checkExistedAttrs$1(animations, animation2) {
  if (animation2.onFrame) {
    return animations;
  }
  var startTime = animation2.startTime, delay = animation2.delay, duration = animation2.duration;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  each$1(animations, function(item) {
    if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
      each$1(animation2.toAttrs, function(v, k) {
        if (hasOwnProperty2.call(item.toAttrs, k)) {
          delete item.toAttrs[k];
          delete item.fromAttrs[k];
        }
      });
    }
  });
  return animations;
}
var Element$3 = function(_super) {
  __extends$2(Element2, _super);
  function Element2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.attrs = {};
    var attrs = _this.getDefaultAttrs();
    mix(attrs, cfg.attrs);
    _this.attrs = attrs;
    _this.initAttrs(attrs);
    _this.initAnimate();
    return _this;
  }
  Element2.prototype.getDefaultCfg = function() {
    return {
      visible: true,
      capture: true,
      zIndex: 0
    };
  };
  Element2.prototype.getDefaultAttrs = function() {
    return {
      matrix: this.getDefaultMatrix(),
      opacity: 1
    };
  };
  Element2.prototype.onCanvasChange = function(changeType) {
  };
  Element2.prototype.initAttrs = function(attrs) {
  };
  Element2.prototype.initAnimate = function() {
    this.set("animable", true);
    this.set("animating", false);
  };
  Element2.prototype.isGroup = function() {
    return false;
  };
  Element2.prototype.getParent = function() {
    return this.get("parent");
  };
  Element2.prototype.getCanvas = function() {
    return this.get("canvas");
  };
  Element2.prototype.attr = function() {
    var _a2;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var name = args[0], value2 = args[1];
    if (!name)
      return this.attrs;
    if (isObject(name)) {
      for (var k in name) {
        this.setAttr(k, name[k]);
      }
      this.afterAttrsChange(name);
      return this;
    }
    if (args.length === 2) {
      this.setAttr(name, value2);
      this.afterAttrsChange((_a2 = {}, _a2[name] = value2, _a2));
      return this;
    }
    return this.attrs[name];
  };
  Element2.prototype.isClipped = function(refX, refY) {
    var clip = this.getClip();
    return clip && !clip.isHit(refX, refY);
  };
  Element2.prototype.setAttr = function(name, value2) {
    var originValue = this.attrs[name];
    if (originValue !== value2) {
      this.attrs[name] = value2;
      this.onAttrChange(name, value2, originValue);
    }
  };
  Element2.prototype.onAttrChange = function(name, value2, originValue) {
    if (name === "matrix") {
      this.set("totalMatrix", null);
    }
  };
  Element2.prototype.afterAttrsChange = function(targetAttrs) {
    if (this.cfg.isClipShape) {
      var applyTo = this.cfg.applyTo;
      if (applyTo) {
        applyTo.onCanvasChange("clip");
      }
    } else {
      this.onCanvasChange("attr");
    }
  };
  Element2.prototype.show = function() {
    this.set("visible", true);
    this.onCanvasChange("show");
    return this;
  };
  Element2.prototype.hide = function() {
    this.set("visible", false);
    this.onCanvasChange("hide");
    return this;
  };
  Element2.prototype.setZIndex = function(zIndex) {
    this.set("zIndex", zIndex);
    var parent = this.getParent();
    if (parent) {
      parent.sort();
    }
    return this;
  };
  Element2.prototype.toFront = function() {
    var parent = this.getParent();
    if (!parent) {
      return;
    }
    var children = parent.getChildren();
    this.get("el");
    var index2 = children.indexOf(this);
    children.splice(index2, 1);
    children.push(this);
    this.onCanvasChange("zIndex");
  };
  Element2.prototype.toBack = function() {
    var parent = this.getParent();
    if (!parent) {
      return;
    }
    var children = parent.getChildren();
    this.get("el");
    var index2 = children.indexOf(this);
    children.splice(index2, 1);
    children.unshift(this);
    this.onCanvasChange("zIndex");
  };
  Element2.prototype.remove = function(destroy) {
    if (destroy === void 0) {
      destroy = true;
    }
    var parent = this.getParent();
    if (parent) {
      removeFromArray$1(parent.getChildren(), this);
      if (!parent.get("clearing")) {
        this.onCanvasChange("remove");
      }
    } else {
      this.onCanvasChange("remove");
    }
    if (destroy) {
      this.destroy();
    }
  };
  Element2.prototype.resetMatrix = function() {
    this.attr(MATRIX$1, this.getDefaultMatrix());
    this.onCanvasChange("matrix");
  };
  Element2.prototype.getMatrix = function() {
    return this.attr(MATRIX$1);
  };
  Element2.prototype.setMatrix = function(m) {
    this.attr(MATRIX$1, m);
    this.onCanvasChange("matrix");
  };
  Element2.prototype.getTotalMatrix = function() {
    var totalMatrix = this.cfg.totalMatrix;
    if (!totalMatrix) {
      var currentMatrix = this.attr("matrix");
      var parentMatrix = this.cfg.parentMatrix;
      if (parentMatrix && currentMatrix) {
        totalMatrix = multiplyMatrix$1(parentMatrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || parentMatrix;
      }
      this.set("totalMatrix", totalMatrix);
    }
    return totalMatrix;
  };
  Element2.prototype.applyMatrix = function(matrix) {
    var currentMatrix = this.attr("matrix");
    var totalMatrix = null;
    if (matrix && currentMatrix) {
      totalMatrix = multiplyMatrix$1(matrix, currentMatrix);
    } else {
      totalMatrix = currentMatrix || matrix;
    }
    this.set("totalMatrix", totalMatrix);
    this.set("parentMatrix", matrix);
  };
  Element2.prototype.getDefaultMatrix = function() {
    return null;
  };
  Element2.prototype.applyToMatrix = function(v) {
    var matrix = this.attr("matrix");
    if (matrix) {
      return multiplyVec2$2(matrix, v);
    }
    return v;
  };
  Element2.prototype.invertFromMatrix = function(v) {
    var matrix = this.attr("matrix");
    if (matrix) {
      var invertMatrix = invert$1(matrix);
      if (invertMatrix) {
        return multiplyVec2$2(invertMatrix, v);
      }
    }
    return v;
  };
  Element2.prototype.setClip = function(clipCfg) {
    var canvas = this.getCanvas();
    var clipShape = null;
    if (clipCfg) {
      var ShapeBase2 = this.getShapeBase();
      var shapeType = upperFirst(clipCfg.type);
      var Cons = ShapeBase2[shapeType];
      if (Cons) {
        clipShape = new Cons({
          type: clipCfg.type,
          isClipShape: true,
          applyTo: this,
          attrs: clipCfg.attrs,
          canvas
        });
      }
    }
    this.set("clipShape", clipShape);
    this.onCanvasChange("clip");
    return clipShape;
  };
  Element2.prototype.getClip = function() {
    var clipShape = this.cfg.clipShape;
    if (!clipShape) {
      return null;
    }
    return clipShape;
  };
  Element2.prototype.clone = function() {
    var _this = this;
    var originAttrs = this.attrs;
    var attrs = {};
    each$1(originAttrs, function(i, k) {
      if (isArray$1(originAttrs[k])) {
        attrs[k] = _cloneArrayAttr$1(originAttrs[k]);
      } else {
        attrs[k] = originAttrs[k];
      }
    });
    var cons = this.constructor;
    var clone2 = new cons({ attrs });
    each$1(CLONE_CFGS$1, function(cfgName) {
      clone2.set(cfgName, _this.get(cfgName));
    });
    return clone2;
  };
  Element2.prototype.destroy = function() {
    var destroyed = this.destroyed;
    if (destroyed) {
      return;
    }
    this.attrs = {};
    _super.prototype.destroy.call(this);
  };
  Element2.prototype.isAnimatePaused = function() {
    return this.get("_pause").isPaused;
  };
  Element2.prototype.animate = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!this.get("timeline") && !this.get("canvas")) {
      return;
    }
    this.set("animating", true);
    var timeline = this.get("timeline");
    if (!timeline) {
      timeline = this.get("canvas").get("timeline");
      this.set("timeline", timeline);
    }
    var animations = this.get("animations") || [];
    if (!timeline.timer) {
      timeline.initTimer();
    }
    var toAttrs = args[0], duration = args[1], _a2 = args[2], easing = _a2 === void 0 ? "easeLinear" : _a2, _b = args[3], callback = _b === void 0 ? noop : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;
    var onFrame;
    var repeat;
    var pauseCallback;
    var resumeCallback;
    var animateCfg;
    if (isFunction(toAttrs)) {
      onFrame = toAttrs;
      toAttrs = {};
    } else if (isObject(toAttrs) && toAttrs.onFrame) {
      onFrame = toAttrs.onFrame;
      repeat = toAttrs.repeat;
    }
    if (isObject(duration)) {
      animateCfg = duration;
      duration = animateCfg.duration;
      easing = animateCfg.easing || "easeLinear";
      delay = animateCfg.delay || 0;
      repeat = animateCfg.repeat || repeat || false;
      callback = animateCfg.callback || noop;
      pauseCallback = animateCfg.pauseCallback || noop;
      resumeCallback = animateCfg.resumeCallback || noop;
    } else {
      if (isNumber$1(callback)) {
        delay = callback;
        callback = null;
      }
      if (isFunction(easing)) {
        callback = easing;
        easing = "easeLinear";
      } else {
        easing = easing || "easeLinear";
      }
    }
    var formatToAttrs = getFormatToAttrs$1(toAttrs, this);
    var animation2 = {
      fromAttrs: getFormatFromAttrs$1(formatToAttrs, this),
      toAttrs: formatToAttrs,
      duration,
      easing,
      repeat,
      callback,
      pauseCallback,
      resumeCallback,
      delay,
      startTime: timeline.getTime(),
      id: uniqueId(),
      onFrame,
      pathFormatted: false
    };
    if (animations.length > 0) {
      animations = checkExistedAttrs$1(animations, animation2);
    } else {
      timeline.addAnimator(this);
    }
    animations.push(animation2);
    this.set("animations", animations);
    this.set("_pause", { isPaused: false });
  };
  Element2.prototype.stopAnimate = function(toEnd) {
    var _this = this;
    if (toEnd === void 0) {
      toEnd = true;
    }
    var animations = this.get("animations");
    each$1(animations, function(animation2) {
      if (toEnd) {
        if (animation2.onFrame) {
          _this.attr(animation2.onFrame(1));
        } else {
          _this.attr(animation2.toAttrs);
        }
      }
      if (animation2.callback) {
        animation2.callback();
      }
    });
    this.set("animating", false);
    this.set("animations", []);
  };
  Element2.prototype.pauseAnimate = function() {
    var timeline = this.get("timeline");
    var animations = this.get("animations");
    var pauseTime = timeline.getTime();
    each$1(animations, function(animation2) {
      animation2._paused = true;
      animation2._pauseTime = pauseTime;
      if (animation2.pauseCallback) {
        animation2.pauseCallback();
      }
    });
    this.set("_pause", {
      isPaused: true,
      pauseTime
    });
    return this;
  };
  Element2.prototype.resumeAnimate = function() {
    var timeline = this.get("timeline");
    var current = timeline.getTime();
    var animations = this.get("animations");
    var pauseTime = this.get("_pause").pauseTime;
    each$1(animations, function(animation2) {
      animation2.startTime = animation2.startTime + (current - pauseTime);
      animation2._paused = false;
      animation2._pauseTime = null;
      if (animation2.resumeCallback) {
        animation2.resumeCallback();
      }
    });
    this.set("_pause", {
      isPaused: false
    });
    this.set("animations", animations);
    return this;
  };
  Element2.prototype.emitDelegation = function(type, eventObj) {
    var _this = this;
    var paths = eventObj.propagationPath;
    this.getEvents();
    var relativeShape;
    if (type === "mouseenter") {
      relativeShape = eventObj.fromShape;
    } else if (type === "mouseleave") {
      relativeShape = eventObj.toShape;
    }
    var _loop_1 = function(i2) {
      var element = paths[i2];
      var name_1 = element.get("name");
      if (name_1) {
        if ((element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent$1(element, relativeShape)) {
          return "break";
        }
        if (isArray$1(name_1)) {
          each$1(name_1, function(subName) {
            _this.emitDelegateEvent(element, subName, eventObj);
          });
        } else {
          this_1.emitDelegateEvent(element, name_1, eventObj);
        }
      }
    };
    var this_1 = this;
    for (var i = 0; i < paths.length; i++) {
      var state_1 = _loop_1(i);
      if (state_1 === "break")
        break;
    }
  };
  Element2.prototype.emitDelegateEvent = function(element, name, eventObj) {
    var events = this.getEvents();
    var eventName = name + DELEGATION_SPLIT$1 + eventObj.type;
    if (events[eventName] || events[WILDCARD$1]) {
      eventObj.name = eventName;
      eventObj.currentTarget = element;
      eventObj.delegateTarget = this;
      eventObj.delegateObject = element.get("delegateObject");
      this.emit(eventName, eventObj);
    }
  };
  Element2.prototype.translate = function(translateX, translateY) {
    if (translateX === void 0) {
      translateX = 0;
    }
    if (translateY === void 0) {
      translateY = 0;
    }
    var matrix = this.getMatrix();
    var newMatrix = transform$6(matrix, [["t", translateX, translateY]]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element2.prototype.move = function(targetX, targetY) {
    var x = this.attr("x") || 0;
    var y = this.attr("y") || 0;
    this.translate(targetX - x, targetY - y);
    return this;
  };
  Element2.prototype.moveTo = function(targetX, targetY) {
    return this.move(targetX, targetY);
  };
  Element2.prototype.scale = function(ratioX, ratioY) {
    var matrix = this.getMatrix();
    var newMatrix = transform$6(matrix, [["s", ratioX, ratioY || ratioX]]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element2.prototype.rotate = function(radian) {
    var matrix = this.getMatrix();
    var newMatrix = transform$6(matrix, [["r", radian]]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element2.prototype.rotateAtStart = function(rotate2) {
    var _a2 = this.attr(), x = _a2.x, y = _a2.y;
    var matrix = this.getMatrix();
    var newMatrix = transform$6(matrix, [
      ["t", -x, -y],
      ["r", rotate2],
      ["t", x, y]
    ]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element2.prototype.rotateAtPoint = function(x, y, rotate2) {
    var matrix = this.getMatrix();
    var newMatrix = transform$6(matrix, [
      ["t", -x, -y],
      ["r", rotate2],
      ["t", x, y]
    ]);
    this.setMatrix(newMatrix);
    return this;
  };
  return Element2;
}(Base$1);
var SHAPE_MAP$1 = {};
var INDEX$1 = "_INDEX";
function setCanvas$1(element, canvas) {
  element.set("canvas", canvas);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setCanvas$1(child, canvas);
      });
    }
  }
}
function setTimeline$1(element, timeline) {
  element.set("timeline", timeline);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setTimeline$1(child, timeline);
      });
    }
  }
}
function removeChild$1(container, element, destroy) {
  if (destroy === void 0) {
    destroy = true;
  }
  if (destroy) {
    element.destroy();
  } else {
    element.set("parent", null);
    element.set("canvas", null);
  }
  removeFromArray$1(container.getChildren(), element);
}
function getComparer$1(compare2) {
  return function(left2, right2) {
    var result = compare2(left2, right2);
    return result === 0 ? left2[INDEX$1] - right2[INDEX$1] : result;
  };
}
var Container$1 = function(_super) {
  __extends$2(Container2, _super);
  function Container2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Container2.prototype.isCanvas = function() {
    return false;
  };
  Container2.prototype.getBBox = function() {
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    var xArr = [];
    var yArr = [];
    var children = this.getChildren().filter(function(child) {
      return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
    });
    if (children.length > 0) {
      each$1(children, function(child) {
        var box3 = child.getBBox();
        xArr.push(box3.minX, box3.maxX);
        yArr.push(box3.minY, box3.maxY);
      });
      minX = min$1(xArr);
      maxX = max$1(xArr);
      minY = min$1(yArr);
      maxY = max$1(yArr);
    } else {
      minX = 0;
      maxX = 0;
      minY = 0;
      maxY = 0;
    }
    var box2 = {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
    return box2;
  };
  Container2.prototype.getCanvasBBox = function() {
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    var xArr = [];
    var yArr = [];
    var children = this.getChildren().filter(function(child) {
      return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
    });
    if (children.length > 0) {
      each$1(children, function(child) {
        var box3 = child.getCanvasBBox();
        xArr.push(box3.minX, box3.maxX);
        yArr.push(box3.minY, box3.maxY);
      });
      minX = min$1(xArr);
      maxX = max$1(xArr);
      minY = min$1(yArr);
      maxY = max$1(yArr);
    } else {
      minX = 0;
      maxX = 0;
      minY = 0;
      maxY = 0;
    }
    var box2 = {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
    return box2;
  };
  Container2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg["children"] = [];
    return cfg;
  };
  Container2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    if (name === "matrix") {
      var totalMatrix = this.getTotalMatrix();
      this._applyChildrenMarix(totalMatrix);
    }
  };
  Container2.prototype.applyMatrix = function(matrix) {
    var preTotalMatrix = this.getTotalMatrix();
    _super.prototype.applyMatrix.call(this, matrix);
    var totalMatrix = this.getTotalMatrix();
    if (totalMatrix === preTotalMatrix) {
      return;
    }
    this._applyChildrenMarix(totalMatrix);
  };
  Container2.prototype._applyChildrenMarix = function(totalMatrix) {
    var children = this.getChildren();
    each$1(children, function(child) {
      child.applyMatrix(totalMatrix);
    });
  };
  Container2.prototype.addShape = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var type = args[0];
    var cfg = args[1];
    if (isObject(type)) {
      cfg = type;
    } else {
      cfg["type"] = type;
    }
    var shapeType = SHAPE_MAP$1[cfg.type];
    if (!shapeType) {
      shapeType = upperFirst(cfg.type);
      SHAPE_MAP$1[cfg.type] = shapeType;
    }
    var ShapeBase2 = this.getShapeBase();
    var shape = new ShapeBase2[shapeType](cfg);
    this.add(shape);
    return shape;
  };
  Container2.prototype.addGroup = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var groupClass = args[0], cfg = args[1];
    var group2;
    if (isFunction(groupClass)) {
      if (cfg) {
        group2 = new groupClass(cfg);
      } else {
        group2 = new groupClass({
          parent: this
        });
      }
    } else {
      var tmpCfg = groupClass || {};
      var TmpGroupClass = this.getGroupBase();
      group2 = new TmpGroupClass(tmpCfg);
    }
    this.add(group2);
    return group2;
  };
  Container2.prototype.getCanvas = function() {
    var canvas;
    if (this.isCanvas()) {
      canvas = this;
    } else {
      canvas = this.get("canvas");
    }
    return canvas;
  };
  Container2.prototype.getShape = function(x, y, ev) {
    if (!isAllowCapture$1(this)) {
      return null;
    }
    var children = this.getChildren();
    var shape;
    if (!this.isCanvas()) {
      var v = [x, y, 1];
      v = this.invertFromMatrix(v);
      if (!this.isClipped(v[0], v[1])) {
        shape = this._findShape(children, v[0], v[1], ev);
      }
    } else {
      shape = this._findShape(children, x, y, ev);
    }
    return shape;
  };
  Container2.prototype._findShape = function(children, x, y, ev) {
    var shape = null;
    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];
      if (isAllowCapture$1(child)) {
        if (child.isGroup()) {
          shape = child.getShape(x, y, ev);
        } else if (child.isHit(x, y)) {
          shape = child;
        }
      }
      if (shape) {
        break;
      }
    }
    return shape;
  };
  Container2.prototype.add = function(element) {
    var canvas = this.getCanvas();
    var children = this.getChildren();
    var timeline = this.get("timeline");
    var preParent = element.getParent();
    if (preParent) {
      removeChild$1(preParent, element, false);
    }
    element.set("parent", this);
    if (canvas) {
      setCanvas$1(element, canvas);
    }
    if (timeline) {
      setTimeline$1(element, timeline);
    }
    children.push(element);
    element.onCanvasChange("add");
    this._applyElementMatrix(element);
  };
  Container2.prototype._applyElementMatrix = function(element) {
    var totalMatrix = this.getTotalMatrix();
    if (totalMatrix) {
      element.applyMatrix(totalMatrix);
    }
  };
  Container2.prototype.getChildren = function() {
    return this.get("children");
  };
  Container2.prototype.sort = function() {
    var children = this.getChildren();
    each$1(children, function(child, index2) {
      child[INDEX$1] = index2;
      return child;
    });
    children.sort(getComparer$1(function(obj1, obj2) {
      return obj1.get("zIndex") - obj2.get("zIndex");
    }));
    this.onCanvasChange("sort");
  };
  Container2.prototype.clear = function() {
    this.set("clearing", true);
    if (this.destroyed) {
      return;
    }
    var children = this.getChildren();
    for (var i = children.length - 1; i >= 0; i--) {
      children[i].destroy();
    }
    this.set("children", []);
    this.onCanvasChange("clear");
    this.set("clearing", false);
  };
  Container2.prototype.destroy = function() {
    if (this.get("destroyed")) {
      return;
    }
    this.clear();
    _super.prototype.destroy.call(this);
  };
  Container2.prototype.getFirst = function() {
    return this.getChildByIndex(0);
  };
  Container2.prototype.getLast = function() {
    var children = this.getChildren();
    return this.getChildByIndex(children.length - 1);
  };
  Container2.prototype.getChildByIndex = function(index2) {
    var children = this.getChildren();
    return children[index2];
  };
  Container2.prototype.getCount = function() {
    var children = this.getChildren();
    return children.length;
  };
  Container2.prototype.contain = function(element) {
    var children = this.getChildren();
    return children.indexOf(element) > -1;
  };
  Container2.prototype.removeChild = function(element, destroy) {
    if (destroy === void 0) {
      destroy = true;
    }
    if (this.contain(element)) {
      element.remove(destroy);
    }
  };
  Container2.prototype.findAll = function(fn) {
    var rst = [];
    var children = this.getChildren();
    each$1(children, function(element) {
      if (fn(element)) {
        rst.push(element);
      }
      if (element.isGroup()) {
        rst = rst.concat(element.findAll(fn));
      }
    });
    return rst;
  };
  Container2.prototype.find = function(fn) {
    var rst = null;
    var children = this.getChildren();
    each$1(children, function(element) {
      if (fn(element)) {
        rst = element;
      } else if (element.isGroup()) {
        rst = element.find(fn);
      }
      if (rst) {
        return false;
      }
    });
    return rst;
  };
  Container2.prototype.findById = function(id) {
    return this.find(function(element) {
      return element.get("id") === id;
    });
  };
  Container2.prototype.findByClassName = function(className) {
    return this.find(function(element) {
      return element.get("className") === className;
    });
  };
  Container2.prototype.findAllByName = function(name) {
    return this.findAll(function(element) {
      return element.get("name") === name;
    });
  };
  return Container2;
}(Element$3);
var isColorProp$1 = function(prop) {
  return ["fill", "stroke", "fillStyle", "strokeStyle"].includes(prop);
};
var isGradientColor$2 = function(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};
var IDENTITY_MATRIX$1 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function _update$1(shape, animation2, ratio) {
  var cProps = {};
  var fromAttrs = animation2.fromAttrs, toAttrs = animation2.toAttrs;
  if (shape.destroyed) {
    return;
  }
  var interf;
  for (var k in toAttrs) {
    if (!isEqual$2(fromAttrs[k], toAttrs[k])) {
      if (k === "path") {
        var toPath = toAttrs[k];
        var fromPath = fromAttrs[k];
        if (toPath.length > fromPath.length) {
          toPath = parsePathString$2(toAttrs[k]);
          fromPath = parsePathString$2(fromAttrs[k]);
          fromPath = fillPathByDiff$1(fromPath, toPath);
          fromPath = formatPath$1(fromPath, toPath);
          animation2.fromAttrs.path = fromPath;
          animation2.toAttrs.path = toPath;
        } else if (!animation2.pathFormatted) {
          toPath = parsePathString$2(toAttrs[k]);
          fromPath = parsePathString$2(fromAttrs[k]);
          fromPath = formatPath$1(fromPath, toPath);
          animation2.fromAttrs.path = fromPath;
          animation2.toAttrs.path = toPath;
          animation2.pathFormatted = true;
        }
        cProps[k] = [];
        for (var i = 0; i < toPath.length; i++) {
          var toPathPoint = toPath[i];
          var fromPathPoint = fromPath[i];
          var cPathPoint = [];
          for (var j = 0; j < toPathPoint.length; j++) {
            if (isNumber$1(toPathPoint[j]) && fromPathPoint && isNumber$1(fromPathPoint[j])) {
              interf = interpolate(fromPathPoint[j], toPathPoint[j]);
              cPathPoint.push(interf(ratio));
            } else {
              cPathPoint.push(toPathPoint[j]);
            }
          }
          cProps[k].push(cPathPoint);
        }
      } else if (k === "matrix") {
        var matrixFn = interpolateArray(fromAttrs[k] || IDENTITY_MATRIX$1, toAttrs[k] || IDENTITY_MATRIX$1);
        var currentMatrix = matrixFn(ratio);
        cProps[k] = currentMatrix;
      } else if (isColorProp$1(k) && isGradientColor$2(toAttrs[k])) {
        cProps[k] = toAttrs[k];
      } else if (!isFunction(toAttrs[k])) {
        interf = interpolate(fromAttrs[k], toAttrs[k]);
        cProps[k] = interf(ratio);
      }
    }
  }
  shape.attr(cProps);
}
function update$1(shape, animation2, elapsed) {
  var startTime = animation2.startTime, delay = animation2.delay;
  if (elapsed < startTime + delay || animation2._paused) {
    return false;
  }
  var ratio;
  var duration = animation2.duration;
  var easing = animation2.easing;
  elapsed = elapsed - startTime - animation2.delay;
  if (animation2.repeat) {
    ratio = elapsed % duration / duration;
    ratio = d3Ease[easing](ratio);
  } else {
    ratio = elapsed / duration;
    if (ratio < 1) {
      ratio = d3Ease[easing](ratio);
    } else {
      if (animation2.onFrame) {
        shape.attr(animation2.onFrame(1));
      } else {
        shape.attr(animation2.toAttrs);
      }
      return true;
    }
  }
  if (animation2.onFrame) {
    var attrs = animation2.onFrame(ratio);
    shape.attr(attrs);
  } else {
    _update$1(shape, animation2, ratio);
  }
  return false;
}
var Timeline$1 = function() {
  function Timeline2(canvas) {
    this.animators = [];
    this.current = 0;
    this.timer = null;
    this.canvas = canvas;
  }
  Timeline2.prototype.initTimer = function() {
    var _this = this;
    var isFinished = false;
    var shape;
    var animations;
    var animation2;
    this.timer = timer(function(elapsed) {
      _this.current = elapsed;
      if (_this.animators.length > 0) {
        for (var i = _this.animators.length - 1; i >= 0; i--) {
          shape = _this.animators[i];
          if (shape.destroyed) {
            _this.removeAnimator(i);
            continue;
          }
          if (!shape.isAnimatePaused()) {
            animations = shape.get("animations");
            for (var j = animations.length - 1; j >= 0; j--) {
              animation2 = animations[j];
              isFinished = update$1(shape, animation2, elapsed);
              if (isFinished) {
                animations.splice(j, 1);
                isFinished = false;
                if (animation2.callback) {
                  animation2.callback();
                }
              }
            }
          }
          if (animations.length === 0) {
            _this.removeAnimator(i);
          }
        }
        var autoDraw = _this.canvas.get("autoDraw");
        if (!autoDraw) {
          _this.canvas.draw();
        }
      }
    });
  };
  Timeline2.prototype.addAnimator = function(shape) {
    this.animators.push(shape);
  };
  Timeline2.prototype.removeAnimator = function(index2) {
    this.animators.splice(index2, 1);
  };
  Timeline2.prototype.isAnimating = function() {
    return !!this.animators.length;
  };
  Timeline2.prototype.stop = function() {
    if (this.timer) {
      this.timer.stop();
    }
  };
  Timeline2.prototype.stopAllAnimations = function(toEnd) {
    if (toEnd === void 0) {
      toEnd = true;
    }
    this.animators.forEach(function(animator) {
      animator.stopAnimate(toEnd);
    });
    this.animators = [];
    this.canvas.draw();
  };
  Timeline2.prototype.getTime = function() {
    return this.current;
  };
  return Timeline2;
}();
var CLICK_OFFSET$1 = 40;
var LEFT_BTN_CODE$1 = 0;
var EVENTS$3 = [
  "mousedown",
  "mouseup",
  "dblclick",
  "mouseout",
  "mouseover",
  "mousemove",
  "mouseleave",
  "mouseenter",
  "touchstart",
  "touchmove",
  "touchend",
  "dragenter",
  "dragover",
  "dragleave",
  "drop",
  "contextmenu",
  "mousewheel"
];
function emitTargetEvent$1(target, type, eventObj) {
  eventObj.name = type;
  eventObj.target = target;
  eventObj.currentTarget = target;
  eventObj.delegateTarget = target;
  target.emit(type, eventObj);
}
function bubbleEvent$1(container, type, eventObj) {
  if (eventObj.bubbles) {
    var relativeShape = void 0;
    var isOverEvent = false;
    if (type === "mouseenter") {
      relativeShape = eventObj.fromShape;
      isOverEvent = true;
    } else if (type === "mouseleave") {
      isOverEvent = true;
      relativeShape = eventObj.toShape;
    }
    if (container.isCanvas() && isOverEvent) {
      return;
    }
    if (relativeShape && isParent$1(container, relativeShape)) {
      eventObj.bubbles = false;
      return;
    }
    eventObj.name = type;
    eventObj.currentTarget = container;
    eventObj.delegateTarget = container;
    container.emit(type, eventObj);
  }
}
var EventController$1 = function() {
  function EventController2(cfg) {
    var _this = this;
    this.draggingShape = null;
    this.dragging = false;
    this.currentShape = null;
    this.mousedownShape = null;
    this.mousedownPoint = null;
    this._eventCallback = function(ev) {
      var type = ev.type;
      _this._triggerEvent(type, ev);
    };
    this._onDocumentMove = function(ev) {
      var canvas = _this.canvas;
      var el = canvas.get("el");
      if (el !== ev.target) {
        if (_this.dragging || _this.currentShape) {
          var pointInfo = _this._getPointInfo(ev);
          if (_this.dragging) {
            _this._emitEvent("drag", ev, pointInfo, _this.draggingShape);
          }
        }
      }
    };
    this._onDocumentMouseUp = function(ev) {
      var canvas = _this.canvas;
      var el = canvas.get("el");
      if (el !== ev.target) {
        if (_this.dragging) {
          var pointInfo = _this._getPointInfo(ev);
          if (_this.draggingShape) {
            _this._emitEvent("drop", ev, pointInfo, null);
          }
          _this._emitEvent("dragend", ev, pointInfo, _this.draggingShape);
          _this._afterDrag(_this.draggingShape, pointInfo, ev);
        }
      }
    };
    this.canvas = cfg.canvas;
  }
  EventController2.prototype.init = function() {
    this._bindEvents();
  };
  EventController2.prototype._bindEvents = function() {
    var _this = this;
    var el = this.canvas.get("el");
    each$1(EVENTS$3, function(eventName) {
      el.addEventListener(eventName, _this._eventCallback);
    });
    if (document) {
      document.addEventListener("mousemove", this._onDocumentMove);
      document.addEventListener("mouseup", this._onDocumentMouseUp);
    }
  };
  EventController2.prototype._clearEvents = function() {
    var _this = this;
    var el = this.canvas.get("el");
    each$1(EVENTS$3, function(eventName) {
      el.removeEventListener(eventName, _this._eventCallback);
    });
    if (document) {
      document.removeEventListener("mousemove", this._onDocumentMove);
      document.removeEventListener("mouseup", this._onDocumentMouseUp);
    }
  };
  EventController2.prototype._getEventObj = function(type, event, point2, target, fromShape, toShape) {
    var eventObj = new GraphEvent$1(type, event);
    eventObj.fromShape = fromShape;
    eventObj.toShape = toShape;
    eventObj.x = point2.x;
    eventObj.y = point2.y;
    eventObj.clientX = point2.clientX;
    eventObj.clientY = point2.clientY;
    eventObj.propagationPath.push(target);
    return eventObj;
  };
  EventController2.prototype._getShape = function(point2, ev) {
    return this.canvas.getShape(point2.x, point2.y, ev);
  };
  EventController2.prototype._getPointInfo = function(ev) {
    var canvas = this.canvas;
    var clientPoint = canvas.getClientByEvent(ev);
    var point2 = canvas.getPointByEvent(ev);
    return {
      x: point2.x,
      y: point2.y,
      clientX: clientPoint.x,
      clientY: clientPoint.y
    };
  };
  EventController2.prototype._triggerEvent = function(type, ev) {
    var pointInfo = this._getPointInfo(ev);
    var shape = this._getShape(pointInfo, ev);
    var method = this["_on" + type];
    var leaveCanvas = false;
    if (method) {
      method.call(this, pointInfo, shape, ev);
    } else {
      var preShape = this.currentShape;
      if (type === "mouseenter" || type === "dragenter" || type === "mouseover") {
        this._emitEvent(type, ev, pointInfo, null, null, shape);
        if (shape) {
          this._emitEvent(type, ev, pointInfo, shape, null, shape);
        }
        if (type === "mouseenter" && this.draggingShape) {
          this._emitEvent("dragenter", ev, pointInfo, null);
        }
      } else if (type === "mouseleave" || type === "dragleave" || type === "mouseout") {
        leaveCanvas = true;
        if (preShape) {
          this._emitEvent(type, ev, pointInfo, preShape, preShape, null);
        }
        this._emitEvent(type, ev, pointInfo, null, preShape, null);
        if (type === "mouseleave" && this.draggingShape) {
          this._emitEvent("dragleave", ev, pointInfo, null);
        }
      } else {
        this._emitEvent(type, ev, pointInfo, shape, null, null);
      }
    }
    if (!leaveCanvas) {
      this.currentShape = shape;
    }
    if (shape && !shape.get("destroyed")) {
      var canvas = this.canvas;
      var el = canvas.get("el");
      el.style.cursor = shape.attr("cursor") || canvas.get("cursor");
    }
  };
  EventController2.prototype._onmousedown = function(pointInfo, shape, event) {
    if (event.button === LEFT_BTN_CODE$1) {
      this.mousedownShape = shape;
      this.mousedownPoint = pointInfo;
      this.mousedownTimeStamp = event.timeStamp;
    }
    this._emitEvent("mousedown", event, pointInfo, shape, null, null);
  };
  EventController2.prototype._emitMouseoverEvents = function(event, pointInfo, fromShape, toShape) {
    var el = this.canvas.get("el");
    if (fromShape !== toShape) {
      if (fromShape) {
        this._emitEvent("mouseout", event, pointInfo, fromShape, fromShape, toShape);
        this._emitEvent("mouseleave", event, pointInfo, fromShape, fromShape, toShape);
        if (!toShape || toShape.get("destroyed")) {
          el.style.cursor = this.canvas.get("cursor");
        }
      }
      if (toShape) {
        this._emitEvent("mouseover", event, pointInfo, toShape, fromShape, toShape);
        this._emitEvent("mouseenter", event, pointInfo, toShape, fromShape, toShape);
      }
    }
  };
  EventController2.prototype._emitDragoverEvents = function(event, pointInfo, fromShape, toShape, isCanvasEmit) {
    if (toShape) {
      if (toShape !== fromShape) {
        if (fromShape) {
          this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
        }
        this._emitEvent("dragenter", event, pointInfo, toShape, fromShape, toShape);
      }
      if (!isCanvasEmit) {
        this._emitEvent("dragover", event, pointInfo, toShape);
      }
    } else if (fromShape) {
      this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
    }
    if (isCanvasEmit) {
      this._emitEvent("dragover", event, pointInfo, toShape);
    }
  };
  EventController2.prototype._afterDrag = function(draggingShape, pointInfo, event) {
    if (draggingShape) {
      draggingShape.set("capture", true);
      this.draggingShape = null;
    }
    this.dragging = false;
    var shape = this._getShape(pointInfo, event);
    if (shape !== draggingShape) {
      this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
    }
    this.currentShape = shape;
  };
  EventController2.prototype._onmouseup = function(pointInfo, shape, event) {
    if (event.button === LEFT_BTN_CODE$1) {
      var draggingShape = this.draggingShape;
      if (this.dragging) {
        if (draggingShape) {
          this._emitEvent("drop", event, pointInfo, shape);
        }
        this._emitEvent("dragend", event, pointInfo, draggingShape);
        this._afterDrag(draggingShape, pointInfo, event);
      } else {
        this._emitEvent("mouseup", event, pointInfo, shape);
        if (shape === this.mousedownShape) {
          this._emitEvent("click", event, pointInfo, shape);
        }
        this.mousedownShape = null;
        this.mousedownPoint = null;
      }
    }
  };
  EventController2.prototype._ondragover = function(pointInfo, shape, event) {
    event.preventDefault();
    var preShape = this.currentShape;
    this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
  };
  EventController2.prototype._onmousemove = function(pointInfo, shape, event) {
    var canvas = this.canvas;
    var preShape = this.currentShape;
    var draggingShape = this.draggingShape;
    if (this.dragging) {
      if (draggingShape) {
        this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
      }
      this._emitEvent("drag", event, pointInfo, draggingShape);
    } else {
      var mousedownPoint = this.mousedownPoint;
      if (mousedownPoint) {
        var mousedownShape = this.mousedownShape;
        var now = event.timeStamp;
        var timeWindow = now - this.mousedownTimeStamp;
        var dx = mousedownPoint.clientX - pointInfo.clientX;
        var dy = mousedownPoint.clientY - pointInfo.clientY;
        var dist = dx * dx + dy * dy;
        if (timeWindow > 120 || dist > CLICK_OFFSET$1) {
          if (mousedownShape && mousedownShape.get("draggable")) {
            draggingShape = this.mousedownShape;
            draggingShape.set("capture", false);
            this.draggingShape = draggingShape;
            this.dragging = true;
            this._emitEvent("dragstart", event, pointInfo, draggingShape);
            this.mousedownShape = null;
            this.mousedownPoint = null;
          } else if (!mousedownShape && canvas.get("draggable")) {
            this.dragging = true;
            this._emitEvent("dragstart", event, pointInfo, null);
            this.mousedownShape = null;
            this.mousedownPoint = null;
          } else {
            this._emitMouseoverEvents(event, pointInfo, preShape, shape);
            this._emitEvent("mousemove", event, pointInfo, shape);
          }
        } else {
          this._emitMouseoverEvents(event, pointInfo, preShape, shape);
          this._emitEvent("mousemove", event, pointInfo, shape);
        }
      } else {
        this._emitMouseoverEvents(event, pointInfo, preShape, shape);
        this._emitEvent("mousemove", event, pointInfo, shape);
      }
    }
  };
  EventController2.prototype._emitEvent = function(type, event, pointInfo, shape, fromShape, toShape) {
    var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);
    if (shape) {
      eventObj.shape = shape;
      emitTargetEvent$1(shape, type, eventObj);
      var parent_1 = shape.getParent();
      while (parent_1) {
        parent_1.emitDelegation(type, eventObj);
        if (!eventObj.propagationStopped) {
          bubbleEvent$1(parent_1, type, eventObj);
        }
        eventObj.propagationPath.push(parent_1);
        parent_1 = parent_1.getParent();
      }
    } else {
      var canvas = this.canvas;
      emitTargetEvent$1(canvas, type, eventObj);
    }
  };
  EventController2.prototype.destroy = function() {
    this._clearEvents();
    this.canvas = null;
    this.currentShape = null;
    this.draggingShape = null;
    this.mousedownPoint = null;
    this.mousedownShape = null;
    this.mousedownTimeStamp = null;
  };
  return EventController2;
}();
var PX_SUFFIX$1 = "px";
var browser$1 = detect();
var isFirefox$1 = browser$1 && browser$1.name === "firefox";
var Canvas$2 = function(_super) {
  __extends$2(Canvas2, _super);
  function Canvas2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.initContainer();
    _this.initDom();
    _this.initEvents();
    _this.initTimeline();
    return _this;
  }
  Canvas2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg["cursor"] = "default";
    cfg["supportCSSTransform"] = false;
    return cfg;
  };
  Canvas2.prototype.initContainer = function() {
    var container = this.get("container");
    if (isString(container)) {
      container = document.getElementById(container);
      this.set("container", container);
    }
  };
  Canvas2.prototype.initDom = function() {
    var el = this.createDom();
    this.set("el", el);
    var container = this.get("container");
    container.appendChild(el);
    this.setDOMSize(this.get("width"), this.get("height"));
  };
  Canvas2.prototype.initEvents = function() {
    var eventController = new EventController$1({
      canvas: this
    });
    eventController.init();
    this.set("eventController", eventController);
  };
  Canvas2.prototype.initTimeline = function() {
    var timeline = new Timeline$1(this);
    this.set("timeline", timeline);
  };
  Canvas2.prototype.setDOMSize = function(width, height) {
    var el = this.get("el");
    if (isBrowser$1) {
      el.style.width = width + PX_SUFFIX$1;
      el.style.height = height + PX_SUFFIX$1;
    }
  };
  Canvas2.prototype.changeSize = function(width, height) {
    this.setDOMSize(width, height);
    this.set("width", width);
    this.set("height", height);
    this.onCanvasChange("changeSize");
  };
  Canvas2.prototype.getRenderer = function() {
    return this.get("renderer");
  };
  Canvas2.prototype.getCursor = function() {
    return this.get("cursor");
  };
  Canvas2.prototype.setCursor = function(cursor) {
    this.set("cursor", cursor);
    var el = this.get("el");
    if (isBrowser$1 && el) {
      el.style.cursor = cursor;
    }
  };
  Canvas2.prototype.getPointByEvent = function(ev) {
    var supportCSSTransform = this.get("supportCSSTransform");
    if (supportCSSTransform) {
      if (isFirefox$1 && !isNil(ev.layerX) && ev.layerX !== ev.offsetX) {
        return {
          x: ev.layerX,
          y: ev.layerY
        };
      }
      if (!isNil(ev.offsetX)) {
        return {
          x: ev.offsetX,
          y: ev.offsetY
        };
      }
    }
    var _a2 = this.getClientByEvent(ev), clientX = _a2.x, clientY = _a2.y;
    return this.getPointByClient(clientX, clientY);
  };
  Canvas2.prototype.getClientByEvent = function(ev) {
    var clientInfo = ev;
    if (ev.touches) {
      if (ev.type === "touchend") {
        clientInfo = ev.changedTouches[0];
      } else {
        clientInfo = ev.touches[0];
      }
    }
    return {
      x: clientInfo.clientX,
      y: clientInfo.clientY
    };
  };
  Canvas2.prototype.getPointByClient = function(clientX, clientY) {
    var el = this.get("el");
    var bbox = el.getBoundingClientRect();
    return {
      x: clientX - bbox.left,
      y: clientY - bbox.top
    };
  };
  Canvas2.prototype.getClientByPoint = function(x, y) {
    var el = this.get("el");
    var bbox = el.getBoundingClientRect();
    return {
      x: x + bbox.left,
      y: y + bbox.top
    };
  };
  Canvas2.prototype.draw = function() {
  };
  Canvas2.prototype.removeDom = function() {
    var el = this.get("el");
    el.parentNode.removeChild(el);
  };
  Canvas2.prototype.clearEvents = function() {
    var eventController = this.get("eventController");
    eventController.destroy();
  };
  Canvas2.prototype.isCanvas = function() {
    return true;
  };
  Canvas2.prototype.getParent = function() {
    return null;
  };
  Canvas2.prototype.destroy = function() {
    var timeline = this.get("timeline");
    if (this.get("destroyed")) {
      return;
    }
    this.clear();
    if (timeline) {
      timeline.stop();
    }
    this.clearEvents();
    this.removeDom();
    _super.prototype.destroy.call(this);
  };
  return Canvas2;
}(Container$1);
var AbstractGroup = function(_super) {
  __extends$2(AbstractGroup2, _super);
  function AbstractGroup2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AbstractGroup2.prototype.isGroup = function() {
    return true;
  };
  AbstractGroup2.prototype.isEntityGroup = function() {
    return false;
  };
  AbstractGroup2.prototype.clone = function() {
    var clone2 = _super.prototype.clone.call(this);
    var children = this.getChildren();
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      clone2.add(child.clone());
    }
    return clone2;
  };
  return AbstractGroup2;
}(Container$1);
var AbstractShape = function(_super) {
  __extends$2(AbstractShape2, _super);
  function AbstractShape2(cfg) {
    return _super.call(this, cfg) || this;
  }
  AbstractShape2.prototype._isInBBox = function(refX, refY) {
    var bbox = this.getBBox();
    return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
  };
  AbstractShape2.prototype.afterAttrsChange = function(targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    this.clearCacheBBox();
  };
  AbstractShape2.prototype.getBBox = function() {
    var bbox = this.cfg.bbox;
    if (!bbox) {
      bbox = this.calculateBBox();
      this.set("bbox", bbox);
    }
    return bbox;
  };
  AbstractShape2.prototype.getCanvasBBox = function() {
    var canvasBBox = this.cfg.canvasBBox;
    if (!canvasBBox) {
      canvasBBox = this.calculateCanvasBBox();
      this.set("canvasBBox", canvasBBox);
    }
    return canvasBBox;
  };
  AbstractShape2.prototype.applyMatrix = function(matrix) {
    _super.prototype.applyMatrix.call(this, matrix);
    this.set("canvasBBox", null);
  };
  AbstractShape2.prototype.calculateCanvasBBox = function() {
    var bbox = this.getBBox();
    var totalMatrix = this.getTotalMatrix();
    var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
    if (totalMatrix) {
      var topLeft = multiplyVec2$2(totalMatrix, [bbox.minX, bbox.minY]);
      var topRight = multiplyVec2$2(totalMatrix, [bbox.maxX, bbox.minY]);
      var bottomLeft = multiplyVec2$2(totalMatrix, [bbox.minX, bbox.maxY]);
      var bottomRight = multiplyVec2$2(totalMatrix, [bbox.maxX, bbox.maxY]);
      minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
      maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
      minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
      maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
    }
    var attrs = this.attrs;
    if (attrs.shadowColor) {
      var _a2 = attrs.shadowBlur, shadowBlur = _a2 === void 0 ? 0 : _a2, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
      var shadowLeft = minX - shadowBlur + shadowOffsetX;
      var shadowRight = maxX + shadowBlur + shadowOffsetX;
      var shadowTop = minY - shadowBlur + shadowOffsetY;
      var shadowBottom = maxY + shadowBlur + shadowOffsetY;
      minX = Math.min(minX, shadowLeft);
      maxX = Math.max(maxX, shadowRight);
      minY = Math.min(minY, shadowTop);
      maxY = Math.max(maxY, shadowBottom);
    }
    return {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  };
  AbstractShape2.prototype.clearCacheBBox = function() {
    this.set("bbox", null);
    this.set("canvasBBox", null);
  };
  AbstractShape2.prototype.isClipShape = function() {
    return this.get("isClipShape");
  };
  AbstractShape2.prototype.isInShape = function(refX, refY) {
    return false;
  };
  AbstractShape2.prototype.isOnlyHitBox = function() {
    return false;
  };
  AbstractShape2.prototype.isHit = function(x, y) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    var vec = [x, y, 1];
    vec = this.invertFromMatrix(vec);
    var refX = vec[0], refY = vec[1];
    var inBBox = this._isInBBox(refX, refY);
    if (this.isOnlyHitBox()) {
      return inBBox;
    }
    if (inBBox && !this.isClipped(refX, refY)) {
      if (this.isInShape(refX, refY)) {
        return true;
      }
      if (startArrowShape && startArrowShape.isHit(refX, refY)) {
        return true;
      }
      if (endArrowShape && endArrowShape.isHit(refX, refY)) {
        return true;
      }
    }
    return false;
  };
  return AbstractShape2;
}(Element$3);
var cache$1 = new Map();
function register$1(type, method) {
  cache$1.set(type, method);
}
function getMethod(type) {
  return cache$1.get(type);
}
function rect$2(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height;
  return {
    x,
    y,
    width,
    height
  };
}
function circle$2(shape) {
  var _a2 = shape.attr(), x = _a2.x, y = _a2.y, r = _a2.r;
  return {
    x: x - r,
    y: y - r,
    width: r * 2,
    height: r * 2
  };
}
function minNum(array) {
  return Math.min.apply(null, array);
}
function maxNum(array) {
  return Math.max.apply(null, array);
}
function distance$5(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual(v1, v2) {
  return Math.abs(v1 - v2) < 1e-3;
}
function getBBoxByArray(xArr, yArr) {
  var minX = minNum(xArr);
  var minY = minNum(yArr);
  var maxX = maxNum(xArr);
  var maxY = maxNum(yArr);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function piMod(angle2) {
  return (angle2 + Math.PI * 2) % (Math.PI * 2);
}
var LineUtil = {
  box: function(x1, y1, x2, y2) {
    return getBBoxByArray([x1, x2], [y1, y2]);
  },
  length: function(x1, y1, x2, y2) {
    return distance$5(x1, y1, x2, y2);
  },
  pointAt: function(x1, y1, x2, y2, t) {
    return {
      x: (1 - t) * x1 + t * x2,
      y: (1 - t) * y1 + t * y2
    };
  },
  pointDistance: function(x1, y1, x2, y2, x, y) {
    var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
    if (cross < 0) {
      return distance$5(x1, y1, x, y);
    }
    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (cross > lengthSquare) {
      return distance$5(x2, y2, x, y);
    }
    return this.pointToLine(x1, y1, x2, y2, x, y);
  },
  pointToLine: function(x1, y1, x2, y2, x, y) {
    var d = [x2 - x1, y2 - y1];
    if (exactEquals(d, [0, 0])) {
      return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    }
    var u = [-d[1], d[0]];
    normalize(u, u);
    var a = [x - x1, y - y1];
    return Math.abs(dot$1(a, u));
  },
  tangentAngle: function(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
};
var EPSILON = 1e-4;
function nearestPoint(xArr, yArr, x, y, tCallback, length2) {
  var t;
  var d = Infinity;
  var v0 = [x, y];
  var segNum = 20;
  if (length2 && length2 > 200) {
    segNum = length2 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval2 = increaseRate / 10;
  for (var i = 0; i <= segNum; i++) {
    var _t = i * increaseRate;
    var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];
    var d1 = distance$5(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }
  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t === 1) {
    var count = xArr.length;
    return {
      x: xArr[count - 1],
      y: yArr[count - 1]
    };
  }
  d = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval2 < EPSILON) {
      break;
    }
    var prev = t - interval2;
    var next = t + interval2;
    var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];
    var d1 = distance$5(v0[0], v0[1], v1[0], v1[1]);
    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];
      var d2 = distance$5(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval2 *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(null, xArr.concat([t])),
    y: tCallback.apply(null, yArr.concat([t]))
  };
}
function snapLength(xArr, yArr) {
  var totalLength = 0;
  var count = xArr.length;
  for (var i = 0; i < count; i++) {
    var x = xArr[i];
    var y = yArr[i];
    var nextX = xArr[(i + 1) % count];
    var nextY = yArr[(i + 1) % count];
    totalLength += distance$5(x, y, nextX, nextY);
  }
  return totalLength / 2;
}
function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
}
function extrema$1(p0, p1, p2) {
  var a = p0 + p2 - 2 * p1;
  if (isNumberEqual(a, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function derivativeAt$1(p0, p1, p2, t) {
  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
}
function divideQuadratic(x1, y1, x2, y2, x3, y3, t) {
  var xt = quadraticAt(x1, x2, x3, t);
  var yt = quadraticAt(y1, y2, y3, t);
  var controlPoint1 = LineUtil.pointAt(x1, y1, x2, y2, t);
  var controlPoint2 = LineUtil.pointAt(x2, y2, x3, y3, t);
  return [
    [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],
    [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]
  ];
}
function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
  if (iterationCount === 0) {
    return (distance$5(x1, y1, x2, y2) + distance$5(x2, y2, x3, y3) + distance$5(x1, y1, x3, y3)) / 2;
  }
  var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);
  var left2 = quadratics[0];
  var right2 = quadratics[1];
  left2.push(iterationCount - 1);
  right2.push(iterationCount - 1);
  return quadraticLength.apply(null, left2) + quadraticLength.apply(null, right2);
}
var QuadUtil = {
  box: function(x1, y1, x2, y2, x3, y3) {
    var xExtrema2 = extrema$1(x1, x2, x3)[0];
    var yExtrema2 = extrema$1(y1, y2, y3)[0];
    var xArr = [x1, x3];
    var yArr = [y1, y3];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt(x1, x2, x3, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt(y1, y2, y3, yExtrema2));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3) {
    return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    var point2 = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
    return distance$5(point2.x, point2.y, x0, y0);
  },
  interpolationAt: quadraticAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, t) {
    return {
      x: quadraticAt(x1, x2, x3, t),
      y: quadraticAt(y1, y2, y3, t)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, t) {
    return divideQuadratic(x1, y1, x2, y2, x3, y3, t);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, t) {
    var dx = derivativeAt$1(x1, x2, x3, t);
    var dy = derivativeAt$1(y1, y2, y3, t);
    var angle2 = Math.atan2(dy, dx);
    return piMod(angle2);
  }
};
function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}
function derivativeAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
}
function extrema(p0, p1, p2, p3) {
  var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b = 6 * p0 - 12 * p1 + 6 * p2;
  var c = 3 * p1 - 3 * p0;
  var extremas = [];
  var t1;
  var t2;
  var discSqrt;
  if (isNumberEqual(a, 0)) {
    if (!isNumberEqual(b, 0)) {
      t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        extremas.push(t1);
      }
    }
  } else {
    var disc = b * b - 4 * a * c;
    if (isNumberEqual(disc, 0)) {
      extremas.push(-b / (2 * a));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t1 = (-b + discSqrt) / (2 * a);
      t2 = (-b - discSqrt) / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        extremas.push(t1);
      }
      if (t2 >= 0 && t2 <= 1) {
        extremas.push(t2);
      }
    }
  }
  return extremas;
}
function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {
  var xt = cubicAt(x1, x2, x3, x4, t);
  var yt = cubicAt(y1, y2, y3, y4, t);
  var c1 = LineUtil.pointAt(x1, y1, x2, y2, t);
  var c2 = LineUtil.pointAt(x2, y2, x3, y3, t);
  var c3 = LineUtil.pointAt(x3, y3, x4, y4, t);
  var c12 = LineUtil.pointAt(c1.x, c1.y, c2.x, c2.y, t);
  var c23 = LineUtil.pointAt(c2.x, c2.y, c3.x, c3.y, t);
  return [
    [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],
    [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]
  ];
}
function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
  if (iterationCount === 0) {
    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);
  }
  var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
  var left2 = cubics[0];
  var right2 = cubics[1];
  left2.push(iterationCount - 1);
  right2.push(iterationCount - 1);
  return cubicLength.apply(null, left2) + cubicLength.apply(null, right2);
}
var CubicUtil = {
  extrema,
  box: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    var xArr = [x1, x4];
    var yArr = [y1, y4];
    var xExtrema2 = extrema(x1, x2, x3, x4);
    var yExtrema2 = extrema(y1, y2, y3, y4);
    for (var i = 0; i < xExtrema2.length; i++) {
      xArr.push(cubicAt(x1, x2, x3, x4, xExtrema2[i]));
    }
    for (var i = 0; i < yExtrema2.length; i++) {
      yArr.push(cubicAt(y1, y2, y3, y4, yExtrema2[i]));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length2) {
    return nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length2);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length2) {
    var point2 = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length2);
    return distance$5(point2.x, point2.y, x0, y0);
  },
  interpolationAt: cubicAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return {
      x: cubicAt(x1, x2, x3, x4, t),
      y: cubicAt(y1, y2, y3, y4, t)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    var dx = derivativeAt(x1, x2, x3, x4, t);
    var dy = derivativeAt(y1, y2, y3, y4, t);
    return piMod(Math.atan2(dy, dx));
  }
};
function copysign(v1, v2) {
  var absv = Math.abs(v1);
  return v2 > 0 ? absv : absv * -1;
}
var ellipse$2 = {
  box: function(x, y, rx, ry) {
    return {
      x: x - rx,
      y: y - ry,
      width: rx * 2,
      height: ry * 2
    };
  },
  length: function(x, y, rx, ry) {
    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
  },
  nearestPoint: function(x, y, rx, ry, x0, y0) {
    var a = rx;
    var b = ry;
    if (a === 0 || b === 0) {
      return {
        x,
        y
      };
    }
    var relativeX = x0 - x;
    var relativeY = y0 - y;
    var px = Math.abs(relativeX);
    var py = Math.abs(relativeY);
    var squareA = a * a;
    var squareB = b * b;
    var t = Math.PI / 4;
    var nearestX;
    var nearestY;
    for (var i = 0; i < 4; i++) {
      nearestX = a * Math.cos(t);
      nearestY = b * Math.sin(t);
      var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;
      var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;
      var rx1 = nearestX - ex;
      var ry1 = nearestY - ey;
      var qx = px - ex;
      var qy = py - ey;
      var r = Math.hypot(ry1, rx1);
      var q = Math.hypot(qy, qx);
      var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));
      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
      t += delta_t;
      t = Math.min(Math.PI / 2, Math.max(0, t));
    }
    return {
      x: x + copysign(nearestX, relativeX),
      y: y + copysign(nearestY, relativeY)
    };
  },
  pointDistance: function(x, y, rx, ry, x0, y0) {
    var nearestPoint2 = this.nearestPoint(x, y, rx, ry, x0, y0);
    return distance$5(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  pointAt: function(x, y, rx, ry, t) {
    var angle2 = 2 * Math.PI * t;
    return {
      x: x + rx * Math.cos(angle2),
      y: y + ry * Math.sin(angle2)
    };
  },
  tangentAngle: function(x, y, rx, ry, t) {
    var angle2 = 2 * Math.PI * t;
    var tangentAngle = Math.atan2(ry * Math.cos(angle2), -rx * Math.sin(angle2));
    return piMod(tangentAngle);
  }
};
function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2) {
  return -1 * rx * Math.cos(xRotation) * Math.sin(angle2) - ry * Math.sin(xRotation) * Math.cos(angle2);
}
function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2) {
  return -1 * rx * Math.sin(xRotation) * Math.sin(angle2) + ry * Math.cos(xRotation) * Math.cos(angle2);
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle2) {
  return rx * Math.cos(xRotation) * Math.cos(angle2) - ry * Math.sin(xRotation) * Math.sin(angle2) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle2) {
  return rx * Math.sin(xRotation) * Math.cos(angle2) + ry * Math.cos(xRotation) * Math.sin(angle2) + cy;
}
function getAngle$2(rx, ry, x0, y0) {
  var angle2 = Math.atan2(y0 * rx, x0 * ry);
  return (angle2 + Math.PI * 2) % (Math.PI * 2);
}
function getPoint(rx, ry, angle2) {
  return {
    x: rx * Math.cos(angle2),
    y: ry * Math.sin(angle2)
  };
}
function rotate$1(x, y, angle2) {
  var cos2 = Math.cos(angle2);
  var sin2 = Math.sin(angle2);
  return [x * cos2 - y * sin2, x * sin2 + y * cos2];
}
var EllipseArcUtil = {
  box: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    var xDim = xExtrema(rx, ry, xRotation);
    var minX = Infinity;
    var maxX = -Infinity;
    var xs = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var xAngle = xDim + i;
      if (startAngle < endAngle) {
        if (startAngle < xAngle && xAngle < endAngle) {
          xs.push(xAngle);
        }
      } else {
        if (endAngle < xAngle && xAngle < startAngle) {
          xs.push(xAngle);
        }
      }
    }
    for (var i = 0; i < xs.length; i++) {
      var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);
      if (x < minX) {
        minX = x;
      }
      if (x > maxX) {
        maxX = x;
      }
    }
    var yDim = yExtrema(rx, ry, xRotation);
    var minY = Infinity;
    var maxY = -Infinity;
    var ys = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var yAngle = yDim + i;
      if (startAngle < endAngle) {
        if (startAngle < yAngle && yAngle < endAngle) {
          ys.push(yAngle);
        }
      } else {
        if (endAngle < yAngle && yAngle < startAngle) {
          ys.push(yAngle);
        }
      }
    }
    for (var i = 0; i < ys.length; i++) {
      var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);
      if (y < minY) {
        minY = y;
      }
      if (y > maxY) {
        maxY = y;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  },
  length: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  },
  nearestPoint: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var relativeVector = rotate$1(x0 - cx, y0 - cy, -xRotation);
    var x1 = relativeVector[0], y1 = relativeVector[1];
    var relativePoint = ellipse$2.nearestPoint(0, 0, rx, ry, x1, y1);
    var angle2 = getAngle$2(rx, ry, relativePoint.x, relativePoint.y);
    if (angle2 < startAngle) {
      relativePoint = getPoint(rx, ry, startAngle);
    } else if (angle2 > endAngle) {
      relativePoint = getPoint(rx, ry, endAngle);
    }
    var vector = rotate$1(relativePoint.x, relativePoint.y, xRotation);
    return {
      x: vector[0] + cx,
      y: vector[1] + cy
    };
  },
  pointDistance: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var nearestPoint2 = this.nearestPoint(cx, cy, rx, ry, x0, y0);
    return distance$5(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  pointAt: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle2 = (endAngle - startAngle) * t + startAngle;
    return {
      x: xAt(cx, cy, rx, ry, xRotation, angle2),
      y: yAt(cx, cy, rx, ry, xRotation, angle2)
    };
  },
  tangentAngle: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle2 = (endAngle - startAngle) * t + startAngle;
    var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2);
    var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2);
    return piMod(Math.atan2(dy, dx));
  }
};
function analyzePoints(points) {
  var totalLength = 0;
  var segments = [];
  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    var length_1 = distance$5(from[0], from[1], to[0], to[1]);
    var seg = {
      from,
      to,
      length: length_1
    };
    segments.push(seg);
    totalLength += length_1;
  }
  return { segments, totalLength };
}
function lengthOfSegment(points) {
  if (points.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    totalLength += distance$5(from[0], from[1], to[0], to[1]);
  }
  return totalLength;
}
function pointAtSegments(points, t) {
  if (t > 1 || t < 0 || points.length < 2) {
    return null;
  }
  var _a2 = analyzePoints(points), segments = _a2.segments, totalLength = _a2.totalLength;
  if (totalLength === 0) {
    return {
      x: points[0][0],
      y: points[0][1]
    };
  }
  var startRatio = 0;
  var point2 = null;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      var localRatio = (t - startRatio) / currentRatio;
      point2 = LineUtil.pointAt(from[0], from[1], to[0], to[1], localRatio);
      break;
    }
    startRatio += currentRatio;
  }
  return point2;
}
function angleAtSegments(points, t) {
  if (t > 1 || t < 0 || points.length < 2) {
    return 0;
  }
  var _a2 = analyzePoints(points), segments = _a2.segments, totalLength = _a2.totalLength;
  var startRatio = 0;
  var angle2 = 0;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      angle2 = Math.atan2(to[1] - from[1], to[0] - from[0]);
      break;
    }
    startRatio += currentRatio;
  }
  return angle2;
}
function distanceAtSegment(points, x, y) {
  var minDistance = Infinity;
  for (var i = 0; i < points.length - 1; i++) {
    var point2 = points[i];
    var nextPoint = points[i + 1];
    var distance_1 = LineUtil.pointDistance(point2[0], point2[1], nextPoint[0], nextPoint[1], x, y);
    if (distance_1 < minDistance) {
      minDistance = distance_1;
    }
  }
  return minDistance;
}
var PolylineUtil = {
  box: function(points) {
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
      var point2 = points[i];
      xArr.push(point2[0]);
      yArr.push(point2[1]);
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(points) {
    return lengthOfSegment(points);
  },
  pointAt: function(points, t) {
    return pointAtSegments(points, t);
  },
  pointDistance: function(points, x, y) {
    return distanceAtSegment(points, x, y);
  },
  tangentAngle: function(points, t) {
    return angleAtSegments(points, t);
  }
};
function mergeBBox$1(bbox1, bbox2) {
  if (!bbox1 || !bbox2) {
    return bbox1 || bbox2;
  }
  return {
    minX: Math.min(bbox1.minX, bbox2.minX),
    minY: Math.min(bbox1.minY, bbox2.minY),
    maxX: Math.max(bbox1.maxX, bbox2.maxX),
    maxY: Math.max(bbox1.maxY, bbox2.maxY)
  };
}
function mergeArrowBBox$1(shape, bbox) {
  var startArrowShape = shape.get("startArrowShape");
  var endArrowShape = shape.get("endArrowShape");
  var startArrowBBox = null;
  var endArrowBBox = null;
  if (startArrowShape) {
    startArrowBBox = startArrowShape.getCanvasBBox();
    bbox = mergeBBox$1(bbox, startArrowBBox);
  }
  if (endArrowShape) {
    endArrowBBox = endArrowShape.getCanvasBBox();
    bbox = mergeBBox$1(bbox, endArrowBBox);
  }
  return bbox;
}
function polyline$1(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i = 0; i < points.length; i++) {
    var point2 = points[i];
    xArr.push(point2[0]);
    yArr.push(point2[1]);
  }
  var _a2 = getBBoxByArray(xArr, yArr), x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
  var bbox = {
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height
  };
  bbox = mergeArrowBBox$1(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}
function polygon$2(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i = 0; i < points.length; i++) {
    var point2 = points[i];
    xArr.push(point2[0]);
    yArr.push(point2[1]);
  }
  return getBBoxByArray(xArr, yArr);
}
var offScreenCtx$1 = null;
function getOffScreenContext$1() {
  if (!offScreenCtx$1) {
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    offScreenCtx$1 = canvas.getContext("2d");
  }
  return offScreenCtx$1;
}
function getTextHeight$1(text2, fontSize, lineHeight) {
  var lineCount = 1;
  if (isString(text2)) {
    lineCount = text2.split("\n").length;
  }
  if (lineCount > 1) {
    var spaceingY = getLineSpaceing$1(fontSize, lineHeight);
    return fontSize * lineCount + spaceingY * (lineCount - 1);
  }
  return fontSize;
}
function getLineSpaceing$1(fontSize, lineHeight) {
  return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
}
function getTextWidth$1(text2, font) {
  var context = getOffScreenContext$1();
  var width = 0;
  if (isNil(text2) || text2 === "") {
    return width;
  }
  context.save();
  context.font = font;
  if (isString(text2) && text2.includes("\n")) {
    var textArr = text2.split("\n");
    each$1(textArr, function(subText) {
      var measureWidth = context.measureText(subText).width;
      if (width < measureWidth) {
        width = measureWidth;
      }
    });
  } else {
    width = context.measureText(text2).width;
  }
  context.restore();
  return width;
}
function assembleFont$1(attrs) {
  var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
  return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ").trim();
}
function text$1(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, text2 = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;
  var font = attrs.font;
  if (!font) {
    font = assembleFont$1(attrs);
  }
  var width = getTextWidth$1(text2, font);
  var bbox;
  if (!width) {
    bbox = {
      x,
      y,
      width: 0,
      height: 0
    };
  } else {
    var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
    var height = getTextHeight$1(text2, fontSize, lineHeight);
    var point2 = {
      x,
      y: y - height
    };
    if (textAlign) {
      if (textAlign === "end" || textAlign === "right") {
        point2.x -= width;
      } else if (textAlign === "center") {
        point2.x -= width / 2;
      }
    }
    if (textBaseline) {
      if (textBaseline === "top") {
        point2.y += height;
      } else if (textBaseline === "middle") {
        point2.y += height / 2;
      }
    }
    bbox = {
      x: point2.x,
      y: point2.y,
      width,
      height
    };
  }
  return bbox;
}
var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
var regexDot = /[^\s\,]+/ig;
function parsePath(p) {
  var path2 = p || [];
  if (isArray$1(path2)) {
    return path2;
  }
  if (isString(path2)) {
    path2 = path2.match(regexTags);
    each$1(path2, function(item, index2) {
      item = item.match(regexDot);
      if (item[0].length > 1) {
        var tag = item[0].charAt(0);
        item.splice(1, 0, item[0].substr(1));
        item[0] = tag;
      }
      each$1(item, function(sub2, i) {
        if (!isNaN(sub2)) {
          item[i] = +sub2;
        }
      });
      path2[index2] = item;
    });
    return path2;
  }
}
function smoothBezier$2(points, smooth, isLoop, constraint) {
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min2;
  var max2;
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    min2 = constraint[0], max2 = constraint[1];
    for (var i = 0, l = points.length; i < l; i += 1) {
      var point2 = points[i];
      min2 = min$2([0, 0], min2, point2);
      max2 = max$2([0, 0], max2, point2);
    }
  }
  for (var i = 0, len = points.length; i < len; i += 1) {
    var point2 = points[i];
    if (i === 0 && !isLoop) {
      cp0 = point2;
    } else if (i === len - 1 && !isLoop) {
      cp1 = point2;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      var prevIdx = [i ? i - 1 : len - 1, i - 1][isLoop ? 0 : 1];
      prevPoint = points[prevIdx];
      nextPoint = points[isLoop ? (i + 1) % len : i + 1];
      var v = [0, 0];
      v = sub(v, nextPoint, prevPoint);
      v = scale$2(v, v, smooth);
      var d0 = distance$6(point2, prevPoint);
      var d1 = distance$6(point2, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      var v1 = scale$2([0, 0], v, -d0);
      var v2 = scale$2([0, 0], v, d1);
      cp1 = add([0, 0], point2, v1);
      nextCp0 = add([0, 0], point2, v2);
      nextCp0 = min$2([0, 0], nextCp0, max$2([0, 0], nextPoint, point2));
      nextCp0 = max$2([0, 0], nextCp0, min$2([0, 0], nextPoint, point2));
      v1 = sub([0, 0], nextCp0, point2);
      v1 = scale$2([0, 0], v1, -d0 / d1);
      cp1 = add([0, 0], point2, v1);
      cp1 = min$2([0, 0], cp1, max$2([0, 0], prevPoint, point2));
      cp1 = max$2([0, 0], cp1, min$2([0, 0], prevPoint, point2));
      v2 = sub([0, 0], point2, cp1);
      v2 = scale$2([0, 0], v2, d1 / d0);
      nextCp0 = add([0, 0], point2, v2);
      if (hasConstraint) {
        cp1 = max$2([0, 0], cp1, min2);
        cp1 = min$2([0, 0], cp1, max2);
        nextCp0 = max$2([0, 0], nextCp0, min2);
        nextCp0 = min$2([0, 0], nextCp0, max2);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function catmullRom2Bezier(crp, z, constraint) {
  if (z === void 0) {
    z = false;
  }
  if (constraint === void 0) {
    constraint = [
      [0, 0],
      [1, 1]
    ];
  }
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = smoothBezier$2(pointList, 0.4, isLoop, constraint);
  var len = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len - 1; i += 1) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len];
    cp2 = controlPointList[len + 1];
    p = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  return d1;
}
var SPACES$1 = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND$1 = new RegExp("([a-z])[" + SPACES$1 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES$1 + "]*,?[" + SPACES$1 + "]*)+)", "ig");
var PATH_VALUES$1 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES$1 + "]*,?[" + SPACES$1 + "]*", "ig");
function parsePathString$1(pathString) {
  if (!pathString) {
    return null;
  }
  if (isArray$1(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data2 = [];
  String(pathString).replace(PATH_COMMAND$1, function(a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES$1, function(a2, b2) {
      b2 && params.push(+b2);
    });
    if (name === "m" && params.length > 2) {
      data2.push([b].concat(params.splice(0, 2)));
      name = "l";
      b = b === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data2.push([b, params[0]]);
    }
    if (name === "r") {
      data2.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data2.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return "";
  });
  return data2;
}
var REGEX_MD = /[a-z]/;
function toSymmetry$1(p, c) {
  return [
    c[0] + (c[0] - p[0]),
    c[1] + (c[1] - p[1])
  ];
}
function pathToAbsolute(pathString) {
  var pathArray = parsePathString$1(pathString);
  if (!pathArray || !pathArray.length) {
    return [
      ["M", 0, 0]
    ];
  }
  var needProcess = false;
  for (var i = 0; i < pathArray.length; i++) {
    var cmd = pathArray[i][0];
    if (REGEX_MD.test(cmd) || ["V", "H", "T", "S"].indexOf(cmd) >= 0) {
      needProcess = true;
      break;
    }
  }
  if (!needProcess) {
    return pathArray;
  }
  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var first = pathArray[0];
  if (first[0] === "M" || first[0] === "m") {
    x = +first[1];
    y = +first[2];
    mx = x;
    my = y;
    start++;
    res[0] = ["M", x, y];
  }
  for (var i = start, ii = pathArray.length; i < ii; i++) {
    var pa = pathArray[i];
    var preParams = res[i - 1];
    var r = [];
    var cmd = pa[0];
    var upCmd = cmd.toUpperCase();
    if (cmd !== upCmd) {
      r[0] = upCmd;
      switch (upCmd) {
        case "A":
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;
        case "V":
          r[1] = +pa[1] + y;
          break;
        case "H":
          r[1] = +pa[1] + x;
          break;
        case "M":
          mx = +pa[1] + x;
          my = +pa[2] + y;
          r[1] = mx;
          r[2] = my;
          break;
        default:
          for (var j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }
      }
    } else {
      r = pathArray[i];
    }
    switch (upCmd) {
      case "Z":
        x = +mx;
        y = +my;
        break;
      case "H":
        x = r[1];
        r = ["L", x, y];
        break;
      case "V":
        y = r[1];
        r = ["L", x, y];
        break;
      case "T":
        x = r[1];
        y = r[2];
        var symetricT = toSymmetry$1([preParams[1], preParams[2]], [preParams[3], preParams[4]]);
        r = ["Q", symetricT[0], symetricT[1], x, y];
        break;
      case "S":
        x = r[r.length - 2];
        y = r[r.length - 1];
        var length_1 = preParams.length;
        var symetricS = toSymmetry$1([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);
        r = ["C", symetricS[0], symetricS[1], r[1], r[2], x, y];
        break;
      case "M":
        mx = r[r.length - 2];
        my = r[r.length - 1];
        break;
      default:
        x = r[r.length - 2];
        y = r[r.length - 1];
    }
    res.push(r);
  }
  return res;
}
function vMag$1(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio$1(u, v) {
  return vMag$1(u) * vMag$1(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag$1(u) * vMag$1(v)) : 1;
}
function vAngle$1(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio$1(u, v));
}
function isSamePoint$1(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
function getArcParams$1(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod$1(toRadian(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff2 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff2 ? Math.sqrt((rx * rx * (ry * ry) - diff2) / diff2) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle$1([1, 0], u);
  var dTheta = vAngle$1(u, v);
  if (vRatio$1(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio$1(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    rx: isSamePoint$1(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint$1(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}
function toSymmetry(point2, center2) {
  return [center2[0] + (center2[0] - point2[0]), center2[1] + (center2[1] - point2[1])];
}
function getSegments(path2) {
  path2 = parsePath(path2);
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count = path2.length;
  for (var i = 0; i < count; i++) {
    var params = path2[i];
    nextParams = path2[i + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i;
        break;
      case "A":
        var arcParams = getArcParams$1(currentPoint, params);
        segment["arcParams"] = arcParams;
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path2[lastStartMovePointIndex + 1];
    } else {
      var len = params.length;
      currentPoint = [params[len - 2], params[len - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path2[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment["currentPoint"] = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint$1(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment["nextPoint"] = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i - 1];
      var cp = toSymmetry(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var preSegment = segments[i - 1];
      var cp1 = toSymmetry(preSegment.currentPoint, prePoint);
      var cp2 = [params[1], params[2]];
      if (preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      }
    } else if (command === "A") {
      var d = 1e-3;
      var _a2 = segment["arcParams"] || {}, _b = _a2.cx, cx = _b === void 0 ? 0 : _b, _c = _a2.cy, cy = _c === void 0 ? 0 : _c, _d = _a2.rx, rx = _d === void 0 ? 0 : _d, _e = _a2.ry, ry = _e === void 0 ? 0 : _e, _f = _a2.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a2.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a2.endAngle, endAngle = _h === void 0 ? 0 : _h;
      if (sweepFlag === 0) {
        d *= -1;
      }
      var dx1 = rx * Math.cos(startAngle - d) + cx;
      var dy1 = ry * Math.sin(startAngle - d) + cy;
      segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];
      var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;
      var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;
      segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];
    }
    segments.push(segment);
  }
  return segments;
}
var isBetween$2 = function(value2, min2, max2) {
  return value2 >= min2 && value2 <= max2;
};
function getLineIntersect(p0, p1, p2, p3) {
  var tolerance2 = 1e-3;
  var E = {
    x: p2.x - p0.x,
    y: p2.y - p0.y
  };
  var D0 = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var D1 = {
    x: p3.x - p2.x,
    y: p3.y - p2.y
  };
  var kross = D0.x * D1.y - D0.y * D1.x;
  var sqrKross = kross * kross;
  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
  var point2 = null;
  if (sqrKross > tolerance2 * sqrLen0 * sqrLen1) {
    var s = (E.x * D1.y - E.y * D1.x) / kross;
    var t = (E.x * D0.y - E.y * D0.x) / kross;
    if (isBetween$2(s, 0, 1) && isBetween$2(t, 0, 1)) {
      point2 = {
        x: p0.x + s * D0.x,
        y: p0.y + s * D0.y
      };
    }
  }
  return point2;
}
var tolerance$1 = 1e-6;
function dcmp$1(x) {
  if (Math.abs(x) < tolerance$1) {
    return 0;
  }
  return x < 0 ? -1 : 1;
}
function onSegment$1(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isInPolygon$1(points, x, y) {
  var isHit = false;
  var n = points.length;
  if (n <= 2) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];
    if (onSegment$1(p1, p2, [x, y])) {
      return true;
    }
    if (dcmp$1(p1[1] - y) > 0 !== dcmp$1(p2[1] - y) > 0 && dcmp$1(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
function parseToLines(points) {
  var lines = [];
  var count = points.length;
  for (var i = 0; i < count - 1; i++) {
    var point2 = points[i];
    var next = points[i + 1];
    lines.push({
      from: {
        x: point2[0],
        y: point2[1]
      },
      to: {
        x: next[0],
        y: next[1]
      }
    });
  }
  if (lines.length > 1) {
    var first = points[0];
    var last2 = points[count - 1];
    lines.push({
      from: {
        x: last2[0],
        y: last2[1]
      },
      to: {
        x: first[0],
        y: first[1]
      }
    });
  }
  return lines;
}
function lineIntersectPolygon(lines, line2) {
  var isIntersect2 = false;
  each$1(lines, function(l) {
    if (getLineIntersect(l.from, l.to, line2.from, line2.to)) {
      isIntersect2 = true;
      return false;
    }
  });
  return isIntersect2;
}
function getBBox(points) {
  var xArr = points.map(function(p) {
    return p[0];
  });
  var yArr = points.map(function(p) {
    return p[1];
  });
  return {
    minX: Math.min.apply(null, xArr),
    maxX: Math.max.apply(null, xArr),
    minY: Math.min.apply(null, yArr),
    maxY: Math.max.apply(null, yArr)
  };
}
function intersectBBox$1(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function isPolygonsIntersect(points1, points2) {
  if (points1.length < 2 || points2.length < 2) {
    return false;
  }
  var bbox1 = getBBox(points1);
  var bbox2 = getBBox(points2);
  if (!intersectBBox$1(bbox1, bbox2)) {
    return false;
  }
  var isIn = false;
  each$1(points2, function(point2) {
    if (isInPolygon$1(points1, point2[0], point2[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  each$1(points1, function(point2) {
    if (isInPolygon$1(points2, point2[0], point2[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  var lines1 = parseToLines(points1);
  var lines2 = parseToLines(points2);
  var isIntersect2 = false;
  each$1(lines2, function(line2) {
    if (lineIntersectPolygon(lines1, line2)) {
      isIntersect2 = true;
      return false;
    }
  });
  return isIntersect2;
}
function getPathBox$1(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box2 = void 0;
    switch (segment.command) {
      case "Q":
        box2 = QuadUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box2 = CubicUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box2 = EllipseArcUtil.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box2) {
      segment.box = box2;
      xArr.push(box2.x, box2.x + box2.width);
      yArr.push(box2.y, box2.y + box2.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item);
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item);
  });
  var minX = min$1(xArr);
  var minY = min$1(yArr);
  var maxX = max$1(xArr);
  var maxY = max$1(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  for (var i = 0; i < segmentsWithAngle.length; i++) {
    var segment = segmentsWithAngle[i];
    var currentPoint = segment.currentPoint;
    var extra = void 0;
    if (currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle$1(segment, lineWidth);
      minX = minX - extra.xExtra;
    } else if (currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle$1(segment, lineWidth);
      maxX = maxX + extra.xExtra;
    }
    if (currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle$1(segment, lineWidth);
      minY = minY - extra.yExtra;
    } else if (currentPoint[1] === maxY) {
      extra = getExtraFromSegmentWithAngle$1(segment, lineWidth);
      maxY = maxY + extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getExtraFromSegmentWithAngle$1(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual$1(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function path$1(shape) {
  var attrs = shape.attr();
  var path2 = attrs.path, stroke = attrs.stroke;
  var lineWidth = stroke ? attrs.lineWidth : 0;
  var segments = shape.get("segments") || getSegments(path2);
  var _a2 = getPathBox$1(segments, lineWidth), x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
  var bbox = {
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height
  };
  bbox = mergeArrowBBox$1(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}
function line$2(shape) {
  var attrs = shape.attr();
  var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var bbox = {
    minX,
    maxX,
    minY,
    maxY
  };
  bbox = mergeArrowBBox$1(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}
function ellipse$1(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, rx = attrs.rx, ry = attrs.ry;
  return {
    x: x - rx,
    y: y - ry,
    width: rx * 2,
    height: ry * 2
  };
}
register$1("rect", rect$2);
register$1("image", rect$2);
register$1("circle", circle$2);
register$1("marker", circle$2);
register$1("polyline", polyline$1);
register$1("polygon", polygon$2);
register$1("text", text$1);
register$1("path", path$1);
register$1("line", line$2);
register$1("ellipse", ellipse$1);
var DEFAULT_Y = 0;
var MARGIN_RATIO = 1 / 2;
var DODGE_RATIO = 1 / 2;
var GAP = 0.05;
var Adjust = function() {
  function Adjust2(cfg) {
    var xField = cfg.xField, yField = cfg.yField, _a2 = cfg.adjustNames, adjustNames = _a2 === void 0 ? ["x", "y"] : _a2;
    this.adjustNames = adjustNames;
    this.xField = xField;
    this.yField = yField;
  }
  Adjust2.prototype.isAdjust = function(dim) {
    return this.adjustNames.indexOf(dim) >= 0;
  };
  Adjust2.prototype.getAdjustRange = function(dim, dimValue, values2) {
    var yField = this.yField;
    var index2 = values2.indexOf(dimValue);
    var length2 = values2.length;
    var pre;
    var next;
    if (!yField && this.isAdjust("y")) {
      pre = 0;
      next = 1;
    } else if (length2 > 1) {
      pre = values2[index2 === 0 ? 0 : index2 - 1];
      next = values2[index2 === length2 - 1 ? length2 - 1 : index2 + 1];
      if (index2 !== 0) {
        pre += (dimValue - pre) / 2;
      } else {
        pre -= (next - dimValue) / 2;
      }
      if (index2 !== length2 - 1) {
        next -= (next - dimValue) / 2;
      } else {
        next += (dimValue - values2[length2 - 2]) / 2;
      }
    } else {
      pre = dimValue === 0 ? 0 : dimValue - 0.5;
      next = dimValue === 0 ? 1 : dimValue + 0.5;
    }
    return {
      pre,
      next
    };
  };
  Adjust2.prototype.adjustData = function(groupedDataArray, mergedData) {
    var _this = this;
    var dimValuesMap = this.getDimValues(mergedData);
    each$1(groupedDataArray, function(dataArray, index2) {
      each$1(dimValuesMap, function(values2, dim) {
        _this.adjustDim(dim, values2, dataArray, index2);
      });
    });
  };
  Adjust2.prototype.groupData = function(data2, dim) {
    each$1(data2, function(record) {
      if (record[dim] === void 0) {
        record[dim] = DEFAULT_Y;
      }
    });
    return groupBy(data2, dim);
  };
  Adjust2.prototype.adjustDim = function(dim, values2, data2, index2) {
  };
  Adjust2.prototype.getDimValues = function(mergedData) {
    var _a2 = this, xField = _a2.xField, yField = _a2.yField;
    var dimValuesMap = {};
    var dims = [];
    if (xField && this.isAdjust("x")) {
      dims.push(xField);
    }
    if (yField && this.isAdjust("y")) {
      dims.push(yField);
    }
    dims.forEach(function(dim2) {
      dimValuesMap[dim2] = valuesOfKey(mergedData, dim2).sort(function(v1, v2) {
        return v1 - v2;
      });
    });
    if (!yField && this.isAdjust("y")) {
      var dim = "y";
      dimValuesMap[dim] = [DEFAULT_Y, 1];
    }
    return dimValuesMap;
  };
  return Adjust2;
}();
var ADJUST_MAP = {};
var getAdjust = function(type) {
  return ADJUST_MAP[type.toLowerCase()];
};
var registerAdjust = function(type, ctor) {
  if (getAdjust(type)) {
    throw new Error("Adjust type '" + type + "' existed.");
  }
  ADJUST_MAP[type.toLowerCase()] = ctor;
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(d, b) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics$1(d, b);
};
function __extends$1(d, b) {
  extendStatics$1(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var Dodge = function(_super) {
  __extends$1(Dodge2, _super);
  function Dodge2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.cacheMap = {};
    _this.adjustDataArray = [];
    _this.mergeData = [];
    var _a2 = cfg.marginRatio, marginRatio = _a2 === void 0 ? MARGIN_RATIO : _a2, _b = cfg.dodgeRatio, dodgeRatio = _b === void 0 ? DODGE_RATIO : _b, dodgeBy = cfg.dodgeBy, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, xDimensionLength = cfg.xDimensionLength, groupNum = cfg.groupNum, defaultSize = cfg.defaultSize, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio;
    _this.marginRatio = marginRatio;
    _this.dodgeRatio = dodgeRatio;
    _this.dodgeBy = dodgeBy;
    _this.intervalPadding = intervalPadding;
    _this.dodgePadding = dodgePadding;
    _this.xDimensionLegenth = xDimensionLength;
    _this.groupNum = groupNum;
    _this.defaultSize = defaultSize;
    _this.maxColumnWidth = maxColumnWidth;
    _this.minColumnWidth = minColumnWidth;
    _this.columnWidthRatio = columnWidthRatio;
    return _this;
  }
  Dodge2.prototype.process = function(groupDataArray) {
    var groupedDataArray = clone(groupDataArray);
    var mergeData = flatten(groupedDataArray);
    var dodgeBy = this.dodgeBy;
    var adjustDataArray = dodgeBy ? group$1(mergeData, dodgeBy) : groupedDataArray;
    this.cacheMap = {};
    this.adjustDataArray = adjustDataArray;
    this.mergeData = mergeData;
    this.adjustData(adjustDataArray, mergeData);
    this.adjustDataArray = [];
    this.mergeData = [];
    return groupedDataArray;
  };
  Dodge2.prototype.adjustDim = function(dim, values2, data2, frameIndex) {
    var _this = this;
    var map2 = this.getDistribution(dim);
    var groupData = this.groupData(data2, dim);
    each$1(groupData, function(group2, key) {
      var range;
      if (values2.length === 1) {
        range = {
          pre: values2[0] - 1,
          next: values2[0] + 1
        };
      } else {
        range = _this.getAdjustRange(dim, parseFloat(key), values2);
      }
      each$1(group2, function(d) {
        var value2 = d[dim];
        var valueArr = map2[value2];
        var valIndex = valueArr.indexOf(frameIndex);
        d[dim] = _this.getDodgeOffset(range, valIndex, valueArr.length);
      });
    });
    return [];
  };
  Dodge2.prototype.getDodgeOffset = function(range, idx, len) {
    var _a2 = this, dodgeRatio = _a2.dodgeRatio, marginRatio = _a2.marginRatio, intervalPadding = _a2.intervalPadding, dodgePadding = _a2.dodgePadding;
    var pre = range.pre, next = range.next;
    var tickLength = next - pre;
    var position;
    if (!isNil(intervalPadding) && isNil(dodgePadding) && intervalPadding >= 0) {
      var offset = this.getIntervalOnlyOffset(len, idx);
      position = pre + offset;
    } else if (!isNil(dodgePadding) && isNil(intervalPadding) && dodgePadding >= 0) {
      var offset = this.getDodgeOnlyOffset(len, idx);
      position = pre + offset;
    } else if (!isNil(intervalPadding) && !isNil(dodgePadding) && intervalPadding >= 0 && dodgePadding >= 0) {
      var offset = this.getIntervalAndDodgeOffset(len, idx);
      position = pre + offset;
    } else {
      var width = tickLength * dodgeRatio / len;
      var margin = marginRatio * width;
      var offset = 1 / 2 * (tickLength - len * width - (len - 1) * margin) + ((idx + 1) * width + idx * margin) - 1 / 2 * width - 1 / 2 * tickLength;
      position = (pre + next) / 2 + offset;
    }
    return position;
  };
  Dodge2.prototype.getIntervalOnlyOffset = function(len, idx) {
    var _a2 = this, defaultSize = _a2.defaultSize, intervalPadding = _a2.intervalPadding, xDimensionLegenth = _a2.xDimensionLegenth, groupNum = _a2.groupNum, dodgeRatio = _a2.dodgeRatio, maxColumnWidth = _a2.maxColumnWidth, minColumnWidth = _a2.minColumnWidth, columnWidthRatio = _a2.columnWidthRatio;
    var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
    var normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len - 1);
    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
    geomWidth = !isNil(columnWidthRatio) ? 1 / groupNum / len * columnWidthRatio : geomWidth;
    if (!isNil(maxColumnWidth)) {
      var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
      geomWidth = Math.min(geomWidth, normalizedMaxWidht);
    }
    if (!isNil(minColumnWidth)) {
      var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
      geomWidth = Math.max(geomWidth, normalizedMinWidht);
    }
    geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
    normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len * geomWidth) / (len - 1);
    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
    return offset;
  };
  Dodge2.prototype.getDodgeOnlyOffset = function(len, idx) {
    var _a2 = this, defaultSize = _a2.defaultSize, dodgePadding = _a2.dodgePadding, xDimensionLegenth = _a2.xDimensionLegenth, groupNum = _a2.groupNum, marginRatio = _a2.marginRatio, maxColumnWidth = _a2.maxColumnWidth, minColumnWidth = _a2.minColumnWidth, columnWidthRatio = _a2.columnWidthRatio;
    var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
    var normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);
    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
    geomWidth = columnWidthRatio ? 1 / groupNum / len * columnWidthRatio : geomWidth;
    if (!isNil(maxColumnWidth)) {
      var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
      geomWidth = Math.min(geomWidth, normalizedMaxWidht);
    }
    if (!isNil(minColumnWidth)) {
      var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
      geomWidth = Math.max(geomWidth, normalizedMinWidht);
    }
    geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
    normalizedIntervalPadding = (1 - (geomWidth * len + normalizedDodgePadding * (len - 1)) * groupNum) / (groupNum - 1);
    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
    return offset;
  };
  Dodge2.prototype.getIntervalAndDodgeOffset = function(len, idx) {
    var _a2 = this, intervalPadding = _a2.intervalPadding, dodgePadding = _a2.dodgePadding, xDimensionLegenth = _a2.xDimensionLegenth, groupNum = _a2.groupNum;
    var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
    var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
    return offset;
  };
  Dodge2.prototype.getDistribution = function(dim) {
    var groupedDataArray = this.adjustDataArray;
    var cacheMap = this.cacheMap;
    var map2 = cacheMap[dim];
    if (!map2) {
      map2 = {};
      each$1(groupedDataArray, function(data2, index2) {
        var values2 = valuesOfKey(data2, dim);
        if (!values2.length) {
          values2.push(0);
        }
        each$1(values2, function(val) {
          if (!map2[val]) {
            map2[val] = [];
          }
          map2[val].push(index2);
        });
      });
      cacheMap[dim] = map2;
    }
    return map2;
  };
  return Dodge2;
}(Adjust);
function randomNumber(min2, max2) {
  return (max2 - min2) * Math.random() + min2;
}
var Jitter = function(_super) {
  __extends$1(Jitter2, _super);
  function Jitter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Jitter2.prototype.process = function(groupDataArray) {
    var groupedDataArray = clone(groupDataArray);
    var mergeData = flatten(groupedDataArray);
    this.adjustData(groupedDataArray, mergeData);
    return groupedDataArray;
  };
  Jitter2.prototype.adjustDim = function(dim, values2, dataArray) {
    var _this = this;
    var groupDataArray = this.groupData(dataArray, dim);
    return each$1(groupDataArray, function(data2, dimValue) {
      return _this.adjustGroup(data2, dim, parseFloat(dimValue), values2);
    });
  };
  Jitter2.prototype.getAdjustOffset = function(range) {
    var pre = range.pre, next = range.next;
    var margin = (next - pre) * GAP;
    return randomNumber(pre + margin, next - margin);
  };
  Jitter2.prototype.adjustGroup = function(group2, dim, dimValue, values2) {
    var _this = this;
    var range = this.getAdjustRange(dim, dimValue, values2);
    each$1(group2, function(data2) {
      data2[dim] = _this.getAdjustOffset(range);
    });
    return group2;
  };
  return Jitter2;
}(Adjust);
var Cache = default_1;
var Stack = function(_super) {
  __extends$1(Stack2, _super);
  function Stack2(cfg) {
    var _this = _super.call(this, cfg) || this;
    var _a2 = cfg.adjustNames, adjustNames = _a2 === void 0 ? ["y"] : _a2, _b = cfg.height, height = _b === void 0 ? NaN : _b, _c = cfg.size, size2 = _c === void 0 ? 10 : _c, _d = cfg.reverseOrder, reverseOrder = _d === void 0 ? false : _d;
    _this.adjustNames = adjustNames;
    _this.height = height;
    _this.size = size2;
    _this.reverseOrder = reverseOrder;
    return _this;
  }
  Stack2.prototype.process = function(groupDataArray) {
    var _a2 = this, yField = _a2.yField, reverseOrder = _a2.reverseOrder;
    var d = yField ? this.processStack(groupDataArray) : this.processOneDimStack(groupDataArray);
    return reverseOrder ? this.reverse(d) : d;
  };
  Stack2.prototype.reverse = function(groupedDataArray) {
    return groupedDataArray.slice(0).reverse();
  };
  Stack2.prototype.processStack = function(groupDataArray) {
    var _a2 = this, xField = _a2.xField, yField = _a2.yField, reverseOrder = _a2.reverseOrder;
    var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
    var positive = new Cache();
    var negative = new Cache();
    return groupedDataArray.map(function(dataArray) {
      return dataArray.map(function(data2) {
        var _a3;
        var x = get(data2, xField, 0);
        var y = get(data2, [yField]);
        var xKey = x.toString();
        y = isArray$1(y) ? y[1] : y;
        if (!isNil(y)) {
          var cache2 = y >= 0 ? positive : negative;
          if (!cache2.has(xKey)) {
            cache2.set(xKey, 0);
          }
          var xValue = cache2.get(xKey);
          var newXValue = y + xValue;
          cache2.set(xKey, newXValue);
          return __assign(__assign({}, data2), (_a3 = {}, _a3[yField] = [xValue, newXValue], _a3));
        }
        return data2;
      });
    });
  };
  Stack2.prototype.processOneDimStack = function(groupDataArray) {
    var _this = this;
    var _a2 = this, xField = _a2.xField, height = _a2.height, reverseOrder = _a2.reverseOrder;
    var yField = "y";
    var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
    var cache2 = new Cache();
    return groupedDataArray.map(function(dataArray) {
      return dataArray.map(function(data2) {
        var _a3;
        var size2 = _this.size;
        var xValue = data2[xField];
        var stackHeight = size2 * 2 / height;
        if (!cache2.has(xValue)) {
          cache2.set(xValue, stackHeight / 2);
        }
        var stackValue = cache2.get(xValue);
        cache2.set(xValue, stackValue + stackHeight);
        return __assign(__assign({}, data2), (_a3 = {}, _a3[yField] = stackValue, _a3));
      });
    });
  };
  return Stack2;
}(Adjust);
var Symmetric = function(_super) {
  __extends$1(Symmetric2, _super);
  function Symmetric2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Symmetric2.prototype.process = function(groupDataArray) {
    var mergeData = flatten(groupDataArray);
    var _a2 = this, xField = _a2.xField, yField = _a2.yField;
    var cache2 = this.getXValuesMaxMap(mergeData);
    var max2 = Math.max.apply(Math, Object.keys(cache2).map(function(key) {
      return cache2[key];
    }));
    return map$2(groupDataArray, function(dataArray) {
      return map$2(dataArray, function(data2) {
        var _a3, _b;
        var yValue = data2[yField];
        var xValue = data2[xField];
        if (isArray$1(yValue)) {
          var off_1 = (max2 - cache2[xValue]) / 2;
          return __assign(__assign({}, data2), (_a3 = {}, _a3[yField] = map$2(yValue, function(y) {
            return off_1 + y;
          }), _a3));
        }
        var offset = (max2 - yValue) / 2;
        return __assign(__assign({}, data2), (_b = {}, _b[yField] = [offset, yValue + offset], _b));
      });
    });
  };
  Symmetric2.prototype.getXValuesMaxMap = function(mergeData) {
    var _this = this;
    var _a2 = this, xField = _a2.xField, yField = _a2.yField;
    var groupDataArray = groupBy(mergeData, function(data2) {
      return data2[xField];
    });
    return mapValues(groupDataArray, function(dataArray) {
      return _this.getDimMaxValue(dataArray, yField);
    });
  };
  Symmetric2.prototype.getDimMaxValue = function(mergeData, dim) {
    var dimValues = map$2(mergeData, function(data2) {
      return get(data2, dim, []);
    });
    var flattenValues = flatten(dimValues);
    return Math.max.apply(Math, flattenValues);
  };
  return Symmetric2;
}(Adjust);
registerAdjust("Dodge", Dodge);
registerAdjust("Jitter", Jitter);
registerAdjust("Stack", Stack);
registerAdjust("Symmetric", Symmetric);
var toScaleString = function(scale2, value2) {
  if (isString(value2)) {
    return value2;
  }
  return scale2.invert(scale2.scale(value2));
};
var Attribute = function() {
  function Attribute2(cfg) {
    this.names = [];
    this.scales = [];
    this.linear = false;
    this.values = [];
    this.callback = function() {
      return [];
    };
    this._parseCfg(cfg);
  }
  Attribute2.prototype.mapping = function() {
    var _this = this;
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    var values2 = params.map(function(param, idx) {
      return _this._toOriginParam(param, _this.scales[idx]);
    });
    return this.callback.apply(this, values2);
  };
  Attribute2.prototype.getLinearValue = function(percent2) {
    var steps = this.values.length - 1;
    var step = Math.floor(steps * percent2);
    var leftPercent = steps * percent2 - step;
    var start = this.values[step];
    var end = step === steps ? start : this.values[step + 1];
    return start + (end - start) * leftPercent;
  };
  Attribute2.prototype.getNames = function() {
    var scales = this.scales;
    var names = this.names;
    var length2 = Math.min(scales.length, names.length);
    var rst = [];
    for (var i = 0; i < length2; i += 1) {
      rst.push(names[i]);
    }
    return rst;
  };
  Attribute2.prototype.getFields = function() {
    return this.scales.map(function(scale2) {
      return scale2.field;
    });
  };
  Attribute2.prototype.getScale = function(name) {
    return this.scales[this.names.indexOf(name)];
  };
  Attribute2.prototype.defaultCallback = function() {
    var _this = this;
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    if (params.length === 0) {
      return this.values;
    }
    return params.map(function(param, idx) {
      var scale2 = _this.scales[idx];
      return scale2.type === "identity" ? scale2.values[0] : _this._getAttributeValue(scale2, param);
    });
  };
  Attribute2.prototype._parseCfg = function(cfg) {
    var _this = this;
    var _a2 = cfg.type, type = _a2 === void 0 ? "base" : _a2, _b = cfg.names, names = _b === void 0 ? [] : _b, _c = cfg.scales, scales = _c === void 0 ? [] : _c, _d = cfg.values, values2 = _d === void 0 ? [] : _d, callback = cfg.callback;
    this.type = type;
    this.scales = scales;
    this.values = values2;
    this.names = names;
    this.callback = function() {
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      if (callback) {
        var ret = callback.apply(void 0, params);
        if (!isNil(ret)) {
          return [ret];
        }
      }
      return _this.defaultCallback.apply(_this, params);
    };
  };
  Attribute2.prototype._getAttributeValue = function(scale2, value2) {
    if (scale2.isCategory && !this.linear) {
      var idx = scale2.translate(value2);
      return this.values[idx % this.values.length];
    }
    var percent2 = scale2.scale(value2);
    return this.getLinearValue(percent2);
  };
  Attribute2.prototype._toOriginParam = function(param, scale2) {
    return !scale2.isLinear ? isArray$1(param) ? param.map(function(p) {
      return toScaleString(scale2, p);
    }) : toScaleString(scale2, param) : param;
  };
  return Attribute2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
var regexLG$2 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG$2 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop$2 = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
var isGradientColor$1 = function(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};
var createTmp = function() {
  var i = document.createElement("i");
  i.title = "Web Colour Picker";
  i.style.display = "none";
  document.body.appendChild(i);
  return i;
};
var getValue = function(start, end, percent2, index2) {
  return start[index2] + (end[index2] - start[index2]) * percent2;
};
function arr2rgb(arr) {
  return "#" + toHex(arr[0]) + toHex(arr[1]) + toHex(arr[2]);
}
var rgb2arr = function(str) {
  return [
    parseInt(str.substr(1, 2), 16),
    parseInt(str.substr(3, 2), 16),
    parseInt(str.substr(5, 2), 16)
  ];
};
var toHex = function(value2) {
  var x16Value = Math.round(value2).toString(16);
  return x16Value.length === 1 ? "0" + x16Value : x16Value;
};
var calColor = function(points, percent2) {
  var fixedPercent = isNaN(Number(percent2)) || percent2 < 0 ? 0 : percent2 > 1 ? 1 : Number(percent2);
  var steps = points.length - 1;
  var step = Math.floor(steps * fixedPercent);
  var left2 = steps * fixedPercent - step;
  var start = points[step];
  var end = step === steps ? start : points[step + 1];
  return arr2rgb([
    getValue(start, end, left2, 0),
    getValue(start, end, left2, 1),
    getValue(start, end, left2, 2)
  ]);
};
var iEl;
var toRGB = function(color2) {
  if (color2[0] === "#" && color2.length === 7) {
    return color2;
  }
  if (!iEl) {
    iEl = createTmp();
  }
  iEl.style.color = color2;
  var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
  var matches = RGB_REG.exec(rst);
  var cArray = matches[1].split(/\s*,\s*/).map(function(s) {
    return Number(s);
  });
  rst = arr2rgb(cArray);
  return rst;
};
var gradient = function(colors) {
  var colorArray = isString(colors) ? colors.split("-") : colors;
  var points = map$2(colorArray, function(color2) {
    return rgb2arr(color2.indexOf("#") === -1 ? toRGB(color2) : color2);
  });
  return function(percent2) {
    return calColor(points, percent2);
  };
};
var toCSSGradient = function(gradientColor) {
  if (isGradientColor$1(gradientColor)) {
    var cssColor_1;
    var steps = void 0;
    if (gradientColor[0] === "l") {
      var arr = regexLG$2.exec(gradientColor);
      var angle2 = +arr[1] + 90;
      steps = arr[2];
      cssColor_1 = "linear-gradient(" + angle2 + "deg, ";
    } else if (gradientColor[0] === "r") {
      cssColor_1 = "radial-gradient(";
      var arr = regexRG$2.exec(gradientColor);
      steps = arr[4];
    }
    var colorStops_1 = steps.match(regexColorStop$2);
    each$1(colorStops_1, function(item, index2) {
      var itemArr = item.split(":");
      cssColor_1 += itemArr[1] + " " + itemArr[0] * 100 + "%";
      if (index2 !== colorStops_1.length - 1) {
        cssColor_1 += ", ";
      }
    });
    cssColor_1 += ")";
    return cssColor_1;
  }
  return gradientColor;
};
var colorUtil = {
  rgb2arr,
  gradient,
  toRGB: memoize(toRGB),
  toCSSGradient
};
var Color = function(_super) {
  __extends(Color2, _super);
  function Color2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "color";
    _this.names = ["color"];
    if (isString(_this.values)) {
      _this.linear = true;
    }
    _this.gradient = colorUtil.gradient(_this.values);
    return _this;
  }
  Color2.prototype.getLinearValue = function(percent2) {
    return this.gradient(percent2);
  };
  return Color2;
}(Attribute);
var Opacity = function(_super) {
  __extends(Opacity2, _super);
  function Opacity2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "opacity";
    _this.names = ["opacity"];
    return _this;
  }
  return Opacity2;
}(Attribute);
var Position = function(_super) {
  __extends(Position2, _super);
  function Position2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.names = ["x", "y"];
    _this.type = "position";
    return _this;
  }
  Position2.prototype.mapping = function(x, y) {
    var _a2 = this.scales, scaleX = _a2[0], scaleY = _a2[1];
    if (isNil(x) || isNil(y)) {
      return [];
    }
    return [
      isArray$1(x) ? x.map(function(xi) {
        return scaleX.scale(xi);
      }) : scaleX.scale(x),
      isArray$1(y) ? y.map(function(yi) {
        return scaleY.scale(yi);
      }) : scaleY.scale(y)
    ];
  };
  return Position2;
}(Attribute);
var Shape$2 = function(_super) {
  __extends(Shape2, _super);
  function Shape2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "shape";
    _this.names = ["shape"];
    return _this;
  }
  Shape2.prototype.getLinearValue = function(percent2) {
    var idx = Math.round((this.values.length - 1) * percent2);
    return this.values[idx];
  };
  return Shape2;
}(Attribute);
var Size = function(_super) {
  __extends(Size2, _super);
  function Size2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "size";
    _this.names = ["size"];
    return _this;
  }
  return Size2;
}(Attribute);
var methodCache = {};
function getTickMethod(key) {
  return methodCache[key];
}
function registerTickMethod(key, method) {
  methodCache[key] = method;
}
var Scale = function() {
  function Scale2(cfg) {
    this.type = "base";
    this.isCategory = false;
    this.isLinear = false;
    this.isContinuous = false;
    this.isIdentity = false;
    this.values = [];
    this.range = [0, 1];
    this.ticks = [];
    this.__cfg__ = cfg;
    this.initCfg();
    this.init();
  }
  Scale2.prototype.translate = function(v) {
    return v;
  };
  Scale2.prototype.change = function(cfg) {
    mix(this.__cfg__, cfg);
    this.init();
  };
  Scale2.prototype.clone = function() {
    return this.constructor(this.__cfg__);
  };
  Scale2.prototype.getTicks = function() {
    var _this = this;
    return map$2(this.ticks, function(tick, idx) {
      if (isObject(tick)) {
        return tick;
      }
      return {
        text: _this.getText(tick, idx),
        tickValue: tick,
        value: _this.scale(tick)
      };
    });
  };
  Scale2.prototype.getText = function(value2, key) {
    var formatter = this.formatter;
    var res = formatter ? formatter(value2, key) : value2;
    if (isNil(res) || !isFunction(res.toString)) {
      return "";
    }
    return res.toString();
  };
  Scale2.prototype.getConfig = function(key) {
    return this.__cfg__[key];
  };
  Scale2.prototype.init = function() {
    mix(this, this.__cfg__);
    this.setDomain();
    if (isEmpty(this.getConfig("ticks"))) {
      this.ticks = this.calculateTicks();
    }
  };
  Scale2.prototype.initCfg = function() {
  };
  Scale2.prototype.setDomain = function() {
  };
  Scale2.prototype.calculateTicks = function() {
    var tickMethod = this.tickMethod;
    var ticks = [];
    if (isString(tickMethod)) {
      var method = getTickMethod(tickMethod);
      if (!method) {
        throw new Error("There is no method to to calculate ticks!");
      }
      ticks = method(this);
    } else if (isFunction(tickMethod)) {
      ticks = tickMethod(this);
    }
    return ticks;
  };
  Scale2.prototype.rangeMin = function() {
    return this.range[0];
  };
  Scale2.prototype.rangeMax = function() {
    return this.range[1];
  };
  Scale2.prototype.calcPercent = function(value2, min2, max2) {
    if (isNumber$1(value2)) {
      return (value2 - min2) / (max2 - min2);
    }
    return NaN;
  };
  Scale2.prototype.calcValue = function(percent2, min2, max2) {
    return min2 + percent2 * (max2 - min2);
  };
  return Scale2;
}();
var Category$1 = function(_super) {
  __extends$2(Category2, _super);
  function Category2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "cat";
    _this.isCategory = true;
    return _this;
  }
  Category2.prototype.buildIndexMap = function() {
    if (!this.translateIndexMap) {
      this.translateIndexMap = new Map();
      for (var i = 0; i < this.values.length; i++) {
        this.translateIndexMap.set(this.values[i], i);
      }
    }
  };
  Category2.prototype.translate = function(value2) {
    this.buildIndexMap();
    var idx = this.translateIndexMap.get(value2);
    if (idx === void 0) {
      idx = isNumber$1(value2) ? value2 : NaN;
    }
    return idx;
  };
  Category2.prototype.scale = function(value2) {
    var order = this.translate(value2);
    var percent2 = this.calcPercent(order, this.min, this.max);
    return this.calcValue(percent2, this.rangeMin(), this.rangeMax());
  };
  Category2.prototype.invert = function(scaledValue) {
    var domainRange = this.max - this.min;
    var percent2 = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());
    var idx = Math.round(domainRange * percent2) + this.min;
    if (idx < this.min || idx > this.max) {
      return NaN;
    }
    return this.values[idx];
  };
  Category2.prototype.getText = function(value2) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var v = value2;
    if (isNumber$1(value2) && !this.values.includes(value2)) {
      v = this.values[v];
    }
    return _super.prototype.getText.apply(this, __spreadArray([v], args, false));
  };
  Category2.prototype.initCfg = function() {
    this.tickMethod = "cat";
  };
  Category2.prototype.setDomain = function() {
    if (isNil(this.getConfig("min"))) {
      this.min = 0;
    }
    if (isNil(this.getConfig("max"))) {
      var size2 = this.values.length;
      this.max = size2 > 1 ? size2 - 1 : size2;
    }
    if (this.translateIndexMap) {
      this.translateIndexMap = void 0;
    }
  };
  return Category2;
}(Scale);
function bisector(getter) {
  return function(a, x, _lo, _hi) {
    var lo = isNil(_lo) ? 0 : _lo;
    var hi = isNil(_hi) ? a.length : _hi;
    while (lo < hi) {
      var mid2 = lo + hi >>> 1;
      if (getter(a[mid2]) > x) {
        hi = mid2;
      } else {
        lo = mid2 + 1;
      }
    }
    return lo;
  };
}
var FORMAT_METHOD = "format";
function timeFormat(time, mask) {
  var method = fecha1[FORMAT_METHOD] || fecha[FORMAT_METHOD];
  return method(time, mask);
}
function toTimeStamp(value2) {
  if (isString(value2)) {
    if (value2.indexOf("T") > 0) {
      value2 = new Date(value2).getTime();
    } else {
      value2 = new Date(value2.replace(/-/gi, "/")).getTime();
    }
  }
  if (isDate(value2)) {
    value2 = value2.getTime();
  }
  return value2;
}
var SECOND = 1e3;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
var MONTH = DAY * 31;
var YEAR = DAY * 365;
var intervals = [
  ["HH:mm:ss", SECOND],
  ["HH:mm:ss", SECOND * 10],
  ["HH:mm:ss", SECOND * 30],
  ["HH:mm", MINUTE],
  ["HH:mm", MINUTE * 10],
  ["HH:mm", MINUTE * 30],
  ["HH", HOUR],
  ["HH", HOUR * 6],
  ["HH", HOUR * 12],
  ["YYYY-MM-DD", DAY],
  ["YYYY-MM-DD", DAY * 4],
  ["YYYY-WW", DAY * 7],
  ["YYYY-MM", MONTH],
  ["YYYY-MM", MONTH * 4],
  ["YYYY-MM", MONTH * 6],
  ["YYYY", DAY * 380]
];
function getTickInterval(min2, max2, tickCount) {
  var target = (max2 - min2) / tickCount;
  var idx = bisector(function(o) {
    return o[1];
  })(intervals, target) - 1;
  var interval2 = intervals[idx];
  if (idx < 0) {
    interval2 = intervals[0];
  } else if (idx >= intervals.length) {
    interval2 = last(intervals);
  }
  return interval2;
}
var TimeCat = function(_super) {
  __extends$2(TimeCat2, _super);
  function TimeCat2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "timeCat";
    return _this;
  }
  TimeCat2.prototype.translate = function(value2) {
    value2 = toTimeStamp(value2);
    var index2 = this.values.indexOf(value2);
    if (index2 === -1) {
      if (isNumber$1(value2) && value2 < this.values.length) {
        index2 = value2;
      } else {
        index2 = NaN;
      }
    }
    return index2;
  };
  TimeCat2.prototype.getText = function(value2, tickIndex) {
    var index2 = this.translate(value2);
    if (index2 > -1) {
      var result = this.values[index2];
      var formatter = this.formatter;
      result = formatter ? formatter(result, tickIndex) : timeFormat(result, this.mask);
      return result;
    }
    return value2;
  };
  TimeCat2.prototype.initCfg = function() {
    this.tickMethod = "time-cat";
    this.mask = "YYYY-MM-DD";
    this.tickCount = 7;
  };
  TimeCat2.prototype.setDomain = function() {
    var values2 = this.values;
    each$1(values2, function(v, i) {
      values2[i] = toTimeStamp(v);
    });
    values2.sort(function(v1, v2) {
      return v1 - v2;
    });
    _super.prototype.setDomain.call(this);
  };
  return TimeCat2;
}(Category$1);
var Continuous = function(_super) {
  __extends$2(Continuous2, _super);
  function Continuous2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.isContinuous = true;
    return _this;
  }
  Continuous2.prototype.scale = function(value2) {
    if (isNil(value2)) {
      return NaN;
    }
    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    var max2 = this.max;
    var min2 = this.min;
    if (max2 === min2) {
      return rangeMin;
    }
    var percent2 = this.getScalePercent(value2);
    return rangeMin + percent2 * (rangeMax - rangeMin);
  };
  Continuous2.prototype.init = function() {
    _super.prototype.init.call(this);
    var ticks = this.ticks;
    var firstTick = head(ticks);
    var lastTick = last(ticks);
    if (firstTick < this.min) {
      this.min = firstTick;
    }
    if (lastTick > this.max) {
      this.max = lastTick;
    }
    if (!isNil(this.minLimit)) {
      this.min = firstTick;
    }
    if (!isNil(this.maxLimit)) {
      this.max = lastTick;
    }
  };
  Continuous2.prototype.setDomain = function() {
    var _a2 = getRange(this.values), min2 = _a2.min, max2 = _a2.max;
    if (isNil(this.min)) {
      this.min = min2;
    }
    if (isNil(this.max)) {
      this.max = max2;
    }
    if (this.min > this.max) {
      this.min = min2;
      this.max = max2;
    }
  };
  Continuous2.prototype.calculateTicks = function() {
    var _this = this;
    var ticks = _super.prototype.calculateTicks.call(this);
    if (!this.nice) {
      ticks = filter(ticks, function(tick) {
        return tick >= _this.min && tick <= _this.max;
      });
    }
    return ticks;
  };
  Continuous2.prototype.getScalePercent = function(value2) {
    var max2 = this.max;
    var min2 = this.min;
    return (value2 - min2) / (max2 - min2);
  };
  Continuous2.prototype.getInvertPercent = function(value2) {
    return (value2 - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
  };
  return Continuous2;
}(Scale);
var Linear = function(_super) {
  __extends$2(Linear2, _super);
  function Linear2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "linear";
    _this.isLinear = true;
    return _this;
  }
  Linear2.prototype.invert = function(value2) {
    var percent2 = this.getInvertPercent(value2);
    return this.min + percent2 * (this.max - this.min);
  };
  Linear2.prototype.initCfg = function() {
    this.tickMethod = "wilkinson-extended";
    this.nice = false;
  };
  return Linear2;
}(Continuous);
function calBase(a, b) {
  var e = Math.E;
  var value2;
  if (b >= 0) {
    value2 = Math.pow(e, Math.log(b) / a);
  } else {
    value2 = Math.pow(e, Math.log(-b) / a) * -1;
  }
  return value2;
}
function log$1(a, b) {
  if (a === 1) {
    return 1;
  }
  return Math.log(b) / Math.log(a);
}
function getLogPositiveMin(values2, base, max2) {
  if (isNil(max2)) {
    max2 = Math.max.apply(null, values2);
  }
  var positiveMin = max2;
  each$1(values2, function(value2) {
    if (value2 > 0 && value2 < positiveMin) {
      positiveMin = value2;
    }
  });
  if (positiveMin === max2) {
    positiveMin = max2 / base;
  }
  if (positiveMin > 1) {
    positiveMin = 1;
  }
  return positiveMin;
}
var Log = function(_super) {
  __extends$2(Log2, _super);
  function Log2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "log";
    return _this;
  }
  Log2.prototype.invert = function(value2) {
    var base = this.base;
    var max2 = log$1(base, this.max);
    var rangeMin = this.rangeMin();
    var range = this.rangeMax() - rangeMin;
    var min2;
    var positiveMin = this.positiveMin;
    if (positiveMin) {
      if (value2 === 0) {
        return 0;
      }
      min2 = log$1(base, positiveMin / base);
      var appendPercent = 1 / (max2 - min2) * range;
      if (value2 < appendPercent) {
        return value2 / appendPercent * positiveMin;
      }
    } else {
      min2 = log$1(base, this.min);
    }
    var percent2 = (value2 - rangeMin) / range;
    var tmp = percent2 * (max2 - min2) + min2;
    return Math.pow(base, tmp);
  };
  Log2.prototype.initCfg = function() {
    this.tickMethod = "log";
    this.base = 10;
    this.tickCount = 6;
    this.nice = true;
  };
  Log2.prototype.setDomain = function() {
    _super.prototype.setDomain.call(this);
    var min2 = this.min;
    if (min2 < 0) {
      throw new Error("When you use log scale, the minimum value must be greater than zero!");
    }
    if (min2 === 0) {
      this.positiveMin = getLogPositiveMin(this.values, this.base, this.max);
    }
  };
  Log2.prototype.getScalePercent = function(value2) {
    var max2 = this.max;
    var min2 = this.min;
    if (max2 === min2) {
      return 0;
    }
    if (value2 <= 0) {
      return 0;
    }
    var base = this.base;
    var positiveMin = this.positiveMin;
    if (positiveMin) {
      min2 = positiveMin * 1 / base;
    }
    var percent2;
    if (value2 < positiveMin) {
      percent2 = value2 / positiveMin / (log$1(base, max2) - log$1(base, min2));
    } else {
      percent2 = (log$1(base, value2) - log$1(base, min2)) / (log$1(base, max2) - log$1(base, min2));
    }
    return percent2;
  };
  return Log2;
}(Continuous);
var Pow = function(_super) {
  __extends$2(Pow2, _super);
  function Pow2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "pow";
    return _this;
  }
  Pow2.prototype.invert = function(value2) {
    var percent2 = this.getInvertPercent(value2);
    var exponent = this.exponent;
    var max2 = calBase(exponent, this.max);
    var min2 = calBase(exponent, this.min);
    var tmp = percent2 * (max2 - min2) + min2;
    var factor = tmp >= 0 ? 1 : -1;
    return Math.pow(tmp, exponent) * factor;
  };
  Pow2.prototype.initCfg = function() {
    this.tickMethod = "pow";
    this.exponent = 2;
    this.tickCount = 5;
    this.nice = true;
  };
  Pow2.prototype.getScalePercent = function(value2) {
    var max2 = this.max;
    var min2 = this.min;
    if (max2 === min2) {
      return 0;
    }
    var exponent = this.exponent;
    var percent2 = (calBase(exponent, value2) - calBase(exponent, min2)) / (calBase(exponent, max2) - calBase(exponent, min2));
    return percent2;
  };
  return Pow2;
}(Continuous);
var Time = function(_super) {
  __extends$2(Time2, _super);
  function Time2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "time";
    return _this;
  }
  Time2.prototype.getText = function(value2, index2) {
    var numberValue = this.translate(value2);
    var formatter = this.formatter;
    return formatter ? formatter(numberValue, index2) : timeFormat(numberValue, this.mask);
  };
  Time2.prototype.scale = function(value2) {
    var v = value2;
    if (isString(v) || isDate(v)) {
      v = this.translate(v);
    }
    return _super.prototype.scale.call(this, v);
  };
  Time2.prototype.translate = function(v) {
    return toTimeStamp(v);
  };
  Time2.prototype.initCfg = function() {
    this.tickMethod = "time-pretty";
    this.mask = "YYYY-MM-DD";
    this.tickCount = 7;
    this.nice = false;
  };
  Time2.prototype.setDomain = function() {
    var values2 = this.values;
    var minConfig = this.getConfig("min");
    var maxConfig = this.getConfig("max");
    if (!isNil(minConfig) || !isNumber$1(minConfig)) {
      this.min = this.translate(this.min);
    }
    if (!isNil(maxConfig) || !isNumber$1(maxConfig)) {
      this.max = this.translate(this.max);
    }
    if (values2 && values2.length) {
      var timeStamps_1 = [];
      var min_1 = Infinity;
      var secondMin_1 = min_1;
      var max_1 = 0;
      each$1(values2, function(v) {
        var timeStamp = toTimeStamp(v);
        if (isNaN(timeStamp)) {
          throw new TypeError("Invalid Time: " + v + " in time scale!");
        }
        if (min_1 > timeStamp) {
          secondMin_1 = min_1;
          min_1 = timeStamp;
        } else if (secondMin_1 > timeStamp) {
          secondMin_1 = timeStamp;
        }
        if (max_1 < timeStamp) {
          max_1 = timeStamp;
        }
        timeStamps_1.push(timeStamp);
      });
      if (values2.length > 1) {
        this.minTickInterval = secondMin_1 - min_1;
      }
      if (isNil(minConfig)) {
        this.min = min_1;
      }
      if (isNil(maxConfig)) {
        this.max = max_1;
      }
    }
  };
  return Time2;
}(Linear);
var Quantize = function(_super) {
  __extends$2(Quantize2, _super);
  function Quantize2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "quantize";
    return _this;
  }
  Quantize2.prototype.invert = function(value2) {
    var ticks = this.ticks;
    var length2 = ticks.length;
    var percent2 = this.getInvertPercent(value2);
    var minIndex = Math.floor(percent2 * (length2 - 1));
    if (minIndex >= length2 - 1) {
      return last(ticks);
    }
    if (minIndex < 0) {
      return head(ticks);
    }
    var minTick = ticks[minIndex];
    var nextTick = ticks[minIndex + 1];
    var minIndexPercent = minIndex / (length2 - 1);
    var maxIndexPercent = (minIndex + 1) / (length2 - 1);
    return minTick + (percent2 - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);
  };
  Quantize2.prototype.initCfg = function() {
    this.tickMethod = "r-pretty";
    this.tickCount = 5;
    this.nice = true;
  };
  Quantize2.prototype.calculateTicks = function() {
    var ticks = _super.prototype.calculateTicks.call(this);
    if (!this.nice) {
      if (last(ticks) !== this.max) {
        ticks.push(this.max);
      }
      if (head(ticks) !== this.min) {
        ticks.unshift(this.min);
      }
    }
    return ticks;
  };
  Quantize2.prototype.getScalePercent = function(value2) {
    var ticks = this.ticks;
    if (value2 < head(ticks)) {
      return 0;
    }
    if (value2 > last(ticks)) {
      return 1;
    }
    var minIndex = 0;
    each$1(ticks, function(tick, index2) {
      if (value2 >= tick) {
        minIndex = index2;
      } else {
        return false;
      }
    });
    return minIndex / (ticks.length - 1);
  };
  return Quantize2;
}(Continuous);
var Quantile = function(_super) {
  __extends$2(Quantile2, _super);
  function Quantile2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "quantile";
    return _this;
  }
  Quantile2.prototype.initCfg = function() {
    this.tickMethod = "quantile";
    this.tickCount = 5;
    this.nice = true;
  };
  return Quantile2;
}(Quantize);
var map = {};
function getClass(key) {
  return map[key];
}
function registerClass(key, cls) {
  if (getClass(key)) {
    throw new Error("type '" + key + "' existed.");
  }
  map[key] = cls;
}
var Identity = function(_super) {
  __extends$2(Identity2, _super);
  function Identity2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "identity";
    _this.isIdentity = true;
    return _this;
  }
  Identity2.prototype.calculateTicks = function() {
    return this.values;
  };
  Identity2.prototype.scale = function(value2) {
    if (this.values[0] !== value2 && isNumber$1(value2)) {
      return value2;
    }
    return this.range[0];
  };
  Identity2.prototype.invert = function(value2) {
    var range = this.range;
    if (value2 < range[0] || value2 > range[1]) {
      return NaN;
    }
    return this.values[0];
  };
  return Identity2;
}(Scale);
function prettyNumber(n) {
  return Math.abs(n) < 1e-15 ? n : parseFloat(n.toFixed(15));
}
var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
var eps = Number.EPSILON * 100;
function mod(n, m) {
  return (n % m + m) % m;
}
function round(n) {
  return Math.round(n * 1e12) / 1e12;
}
function simplicity(q, Q, j, lmin, lmax, lstep) {
  var n = size(Q);
  var i = indexOf(Q, q);
  var v = 0;
  var m = mod(lmin, lstep);
  if ((m < eps || lstep - m < eps) && lmin <= 0 && lmax >= 0) {
    v = 1;
  }
  return 1 - i / (n - 1) - j + v;
}
function simplicityMax(q, Q, j) {
  var n = size(Q);
  var i = indexOf(Q, q);
  var v = 1;
  return 1 - i / (n - 1) - j + v;
}
function density(k, m, dMin, dMax, lMin, lMax) {
  var r = (k - 1) / (lMax - lMin);
  var rt = (m - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
  return 2 - Math.max(r / rt, rt / r);
}
function densityMax(k, m) {
  if (k >= m) {
    return 2 - (k - 1) / (m - 1);
  }
  return 1;
}
function coverage(dMin, dMax, lMin, lMax) {
  var range = dMax - dMin;
  return 1 - 0.5 * (Math.pow(dMax - lMax, 2) + Math.pow(dMin - lMin, 2)) / Math.pow(0.1 * range, 2);
}
function coverageMax(dMin, dMax, span) {
  var range = dMax - dMin;
  if (span > range) {
    var half = (span - range) / 2;
    return 1 - Math.pow(half, 2) / Math.pow(0.1 * range, 2);
  }
  return 1;
}
function legibility() {
  return 1;
}
function extended(dMin, dMax, n, onlyLoose, Q, w) {
  if (n === void 0) {
    n = 5;
  }
  if (onlyLoose === void 0) {
    onlyLoose = true;
  }
  if (Q === void 0) {
    Q = DEFAULT_Q;
  }
  if (w === void 0) {
    w = [0.25, 0.2, 0.5, 0.05];
  }
  var m = n < 0 ? 0 : Math.round(n);
  if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m) {
    return {
      min: 0,
      max: 0,
      ticks: []
    };
  }
  if (dMax - dMin < 1e-15 || m === 1) {
    return {
      min: dMin,
      max: dMax,
      ticks: [dMin]
    };
  }
  var best = {
    score: -2,
    lmin: 0,
    lmax: 0,
    lstep: 0
  };
  var j = 1;
  while (j < Infinity) {
    for (var i = 0; i < Q.length; i += 1) {
      var q = Q[i];
      var sm = simplicityMax(q, Q, j);
      if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {
        j = Infinity;
        break;
      }
      var k = 2;
      while (k < Infinity) {
        var dm = densityMax(k, m);
        if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {
          break;
        }
        var delta = (dMax - dMin) / (k + 1) / j / q;
        var z = Math.ceil(Math.log10(delta));
        while (z < Infinity) {
          var step = j * q * Math.pow(10, z);
          var cm = coverageMax(dMin, dMax, step * (k - 1));
          if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {
            break;
          }
          var minStart = Math.floor(dMax / step) * j - (k - 1) * j;
          var maxStart = Math.ceil(dMin / step) * j;
          if (minStart <= maxStart) {
            var count = maxStart - minStart;
            for (var i_1 = 0; i_1 <= count; i_1 += 1) {
              var start = minStart + i_1;
              var lMin = start * (step / j);
              var lMax = lMin + step * (k - 1);
              var lStep = step;
              var s = simplicity(q, Q, j, lMin, lMax, lStep);
              var c = coverage(dMin, dMax, lMin, lMax);
              var g = density(k, m, dMin, dMax, lMin, lMax);
              var l = legibility();
              var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;
              if (score > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                best.lmin = lMin;
                best.lmax = lMax;
                best.lstep = lStep;
                best.score = score;
              }
            }
          }
          z += 1;
        }
        k += 1;
      }
    }
    j += 1;
  }
  var lmax = prettyNumber(best.lmax);
  var lmin = prettyNumber(best.lmin);
  var lstep = prettyNumber(best.lstep);
  var tickCount = Math.floor(round((lmax - lmin) / lstep)) + 1;
  var ticks = new Array(tickCount);
  ticks[0] = prettyNumber(lmin);
  for (var i = 1; i < tickCount; i++) {
    ticks[i] = prettyNumber(ticks[i - 1] + lstep);
  }
  return {
    min: Math.min(dMin, head(ticks)),
    max: Math.max(dMax, last(ticks)),
    ticks
  };
}
function calculateCatTicks(cfg) {
  var values2 = cfg.values, tickInterval = cfg.tickInterval, tickCount = cfg.tickCount;
  var ticks = values2;
  if (isNumber$1(tickInterval)) {
    return filter(ticks, function(__, i) {
      return i % tickInterval === 0;
    });
  }
  var min2 = cfg.min, max2 = cfg.max;
  if (isNil(min2)) {
    min2 = 0;
  }
  if (isNil(max2)) {
    max2 = values2.length - 1;
  }
  if (isNumber$1(tickCount) && tickCount < max2 - min2) {
    var ticks_1 = extended(min2, max2, tickCount, false, [1, 2, 5, 3, 4, 7, 6, 8, 9]).ticks;
    var valid = filter(ticks_1, function(tick) {
      return tick >= min2 && tick <= max2;
    });
    return valid.map(function(index2) {
      return values2[index2];
    });
  }
  return values2.slice(min2, max2 + 1);
}
function d3Linear(cfg) {
  var min2 = cfg.min, max2 = cfg.max, nice = cfg.nice, tickCount = cfg.tickCount;
  var linear2 = new D3Linear();
  linear2.domain([min2, max2]);
  if (nice) {
    linear2.nice(tickCount);
  }
  return linear2.ticks(tickCount);
}
var DEFAULT_COUNT = 5;
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
var D3Linear = function() {
  function D3Linear2() {
    this._domain = [0, 1];
  }
  D3Linear2.prototype.domain = function(domain) {
    if (domain) {
      this._domain = Array.from(domain, Number);
      return this;
    }
    return this._domain.slice();
  };
  D3Linear2.prototype.nice = function(count) {
    var _a2, _b;
    if (count === void 0) {
      count = DEFAULT_COUNT;
    }
    var d = this._domain.slice();
    var i0 = 0;
    var i1 = this._domain.length - 1;
    var start = this._domain[i0];
    var stop = this._domain[i1];
    var step;
    if (stop < start) {
      _a2 = [stop, start], start = _a2[0], stop = _a2[1];
      _b = [i1, i0], i0 = _b[0], i1 = _b[1];
    }
    step = tickIncrement(start, stop, count);
    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = tickIncrement(start, stop, count);
    }
    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      this.domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      this.domain(d);
    }
    return this;
  };
  D3Linear2.prototype.ticks = function(count) {
    if (count === void 0) {
      count = DEFAULT_COUNT;
    }
    return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count || DEFAULT_COUNT);
  };
  return D3Linear2;
}();
function d3ArrayTicks(start, stop, count) {
  var reverse;
  var i = -1;
  var n;
  var ticks;
  var step;
  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) {
    return [start];
  }
  if (reverse = stop < start) {
    n = start, start = stop, stop = n;
  }
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) {
    return [];
  }
  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) {
      ticks[i] = (start + i) * step;
    }
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) {
      ticks[i] = (start - i) / step;
    }
  }
  if (reverse) {
    ticks.reverse();
  }
  return ticks;
}
function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count);
  var power2 = Math.floor(Math.log(step) / Math.LN10);
  var error = step / Math.pow(10, power2);
  return power2 >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power2) : -Math.pow(10, -power2) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function snapMultiple(v, base, snapType) {
  var div;
  if (snapType === "ceil") {
    div = Math.ceil(v / base);
  } else if (snapType === "floor") {
    div = Math.floor(v / base);
  } else {
    div = Math.round(v / base);
  }
  return div * base;
}
function intervalTicks(min2, max2, interval2) {
  var minTick = snapMultiple(min2, interval2, "floor");
  var maxTick = snapMultiple(max2, interval2, "ceil");
  minTick = fixedBase(minTick, interval2);
  maxTick = fixedBase(maxTick, interval2);
  var ticks = [];
  for (var i = minTick; i <= maxTick; i = i + interval2) {
    var tickValue = fixedBase(i, interval2);
    ticks.push(tickValue);
  }
  return {
    min: minTick,
    max: maxTick,
    ticks
  };
}
function strictLimit(cfg, defaultMin, defaultMax) {
  var _a2;
  var minLimit = cfg.minLimit, maxLimit = cfg.maxLimit, min2 = cfg.min, max2 = cfg.max, _b = cfg.tickCount, tickCount = _b === void 0 ? 5 : _b;
  var tickMin = isNil(minLimit) ? isNil(defaultMin) ? min2 : defaultMin : minLimit;
  var tickMax = isNil(maxLimit) ? isNil(defaultMax) ? max2 : defaultMax : maxLimit;
  if (tickMin > tickMax) {
    _a2 = [tickMin, tickMax], tickMax = _a2[0], tickMin = _a2[1];
  }
  if (tickCount <= 2) {
    return [tickMin, tickMax];
  }
  var step = (tickMax - tickMin) / (tickCount - 1);
  var ticks = [];
  for (var i = 0; i < tickCount; i++) {
    ticks.push(tickMin + step * i);
  }
  return ticks;
}
function d3LinearTickMethod(cfg) {
  var min2 = cfg.min, max2 = cfg.max, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = d3Linear(cfg);
  if (!isNil(minLimit) || !isNil(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min2, max2, tickInterval).ticks;
  }
  return ticks;
}
function linear(cfg) {
  var min2 = cfg.min, max2 = cfg.max, tickCount = cfg.tickCount, nice = cfg.nice, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = extended(min2, max2, tickCount, nice).ticks;
  if (!isNil(minLimit) || !isNil(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min2, max2, tickInterval).ticks;
  }
  return ticks;
}
function calculateLogTicks(cfg) {
  var base = cfg.base, tickCount = cfg.tickCount, min2 = cfg.min, max2 = cfg.max, values2 = cfg.values;
  var minTick;
  var maxTick = log$1(base, max2);
  if (min2 > 0) {
    minTick = Math.floor(log$1(base, min2));
  } else {
    var positiveMin = getLogPositiveMin(values2, base, max2);
    minTick = Math.floor(log$1(base, positiveMin));
  }
  var count = maxTick - minTick;
  var avg2 = Math.ceil(count / tickCount);
  var ticks = [];
  for (var i = minTick; i < maxTick + avg2; i = i + avg2) {
    ticks.push(Math.pow(base, i));
  }
  if (min2 <= 0) {
    ticks.unshift(0);
  }
  return ticks;
}
function pretty(min2, max2, m) {
  if (m === void 0) {
    m = 5;
  }
  if (min2 === max2) {
    return {
      max: max2,
      min: min2,
      ticks: [min2]
    };
  }
  var n = m < 0 ? 0 : Math.round(m);
  if (n === 0)
    return { max: max2, min: min2, ticks: [] };
  var h = 1.5;
  var h5 = 0.5 + 1.5 * h;
  var d = max2 - min2;
  var c = d / n;
  var base = Math.pow(10, Math.floor(Math.log10(c)));
  var unit = base;
  if (2 * base - c < h * (c - unit)) {
    unit = 2 * base;
    if (5 * base - c < h5 * (c - unit)) {
      unit = 5 * base;
      if (10 * base - c < h * (c - unit)) {
        unit = 10 * base;
      }
    }
  }
  var nu = Math.ceil(max2 / unit);
  var ns = Math.floor(min2 / unit);
  var hi = Math.max(nu * unit, max2);
  var lo = Math.min(ns * unit, min2);
  var size2 = Math.floor((hi - lo) / unit) + 1;
  var ticks = new Array(size2);
  for (var i = 0; i < size2; i++) {
    ticks[i] = prettyNumber(lo + i * unit);
  }
  return {
    min: lo,
    max: hi,
    ticks
  };
}
function calculatePowTicks(cfg) {
  var exponent = cfg.exponent, tickCount = cfg.tickCount;
  var max2 = Math.ceil(calBase(exponent, cfg.max));
  var min2 = Math.floor(calBase(exponent, cfg.min));
  var ticks = pretty(min2, max2, tickCount).ticks;
  return ticks.map(function(tick) {
    var factor = tick >= 0 ? 1 : -1;
    return Math.pow(tick, exponent) * factor;
  });
}
function quantileSorted$1(x, p) {
  var idx = x.length * p;
  if (p === 1) {
    return x[x.length - 1];
  } else if (p === 0) {
    return x[0];
  } else if (idx % 1 !== 0) {
    return x[Math.ceil(idx) - 1];
  } else if (x.length % 2 === 0) {
    return (x[idx - 1] + x[idx]) / 2;
  } else {
    return x[idx];
  }
}
function calculateTicks(cfg) {
  var tickCount = cfg.tickCount, values2 = cfg.values;
  if (!values2 || !values2.length) {
    return [];
  }
  var sorted = values2.slice().sort(function(a, b) {
    return a - b;
  });
  var ticks = [];
  for (var i = 0; i < tickCount; i++) {
    var p = i / (tickCount - 1);
    ticks.push(quantileSorted$1(sorted, p));
  }
  return ticks;
}
function linearPretty(cfg) {
  var min2 = cfg.min, max2 = cfg.max, tickCount = cfg.tickCount, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = pretty(min2, max2, tickCount).ticks;
  if (!isNil(minLimit) || !isNil(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min2, max2, tickInterval).ticks;
  }
  return ticks;
}
function calculateTimeTicks(cfg) {
  var min2 = cfg.min, max2 = cfg.max, minTickInterval = cfg.minTickInterval;
  var tickInterval = cfg.tickInterval;
  var tickCount = cfg.tickCount;
  if (tickInterval) {
    tickCount = Math.ceil((max2 - min2) / tickInterval);
  } else {
    tickInterval = getTickInterval(min2, max2, tickCount)[1];
    var count = (max2 - min2) / tickInterval;
    var ratio = count / tickCount;
    if (ratio > 1) {
      tickInterval = tickInterval * Math.ceil(ratio);
    }
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  var ticks = [];
  for (var i = min2; i < max2 + tickInterval; i += tickInterval) {
    ticks.push(i);
  }
  return ticks;
}
function calculateTimeCatTicks(cfg) {
  var ticks = calculateCatTicks(cfg);
  var lastValue = last(cfg.values);
  if (lastValue !== last(ticks)) {
    ticks.push(lastValue);
  }
  return ticks;
}
function getYear(date) {
  return new Date(date).getFullYear();
}
function createYear(year) {
  return new Date(year, 0, 1).getTime();
}
function getMonth(date) {
  return new Date(date).getMonth();
}
function diffMonth(min2, max2) {
  var minYear = getYear(min2);
  var maxYear = getYear(max2);
  var minMonth = getMonth(min2);
  var maxMonth = getMonth(max2);
  return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
}
function creatMonth(year, month) {
  return new Date(year, month, 1).getTime();
}
function diffDay(min2, max2) {
  return Math.ceil((max2 - min2) / DAY);
}
function diffHour(min2, max2) {
  return Math.ceil((max2 - min2) / HOUR);
}
function diffMinus(min2, max2) {
  return Math.ceil((max2 - min2) / (60 * 1e3));
}
function timePretty(cfg) {
  var min2 = cfg.min, max2 = cfg.max, minTickInterval = cfg.minTickInterval, tickCount = cfg.tickCount;
  var tickInterval = cfg.tickInterval;
  var ticks = [];
  if (!tickInterval) {
    tickInterval = (max2 - min2) / tickCount;
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  var minYear = getYear(min2);
  if (tickInterval > YEAR) {
    var maxYear = getYear(max2);
    var yearInterval = Math.ceil(tickInterval / YEAR);
    for (var i = minYear; i <= maxYear + yearInterval; i = i + yearInterval) {
      ticks.push(createYear(i));
    }
  } else if (tickInterval > MONTH) {
    var monthInterval = Math.ceil(tickInterval / MONTH);
    var mmMoth = getMonth(min2);
    var dMonths = diffMonth(min2, max2);
    for (var i = 0; i <= dMonths + monthInterval; i = i + monthInterval) {
      ticks.push(creatMonth(minYear, i + mmMoth));
    }
  } else if (tickInterval > DAY) {
    var date = new Date(min2);
    var year = date.getFullYear();
    var month = date.getMonth();
    var mday = date.getDate();
    var day = Math.ceil(tickInterval / DAY);
    var ddays = diffDay(min2, max2);
    for (var i = 0; i < ddays + day; i = i + day) {
      ticks.push(new Date(year, month, mday + i).getTime());
    }
  } else if (tickInterval > HOUR) {
    var date = new Date(min2);
    var year = date.getFullYear();
    var month = date.getMonth();
    var day = date.getDate();
    var hour = date.getHours();
    var hours = Math.ceil(tickInterval / HOUR);
    var dHours = diffHour(min2, max2);
    for (var i = 0; i <= dHours + hours; i = i + hours) {
      ticks.push(new Date(year, month, day, hour + i).getTime());
    }
  } else if (tickInterval > MINUTE) {
    var dMinus = diffMinus(min2, max2);
    var minutes = Math.ceil(tickInterval / MINUTE);
    for (var i = 0; i <= dMinus + minutes; i = i + minutes) {
      ticks.push(min2 + i * MINUTE);
    }
  } else {
    var interval2 = tickInterval;
    if (interval2 < SECOND) {
      interval2 = SECOND;
    }
    var minSecond = Math.floor(min2 / SECOND) * SECOND;
    var dSeconds = Math.ceil((max2 - min2) / SECOND);
    var seconds = Math.ceil(interval2 / SECOND);
    for (var i = 0; i < dSeconds + seconds; i = i + seconds) {
      ticks.push(minSecond + i * SECOND);
    }
  }
  if (ticks.length >= 512) {
    console.warn("Notice: current ticks length(" + ticks.length + ') >= 512, may cause performance issues, even out of memory. Because of the configure "tickInterval"(in milliseconds, current is ' + tickInterval + ") is too small, increase the value to solve the problem!");
  }
  return ticks;
}
registerTickMethod("cat", calculateCatTicks);
registerTickMethod("time-cat", calculateTimeCatTicks);
registerTickMethod("wilkinson-extended", linear);
registerTickMethod("r-pretty", linearPretty);
registerTickMethod("time", calculateTimeTicks);
registerTickMethod("time-pretty", timePretty);
registerTickMethod("log", calculateLogTicks);
registerTickMethod("pow", calculatePowTicks);
registerTickMethod("quantile", calculateTicks);
registerTickMethod("d3-linear", d3LinearTickMethod);
registerClass("cat", Category$1);
registerClass("category", Category$1);
registerClass("identity", Identity);
registerClass("linear", Linear);
registerClass("log", Log);
registerClass("pow", Pow);
registerClass("time", Time);
registerClass("timeCat", TimeCat);
registerClass("quantize", Quantize);
registerClass("quantile", Quantile);
var ATTRIBUTE_MAP = {};
var getAttribute = function(type) {
  return ATTRIBUTE_MAP[type.toLowerCase()];
};
var registerAttribute = function(type, ctor) {
  if (getAttribute(type)) {
    throw new Error("Attribute type '" + type + "' existed.");
  }
  ATTRIBUTE_MAP[type.toLowerCase()] = ctor;
};
registerAttribute("Color", Color);
registerAttribute("Opacity", Opacity);
registerAttribute("Position", Position);
registerAttribute("Shape", Shape$2);
registerAttribute("Size", Size);
var Coordinate = function() {
  function Coordinate2(cfg) {
    this.type = "coordinate";
    this.isRect = false;
    this.isHelix = false;
    this.isPolar = false;
    this.isReflectX = false;
    this.isReflectY = false;
    var start = cfg.start, end = cfg.end, _a2 = cfg.matrix, matrix = _a2 === void 0 ? [1, 0, 0, 0, 1, 0, 0, 0, 1] : _a2, _b = cfg.isTransposed, isTransposed = _b === void 0 ? false : _b;
    this.start = start;
    this.end = end;
    this.matrix = matrix;
    this.originalMatrix = __spreadArray([], matrix);
    this.isTransposed = isTransposed;
  }
  Coordinate2.prototype.initial = function() {
    this.center = {
      x: (this.start.x + this.end.x) / 2,
      y: (this.start.y + this.end.y) / 2
    };
    this.width = Math.abs(this.end.x - this.start.x);
    this.height = Math.abs(this.end.y - this.start.y);
  };
  Coordinate2.prototype.update = function(cfg) {
    mix(this, cfg);
    this.initial();
  };
  Coordinate2.prototype.convertDim = function(percent2, dim) {
    var _a2;
    var _b = this[dim], start = _b.start, end = _b.end;
    if (this.isReflect(dim)) {
      _a2 = [end, start], start = _a2[0], end = _a2[1];
    }
    return start + percent2 * (end - start);
  };
  Coordinate2.prototype.invertDim = function(value2, dim) {
    var _a2;
    var _b = this[dim], start = _b.start, end = _b.end;
    if (this.isReflect(dim)) {
      _a2 = [end, start], start = _a2[0], end = _a2[1];
    }
    return (value2 - start) / (end - start);
  };
  Coordinate2.prototype.applyMatrix = function(x, y, tag) {
    if (tag === void 0) {
      tag = 0;
    }
    var matrix = this.matrix;
    var vector = [x, y, tag];
    transformMat3(vector, vector, matrix);
    return vector;
  };
  Coordinate2.prototype.invertMatrix = function(x, y, tag) {
    if (tag === void 0) {
      tag = 0;
    }
    var matrix = this.matrix;
    var inverted = invert$2([0, 0, 0, 0, 0, 0, 0, 0, 0], matrix);
    var vector = [x, y, tag];
    if (inverted) {
      transformMat3(vector, vector, inverted);
    }
    return vector;
  };
  Coordinate2.prototype.convert = function(point2) {
    var _a2 = this.convertPoint(point2), x = _a2.x, y = _a2.y;
    var vector = this.applyMatrix(x, y, 1);
    return {
      x: vector[0],
      y: vector[1]
    };
  };
  Coordinate2.prototype.invert = function(point2) {
    var vector = this.invertMatrix(point2.x, point2.y, 1);
    return this.invertPoint({
      x: vector[0],
      y: vector[1]
    });
  };
  Coordinate2.prototype.rotate = function(radian) {
    var matrix = this.matrix;
    var center2 = this.center;
    leftTranslate(matrix, matrix, [-center2.x, -center2.y]);
    leftRotate(matrix, matrix, radian);
    leftTranslate(matrix, matrix, [center2.x, center2.y]);
    return this;
  };
  Coordinate2.prototype.reflect = function(dim) {
    if (dim === "x") {
      this.isReflectX = !this.isReflectX;
    } else {
      this.isReflectY = !this.isReflectY;
    }
    return this;
  };
  Coordinate2.prototype.scale = function(s1, s2) {
    var matrix = this.matrix;
    var center2 = this.center;
    leftTranslate(matrix, matrix, [-center2.x, -center2.y]);
    leftScale(matrix, matrix, [s1, s2]);
    leftTranslate(matrix, matrix, [center2.x, center2.y]);
    return this;
  };
  Coordinate2.prototype.translate = function(x, y) {
    var matrix = this.matrix;
    leftTranslate(matrix, matrix, [x, y]);
    return this;
  };
  Coordinate2.prototype.transpose = function() {
    this.isTransposed = !this.isTransposed;
    return this;
  };
  Coordinate2.prototype.getCenter = function() {
    return this.center;
  };
  Coordinate2.prototype.getWidth = function() {
    return this.width;
  };
  Coordinate2.prototype.getHeight = function() {
    return this.height;
  };
  Coordinate2.prototype.getRadius = function() {
    return this.radius;
  };
  Coordinate2.prototype.isReflect = function(dim) {
    return dim === "x" ? this.isReflectX : this.isReflectY;
  };
  Coordinate2.prototype.resetMatrix = function(matrix) {
    this.matrix = matrix ? matrix : __spreadArray([], this.originalMatrix);
  };
  return Coordinate2;
}();
var Cartesian = function(_super) {
  __extends$2(Cartesian2, _super);
  function Cartesian2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.isRect = true;
    _this.type = "cartesian";
    _this.initial();
    return _this;
  }
  Cartesian2.prototype.initial = function() {
    _super.prototype.initial.call(this);
    var start = this.start;
    var end = this.end;
    this.x = {
      start: start.x,
      end: end.x
    };
    this.y = {
      start: start.y,
      end: end.y
    };
  };
  Cartesian2.prototype.convertPoint = function(point2) {
    var _a2;
    var x = point2.x, y = point2.y;
    if (this.isTransposed) {
      _a2 = [y, x], x = _a2[0], y = _a2[1];
    }
    return {
      x: this.convertDim(x, "x"),
      y: this.convertDim(y, "y")
    };
  };
  Cartesian2.prototype.invertPoint = function(point2) {
    var _a2;
    var x = this.invertDim(point2.x, "x");
    var y = this.invertDim(point2.y, "y");
    if (this.isTransposed) {
      _a2 = [y, x], x = _a2[0], y = _a2[1];
    }
    return { x, y };
  };
  return Cartesian2;
}(Coordinate);
var Helix = function(_super) {
  __extends$2(Helix2, _super);
  function Helix2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.isHelix = true;
    _this.type = "helix";
    var _a2 = cfg.startAngle, startAngle = _a2 === void 0 ? 1.25 * Math.PI : _a2, _b = cfg.endAngle, endAngle = _b === void 0 ? 7.25 * Math.PI : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
    _this.startAngle = startAngle;
    _this.endAngle = endAngle;
    _this.innerRadius = innerRadius;
    _this.radius = radius;
    _this.initial();
    return _this;
  }
  Helix2.prototype.initial = function() {
    _super.prototype.initial.call(this);
    var index2 = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1;
    var maxRadius = Math.min(this.width, this.height) / 2;
    if (this.radius && this.radius >= 0 && this.radius <= 1) {
      maxRadius = maxRadius * this.radius;
    }
    this.d = Math.floor(maxRadius * (1 - this.innerRadius) / index2);
    this.a = this.d / (Math.PI * 2);
    this.x = {
      start: this.startAngle,
      end: this.endAngle
    };
    this.y = {
      start: this.innerRadius * maxRadius,
      end: this.innerRadius * maxRadius + this.d * 0.99
    };
  };
  Helix2.prototype.convertPoint = function(point2) {
    var _a2;
    var x = point2.x, y = point2.y;
    if (this.isTransposed) {
      _a2 = [y, x], x = _a2[0], y = _a2[1];
    }
    var thi = this.convertDim(x, "x");
    var r = this.a * thi;
    var newY = this.convertDim(y, "y");
    return {
      x: this.center.x + Math.cos(thi) * (r + newY),
      y: this.center.y + Math.sin(thi) * (r + newY)
    };
  };
  Helix2.prototype.invertPoint = function(point2) {
    var _a2;
    var d = this.d + this.y.start;
    var v = subtract([0, 0], [point2.x, point2.y], [this.center.x, this.center.y]);
    var thi = angleTo(v, [1, 0], true);
    var rMin = thi * this.a;
    if (length(v) < rMin) {
      rMin = length(v);
    }
    var index2 = Math.floor((length(v) - rMin) / d);
    thi = 2 * index2 * Math.PI + thi;
    var r = this.a * thi;
    var newY = length(v) - r;
    newY = isNumberEqual$1(newY, 0) ? 0 : newY;
    var x = this.invertDim(thi, "x");
    var y = this.invertDim(newY, "y");
    x = isNumberEqual$1(x, 0) ? 0 : x;
    y = isNumberEqual$1(y, 0) ? 0 : y;
    if (this.isTransposed) {
      _a2 = [y, x], x = _a2[0], y = _a2[1];
    }
    return { x, y };
  };
  return Helix2;
}(Coordinate);
var Polar = function(_super) {
  __extends$2(Polar2, _super);
  function Polar2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.isPolar = true;
    _this.type = "polar";
    var _a2 = cfg.startAngle, startAngle = _a2 === void 0 ? -Math.PI / 2 : _a2, _b = cfg.endAngle, endAngle = _b === void 0 ? Math.PI * 3 / 2 : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
    _this.startAngle = startAngle;
    _this.endAngle = endAngle;
    _this.innerRadius = innerRadius;
    _this.radius = radius;
    _this.initial();
    return _this;
  }
  Polar2.prototype.initial = function() {
    _super.prototype.initial.call(this);
    while (this.endAngle < this.startAngle) {
      this.endAngle += Math.PI * 2;
    }
    var oneBox = this.getOneBox();
    var oneWidth = oneBox.maxX - oneBox.minX;
    var oneHeight = oneBox.maxY - oneBox.minY;
    var left2 = Math.abs(oneBox.minX) / oneWidth;
    var top = Math.abs(oneBox.minY) / oneHeight;
    var maxRadius;
    if (this.height / oneHeight > this.width / oneWidth) {
      maxRadius = this.width / oneWidth;
      this.circleCenter = {
        x: this.center.x - (0.5 - left2) * this.width,
        y: this.center.y - (0.5 - top) * maxRadius * oneHeight
      };
    } else {
      maxRadius = this.height / oneHeight;
      this.circleCenter = {
        x: this.center.x - (0.5 - left2) * maxRadius * oneWidth,
        y: this.center.y - (0.5 - top) * this.height
      };
    }
    this.polarRadius = this.radius;
    if (!this.radius) {
      this.polarRadius = maxRadius;
    } else if (this.radius > 0 && this.radius <= 1) {
      this.polarRadius = maxRadius * this.radius;
    } else if (this.radius <= 0 || this.radius > maxRadius) {
      this.polarRadius = maxRadius;
    }
    this.x = {
      start: this.startAngle,
      end: this.endAngle
    };
    this.y = {
      start: this.innerRadius * this.polarRadius,
      end: this.polarRadius
    };
  };
  Polar2.prototype.getRadius = function() {
    return this.polarRadius;
  };
  Polar2.prototype.convertPoint = function(point2) {
    var _a2;
    var center2 = this.getCenter();
    var x = point2.x, y = point2.y;
    if (this.isTransposed) {
      _a2 = [y, x], x = _a2[0], y = _a2[1];
    }
    x = this.convertDim(x, "x");
    y = this.convertDim(y, "y");
    return {
      x: center2.x + Math.cos(x) * y,
      y: center2.y + Math.sin(x) * y
    };
  };
  Polar2.prototype.invertPoint = function(point2) {
    var _a2;
    var center2 = this.getCenter();
    var vPoint = [point2.x - center2.x, point2.y - center2.y];
    var _b = this, startAngle = _b.startAngle, endAngle = _b.endAngle;
    if (this.isReflect("x")) {
      _a2 = [endAngle, startAngle], startAngle = _a2[0], endAngle = _a2[1];
    }
    var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    leftRotate(m, m, startAngle);
    var vStart3 = [1, 0, 0];
    transformMat3(vStart3, vStart3, m);
    var vStart2 = [vStart3[0], vStart3[1]];
    var angle2 = angleTo(vStart2, vPoint, endAngle < startAngle);
    if (isNumberEqual$1(angle2, Math.PI * 2)) {
      angle2 = 0;
    }
    var radius = length(vPoint);
    var xPercent = angle2 / (endAngle - startAngle);
    xPercent = endAngle - startAngle > 0 ? xPercent : -xPercent;
    var yPercent = this.invertDim(radius, "y");
    var rst = { x: 0, y: 0 };
    rst.x = this.isTransposed ? yPercent : xPercent;
    rst.y = this.isTransposed ? xPercent : yPercent;
    return rst;
  };
  Polar2.prototype.getCenter = function() {
    return this.circleCenter;
  };
  Polar2.prototype.getOneBox = function() {
    var startAngle = this.startAngle;
    var endAngle = this.endAngle;
    if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {
      return {
        minX: -1,
        maxX: 1,
        minY: -1,
        maxY: 1
      };
    }
    var xs = [0, Math.cos(startAngle), Math.cos(endAngle)];
    var ys = [0, Math.sin(startAngle), Math.sin(endAngle)];
    for (var i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {
      xs.push(Math.cos(i));
      ys.push(Math.sin(i));
    }
    return {
      minX: Math.min.apply(Math, xs),
      maxX: Math.max.apply(Math, xs),
      minY: Math.min.apply(Math, ys),
      maxY: Math.max.apply(Math, ys)
    };
  };
  return Polar2;
}(Coordinate);
var COORDINATE_MAP = {};
var getCoordinate = function(type) {
  return COORDINATE_MAP[type.toLowerCase()];
};
var registerCoordinate = function(type, ctor) {
  COORDINATE_MAP[type.toLowerCase()] = ctor;
};
registerCoordinate("rect", Cartesian);
registerCoordinate("cartesian", Cartesian);
registerCoordinate("polar", Polar);
registerCoordinate("helix", Helix);
var SPACES = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND = new RegExp("([a-z])[" + SPACES + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES + "]*,?[" + SPACES + "]*)+)", "ig");
var PATH_VALUES = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES + "]*,?[" + SPACES + "]*", "ig");
var parsePathString = function(pathString) {
  if (!pathString) {
    return null;
  }
  if (isArray$1(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data2 = [];
  String(pathString).replace(PATH_COMMAND, function(a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES, function(a2, b2) {
      b2 && params.push(+b2);
    });
    if (name === "m" && params.length > 2) {
      data2.push([b].concat(params.splice(0, 2)));
      name = "l";
      b = b === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data2.push([b, params[0]]);
    }
    if (name === "r") {
      data2.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data2.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return pathString;
  });
  return data2;
};
var isEqual = function(obj1, obj2) {
  if (obj1.length !== obj2.length) {
    return false;
  }
  var result = true;
  each$1(obj1, function(item, i) {
    if (item !== obj2[i]) {
      result = false;
      return false;
    }
  });
  return result;
};
function getMinDiff(del, add2, modify) {
  var type = null;
  var min2 = modify;
  if (add2 < min2) {
    min2 = add2;
    type = "add";
  }
  if (del < min2) {
    min2 = del;
    type = "del";
  }
  return {
    type,
    min: min2
  };
}
var levenshteinDistance = function(source, target) {
  var sourceLen = source.length;
  var targetLen = target.length;
  var sourceSegment;
  var targetSegment;
  var temp = 0;
  if (sourceLen === 0 || targetLen === 0) {
    return null;
  }
  var dist = [];
  for (var i = 0; i <= sourceLen; i++) {
    dist[i] = [];
    dist[i][0] = { min: i };
  }
  for (var j = 0; j <= targetLen; j++) {
    dist[0][j] = { min: j };
  }
  for (var i = 1; i <= sourceLen; i++) {
    sourceSegment = source[i - 1];
    for (var j = 1; j <= targetLen; j++) {
      targetSegment = target[j - 1];
      if (isEqual(sourceSegment, targetSegment)) {
        temp = 0;
      } else {
        temp = 1;
      }
      var del = dist[i - 1][j].min + 1;
      var add2 = dist[i][j - 1].min + 1;
      var modify = dist[i - 1][j - 1].min + temp;
      dist[i][j] = getMinDiff(del, add2, modify);
    }
  }
  return dist;
};
var fillPathByDiff = function(source, target) {
  var diffMatrix = levenshteinDistance(source, target);
  var sourceLen = source.length;
  var targetLen = target.length;
  var changes = [];
  var index2 = 1;
  var minPos = 1;
  if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
    for (var i = 1; i <= sourceLen; i++) {
      var min2 = diffMatrix[i][i].min;
      minPos = i;
      for (var j = index2; j <= targetLen; j++) {
        if (diffMatrix[i][j].min < min2) {
          min2 = diffMatrix[i][j].min;
          minPos = j;
        }
      }
      index2 = minPos;
      if (diffMatrix[i][index2].type) {
        changes.push({ index: i - 1, type: diffMatrix[i][index2].type });
      }
    }
    for (var i = changes.length - 1; i >= 0; i--) {
      index2 = changes[i].index;
      if (changes[i].type === "add") {
        source.splice(index2, 0, [].concat(source[index2]));
      } else {
        source.splice(index2, 1);
      }
    }
  }
  sourceLen = source.length;
  var diff2 = targetLen - sourceLen;
  if (sourceLen < targetLen) {
    for (var i = 0; i < diff2; i++) {
      if (source[sourceLen - 1][0] === "z" || source[sourceLen - 1][0] === "Z") {
        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
      } else {
        source.push(source[sourceLen - 1]);
      }
      sourceLen += 1;
    }
  }
  return source;
};
function _splitPoints(points, former, count) {
  var result = [].concat(points);
  var index2;
  var t = 1 / (count + 1);
  var formerEnd = _getSegmentPoints(former)[0];
  for (var i = 1; i <= count; i++) {
    t *= i;
    index2 = Math.floor(points.length * t);
    if (index2 === 0) {
      result.unshift([formerEnd[0] * t + points[index2][0] * (1 - t), formerEnd[1] * t + points[index2][1] * (1 - t)]);
    } else {
      result.splice(index2, 0, [
        formerEnd[0] * t + points[index2][0] * (1 - t),
        formerEnd[1] * t + points[index2][1] * (1 - t)
      ]);
    }
  }
  return result;
}
function _getSegmentPoints(segment) {
  var points = [];
  switch (segment[0]) {
    case "M":
      points.push([segment[1], segment[2]]);
      break;
    case "L":
      points.push([segment[1], segment[2]]);
      break;
    case "A":
      points.push([segment[6], segment[7]]);
      break;
    case "Q":
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case "T":
      points.push([segment[1], segment[2]]);
      break;
    case "C":
      points.push([segment[5], segment[6]]);
      points.push([segment[1], segment[2]]);
      points.push([segment[3], segment[4]]);
      break;
    case "S":
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case "H":
      points.push([segment[1], segment[1]]);
      break;
    case "V":
      points.push([segment[1], segment[1]]);
      break;
  }
  return points;
}
var formatPath = function(fromPath, toPath) {
  if (fromPath.length <= 1) {
    return fromPath;
  }
  var points;
  for (var i = 0; i < toPath.length; i++) {
    if (fromPath[i][0] !== toPath[i][0]) {
      points = _getSegmentPoints(fromPath[i]);
      switch (toPath[i][0]) {
        case "M":
          fromPath[i] = ["M"].concat(points[0]);
          break;
        case "L":
          fromPath[i] = ["L"].concat(points[0]);
          break;
        case "A":
          fromPath[i] = [].concat(toPath[i]);
          fromPath[i][6] = points[0][0];
          fromPath[i][7] = points[0][1];
          break;
        case "Q":
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ["Q"].concat(points.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        case "T":
          fromPath[i] = ["T"].concat(points[0]);
          break;
        case "C":
          if (points.length < 3) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 2);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ["C"].concat(points.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        case "S":
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ["S"].concat(points.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        default:
          fromPath[i] = toPath[i];
      }
    }
  }
  return fromPath;
};
var GraphEvent = function() {
  function GraphEvent2(type, event) {
    this.bubbles = true;
    this.target = null;
    this.currentTarget = null;
    this.delegateTarget = null;
    this.delegateObject = null;
    this.defaultPrevented = false;
    this.propagationStopped = false;
    this.shape = null;
    this.fromShape = null;
    this.toShape = null;
    this.propagationPath = [];
    this.type = type;
    this.name = type;
    this.originalEvent = event;
    this.timeStamp = event.timeStamp;
  }
  GraphEvent2.prototype.preventDefault = function() {
    this.defaultPrevented = true;
    if (this.originalEvent.preventDefault) {
      this.originalEvent.preventDefault();
    }
  };
  GraphEvent2.prototype.stopPropagation = function() {
    this.propagationStopped = true;
  };
  GraphEvent2.prototype.toString = function() {
    var type = this.type;
    return "[Event (type=" + type + ")]";
  };
  GraphEvent2.prototype.save = function() {
  };
  GraphEvent2.prototype.restore = function() {
  };
  return GraphEvent2;
}();
function removeFromArray(arr, obj) {
  var index2 = arr.indexOf(obj);
  if (index2 !== -1) {
    arr.splice(index2, 1);
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function isParent(container, shape) {
  if (container.isCanvas()) {
    return true;
  }
  var parent = shape.getParent();
  var isParent2 = false;
  while (parent) {
    if (parent === container) {
      isParent2 = true;
      break;
    }
    parent = parent.getParent();
  }
  return isParent2;
}
function isAllowCapture(element) {
  return element.cfg.visible && element.cfg.capture;
}
var Base = function(_super) {
  __extends$2(Base2, _super);
  function Base2(cfg) {
    var _this = _super.call(this) || this;
    _this.destroyed = false;
    var defaultCfg = _this.getDefaultCfg();
    _this.cfg = mix(defaultCfg, cfg);
    return _this;
  }
  Base2.prototype.getDefaultCfg = function() {
    return {};
  };
  Base2.prototype.get = function(name) {
    return this.cfg[name];
  };
  Base2.prototype.set = function(name, value2) {
    this.cfg[name] = value2;
  };
  Base2.prototype.destroy = function() {
    this.cfg = {
      destroyed: true
    };
    this.off();
    this.destroyed = true;
  };
  return Base2;
}(EventEmitter);
function multiplyMatrix(a, b) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b00 = b[0];
  var b01 = b[1];
  var b02 = b[2];
  var b10 = b[3];
  var b11 = b[4];
  var b12 = b[5];
  var b20 = b[6];
  var b21 = b[7];
  var b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function multiplyVec2$1(m, v) {
  var out = [];
  var x = v[0];
  var y = v[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function invert(a) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
var transform$5 = transform$7;
var MATRIX = "matrix";
var CLONE_CFGS = ["zIndex", "capture", "visible", "type"];
var RESERVED_PORPS = ["repeat"];
var DELEGATION_SPLIT = ":";
var WILDCARD = "*";
function _cloneArrayAttr(arr) {
  var result = [];
  for (var i = 0; i < arr.length; i++) {
    if (isArray$1(arr[i])) {
      result.push([].concat(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}
function getFormatFromAttrs(toAttrs, shape) {
  var fromAttrs = {};
  var attrs = shape.attrs;
  for (var k in toAttrs) {
    fromAttrs[k] = attrs[k];
  }
  return fromAttrs;
}
function getFormatToAttrs(props, shape) {
  var toAttrs = {};
  var attrs = shape.attr();
  each$1(props, function(v, k) {
    if (RESERVED_PORPS.indexOf(k) === -1 && !isEqual$2(attrs[k], v)) {
      toAttrs[k] = v;
    }
  });
  return toAttrs;
}
function checkExistedAttrs(animations, animation2) {
  if (animation2.onFrame) {
    return animations;
  }
  var startTime = animation2.startTime, delay = animation2.delay, duration = animation2.duration;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  each$1(animations, function(item) {
    if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
      each$1(animation2.toAttrs, function(v, k) {
        if (hasOwnProperty2.call(item.toAttrs, k)) {
          delete item.toAttrs[k];
          delete item.fromAttrs[k];
        }
      });
    }
  });
  return animations;
}
var Element$2 = function(_super) {
  __extends$2(Element2, _super);
  function Element2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.attrs = {};
    var attrs = _this.getDefaultAttrs();
    mix(attrs, cfg.attrs);
    _this.attrs = attrs;
    _this.initAttrs(attrs);
    _this.initAnimate();
    return _this;
  }
  Element2.prototype.getDefaultCfg = function() {
    return {
      visible: true,
      capture: true,
      zIndex: 0
    };
  };
  Element2.prototype.getDefaultAttrs = function() {
    return {
      matrix: this.getDefaultMatrix(),
      opacity: 1
    };
  };
  Element2.prototype.onCanvasChange = function(changeType) {
  };
  Element2.prototype.initAttrs = function(attrs) {
  };
  Element2.prototype.initAnimate = function() {
    this.set("animable", true);
    this.set("animating", false);
  };
  Element2.prototype.isGroup = function() {
    return false;
  };
  Element2.prototype.getParent = function() {
    return this.get("parent");
  };
  Element2.prototype.getCanvas = function() {
    return this.get("canvas");
  };
  Element2.prototype.attr = function() {
    var _a2;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var name = args[0], value2 = args[1];
    if (!name)
      return this.attrs;
    if (isObject(name)) {
      for (var k in name) {
        this.setAttr(k, name[k]);
      }
      this.afterAttrsChange(name);
      return this;
    }
    if (args.length === 2) {
      this.setAttr(name, value2);
      this.afterAttrsChange((_a2 = {}, _a2[name] = value2, _a2));
      return this;
    }
    return this.attrs[name];
  };
  Element2.prototype.isClipped = function(refX, refY) {
    var clip = this.getClip();
    return clip && !clip.isHit(refX, refY);
  };
  Element2.prototype.setAttr = function(name, value2) {
    var originValue = this.attrs[name];
    if (originValue !== value2) {
      this.attrs[name] = value2;
      this.onAttrChange(name, value2, originValue);
    }
  };
  Element2.prototype.onAttrChange = function(name, value2, originValue) {
    if (name === "matrix") {
      this.set("totalMatrix", null);
    }
  };
  Element2.prototype.afterAttrsChange = function(targetAttrs) {
    if (this.cfg.isClipShape) {
      var applyTo = this.cfg.applyTo;
      if (applyTo) {
        applyTo.onCanvasChange("clip");
      }
    } else {
      this.onCanvasChange("attr");
    }
  };
  Element2.prototype.show = function() {
    this.set("visible", true);
    this.onCanvasChange("show");
    return this;
  };
  Element2.prototype.hide = function() {
    this.set("visible", false);
    this.onCanvasChange("hide");
    return this;
  };
  Element2.prototype.setZIndex = function(zIndex) {
    this.set("zIndex", zIndex);
    var parent = this.getParent();
    if (parent) {
      parent.sort();
    }
    return this;
  };
  Element2.prototype.toFront = function() {
    var parent = this.getParent();
    if (!parent) {
      return;
    }
    var children = parent.getChildren();
    this.get("el");
    var index2 = children.indexOf(this);
    children.splice(index2, 1);
    children.push(this);
    this.onCanvasChange("zIndex");
  };
  Element2.prototype.toBack = function() {
    var parent = this.getParent();
    if (!parent) {
      return;
    }
    var children = parent.getChildren();
    this.get("el");
    var index2 = children.indexOf(this);
    children.splice(index2, 1);
    children.unshift(this);
    this.onCanvasChange("zIndex");
  };
  Element2.prototype.remove = function(destroy) {
    if (destroy === void 0) {
      destroy = true;
    }
    var parent = this.getParent();
    if (parent) {
      removeFromArray(parent.getChildren(), this);
      if (!parent.get("clearing")) {
        this.onCanvasChange("remove");
      }
    } else {
      this.onCanvasChange("remove");
    }
    if (destroy) {
      this.destroy();
    }
  };
  Element2.prototype.resetMatrix = function() {
    this.attr(MATRIX, this.getDefaultMatrix());
    this.onCanvasChange("matrix");
  };
  Element2.prototype.getMatrix = function() {
    return this.attr(MATRIX);
  };
  Element2.prototype.setMatrix = function(m) {
    this.attr(MATRIX, m);
    this.onCanvasChange("matrix");
  };
  Element2.prototype.getTotalMatrix = function() {
    var totalMatrix = this.cfg.totalMatrix;
    if (!totalMatrix) {
      var currentMatrix = this.attr("matrix");
      var parentMatrix = this.cfg.parentMatrix;
      if (parentMatrix && currentMatrix) {
        totalMatrix = multiplyMatrix(parentMatrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || parentMatrix;
      }
      this.set("totalMatrix", totalMatrix);
    }
    return totalMatrix;
  };
  Element2.prototype.applyMatrix = function(matrix) {
    var currentMatrix = this.attr("matrix");
    var totalMatrix = null;
    if (matrix && currentMatrix) {
      totalMatrix = multiplyMatrix(matrix, currentMatrix);
    } else {
      totalMatrix = currentMatrix || matrix;
    }
    this.set("totalMatrix", totalMatrix);
    this.set("parentMatrix", matrix);
  };
  Element2.prototype.getDefaultMatrix = function() {
    return null;
  };
  Element2.prototype.applyToMatrix = function(v) {
    var matrix = this.attr("matrix");
    if (matrix) {
      return multiplyVec2$1(matrix, v);
    }
    return v;
  };
  Element2.prototype.invertFromMatrix = function(v) {
    var matrix = this.attr("matrix");
    if (matrix) {
      var invertMatrix = invert(matrix);
      if (invertMatrix) {
        return multiplyVec2$1(invertMatrix, v);
      }
    }
    return v;
  };
  Element2.prototype.setClip = function(clipCfg) {
    var canvas = this.getCanvas();
    var clipShape = null;
    if (clipCfg) {
      var ShapeBase2 = this.getShapeBase();
      var shapeType = upperFirst(clipCfg.type);
      var Cons = ShapeBase2[shapeType];
      if (Cons) {
        clipShape = new Cons({
          type: clipCfg.type,
          isClipShape: true,
          applyTo: this,
          attrs: clipCfg.attrs,
          canvas
        });
      }
    }
    this.set("clipShape", clipShape);
    this.onCanvasChange("clip");
    return clipShape;
  };
  Element2.prototype.getClip = function() {
    var clipShape = this.cfg.clipShape;
    if (!clipShape) {
      return null;
    }
    return clipShape;
  };
  Element2.prototype.clone = function() {
    var _this = this;
    var originAttrs = this.attrs;
    var attrs = {};
    each$1(originAttrs, function(i, k) {
      if (isArray$1(originAttrs[k])) {
        attrs[k] = _cloneArrayAttr(originAttrs[k]);
      } else {
        attrs[k] = originAttrs[k];
      }
    });
    var cons = this.constructor;
    var clone2 = new cons({ attrs });
    each$1(CLONE_CFGS, function(cfgName) {
      clone2.set(cfgName, _this.get(cfgName));
    });
    return clone2;
  };
  Element2.prototype.destroy = function() {
    var destroyed = this.destroyed;
    if (destroyed) {
      return;
    }
    this.attrs = {};
    _super.prototype.destroy.call(this);
  };
  Element2.prototype.isAnimatePaused = function() {
    return this.get("_pause").isPaused;
  };
  Element2.prototype.animate = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!this.get("timeline") && !this.get("canvas")) {
      return;
    }
    this.set("animating", true);
    var timeline = this.get("timeline");
    if (!timeline) {
      timeline = this.get("canvas").get("timeline");
      this.set("timeline", timeline);
    }
    var animations = this.get("animations") || [];
    if (!timeline.timer) {
      timeline.initTimer();
    }
    var toAttrs = args[0], duration = args[1], _a2 = args[2], easing = _a2 === void 0 ? "easeLinear" : _a2, _b = args[3], callback = _b === void 0 ? noop : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;
    var onFrame;
    var repeat;
    var pauseCallback;
    var resumeCallback;
    var animateCfg;
    if (isFunction(toAttrs)) {
      onFrame = toAttrs;
      toAttrs = {};
    } else if (isObject(toAttrs) && toAttrs.onFrame) {
      onFrame = toAttrs.onFrame;
      repeat = toAttrs.repeat;
    }
    if (isObject(duration)) {
      animateCfg = duration;
      duration = animateCfg.duration;
      easing = animateCfg.easing || "easeLinear";
      delay = animateCfg.delay || 0;
      repeat = animateCfg.repeat || repeat || false;
      callback = animateCfg.callback || noop;
      pauseCallback = animateCfg.pauseCallback || noop;
      resumeCallback = animateCfg.resumeCallback || noop;
    } else {
      if (isNumber$1(callback)) {
        delay = callback;
        callback = null;
      }
      if (isFunction(easing)) {
        callback = easing;
        easing = "easeLinear";
      } else {
        easing = easing || "easeLinear";
      }
    }
    var formatToAttrs = getFormatToAttrs(toAttrs, this);
    var animation2 = {
      fromAttrs: getFormatFromAttrs(formatToAttrs, this),
      toAttrs: formatToAttrs,
      duration,
      easing,
      repeat,
      callback,
      pauseCallback,
      resumeCallback,
      delay,
      startTime: timeline.getTime(),
      id: uniqueId(),
      onFrame,
      pathFormatted: false
    };
    if (animations.length > 0) {
      animations = checkExistedAttrs(animations, animation2);
    } else {
      timeline.addAnimator(this);
    }
    animations.push(animation2);
    this.set("animations", animations);
    this.set("_pause", { isPaused: false });
  };
  Element2.prototype.stopAnimate = function(toEnd) {
    var _this = this;
    if (toEnd === void 0) {
      toEnd = true;
    }
    var animations = this.get("animations");
    each$1(animations, function(animation2) {
      if (toEnd) {
        if (animation2.onFrame) {
          _this.attr(animation2.onFrame(1));
        } else {
          _this.attr(animation2.toAttrs);
        }
      }
      if (animation2.callback) {
        animation2.callback();
      }
    });
    this.set("animating", false);
    this.set("animations", []);
  };
  Element2.prototype.pauseAnimate = function() {
    var timeline = this.get("timeline");
    var animations = this.get("animations");
    var pauseTime = timeline.getTime();
    each$1(animations, function(animation2) {
      animation2._paused = true;
      animation2._pauseTime = pauseTime;
      if (animation2.pauseCallback) {
        animation2.pauseCallback();
      }
    });
    this.set("_pause", {
      isPaused: true,
      pauseTime
    });
    return this;
  };
  Element2.prototype.resumeAnimate = function() {
    var timeline = this.get("timeline");
    var current = timeline.getTime();
    var animations = this.get("animations");
    var pauseTime = this.get("_pause").pauseTime;
    each$1(animations, function(animation2) {
      animation2.startTime = animation2.startTime + (current - pauseTime);
      animation2._paused = false;
      animation2._pauseTime = null;
      if (animation2.resumeCallback) {
        animation2.resumeCallback();
      }
    });
    this.set("_pause", {
      isPaused: false
    });
    this.set("animations", animations);
    return this;
  };
  Element2.prototype.emitDelegation = function(type, eventObj) {
    var _this = this;
    var paths = eventObj.propagationPath;
    this.getEvents();
    var relativeShape;
    if (type === "mouseenter") {
      relativeShape = eventObj.fromShape;
    } else if (type === "mouseleave") {
      relativeShape = eventObj.toShape;
    }
    var _loop_1 = function(i2) {
      var element = paths[i2];
      var name_1 = element.get("name");
      if (name_1) {
        if ((element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent(element, relativeShape)) {
          return "break";
        }
        if (isArray$1(name_1)) {
          each$1(name_1, function(subName) {
            _this.emitDelegateEvent(element, subName, eventObj);
          });
        } else {
          this_1.emitDelegateEvent(element, name_1, eventObj);
        }
      }
    };
    var this_1 = this;
    for (var i = 0; i < paths.length; i++) {
      var state_1 = _loop_1(i);
      if (state_1 === "break")
        break;
    }
  };
  Element2.prototype.emitDelegateEvent = function(element, name, eventObj) {
    var events = this.getEvents();
    var eventName = name + DELEGATION_SPLIT + eventObj.type;
    if (events[eventName] || events[WILDCARD]) {
      eventObj.name = eventName;
      eventObj.currentTarget = element;
      eventObj.delegateTarget = this;
      eventObj.delegateObject = element.get("delegateObject");
      this.emit(eventName, eventObj);
    }
  };
  Element2.prototype.translate = function(translateX, translateY) {
    if (translateX === void 0) {
      translateX = 0;
    }
    if (translateY === void 0) {
      translateY = 0;
    }
    var matrix = this.getMatrix();
    var newMatrix = transform$5(matrix, [["t", translateX, translateY]]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element2.prototype.move = function(targetX, targetY) {
    var x = this.attr("x") || 0;
    var y = this.attr("y") || 0;
    this.translate(targetX - x, targetY - y);
    return this;
  };
  Element2.prototype.moveTo = function(targetX, targetY) {
    return this.move(targetX, targetY);
  };
  Element2.prototype.scale = function(ratioX, ratioY) {
    var matrix = this.getMatrix();
    var newMatrix = transform$5(matrix, [["s", ratioX, ratioY || ratioX]]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element2.prototype.rotate = function(radian) {
    var matrix = this.getMatrix();
    var newMatrix = transform$5(matrix, [["r", radian]]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element2.prototype.rotateAtStart = function(rotate2) {
    var _a2 = this.attr(), x = _a2.x, y = _a2.y;
    var matrix = this.getMatrix();
    var newMatrix = transform$5(matrix, [
      ["t", -x, -y],
      ["r", rotate2],
      ["t", x, y]
    ]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element2.prototype.rotateAtPoint = function(x, y, rotate2) {
    var matrix = this.getMatrix();
    var newMatrix = transform$5(matrix, [
      ["t", -x, -y],
      ["r", rotate2],
      ["t", x, y]
    ]);
    this.setMatrix(newMatrix);
    return this;
  };
  return Element2;
}(Base);
var SHAPE_MAP = {};
var INDEX = "_INDEX";
function setCanvas(element, canvas) {
  element.set("canvas", canvas);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setCanvas(child, canvas);
      });
    }
  }
}
function setTimeline(element, timeline) {
  element.set("timeline", timeline);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setTimeline(child, timeline);
      });
    }
  }
}
function removeChild(container, element, destroy) {
  if (destroy === void 0) {
    destroy = true;
  }
  if (destroy) {
    element.destroy();
  } else {
    element.set("parent", null);
    element.set("canvas", null);
  }
  removeFromArray(container.getChildren(), element);
}
function getComparer(compare2) {
  return function(left2, right2) {
    var result = compare2(left2, right2);
    return result === 0 ? left2[INDEX] - right2[INDEX] : result;
  };
}
var Container = function(_super) {
  __extends$2(Container2, _super);
  function Container2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Container2.prototype.isCanvas = function() {
    return false;
  };
  Container2.prototype.getBBox = function() {
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    var xArr = [];
    var yArr = [];
    var children = this.getChildren().filter(function(child) {
      return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
    });
    if (children.length > 0) {
      each$1(children, function(child) {
        var box3 = child.getBBox();
        xArr.push(box3.minX, box3.maxX);
        yArr.push(box3.minY, box3.maxY);
      });
      minX = min$1(xArr);
      maxX = max$1(xArr);
      minY = min$1(yArr);
      maxY = max$1(yArr);
    } else {
      minX = 0;
      maxX = 0;
      minY = 0;
      maxY = 0;
    }
    var box2 = {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
    return box2;
  };
  Container2.prototype.getCanvasBBox = function() {
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    var xArr = [];
    var yArr = [];
    var children = this.getChildren().filter(function(child) {
      return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
    });
    if (children.length > 0) {
      each$1(children, function(child) {
        var box3 = child.getCanvasBBox();
        xArr.push(box3.minX, box3.maxX);
        yArr.push(box3.minY, box3.maxY);
      });
      minX = min$1(xArr);
      maxX = max$1(xArr);
      minY = min$1(yArr);
      maxY = max$1(yArr);
    } else {
      minX = 0;
      maxX = 0;
      minY = 0;
      maxY = 0;
    }
    var box2 = {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
    return box2;
  };
  Container2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg["children"] = [];
    return cfg;
  };
  Container2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    if (name === "matrix") {
      var totalMatrix = this.getTotalMatrix();
      this._applyChildrenMarix(totalMatrix);
    }
  };
  Container2.prototype.applyMatrix = function(matrix) {
    var preTotalMatrix = this.getTotalMatrix();
    _super.prototype.applyMatrix.call(this, matrix);
    var totalMatrix = this.getTotalMatrix();
    if (totalMatrix === preTotalMatrix) {
      return;
    }
    this._applyChildrenMarix(totalMatrix);
  };
  Container2.prototype._applyChildrenMarix = function(totalMatrix) {
    var children = this.getChildren();
    each$1(children, function(child) {
      child.applyMatrix(totalMatrix);
    });
  };
  Container2.prototype.addShape = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var type = args[0];
    var cfg = args[1];
    if (isObject(type)) {
      cfg = type;
    } else {
      cfg["type"] = type;
    }
    var shapeType = SHAPE_MAP[cfg.type];
    if (!shapeType) {
      shapeType = upperFirst(cfg.type);
      SHAPE_MAP[cfg.type] = shapeType;
    }
    var ShapeBase2 = this.getShapeBase();
    var shape = new ShapeBase2[shapeType](cfg);
    this.add(shape);
    return shape;
  };
  Container2.prototype.addGroup = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var groupClass = args[0], cfg = args[1];
    var group2;
    if (isFunction(groupClass)) {
      if (cfg) {
        group2 = new groupClass(cfg);
      } else {
        group2 = new groupClass({
          parent: this
        });
      }
    } else {
      var tmpCfg = groupClass || {};
      var TmpGroupClass = this.getGroupBase();
      group2 = new TmpGroupClass(tmpCfg);
    }
    this.add(group2);
    return group2;
  };
  Container2.prototype.getCanvas = function() {
    var canvas;
    if (this.isCanvas()) {
      canvas = this;
    } else {
      canvas = this.get("canvas");
    }
    return canvas;
  };
  Container2.prototype.getShape = function(x, y, ev) {
    if (!isAllowCapture(this)) {
      return null;
    }
    var children = this.getChildren();
    var shape;
    if (!this.isCanvas()) {
      var v = [x, y, 1];
      v = this.invertFromMatrix(v);
      if (!this.isClipped(v[0], v[1])) {
        shape = this._findShape(children, v[0], v[1], ev);
      }
    } else {
      shape = this._findShape(children, x, y, ev);
    }
    return shape;
  };
  Container2.prototype._findShape = function(children, x, y, ev) {
    var shape = null;
    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];
      if (isAllowCapture(child)) {
        if (child.isGroup()) {
          shape = child.getShape(x, y, ev);
        } else if (child.isHit(x, y)) {
          shape = child;
        }
      }
      if (shape) {
        break;
      }
    }
    return shape;
  };
  Container2.prototype.add = function(element) {
    var canvas = this.getCanvas();
    var children = this.getChildren();
    var timeline = this.get("timeline");
    var preParent = element.getParent();
    if (preParent) {
      removeChild(preParent, element, false);
    }
    element.set("parent", this);
    if (canvas) {
      setCanvas(element, canvas);
    }
    if (timeline) {
      setTimeline(element, timeline);
    }
    children.push(element);
    element.onCanvasChange("add");
    this._applyElementMatrix(element);
  };
  Container2.prototype._applyElementMatrix = function(element) {
    var totalMatrix = this.getTotalMatrix();
    if (totalMatrix) {
      element.applyMatrix(totalMatrix);
    }
  };
  Container2.prototype.getChildren = function() {
    return this.get("children");
  };
  Container2.prototype.sort = function() {
    var children = this.getChildren();
    each$1(children, function(child, index2) {
      child[INDEX] = index2;
      return child;
    });
    children.sort(getComparer(function(obj1, obj2) {
      return obj1.get("zIndex") - obj2.get("zIndex");
    }));
    this.onCanvasChange("sort");
  };
  Container2.prototype.clear = function() {
    this.set("clearing", true);
    if (this.destroyed) {
      return;
    }
    var children = this.getChildren();
    for (var i = children.length - 1; i >= 0; i--) {
      children[i].destroy();
    }
    this.set("children", []);
    this.onCanvasChange("clear");
    this.set("clearing", false);
  };
  Container2.prototype.destroy = function() {
    if (this.get("destroyed")) {
      return;
    }
    this.clear();
    _super.prototype.destroy.call(this);
  };
  Container2.prototype.getFirst = function() {
    return this.getChildByIndex(0);
  };
  Container2.prototype.getLast = function() {
    var children = this.getChildren();
    return this.getChildByIndex(children.length - 1);
  };
  Container2.prototype.getChildByIndex = function(index2) {
    var children = this.getChildren();
    return children[index2];
  };
  Container2.prototype.getCount = function() {
    var children = this.getChildren();
    return children.length;
  };
  Container2.prototype.contain = function(element) {
    var children = this.getChildren();
    return children.indexOf(element) > -1;
  };
  Container2.prototype.removeChild = function(element, destroy) {
    if (destroy === void 0) {
      destroy = true;
    }
    if (this.contain(element)) {
      element.remove(destroy);
    }
  };
  Container2.prototype.findAll = function(fn) {
    var rst = [];
    var children = this.getChildren();
    each$1(children, function(element) {
      if (fn(element)) {
        rst.push(element);
      }
      if (element.isGroup()) {
        rst = rst.concat(element.findAll(fn));
      }
    });
    return rst;
  };
  Container2.prototype.find = function(fn) {
    var rst = null;
    var children = this.getChildren();
    each$1(children, function(element) {
      if (fn(element)) {
        rst = element;
      } else if (element.isGroup()) {
        rst = element.find(fn);
      }
      if (rst) {
        return false;
      }
    });
    return rst;
  };
  Container2.prototype.findById = function(id) {
    return this.find(function(element) {
      return element.get("id") === id;
    });
  };
  Container2.prototype.findByClassName = function(className) {
    return this.find(function(element) {
      return element.get("className") === className;
    });
  };
  Container2.prototype.findAllByName = function(name) {
    return this.findAll(function(element) {
      return element.get("name") === name;
    });
  };
  return Container2;
}(Element$2);
var isColorProp = function(prop) {
  return ["fill", "stroke", "fillStyle", "strokeStyle"].includes(prop);
};
var isGradientColor = function(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};
var IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function _update(shape, animation2, ratio) {
  var cProps = {};
  var fromAttrs = animation2.fromAttrs, toAttrs = animation2.toAttrs;
  if (shape.destroyed) {
    return;
  }
  var interf;
  for (var k in toAttrs) {
    if (!isEqual$2(fromAttrs[k], toAttrs[k])) {
      if (k === "path") {
        var toPath = toAttrs[k];
        var fromPath = fromAttrs[k];
        if (toPath.length > fromPath.length) {
          toPath = parsePathString(toAttrs[k]);
          fromPath = parsePathString(fromAttrs[k]);
          fromPath = fillPathByDiff(fromPath, toPath);
          fromPath = formatPath(fromPath, toPath);
          animation2.fromAttrs.path = fromPath;
          animation2.toAttrs.path = toPath;
        } else if (!animation2.pathFormatted) {
          toPath = parsePathString(toAttrs[k]);
          fromPath = parsePathString(fromAttrs[k]);
          fromPath = formatPath(fromPath, toPath);
          animation2.fromAttrs.path = fromPath;
          animation2.toAttrs.path = toPath;
          animation2.pathFormatted = true;
        }
        cProps[k] = [];
        for (var i = 0; i < toPath.length; i++) {
          var toPathPoint = toPath[i];
          var fromPathPoint = fromPath[i];
          var cPathPoint = [];
          for (var j = 0; j < toPathPoint.length; j++) {
            if (isNumber$1(toPathPoint[j]) && fromPathPoint && isNumber$1(fromPathPoint[j])) {
              interf = interpolate(fromPathPoint[j], toPathPoint[j]);
              cPathPoint.push(interf(ratio));
            } else {
              cPathPoint.push(toPathPoint[j]);
            }
          }
          cProps[k].push(cPathPoint);
        }
      } else if (k === "matrix") {
        var matrixFn = interpolateArray(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);
        var currentMatrix = matrixFn(ratio);
        cProps[k] = currentMatrix;
      } else if (isColorProp(k) && isGradientColor(toAttrs[k])) {
        cProps[k] = toAttrs[k];
      } else if (!isFunction(toAttrs[k])) {
        interf = interpolate(fromAttrs[k], toAttrs[k]);
        cProps[k] = interf(ratio);
      }
    }
  }
  shape.attr(cProps);
}
function update(shape, animation2, elapsed) {
  var startTime = animation2.startTime, delay = animation2.delay;
  if (elapsed < startTime + delay || animation2._paused) {
    return false;
  }
  var ratio;
  var duration = animation2.duration;
  var easing = animation2.easing;
  elapsed = elapsed - startTime - animation2.delay;
  if (animation2.repeat) {
    ratio = elapsed % duration / duration;
    ratio = d3Ease[easing](ratio);
  } else {
    ratio = elapsed / duration;
    if (ratio < 1) {
      ratio = d3Ease[easing](ratio);
    } else {
      if (animation2.onFrame) {
        shape.attr(animation2.onFrame(1));
      } else {
        shape.attr(animation2.toAttrs);
      }
      return true;
    }
  }
  if (animation2.onFrame) {
    var attrs = animation2.onFrame(ratio);
    shape.attr(attrs);
  } else {
    _update(shape, animation2, ratio);
  }
  return false;
}
var Timeline = function() {
  function Timeline2(canvas) {
    this.animators = [];
    this.current = 0;
    this.timer = null;
    this.canvas = canvas;
  }
  Timeline2.prototype.initTimer = function() {
    var _this = this;
    var isFinished = false;
    var shape;
    var animations;
    var animation2;
    this.timer = timer(function(elapsed) {
      _this.current = elapsed;
      if (_this.animators.length > 0) {
        for (var i = _this.animators.length - 1; i >= 0; i--) {
          shape = _this.animators[i];
          if (shape.destroyed) {
            _this.removeAnimator(i);
            continue;
          }
          if (!shape.isAnimatePaused()) {
            animations = shape.get("animations");
            for (var j = animations.length - 1; j >= 0; j--) {
              animation2 = animations[j];
              isFinished = update(shape, animation2, elapsed);
              if (isFinished) {
                animations.splice(j, 1);
                isFinished = false;
                if (animation2.callback) {
                  animation2.callback();
                }
              }
            }
          }
          if (animations.length === 0) {
            _this.removeAnimator(i);
          }
        }
        var autoDraw = _this.canvas.get("autoDraw");
        if (!autoDraw) {
          _this.canvas.draw();
        }
      }
    });
  };
  Timeline2.prototype.addAnimator = function(shape) {
    this.animators.push(shape);
  };
  Timeline2.prototype.removeAnimator = function(index2) {
    this.animators.splice(index2, 1);
  };
  Timeline2.prototype.isAnimating = function() {
    return !!this.animators.length;
  };
  Timeline2.prototype.stop = function() {
    if (this.timer) {
      this.timer.stop();
    }
  };
  Timeline2.prototype.stopAllAnimations = function(toEnd) {
    if (toEnd === void 0) {
      toEnd = true;
    }
    this.animators.forEach(function(animator) {
      animator.stopAnimate(toEnd);
    });
    this.animators = [];
    this.canvas.draw();
  };
  Timeline2.prototype.getTime = function() {
    return this.current;
  };
  return Timeline2;
}();
var CLICK_OFFSET = 40;
var LEFT_BTN_CODE = 0;
var EVENTS$2 = [
  "mousedown",
  "mouseup",
  "dblclick",
  "mouseout",
  "mouseover",
  "mousemove",
  "mouseleave",
  "mouseenter",
  "touchstart",
  "touchmove",
  "touchend",
  "dragenter",
  "dragover",
  "dragleave",
  "drop",
  "contextmenu",
  "mousewheel"
];
function emitTargetEvent(target, type, eventObj) {
  eventObj.name = type;
  eventObj.target = target;
  eventObj.currentTarget = target;
  eventObj.delegateTarget = target;
  target.emit(type, eventObj);
}
function bubbleEvent(container, type, eventObj) {
  if (eventObj.bubbles) {
    var relativeShape = void 0;
    var isOverEvent = false;
    if (type === "mouseenter") {
      relativeShape = eventObj.fromShape;
      isOverEvent = true;
    } else if (type === "mouseleave") {
      isOverEvent = true;
      relativeShape = eventObj.toShape;
    }
    if (container.isCanvas() && isOverEvent) {
      return;
    }
    if (relativeShape && isParent(container, relativeShape)) {
      eventObj.bubbles = false;
      return;
    }
    eventObj.name = type;
    eventObj.currentTarget = container;
    eventObj.delegateTarget = container;
    container.emit(type, eventObj);
  }
}
var EventController = function() {
  function EventController2(cfg) {
    var _this = this;
    this.draggingShape = null;
    this.dragging = false;
    this.currentShape = null;
    this.mousedownShape = null;
    this.mousedownPoint = null;
    this._eventCallback = function(ev) {
      var type = ev.type;
      _this._triggerEvent(type, ev);
    };
    this._onDocumentMove = function(ev) {
      var canvas = _this.canvas;
      var el = canvas.get("el");
      if (el !== ev.target) {
        if (_this.dragging || _this.currentShape) {
          var pointInfo = _this._getPointInfo(ev);
          if (_this.dragging) {
            _this._emitEvent("drag", ev, pointInfo, _this.draggingShape);
          }
        }
      }
    };
    this._onDocumentMouseUp = function(ev) {
      var canvas = _this.canvas;
      var el = canvas.get("el");
      if (el !== ev.target) {
        if (_this.dragging) {
          var pointInfo = _this._getPointInfo(ev);
          if (_this.draggingShape) {
            _this._emitEvent("drop", ev, pointInfo, null);
          }
          _this._emitEvent("dragend", ev, pointInfo, _this.draggingShape);
          _this._afterDrag(_this.draggingShape, pointInfo, ev);
        }
      }
    };
    this.canvas = cfg.canvas;
  }
  EventController2.prototype.init = function() {
    this._bindEvents();
  };
  EventController2.prototype._bindEvents = function() {
    var _this = this;
    var el = this.canvas.get("el");
    each$1(EVENTS$2, function(eventName) {
      el.addEventListener(eventName, _this._eventCallback);
    });
    if (document) {
      document.addEventListener("mousemove", this._onDocumentMove);
      document.addEventListener("mouseup", this._onDocumentMouseUp);
    }
  };
  EventController2.prototype._clearEvents = function() {
    var _this = this;
    var el = this.canvas.get("el");
    each$1(EVENTS$2, function(eventName) {
      el.removeEventListener(eventName, _this._eventCallback);
    });
    if (document) {
      document.removeEventListener("mousemove", this._onDocumentMove);
      document.removeEventListener("mouseup", this._onDocumentMouseUp);
    }
  };
  EventController2.prototype._getEventObj = function(type, event, point2, target, fromShape, toShape) {
    var eventObj = new GraphEvent(type, event);
    eventObj.fromShape = fromShape;
    eventObj.toShape = toShape;
    eventObj.x = point2.x;
    eventObj.y = point2.y;
    eventObj.clientX = point2.clientX;
    eventObj.clientY = point2.clientY;
    eventObj.propagationPath.push(target);
    return eventObj;
  };
  EventController2.prototype._getShape = function(point2, ev) {
    return this.canvas.getShape(point2.x, point2.y, ev);
  };
  EventController2.prototype._getPointInfo = function(ev) {
    var canvas = this.canvas;
    var clientPoint = canvas.getClientByEvent(ev);
    var point2 = canvas.getPointByEvent(ev);
    return {
      x: point2.x,
      y: point2.y,
      clientX: clientPoint.x,
      clientY: clientPoint.y
    };
  };
  EventController2.prototype._triggerEvent = function(type, ev) {
    var pointInfo = this._getPointInfo(ev);
    var shape = this._getShape(pointInfo, ev);
    var method = this["_on" + type];
    var leaveCanvas = false;
    if (method) {
      method.call(this, pointInfo, shape, ev);
    } else {
      var preShape = this.currentShape;
      if (type === "mouseenter" || type === "dragenter" || type === "mouseover") {
        this._emitEvent(type, ev, pointInfo, null, null, shape);
        if (shape) {
          this._emitEvent(type, ev, pointInfo, shape, null, shape);
        }
        if (type === "mouseenter" && this.draggingShape) {
          this._emitEvent("dragenter", ev, pointInfo, null);
        }
      } else if (type === "mouseleave" || type === "dragleave" || type === "mouseout") {
        leaveCanvas = true;
        if (preShape) {
          this._emitEvent(type, ev, pointInfo, preShape, preShape, null);
        }
        this._emitEvent(type, ev, pointInfo, null, preShape, null);
        if (type === "mouseleave" && this.draggingShape) {
          this._emitEvent("dragleave", ev, pointInfo, null);
        }
      } else {
        this._emitEvent(type, ev, pointInfo, shape, null, null);
      }
    }
    if (!leaveCanvas) {
      this.currentShape = shape;
    }
    if (shape && !shape.get("destroyed")) {
      var canvas = this.canvas;
      var el = canvas.get("el");
      el.style.cursor = shape.attr("cursor") || canvas.get("cursor");
    }
  };
  EventController2.prototype._onmousedown = function(pointInfo, shape, event) {
    if (event.button === LEFT_BTN_CODE) {
      this.mousedownShape = shape;
      this.mousedownPoint = pointInfo;
      this.mousedownTimeStamp = event.timeStamp;
    }
    this._emitEvent("mousedown", event, pointInfo, shape, null, null);
  };
  EventController2.prototype._emitMouseoverEvents = function(event, pointInfo, fromShape, toShape) {
    var el = this.canvas.get("el");
    if (fromShape !== toShape) {
      if (fromShape) {
        this._emitEvent("mouseout", event, pointInfo, fromShape, fromShape, toShape);
        this._emitEvent("mouseleave", event, pointInfo, fromShape, fromShape, toShape);
        if (!toShape || toShape.get("destroyed")) {
          el.style.cursor = this.canvas.get("cursor");
        }
      }
      if (toShape) {
        this._emitEvent("mouseover", event, pointInfo, toShape, fromShape, toShape);
        this._emitEvent("mouseenter", event, pointInfo, toShape, fromShape, toShape);
      }
    }
  };
  EventController2.prototype._emitDragoverEvents = function(event, pointInfo, fromShape, toShape, isCanvasEmit) {
    if (toShape) {
      if (toShape !== fromShape) {
        if (fromShape) {
          this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
        }
        this._emitEvent("dragenter", event, pointInfo, toShape, fromShape, toShape);
      }
      if (!isCanvasEmit) {
        this._emitEvent("dragover", event, pointInfo, toShape);
      }
    } else if (fromShape) {
      this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
    }
    if (isCanvasEmit) {
      this._emitEvent("dragover", event, pointInfo, toShape);
    }
  };
  EventController2.prototype._afterDrag = function(draggingShape, pointInfo, event) {
    if (draggingShape) {
      draggingShape.set("capture", true);
      this.draggingShape = null;
    }
    this.dragging = false;
    var shape = this._getShape(pointInfo, event);
    if (shape !== draggingShape) {
      this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
    }
    this.currentShape = shape;
  };
  EventController2.prototype._onmouseup = function(pointInfo, shape, event) {
    if (event.button === LEFT_BTN_CODE) {
      var draggingShape = this.draggingShape;
      if (this.dragging) {
        if (draggingShape) {
          this._emitEvent("drop", event, pointInfo, shape);
        }
        this._emitEvent("dragend", event, pointInfo, draggingShape);
        this._afterDrag(draggingShape, pointInfo, event);
      } else {
        this._emitEvent("mouseup", event, pointInfo, shape);
        if (shape === this.mousedownShape) {
          this._emitEvent("click", event, pointInfo, shape);
        }
        this.mousedownShape = null;
        this.mousedownPoint = null;
      }
    }
  };
  EventController2.prototype._ondragover = function(pointInfo, shape, event) {
    event.preventDefault();
    var preShape = this.currentShape;
    this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
  };
  EventController2.prototype._onmousemove = function(pointInfo, shape, event) {
    var canvas = this.canvas;
    var preShape = this.currentShape;
    var draggingShape = this.draggingShape;
    if (this.dragging) {
      if (draggingShape) {
        this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
      }
      this._emitEvent("drag", event, pointInfo, draggingShape);
    } else {
      var mousedownPoint = this.mousedownPoint;
      if (mousedownPoint) {
        var mousedownShape = this.mousedownShape;
        var now = event.timeStamp;
        var timeWindow = now - this.mousedownTimeStamp;
        var dx = mousedownPoint.clientX - pointInfo.clientX;
        var dy = mousedownPoint.clientY - pointInfo.clientY;
        var dist = dx * dx + dy * dy;
        if (timeWindow > 120 || dist > CLICK_OFFSET) {
          if (mousedownShape && mousedownShape.get("draggable")) {
            draggingShape = this.mousedownShape;
            draggingShape.set("capture", false);
            this.draggingShape = draggingShape;
            this.dragging = true;
            this._emitEvent("dragstart", event, pointInfo, draggingShape);
            this.mousedownShape = null;
            this.mousedownPoint = null;
          } else if (!mousedownShape && canvas.get("draggable")) {
            this.dragging = true;
            this._emitEvent("dragstart", event, pointInfo, null);
            this.mousedownShape = null;
            this.mousedownPoint = null;
          } else {
            this._emitMouseoverEvents(event, pointInfo, preShape, shape);
            this._emitEvent("mousemove", event, pointInfo, shape);
          }
        } else {
          this._emitMouseoverEvents(event, pointInfo, preShape, shape);
          this._emitEvent("mousemove", event, pointInfo, shape);
        }
      } else {
        this._emitMouseoverEvents(event, pointInfo, preShape, shape);
        this._emitEvent("mousemove", event, pointInfo, shape);
      }
    }
  };
  EventController2.prototype._emitEvent = function(type, event, pointInfo, shape, fromShape, toShape) {
    var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);
    if (shape) {
      eventObj.shape = shape;
      emitTargetEvent(shape, type, eventObj);
      var parent_1 = shape.getParent();
      while (parent_1) {
        parent_1.emitDelegation(type, eventObj);
        if (!eventObj.propagationStopped) {
          bubbleEvent(parent_1, type, eventObj);
        }
        eventObj.propagationPath.push(parent_1);
        parent_1 = parent_1.getParent();
      }
    } else {
      var canvas = this.canvas;
      emitTargetEvent(canvas, type, eventObj);
    }
  };
  EventController2.prototype.destroy = function() {
    this._clearEvents();
    this.canvas = null;
    this.currentShape = null;
    this.draggingShape = null;
    this.mousedownPoint = null;
    this.mousedownShape = null;
    this.mousedownTimeStamp = null;
  };
  return EventController2;
}();
var PX_SUFFIX = "px";
var browser = detect();
var isFirefox = browser && browser.name === "firefox";
(function(_super) {
  __extends$2(Canvas2, _super);
  function Canvas2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.initContainer();
    _this.initDom();
    _this.initEvents();
    _this.initTimeline();
    return _this;
  }
  Canvas2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg["cursor"] = "default";
    cfg["supportCSSTransform"] = false;
    return cfg;
  };
  Canvas2.prototype.initContainer = function() {
    var container = this.get("container");
    if (isString(container)) {
      container = document.getElementById(container);
      this.set("container", container);
    }
  };
  Canvas2.prototype.initDom = function() {
    var el = this.createDom();
    this.set("el", el);
    var container = this.get("container");
    container.appendChild(el);
    this.setDOMSize(this.get("width"), this.get("height"));
  };
  Canvas2.prototype.initEvents = function() {
    var eventController = new EventController({
      canvas: this
    });
    eventController.init();
    this.set("eventController", eventController);
  };
  Canvas2.prototype.initTimeline = function() {
    var timeline = new Timeline(this);
    this.set("timeline", timeline);
  };
  Canvas2.prototype.setDOMSize = function(width, height) {
    var el = this.get("el");
    if (isBrowser) {
      el.style.width = width + PX_SUFFIX;
      el.style.height = height + PX_SUFFIX;
    }
  };
  Canvas2.prototype.changeSize = function(width, height) {
    this.setDOMSize(width, height);
    this.set("width", width);
    this.set("height", height);
    this.onCanvasChange("changeSize");
  };
  Canvas2.prototype.getRenderer = function() {
    return this.get("renderer");
  };
  Canvas2.prototype.getCursor = function() {
    return this.get("cursor");
  };
  Canvas2.prototype.setCursor = function(cursor) {
    this.set("cursor", cursor);
    var el = this.get("el");
    if (isBrowser && el) {
      el.style.cursor = cursor;
    }
  };
  Canvas2.prototype.getPointByEvent = function(ev) {
    var supportCSSTransform = this.get("supportCSSTransform");
    if (supportCSSTransform) {
      if (isFirefox && !isNil(ev.layerX) && ev.layerX !== ev.offsetX) {
        return {
          x: ev.layerX,
          y: ev.layerY
        };
      }
      if (!isNil(ev.offsetX)) {
        return {
          x: ev.offsetX,
          y: ev.offsetY
        };
      }
    }
    var _a2 = this.getClientByEvent(ev), clientX = _a2.x, clientY = _a2.y;
    return this.getPointByClient(clientX, clientY);
  };
  Canvas2.prototype.getClientByEvent = function(ev) {
    var clientInfo = ev;
    if (ev.touches) {
      if (ev.type === "touchend") {
        clientInfo = ev.changedTouches[0];
      } else {
        clientInfo = ev.touches[0];
      }
    }
    return {
      x: clientInfo.clientX,
      y: clientInfo.clientY
    };
  };
  Canvas2.prototype.getPointByClient = function(clientX, clientY) {
    var el = this.get("el");
    var bbox = el.getBoundingClientRect();
    return {
      x: clientX - bbox.left,
      y: clientY - bbox.top
    };
  };
  Canvas2.prototype.getClientByPoint = function(x, y) {
    var el = this.get("el");
    var bbox = el.getBoundingClientRect();
    return {
      x: x + bbox.left,
      y: y + bbox.top
    };
  };
  Canvas2.prototype.draw = function() {
  };
  Canvas2.prototype.removeDom = function() {
    var el = this.get("el");
    el.parentNode.removeChild(el);
  };
  Canvas2.prototype.clearEvents = function() {
    var eventController = this.get("eventController");
    eventController.destroy();
  };
  Canvas2.prototype.isCanvas = function() {
    return true;
  };
  Canvas2.prototype.getParent = function() {
    return null;
  };
  Canvas2.prototype.destroy = function() {
    var timeline = this.get("timeline");
    if (this.get("destroyed")) {
      return;
    }
    this.clear();
    if (timeline) {
      timeline.stop();
    }
    this.clearEvents();
    this.removeDom();
    _super.prototype.destroy.call(this);
  };
  return Canvas2;
})(Container);
(function(_super) {
  __extends$2(AbstractGroup2, _super);
  function AbstractGroup2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AbstractGroup2.prototype.isGroup = function() {
    return true;
  };
  AbstractGroup2.prototype.isEntityGroup = function() {
    return false;
  };
  AbstractGroup2.prototype.clone = function() {
    var clone2 = _super.prototype.clone.call(this);
    var children = this.getChildren();
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      clone2.add(child.clone());
    }
    return clone2;
  };
  return AbstractGroup2;
})(Container);
(function(_super) {
  __extends$2(AbstractShape2, _super);
  function AbstractShape2(cfg) {
    return _super.call(this, cfg) || this;
  }
  AbstractShape2.prototype._isInBBox = function(refX, refY) {
    var bbox = this.getBBox();
    return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
  };
  AbstractShape2.prototype.afterAttrsChange = function(targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    this.clearCacheBBox();
  };
  AbstractShape2.prototype.getBBox = function() {
    var bbox = this.cfg.bbox;
    if (!bbox) {
      bbox = this.calculateBBox();
      this.set("bbox", bbox);
    }
    return bbox;
  };
  AbstractShape2.prototype.getCanvasBBox = function() {
    var canvasBBox = this.cfg.canvasBBox;
    if (!canvasBBox) {
      canvasBBox = this.calculateCanvasBBox();
      this.set("canvasBBox", canvasBBox);
    }
    return canvasBBox;
  };
  AbstractShape2.prototype.applyMatrix = function(matrix) {
    _super.prototype.applyMatrix.call(this, matrix);
    this.set("canvasBBox", null);
  };
  AbstractShape2.prototype.calculateCanvasBBox = function() {
    var bbox = this.getBBox();
    var totalMatrix = this.getTotalMatrix();
    var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
    if (totalMatrix) {
      var topLeft = multiplyVec2$1(totalMatrix, [bbox.minX, bbox.minY]);
      var topRight = multiplyVec2$1(totalMatrix, [bbox.maxX, bbox.minY]);
      var bottomLeft = multiplyVec2$1(totalMatrix, [bbox.minX, bbox.maxY]);
      var bottomRight = multiplyVec2$1(totalMatrix, [bbox.maxX, bbox.maxY]);
      minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
      maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
      minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
      maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
    }
    var attrs = this.attrs;
    if (attrs.shadowColor) {
      var _a2 = attrs.shadowBlur, shadowBlur = _a2 === void 0 ? 0 : _a2, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
      var shadowLeft = minX - shadowBlur + shadowOffsetX;
      var shadowRight = maxX + shadowBlur + shadowOffsetX;
      var shadowTop = minY - shadowBlur + shadowOffsetY;
      var shadowBottom = maxY + shadowBlur + shadowOffsetY;
      minX = Math.min(minX, shadowLeft);
      maxX = Math.max(maxX, shadowRight);
      minY = Math.min(minY, shadowTop);
      maxY = Math.max(maxY, shadowBottom);
    }
    return {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  };
  AbstractShape2.prototype.clearCacheBBox = function() {
    this.set("bbox", null);
    this.set("canvasBBox", null);
  };
  AbstractShape2.prototype.isClipShape = function() {
    return this.get("isClipShape");
  };
  AbstractShape2.prototype.isInShape = function(refX, refY) {
    return false;
  };
  AbstractShape2.prototype.isOnlyHitBox = function() {
    return false;
  };
  AbstractShape2.prototype.isHit = function(x, y) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    var vec = [x, y, 1];
    vec = this.invertFromMatrix(vec);
    var refX = vec[0], refY = vec[1];
    var inBBox = this._isInBBox(refX, refY);
    if (this.isOnlyHitBox()) {
      return inBBox;
    }
    if (inBBox && !this.isClipped(refX, refY)) {
      if (this.isInShape(refX, refY)) {
        return true;
      }
      if (startArrowShape && startArrowShape.isHit(refX, refY)) {
        return true;
      }
      if (endArrowShape && endArrowShape.isHit(refX, refY)) {
        return true;
      }
    }
    return false;
  };
  return AbstractShape2;
})(Element$2);
var cache = new Map();
function register(type, method) {
  cache.set(type, method);
}
function rect$1(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height;
  return {
    x,
    y,
    width,
    height
  };
}
function circle$1(shape) {
  var _a2 = shape.attr(), x = _a2.x, y = _a2.y, r = _a2.r;
  return {
    x: x - r,
    y: y - r,
    width: r * 2,
    height: r * 2
  };
}
function mergeBBox(bbox1, bbox2) {
  if (!bbox1 || !bbox2) {
    return bbox1 || bbox2;
  }
  return {
    minX: Math.min(bbox1.minX, bbox2.minX),
    minY: Math.min(bbox1.minY, bbox2.minY),
    maxX: Math.max(bbox1.maxX, bbox2.maxX),
    maxY: Math.max(bbox1.maxY, bbox2.maxY)
  };
}
function mergeArrowBBox(shape, bbox) {
  var startArrowShape = shape.get("startArrowShape");
  var endArrowShape = shape.get("endArrowShape");
  var startArrowBBox = null;
  var endArrowBBox = null;
  if (startArrowShape) {
    startArrowBBox = startArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, startArrowBBox);
  }
  if (endArrowShape) {
    endArrowBBox = endArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, endArrowBBox);
  }
  return bbox;
}
function polyline(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i = 0; i < points.length; i++) {
    var point2 = points[i];
    xArr.push(point2[0]);
    yArr.push(point2[1]);
  }
  var _a2 = getBBoxByArray(xArr, yArr), x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
  var bbox = {
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}
function polygon$1(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i = 0; i < points.length; i++) {
    var point2 = points[i];
    xArr.push(point2[0]);
    yArr.push(point2[1]);
  }
  return getBBoxByArray(xArr, yArr);
}
var offScreenCtx = null;
function getOffScreenContext() {
  if (!offScreenCtx) {
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    offScreenCtx = canvas.getContext("2d");
  }
  return offScreenCtx;
}
function getTextHeight(text2, fontSize, lineHeight) {
  var lineCount = 1;
  if (isString(text2)) {
    lineCount = text2.split("\n").length;
  }
  if (lineCount > 1) {
    var spaceingY = getLineSpaceing(fontSize, lineHeight);
    return fontSize * lineCount + spaceingY * (lineCount - 1);
  }
  return fontSize;
}
function getLineSpaceing(fontSize, lineHeight) {
  return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
}
function getTextWidth(text2, font) {
  var context = getOffScreenContext();
  var width = 0;
  if (isNil(text2) || text2 === "") {
    return width;
  }
  context.save();
  context.font = font;
  if (isString(text2) && text2.includes("\n")) {
    var textArr = text2.split("\n");
    each$1(textArr, function(subText) {
      var measureWidth = context.measureText(subText).width;
      if (width < measureWidth) {
        width = measureWidth;
      }
    });
  } else {
    width = context.measureText(text2).width;
  }
  context.restore();
  return width;
}
function assembleFont(attrs) {
  var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
  return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ").trim();
}
function text(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, text2 = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;
  var font = attrs.font;
  if (!font) {
    font = assembleFont(attrs);
  }
  var width = getTextWidth(text2, font);
  var bbox;
  if (!width) {
    bbox = {
      x,
      y,
      width: 0,
      height: 0
    };
  } else {
    var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
    var height = getTextHeight(text2, fontSize, lineHeight);
    var point2 = {
      x,
      y: y - height
    };
    if (textAlign) {
      if (textAlign === "end" || textAlign === "right") {
        point2.x -= width;
      } else if (textAlign === "center") {
        point2.x -= width / 2;
      }
    }
    if (textBaseline) {
      if (textBaseline === "top") {
        point2.y += height;
      } else if (textBaseline === "middle") {
        point2.y += height / 2;
      }
    }
    bbox = {
      x: point2.x,
      y: point2.y,
      width,
      height
    };
  }
  return bbox;
}
function getPathBox(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box2 = void 0;
    switch (segment.command) {
      case "Q":
        box2 = QuadUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box2 = CubicUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box2 = EllipseArcUtil.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box2) {
      segment.box = box2;
      xArr.push(box2.x, box2.x + box2.width);
      yArr.push(box2.y, box2.y + box2.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item);
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item);
  });
  var minX = min$1(xArr);
  var minY = min$1(yArr);
  var maxX = max$1(xArr);
  var maxY = max$1(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  for (var i = 0; i < segmentsWithAngle.length; i++) {
    var segment = segmentsWithAngle[i];
    var currentPoint = segment.currentPoint;
    var extra = void 0;
    if (currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minX = minX - extra.xExtra;
    } else if (currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxX = maxX + extra.xExtra;
    }
    if (currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minY = minY - extra.yExtra;
    } else if (currentPoint[1] === maxY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxY = maxY + extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual$1(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function path(shape) {
  var attrs = shape.attr();
  var path2 = attrs.path, stroke = attrs.stroke;
  var lineWidth = stroke ? attrs.lineWidth : 0;
  var segments = shape.get("segments") || getSegments(path2);
  var _a2 = getPathBox(segments, lineWidth), x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
  var bbox = {
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}
function line$1(shape) {
  var attrs = shape.attr();
  var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var bbox = {
    minX,
    maxX,
    minY,
    maxY
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}
function ellipse(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, rx = attrs.rx, ry = attrs.ry;
  return {
    x: x - rx,
    y: y - ry,
    width: rx * 2,
    height: ry * 2
  };
}
register("rect", rect$1);
register("image", rect$1);
register("circle", circle$1);
register("marker", circle$1);
register("polyline", polyline);
register("polygon", polygon$1);
register("text", text);
register("path", path);
register("line", line$1);
register("ellipse", ellipse);
function propagationDelegate(group2, eventName, eventObject) {
  var event = new GraphEvent(eventName, eventObject);
  event.target = group2;
  event.propagationPath.push(group2);
  group2.emitDelegation(eventName, event);
  var parent = group2.getParent();
  while (parent) {
    parent.emitDelegation(eventName, event);
    event.propagationPath.push(parent);
    parent = parent.getParent();
  }
}
var identityMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function getMatrixByAngle(point2, angle2, matrix) {
  if (matrix === void 0) {
    matrix = identityMatrix;
  }
  if (!angle2) {
    return null;
  }
  var m = transform$7(matrix, [
    ["t", -point2.x, -point2.y],
    ["r", angle2],
    ["t", point2.x, point2.y]
  ]);
  return m;
}
function getMatrixByTranslate(point2, currentMatrix) {
  if (!point2.x && !point2.y) {
    return null;
  }
  return transform$7(currentMatrix || identityMatrix, [["t", point2.x, point2.y]]);
}
function getAngleByMatrix(matrix) {
  var xVector = [1, 0, 0];
  var out = [0, 0, 0];
  transformMat3(out, xVector, matrix);
  return Math.atan2(out[1], out[0]);
}
function multiplyVec2(matrix, v) {
  var out = [0, 0];
  transformMat3$1(out, v, matrix);
  return out;
}
function applyMatrix2BBox(matrix, bbox) {
  var topLeft = multiplyVec2(matrix, [bbox.minX, bbox.minY]);
  var topRight = multiplyVec2(matrix, [bbox.maxX, bbox.minY]);
  var bottomLeft = multiplyVec2(matrix, [bbox.minX, bbox.maxY]);
  var bottomRight = multiplyVec2(matrix, [bbox.maxX, bbox.maxY]);
  var minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
  var maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
  var minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
  var maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
  return {
    x: minX,
    y: minY,
    minX,
    minY,
    maxX,
    maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function applyRotate(shape, rotate2, x, y) {
  if (rotate2) {
    var matrix = getMatrixByAngle({ x, y }, rotate2, shape.getMatrix());
    shape.setMatrix(matrix);
  }
}
function applyTranslate(shape, x, y) {
  var translateMatrix = getMatrixByTranslate({ x, y });
  shape.attr("matrix", translateMatrix);
}
function formatPadding(padding2) {
  var top = 0;
  var left2 = 0;
  var right2 = 0;
  var bottom = 0;
  if (isNumber$1(padding2)) {
    top = left2 = right2 = bottom = padding2;
  } else if (isArray$1(padding2)) {
    top = padding2[0];
    right2 = !isNil(padding2[1]) ? padding2[1] : padding2[0];
    bottom = !isNil(padding2[2]) ? padding2[2] : padding2[0];
    left2 = !isNil(padding2[3]) ? padding2[3] : right2;
  }
  return [top, right2, bottom, left2];
}
function clearDom(container) {
  var children = container.childNodes;
  var length2 = children.length;
  for (var i = length2 - 1; i >= 0; i--) {
    container.removeChild(children[i]);
  }
}
function hasClass(elements, cName) {
  return !!elements.className.match(new RegExp("(\\s|^)" + cName + "(\\s|$)"));
}
function regionToBBox(region) {
  var start = region.start, end = region.end;
  var minX = Math.min(start.x, end.x);
  var minY = Math.min(start.y, end.y);
  var maxX = Math.max(start.x, end.x);
  var maxY = Math.max(start.y, end.y);
  return {
    x: minX,
    y: minY,
    minX,
    minY,
    maxX,
    maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function pointsToBBox(points) {
  var xs = points.map(function(point2) {
    return point2.x;
  });
  var ys = points.map(function(point2) {
    return point2.y;
  });
  var minX = Math.min.apply(Math, xs);
  var minY = Math.min.apply(Math, ys);
  var maxX = Math.max.apply(Math, xs);
  var maxY = Math.max.apply(Math, ys);
  return {
    x: minX,
    y: minY,
    minX,
    minY,
    maxX,
    maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function createBBox(x, y, width, height) {
  var maxX = x + width;
  var maxY = y + height;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    maxX: isNaN(maxX) ? 0 : maxX,
    maxY: isNaN(maxY) ? 0 : maxY
  };
}
function getValueByPercent(min2, max2, percent2) {
  return (1 - percent2) * min2 + max2 * percent2;
}
function getCirclePoint(center2, radius, angle2) {
  return {
    x: center2.x + Math.cos(angle2) * radius,
    y: center2.y + Math.sin(angle2) * radius
  };
}
function distance$4(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
var near = function(x, y, e) {
  if (e === void 0) {
    e = Math.pow(Number.EPSILON, 0.5);
  }
  return [x, y].includes(Infinity) ? Math.abs(x) === Math.abs(y) : Math.abs(x - y) < e;
};
function intersectBBox(box1, box2) {
  var minX = Math.max(box1.minX, box2.minX);
  var minY = Math.max(box1.minY, box2.minY);
  var maxX = Math.min(box1.maxX, box2.maxX);
  var maxY = Math.min(box1.maxY, box2.maxY);
  return createBBox(minX, minY, maxX - minX, maxY - minY);
}
function getBBoxWithClip(element) {
  var clipShape = element.getClip();
  var clipBBox = clipShape && clipShape.getBBox();
  var bbox;
  if (!element.isGroup()) {
    bbox = element.getBBox();
  } else {
    var minX_1 = Infinity;
    var maxX_1 = -Infinity;
    var minY_1 = Infinity;
    var maxY_1 = -Infinity;
    var children = element.getChildren();
    if (children.length > 0) {
      each$1(children, function(child) {
        if (child.get("visible")) {
          if (child.isGroup() && child.get("children").length === 0) {
            return true;
          }
          var box2 = getBBoxWithClip(child);
          var leftTop = child.applyToMatrix([box2.minX, box2.minY, 1]);
          var leftBottom = child.applyToMatrix([box2.minX, box2.maxY, 1]);
          var rightTop = child.applyToMatrix([box2.maxX, box2.minY, 1]);
          var rightBottom = child.applyToMatrix([box2.maxX, box2.maxY, 1]);
          var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          if (boxMinX < minX_1) {
            minX_1 = boxMinX;
          }
          if (boxMaxX > maxX_1) {
            maxX_1 = boxMaxX;
          }
          if (boxMinY < minY_1) {
            minY_1 = boxMinY;
          }
          if (boxMaxY > maxY_1) {
            maxY_1 = boxMaxY;
          }
        }
      });
    } else {
      minX_1 = 0;
      maxX_1 = 0;
      minY_1 = 0;
      maxY_1 = 0;
    }
    bbox = createBBox(minX_1, minY_1, maxX_1 - minX_1, maxY_1 - minY_1);
  }
  if (clipBBox) {
    return intersectBBox(bbox, clipBBox);
  } else {
    return bbox;
  }
}
function updateClip(element, newElement) {
  if (!element.getClip() && !newElement.getClip()) {
    return;
  }
  var newClipShape = newElement.getClip();
  if (!newClipShape) {
    element.setClip(null);
    return;
  }
  var clipCfg = {
    type: newClipShape.get("type"),
    attrs: newClipShape.attr()
  };
  element.setClip(clipCfg);
}
function toPx(number) {
  return number + "px";
}
function getTextPoint(start, end, position, offset) {
  var lineLength = distance$4(start, end);
  var offsetPercent = offset / lineLength;
  var percent2 = 0;
  if (position === "start") {
    percent2 = 0 - offsetPercent;
  } else if (position === "end") {
    percent2 = 1 + offsetPercent;
  }
  return {
    x: getValueByPercent(start.x, end.x, percent2),
    y: getValueByPercent(start.y, end.y, percent2)
  };
}
var LOCATION_FIELD_MAP = {
  none: [],
  point: ["x", "y"],
  region: ["start", "end"],
  points: ["points"],
  circle: ["center", "radius", "startAngle", "endAngle"]
};
var Component = function(_super) {
  __extends$2(Component2, _super);
  function Component2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.initCfg();
    return _this;
  }
  Component2.prototype.getDefaultCfg = function() {
    return {
      id: "",
      name: "",
      type: "",
      locationType: "none",
      offsetX: 0,
      offsetY: 0,
      animate: false,
      capture: true,
      updateAutoRender: false,
      animateOption: {
        appear: null,
        update: {
          duration: 400,
          easing: "easeQuadInOut"
        },
        enter: {
          duration: 400,
          easing: "easeQuadInOut"
        },
        leave: {
          duration: 350,
          easing: "easeQuadIn"
        }
      },
      events: null,
      defaultCfg: {},
      visible: true
    };
  };
  Component2.prototype.clear = function() {
  };
  Component2.prototype.update = function(cfg) {
    var _this = this;
    var defaultCfg = this.get("defaultCfg");
    each$1(cfg, function(value2, name) {
      var originCfg = _this.get(name);
      var newCfg = value2;
      if (originCfg !== value2) {
        if (isObject(value2) && defaultCfg[name]) {
          newCfg = deepMix({}, defaultCfg[name], value2);
        }
        _this.set(name, newCfg);
      }
    });
    this.updateInner(cfg);
    this.afterUpdate(cfg);
  };
  Component2.prototype.updateInner = function(cfg) {
  };
  Component2.prototype.afterUpdate = function(cfg) {
    if (has(cfg, "visible")) {
      if (cfg.visible) {
        this.show();
      } else {
        this.hide();
      }
    }
    if (has(cfg, "capture")) {
      this.setCapture(cfg.capture);
    }
  };
  Component2.prototype.getLayoutBBox = function() {
    return this.getBBox();
  };
  Component2.prototype.getLocationType = function() {
    return this.get("locationType");
  };
  Component2.prototype.getOffset = function() {
    return {
      offsetX: this.get("offsetX"),
      offsetY: this.get("offsetY")
    };
  };
  Component2.prototype.setOffset = function(offsetX, offsetY) {
    this.update({
      offsetX,
      offsetY
    });
  };
  Component2.prototype.setLocation = function(cfg) {
    var location = __assign$1({}, cfg);
    this.update(location);
  };
  Component2.prototype.getLocation = function() {
    var _this = this;
    var location = {};
    var locationType = this.get("locationType");
    var fields = LOCATION_FIELD_MAP[locationType];
    each$1(fields, function(field2) {
      location[field2] = _this.get(field2);
    });
    return location;
  };
  Component2.prototype.isList = function() {
    return false;
  };
  Component2.prototype.isSlider = function() {
    return false;
  };
  Component2.prototype.init = function() {
  };
  Component2.prototype.initCfg = function() {
    var _this = this;
    var defaultCfg = this.get("defaultCfg");
    each$1(defaultCfg, function(value2, name) {
      var cfg = _this.get(name);
      if (isObject(cfg)) {
        var newCfg = deepMix({}, value2, cfg);
        _this.set(name, newCfg);
      }
    });
  };
  return Component2;
}(Base);
var STATUS_UPDATE = "update_status";
var COPY_PROPERTIES = ["visible", "tip", "delegateObject"];
var COPY_PROPERTIES_EXCLUDES = ["container", "group", "shapesMap", "isRegister", "isUpdating", "destroyed"];
var GroupComponent = function(_super) {
  __extends$2(GroupComponent2, _super);
  function GroupComponent2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GroupComponent2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), {
      container: null,
      shapesMap: {},
      group: null,
      capture: true,
      isRegister: false,
      isUpdating: false,
      isInit: true
    });
  };
  GroupComponent2.prototype.remove = function() {
    this.clear();
    var group2 = this.get("group");
    group2.remove();
  };
  GroupComponent2.prototype.clear = function() {
    var group2 = this.get("group");
    group2.clear();
    this.set("shapesMap", {});
    this.clearOffScreenCache();
    this.set("isInit", true);
  };
  GroupComponent2.prototype.getChildComponentById = function(id) {
    var group2 = this.getElementById(id);
    var inst = group2 && group2.get("component");
    return inst;
  };
  GroupComponent2.prototype.getElementById = function(id) {
    return this.get("shapesMap")[id];
  };
  GroupComponent2.prototype.getElementByLocalId = function(localId) {
    var id = this.getElementId(localId);
    return this.getElementById(id);
  };
  GroupComponent2.prototype.getElementsByName = function(name) {
    var rst = [];
    each$1(this.get("shapesMap"), function(elem) {
      if (elem.get("name") === name) {
        rst.push(elem);
      }
    });
    return rst;
  };
  GroupComponent2.prototype.getContainer = function() {
    return this.get("container");
  };
  GroupComponent2.prototype.updateInner = function(cfg) {
    this.offScreenRender();
    if (this.get("updateAutoRender")) {
      this.render();
    }
  };
  GroupComponent2.prototype.render = function() {
    var offScreenGroup = this.get("offScreenGroup");
    if (!offScreenGroup) {
      offScreenGroup = this.offScreenRender();
    }
    var group2 = this.get("group");
    this.updateElements(offScreenGroup, group2);
    this.deleteElements();
    this.applyOffset();
    if (!this.get("eventInitted")) {
      this.initEvent();
      this.set("eventInitted", true);
    }
    this.set("isInit", false);
  };
  GroupComponent2.prototype.show = function() {
    var group2 = this.get("group");
    group2.show();
    this.set("visible", true);
  };
  GroupComponent2.prototype.hide = function() {
    var group2 = this.get("group");
    group2.hide();
    this.set("visible", false);
  };
  GroupComponent2.prototype.setCapture = function(capture) {
    var group2 = this.get("group");
    group2.set("capture", capture);
    this.set("capture", capture);
  };
  GroupComponent2.prototype.destroy = function() {
    this.removeEvent();
    this.remove();
    _super.prototype.destroy.call(this);
  };
  GroupComponent2.prototype.getBBox = function() {
    return this.get("group").getCanvasBBox();
  };
  GroupComponent2.prototype.getLayoutBBox = function() {
    var group2 = this.get("group");
    var bbox = this.getInnerLayoutBBox();
    var matrix = group2.getTotalMatrix();
    if (matrix) {
      bbox = applyMatrix2BBox(matrix, bbox);
    }
    return bbox;
  };
  GroupComponent2.prototype.on = function(evt, callback, once) {
    var group2 = this.get("group");
    group2.on(evt, callback, once);
    return this;
  };
  GroupComponent2.prototype.off = function(evt, callback) {
    var group2 = this.get("group");
    group2 && group2.off(evt, callback);
    return this;
  };
  GroupComponent2.prototype.emit = function(eventName, eventObject) {
    var group2 = this.get("group");
    group2.emit(eventName, eventObject);
  };
  GroupComponent2.prototype.init = function() {
    _super.prototype.init.call(this);
    if (!this.get("group")) {
      this.initGroup();
    }
    this.offScreenRender();
  };
  GroupComponent2.prototype.getInnerLayoutBBox = function() {
    return this.get("offScreenBBox") || this.get("group").getBBox();
  };
  GroupComponent2.prototype.delegateEmit = function(eventName, eventObject) {
    var group2 = this.get("group");
    eventObject.target = group2;
    group2.emit(eventName, eventObject);
    propagationDelegate(group2, eventName, eventObject);
  };
  GroupComponent2.prototype.createOffScreenGroup = function() {
    var group2 = this.get("group");
    var GroupClass = group2.getGroupBase();
    var newGroup = new GroupClass({
      delegateObject: this.getDelegateObject()
    });
    return newGroup;
  };
  GroupComponent2.prototype.applyOffset = function() {
    var offsetX = this.get("offsetX");
    var offsetY = this.get("offsetY");
    this.moveElementTo(this.get("group"), {
      x: offsetX,
      y: offsetY
    });
  };
  GroupComponent2.prototype.initGroup = function() {
    var container = this.get("container");
    this.set("group", container.addGroup({
      id: this.get("id"),
      name: this.get("name"),
      capture: this.get("capture"),
      visible: this.get("visible"),
      isComponent: true,
      component: this,
      delegateObject: this.getDelegateObject()
    }));
  };
  GroupComponent2.prototype.offScreenRender = function() {
    this.clearOffScreenCache();
    var offScreenGroup = this.createOffScreenGroup();
    this.renderInner(offScreenGroup);
    this.set("offScreenGroup", offScreenGroup);
    this.set("offScreenBBox", getBBoxWithClip(offScreenGroup));
    return offScreenGroup;
  };
  GroupComponent2.prototype.addGroup = function(parent, cfg) {
    this.appendDelegateObject(parent, cfg);
    var group2 = parent.addGroup(cfg);
    if (this.get("isRegister")) {
      this.registerElement(group2);
    }
    return group2;
  };
  GroupComponent2.prototype.addShape = function(parent, cfg) {
    this.appendDelegateObject(parent, cfg);
    var shape = parent.addShape(cfg);
    if (this.get("isRegister")) {
      this.registerElement(shape);
    }
    return shape;
  };
  GroupComponent2.prototype.addComponent = function(parent, cfg) {
    var id = cfg.id, Ctor = cfg.component, restCfg = __rest(cfg, ["id", "component"]);
    var inst = new Ctor(__assign$1(__assign$1({}, restCfg), { id, container: parent, updateAutoRender: this.get("updateAutoRender") }));
    inst.init();
    inst.render();
    if (this.get("isRegister")) {
      this.registerElement(inst.get("group"));
    }
    return inst;
  };
  GroupComponent2.prototype.initEvent = function() {
  };
  GroupComponent2.prototype.removeEvent = function() {
    var group2 = this.get("group");
    group2.off();
  };
  GroupComponent2.prototype.getElementId = function(localId) {
    var id = this.get("id");
    var name = this.get("name");
    return id + "-" + name + "-" + localId;
  };
  GroupComponent2.prototype.registerElement = function(element) {
    var id = element.get("id");
    this.get("shapesMap")[id] = element;
  };
  GroupComponent2.prototype.unregisterElement = function(element) {
    var id = element.get("id");
    delete this.get("shapesMap")[id];
  };
  GroupComponent2.prototype.moveElementTo = function(element, point2) {
    var matrix = getMatrixByTranslate(point2);
    element.attr("matrix", matrix);
  };
  GroupComponent2.prototype.addAnimation = function(elmentName, newElement, animateCfg) {
    var originOpacity = newElement.attr("opacity");
    if (isNil(originOpacity)) {
      originOpacity = 1;
    }
    newElement.attr("opacity", 0);
    newElement.animate({ opacity: originOpacity }, animateCfg);
  };
  GroupComponent2.prototype.removeAnimation = function(elementName, originElement, animateCfg) {
    originElement.animate({ opacity: 0 }, animateCfg);
  };
  GroupComponent2.prototype.updateAnimation = function(elementName, originElement, newAttrs, animateCfg) {
    originElement.animate(newAttrs, animateCfg);
  };
  GroupComponent2.prototype.updateElements = function(newGroup, originGroup) {
    var _this = this;
    var animate = this.get("animate");
    var animateOption = this.get("animateOption");
    var children = newGroup.getChildren().slice(0);
    var preElement;
    each$1(children, function(element) {
      var elementId = element.get("id");
      var originElement = _this.getElementById(elementId);
      var elementName = element.get("name");
      if (originElement) {
        if (element.get("isComponent")) {
          var childComponent = element.get("component");
          var origChildComponent = originElement.get("component");
          var newCfg = pick$1(childComponent.cfg, difference(keys(childComponent.cfg), COPY_PROPERTIES_EXCLUDES));
          origChildComponent.update(newCfg);
          originElement.set(STATUS_UPDATE, "update");
        } else {
          var replaceAttrs = _this.getReplaceAttrs(originElement, element);
          if (animate && animateOption.update) {
            _this.updateAnimation(elementName, originElement, replaceAttrs, animateOption.update);
          } else {
            originElement.attr(replaceAttrs);
          }
          if (element.isGroup()) {
            _this.updateElements(element, originElement);
          }
          each$1(COPY_PROPERTIES, function(name) {
            originElement.set(name, element.get(name));
          });
          updateClip(originElement, element);
          preElement = originElement;
          originElement.set(STATUS_UPDATE, "update");
        }
      } else {
        originGroup.add(element);
        var siblings = originGroup.getChildren();
        siblings.splice(siblings.length - 1, 1);
        if (preElement) {
          var index2 = siblings.indexOf(preElement);
          siblings.splice(index2 + 1, 0, element);
        } else {
          siblings.unshift(element);
        }
        _this.registerElement(element);
        element.set(STATUS_UPDATE, "add");
        if (element.get("isComponent")) {
          var childComponent = element.get("component");
          childComponent.set("container", originGroup);
        } else if (element.isGroup()) {
          _this.registerNewGroup(element);
        }
        preElement = element;
        if (animate) {
          var animateCfg = _this.get("isInit") ? animateOption.appear : animateOption.enter;
          if (animateCfg) {
            _this.addAnimation(elementName, element, animateCfg);
          }
        }
      }
    });
  };
  GroupComponent2.prototype.clearUpdateStatus = function(group2) {
    var children = group2.getChildren();
    each$1(children, function(el) {
      el.set(STATUS_UPDATE, null);
    });
  };
  GroupComponent2.prototype.clearOffScreenCache = function() {
    var offScreenGroup = this.get("offScreenGroup");
    if (offScreenGroup) {
      offScreenGroup.destroy();
    }
    this.set("offScreenGroup", null);
    this.set("offScreenBBox", null);
  };
  GroupComponent2.prototype.getDelegateObject = function() {
    var _a2;
    var name = this.get("name");
    var delegateObject = (_a2 = {}, _a2[name] = this, _a2.component = this, _a2);
    return delegateObject;
  };
  GroupComponent2.prototype.appendDelegateObject = function(parent, cfg) {
    var parentObject = parent.get("delegateObject");
    if (!cfg.delegateObject) {
      cfg.delegateObject = {};
    }
    mix(cfg.delegateObject, parentObject);
  };
  GroupComponent2.prototype.getReplaceAttrs = function(originElement, newElement) {
    var originAttrs = originElement.attr();
    var newAttrs = newElement.attr();
    each$1(originAttrs, function(v, k) {
      if (newAttrs[k] === void 0) {
        newAttrs[k] = void 0;
      }
    });
    return newAttrs;
  };
  GroupComponent2.prototype.registerNewGroup = function(group2) {
    var _this = this;
    var children = group2.getChildren();
    each$1(children, function(element) {
      _this.registerElement(element);
      element.set(STATUS_UPDATE, "add");
      if (element.isGroup()) {
        _this.registerNewGroup(element);
      }
    });
  };
  GroupComponent2.prototype.deleteElements = function() {
    var _this = this;
    var shapesMap = this.get("shapesMap");
    var deleteArray = [];
    each$1(shapesMap, function(element, id) {
      if (!element.get(STATUS_UPDATE) || element.destroyed) {
        deleteArray.push([id, element]);
      } else {
        element.set(STATUS_UPDATE, null);
      }
    });
    var animate = this.get("animate");
    var animateOption = this.get("animateOption");
    each$1(deleteArray, function(item) {
      var id = item[0], element = item[1];
      if (!element.destroyed) {
        var elementName = element.get("name");
        if (animate && animateOption.leave) {
          var callbackAnimCfg = mix({
            callback: function() {
              _this.removeElement(element);
            }
          }, animateOption.leave);
          _this.removeAnimation(elementName, element, callbackAnimCfg);
        } else {
          _this.removeElement(element);
        }
      }
      delete shapesMap[id];
    });
  };
  GroupComponent2.prototype.removeElement = function(element) {
    if (element.get("isGroup")) {
      var component2 = element.get("component");
      if (component2) {
        component2.destroy();
      }
    }
    element.remove();
  };
  return GroupComponent2;
}(Component);
var ELLIPSIS_CODE$1 = "\u2026";
function strLen(str) {
  var len = 0;
  for (var i = 0; i < str.length; i++) {
    len += charAtLength(str, i);
  }
  return len;
}
function charAtLength(str, i) {
  if (str.charCodeAt(i) > 0 && str.charCodeAt(i) < 128) {
    return 1;
  } else {
    return 2;
  }
}
function ellipsisString(str, reseveLength, position) {
  if (position === void 0) {
    position = "tail";
  }
  var count = str.length;
  var rst = "";
  if (position === "tail") {
    for (var i = 0, index2 = 0; i < reseveLength; ) {
      var charLength = charAtLength(str, index2);
      if (i + charLength <= reseveLength) {
        rst += str[index2];
        i += charAtLength(str, index2);
        index2++;
      } else {
        break;
      }
    }
    rst += ELLIPSIS_CODE$1;
  } else if (position === "head") {
    for (var i = 0, index2 = count - 1; i < reseveLength; ) {
      var charLength = charAtLength(str, index2);
      if (i + charLength <= reseveLength) {
        rst += str[index2];
        i += charAtLength(str, index2);
        index2--;
      } else {
        break;
      }
    }
    rst = ELLIPSIS_CODE$1 + rst;
  } else {
    var startStr = "";
    var endStr = "";
    for (var i = 0, startIndex = 0, endIndex = count - 1; i < reseveLength; ) {
      var startCodeLen = charAtLength(str, startIndex);
      var hasAdd = false;
      if (startCodeLen + i <= reseveLength) {
        startStr += str[startIndex];
        startIndex++;
        i += startCodeLen;
        hasAdd = true;
      }
      var endCodeLen = charAtLength(str, endIndex);
      if (endCodeLen + i <= reseveLength) {
        endStr = str[endIndex] + endStr;
        i += endCodeLen;
        endIndex--;
        hasAdd = true;
      }
      if (!hasAdd) {
        break;
      }
    }
    rst = startStr + ELLIPSIS_CODE$1 + endStr;
  }
  return rst;
}
var ELLIPSIS_CODE = "\u2026";
var ELLIPSIS_CODE_LENGTH = 2;
var OPTIMIZE_THRESHOLD = 400;
function getMaxLabelWidthOptimized(labels) {
  var texts = labels.map(function(label2) {
    var text2 = label2.attr("text");
    return isNil(text2) ? "" : "" + text2;
  });
  var maxLen = 0;
  var maxIdx = 0;
  for (var i = 0; i < texts.length; i += 1) {
    var len = 0;
    for (var j = 0; j <= texts[i].length; j += 1) {
      var code = texts[i].charCodeAt(j);
      if (code >= 19968 && code <= 40869) {
        len += 2;
      } else {
        len += 1;
      }
    }
    if (len > maxLen) {
      maxLen = len;
      maxIdx = i;
    }
  }
  return labels[maxIdx].getBBox().width;
}
function getMaxLabelWidth(labels) {
  if (labels.length > OPTIMIZE_THRESHOLD) {
    return getMaxLabelWidthOptimized(labels);
  }
  var max2 = 0;
  each$1(labels, function(label2) {
    var bbox = label2.getBBox();
    var width = bbox.width;
    if (max2 < width) {
      max2 = width;
    }
  });
  return max2;
}
function getLabelLength(isVertical2, label2) {
  var bbox = label2.getCanvasBBox();
  return isVertical2 ? bbox.width : bbox.height;
}
function ellipsisLabel(isVertical2, label2, limitLength, position) {
  var _a2;
  if (position === void 0) {
    position = "tail";
  }
  var text2 = (_a2 = label2.attr("text")) !== null && _a2 !== void 0 ? _a2 : "";
  if (position === "tail") {
    var font = pick$1(label2.attr(), ["fontSize", "fontFamily", "fontWeight", "fontStyle", "fontVariant"]);
    var ellipsisText = getEllipsisText$1(text2, limitLength, font, "\u2026");
    if (text2 !== ellipsisText) {
      label2.attr("text", ellipsisText);
      label2.set("tip", text2);
      return true;
    }
    label2.set("tip", null);
    return false;
  }
  var labelLength = getLabelLength(isVertical2, label2);
  var codeLength = strLen(text2);
  var ellipsisFlag = false;
  if (limitLength < labelLength) {
    var reserveLength = Math.floor(limitLength / labelLength * codeLength) - ELLIPSIS_CODE_LENGTH;
    var newText = void 0;
    if (reserveLength >= 0) {
      newText = ellipsisString(text2, reserveLength, position);
    } else {
      newText = ELLIPSIS_CODE;
    }
    if (newText) {
      label2.attr("text", newText);
      ellipsisFlag = true;
    }
  }
  if (ellipsisFlag) {
    label2.set("tip", text2);
  } else {
    label2.set("tip", null);
  }
  return ellipsisFlag;
}
function renderTag$1(container, tagCfg) {
  var x = tagCfg.x, y = tagCfg.y, content = tagCfg.content, style = tagCfg.style, id = tagCfg.id, name = tagCfg.name, rotate2 = tagCfg.rotate, maxLength = tagCfg.maxLength, autoEllipsis2 = tagCfg.autoEllipsis, isVertical2 = tagCfg.isVertical, ellipsisPosition = tagCfg.ellipsisPosition, background = tagCfg.background;
  var tagGroup = container.addGroup({
    id: id + "-group",
    name: name + "-group",
    attrs: {
      x,
      y
    }
  });
  var text2 = tagGroup.addShape({
    type: "text",
    id,
    name,
    attrs: __assign$1({ x: 0, y: 0, text: content }, style)
  });
  var padding2 = formatPadding(get(background, "padding", 0));
  if (maxLength && autoEllipsis2) {
    var maxTextLength = maxLength - (padding2[1] + padding2[3]);
    ellipsisLabel(!isVertical2, text2, maxTextLength, ellipsisPosition);
  }
  if (background) {
    var backgroundStyle = get(background, "style", {});
    var _a2 = text2.getCanvasBBox(), minX = _a2.minX, minY = _a2.minY, width = _a2.width, height = _a2.height;
    var tagBg = tagGroup.addShape("rect", {
      id: id + "-bg",
      name: id + "-bg",
      attrs: __assign$1({ x: minX - padding2[3], y: minY - padding2[0], width: width + padding2[1] + padding2[3], height: height + padding2[0] + padding2[2] }, backgroundStyle)
    });
    tagBg.toBack();
  }
  applyTranslate(tagGroup, x, y);
  applyRotate(tagGroup, rotate2, x, y);
}
var Theme = {
  fontFamily: '\n  "-apple-system", BlinkMacSystemFont, "Segoe UI", Roboto,"Helvetica Neue",\n  Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei",\n  SimSun, "sans-serif"',
  textColor: "#2C3542",
  activeTextColor: "#333333",
  uncheckedColor: "#D8D8D8",
  lineColor: "#416180",
  regionColor: "#CCD7EB",
  verticalAxisRotate: -Math.PI / 4,
  horizontalAxisRotate: Math.PI / 4
};
var LineAnnotation = function(_super) {
  __extends$2(LineAnnotation2, _super);
  function LineAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LineAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "line", locationType: "region", start: null, end: null, style: {}, text: null, defaultCfg: {
      style: {
        fill: Theme.textColor,
        fontSize: 12,
        textAlign: "center",
        textBaseline: "bottom",
        fontFamily: Theme.fontFamily
      },
      text: {
        position: "center",
        autoRotate: true,
        content: null,
        offsetX: 0,
        offsetY: 0,
        style: {
          stroke: Theme.lineColor,
          lineWidth: 1
        }
      }
    } });
  };
  LineAnnotation2.prototype.renderInner = function(group2) {
    this.renderLine(group2);
    if (this.get("text")) {
      this.renderLabel(group2);
    }
  };
  LineAnnotation2.prototype.renderLine = function(group2) {
    var start = this.get("start");
    var end = this.get("end");
    var style = this.get("style");
    this.addShape(group2, {
      type: "line",
      id: this.getElementId("line"),
      name: "annotation-line",
      attrs: __assign$1({ x1: start.x, y1: start.y, x2: end.x, y2: end.y }, style)
    });
  };
  LineAnnotation2.prototype.getLabelPoint = function(start, end, position) {
    var percent2;
    if (position === "start") {
      percent2 = 0;
    } else if (position === "center") {
      percent2 = 0.5;
    } else if (isString(position) && position.indexOf("%") !== -1) {
      percent2 = parseInt(position, 10) / 100;
    } else if (isNumber$1(position)) {
      percent2 = position;
    } else {
      percent2 = 1;
    }
    if (percent2 > 1 || percent2 < 0) {
      percent2 = 1;
    }
    return {
      x: getValueByPercent(start.x, end.x, percent2),
      y: getValueByPercent(start.y, end.y, percent2)
    };
  };
  LineAnnotation2.prototype.renderLabel = function(group2) {
    var text2 = this.get("text");
    var start = this.get("start");
    var end = this.get("end");
    var position = text2.position, content = text2.content, style = text2.style, offsetX = text2.offsetX, offsetY = text2.offsetY, autoRotate2 = text2.autoRotate, maxLength = text2.maxLength, autoEllipsis2 = text2.autoEllipsis, ellipsisPosition = text2.ellipsisPosition, background = text2.background, _a2 = text2.isVertical, isVertical2 = _a2 === void 0 ? false : _a2;
    var point2 = this.getLabelPoint(start, end, position);
    var x = point2.x + offsetX;
    var y = point2.y + offsetY;
    var cfg = {
      id: this.getElementId("line-text"),
      name: "annotation-line-text",
      x,
      y,
      content,
      style,
      maxLength,
      autoEllipsis: autoEllipsis2,
      ellipsisPosition,
      background,
      isVertical: isVertical2
    };
    if (autoRotate2) {
      var vector = [end.x - start.x, end.y - start.y];
      cfg.rotate = Math.atan2(vector[1], vector[0]);
    }
    renderTag$1(group2, cfg);
  };
  return LineAnnotation2;
}(GroupComponent);
var TextAnnotation = function(_super) {
  __extends$2(TextAnnotation2, _super);
  function TextAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TextAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "text", locationType: "point", x: 0, y: 0, content: "", rotate: null, style: {}, background: null, maxLength: null, autoEllipsis: true, isVertical: false, ellipsisPosition: "tail", defaultCfg: {
      style: {
        fill: Theme.textColor,
        fontSize: 12,
        textAlign: "center",
        textBaseline: "middle",
        fontFamily: Theme.fontFamily
      }
    } });
  };
  TextAnnotation2.prototype.setLocation = function(location) {
    this.set("x", location.x);
    this.set("y", location.y);
    this.resetLocation();
  };
  TextAnnotation2.prototype.renderInner = function(group2) {
    var _a2 = this.getLocation(), x = _a2.x, y = _a2.y;
    var content = this.get("content");
    var style = this.get("style");
    var id = this.getElementId("text");
    var name = this.get("name") + "-text";
    var maxLength = this.get("maxLength");
    var autoEllipsis2 = this.get("autoEllipsis");
    var isVertical2 = this.get("isVertical");
    var ellipsisPosition = this.get("ellipsisPosition");
    var background = this.get("background");
    var rotate2 = this.get("rotate");
    var cfg = {
      id,
      name,
      x,
      y,
      content,
      style,
      maxLength,
      autoEllipsis: autoEllipsis2,
      isVertical: isVertical2,
      ellipsisPosition,
      background,
      rotate: rotate2
    };
    renderTag$1(group2, cfg);
  };
  TextAnnotation2.prototype.resetLocation = function() {
    var textGroup = this.getElementByLocalId("text-group");
    if (textGroup) {
      var _a2 = this.getLocation(), x = _a2.x, y = _a2.y;
      var rotate2 = this.get("rotate");
      applyTranslate(textGroup, x, y);
      applyRotate(textGroup, rotate2, x, y);
    }
  };
  return TextAnnotation2;
}(GroupComponent);
var ArcAnnotation = function(_super) {
  __extends$2(ArcAnnotation2, _super);
  function ArcAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ArcAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "arc", locationType: "circle", center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2, style: {
      stroke: "#999",
      lineWidth: 1
    } });
  };
  ArcAnnotation2.prototype.renderInner = function(group2) {
    this.renderArc(group2);
  };
  ArcAnnotation2.prototype.getArcPath = function() {
    var _a2 = this.getLocation(), center2 = _a2.center, radius = _a2.radius, startAngle = _a2.startAngle, endAngle = _a2.endAngle;
    var startPoint = getCirclePoint(center2, radius, startAngle);
    var endPoint = getCirclePoint(center2, radius, endAngle);
    var largeFlag = endAngle - startAngle > Math.PI ? 1 : 0;
    var path2 = [["M", startPoint.x, startPoint.y]];
    if (endAngle - startAngle === Math.PI * 2) {
      var middlePoint = getCirclePoint(center2, radius, startAngle + Math.PI);
      path2.push(["A", radius, radius, 0, largeFlag, 1, middlePoint.x, middlePoint.y]);
      path2.push(["A", radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
    } else {
      path2.push(["A", radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
    }
    return path2;
  };
  ArcAnnotation2.prototype.renderArc = function(group2) {
    var path2 = this.getArcPath();
    var style = this.get("style");
    this.addShape(group2, {
      type: "path",
      id: this.getElementId("arc"),
      name: "annotation-arc",
      attrs: __assign$1({ path: path2 }, style)
    });
  };
  return ArcAnnotation2;
}(GroupComponent);
var RegionAnnotation = function(_super) {
  __extends$2(RegionAnnotation2, _super);
  function RegionAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RegionAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "region", locationType: "region", start: null, end: null, style: {}, defaultCfg: {
      style: {
        lineWidth: 0,
        fill: Theme.regionColor,
        opacity: 0.4
      }
    } });
  };
  RegionAnnotation2.prototype.renderInner = function(group2) {
    this.renderRegion(group2);
  };
  RegionAnnotation2.prototype.renderRegion = function(group2) {
    var start = this.get("start");
    var end = this.get("end");
    var style = this.get("style");
    var bbox = regionToBBox({ start, end });
    this.addShape(group2, {
      type: "rect",
      id: this.getElementId("region"),
      name: "annotation-region",
      attrs: __assign$1({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height }, style)
    });
  };
  return RegionAnnotation2;
}(GroupComponent);
var ImageAnnotation = function(_super) {
  __extends$2(ImageAnnotation2, _super);
  function ImageAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ImageAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "image", locationType: "region", start: null, end: null, src: null, style: {} });
  };
  ImageAnnotation2.prototype.renderInner = function(group2) {
    this.renderImage(group2);
  };
  ImageAnnotation2.prototype.getImageAttrs = function() {
    var start = this.get("start");
    var end = this.get("end");
    var style = this.get("style");
    var bbox = regionToBBox({ start, end });
    var src = this.get("src");
    return __assign$1({ x: bbox.x, y: bbox.y, img: src, width: bbox.width, height: bbox.height }, style);
  };
  ImageAnnotation2.prototype.renderImage = function(group2) {
    this.addShape(group2, {
      type: "image",
      id: this.getElementId("image"),
      name: "annotation-image",
      attrs: this.getImageAttrs()
    });
  };
  return ImageAnnotation2;
}(GroupComponent);
var DataMarkerAnnotation = function(_super) {
  __extends$2(DataMarkerAnnotation2, _super);
  function DataMarkerAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataMarkerAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "dataMarker", locationType: "point", x: 0, y: 0, point: {}, line: {}, text: {}, direction: "upward", autoAdjust: true, coordinateBBox: null, defaultCfg: {
      point: {
        display: true,
        style: {
          r: 3,
          fill: "#FFFFFF",
          stroke: "#1890FF",
          lineWidth: 2
        }
      },
      line: {
        display: true,
        length: 20,
        style: {
          stroke: Theme.lineColor,
          lineWidth: 1
        }
      },
      text: {
        content: "",
        display: true,
        style: {
          fill: Theme.textColor,
          opacity: 0.65,
          fontSize: 12,
          textAlign: "start",
          fontFamily: Theme.fontFamily
        }
      }
    } });
  };
  DataMarkerAnnotation2.prototype.renderInner = function(group2) {
    if (get(this.get("line"), "display")) {
      this.renderLine(group2);
    }
    if (get(this.get("text"), "display")) {
      this.renderText(group2);
    }
    if (get(this.get("point"), "display")) {
      this.renderPoint(group2);
    }
    if (this.get("autoAdjust")) {
      this.autoAdjust(group2);
    }
  };
  DataMarkerAnnotation2.prototype.applyOffset = function() {
    this.moveElementTo(this.get("group"), {
      x: this.get("x") + this.get("offsetX"),
      y: this.get("y") + this.get("offsetY")
    });
  };
  DataMarkerAnnotation2.prototype.renderPoint = function(group2) {
    var point2 = this.getShapeAttrs().point;
    this.addShape(group2, {
      type: "circle",
      id: this.getElementId("point"),
      name: "annotation-point",
      attrs: point2
    });
  };
  DataMarkerAnnotation2.prototype.renderLine = function(group2) {
    var line2 = this.getShapeAttrs().line;
    this.addShape(group2, {
      type: "path",
      id: this.getElementId("line"),
      name: "annotation-line",
      attrs: line2
    });
  };
  DataMarkerAnnotation2.prototype.renderText = function(group2) {
    var textAttrs = this.getShapeAttrs().text;
    var x = textAttrs.x, y = textAttrs.y, text2 = textAttrs.text, style = __rest(textAttrs, ["x", "y", "text"]);
    var _a2 = this.get("text"), background = _a2.background, maxLength = _a2.maxLength, autoEllipsis2 = _a2.autoEllipsis, isVertival = _a2.isVertival, ellipsisPosition = _a2.ellipsisPosition;
    var tagCfg = {
      x,
      y,
      id: this.getElementId("text"),
      name: "annotation-text",
      content: text2,
      style,
      background,
      maxLength,
      autoEllipsis: autoEllipsis2,
      isVertival,
      ellipsisPosition
    };
    renderTag$1(group2, tagCfg);
  };
  DataMarkerAnnotation2.prototype.autoAdjust = function(group2) {
    var direction2 = this.get("direction");
    var x = this.get("x");
    var y = this.get("y");
    var lineLength = get(this.get("line"), "length", 0);
    var coordinateBBox = this.get("coordinateBBox");
    var _a2 = group2.getBBox(), minX = _a2.minX, maxX = _a2.maxX, minY = _a2.minY, maxY = _a2.maxY;
    var textGroup = group2.findById(this.getElementId("text-group"));
    var textShape = group2.findById(this.getElementId("text"));
    var lineShape = group2.findById(this.getElementId("line"));
    if (!coordinateBBox) {
      return;
    }
    if (textGroup) {
      if (x + minX <= coordinateBBox.minX) {
        var overflow = coordinateBBox.minX - (x + minX);
        applyTranslate(textGroup, textGroup.attr("x") + overflow, textGroup.attr("y"));
      }
      if (x + maxX >= coordinateBBox.maxX) {
        var overflow = x + maxX - coordinateBBox.maxX;
        applyTranslate(textGroup, textGroup.attr("x") - overflow, textGroup.attr("y"));
      }
    }
    if (direction2 === "upward" && y + minY <= coordinateBBox.minY || direction2 !== "upward" && y + maxY >= coordinateBBox.maxY) {
      var textBaseline = void 0;
      var factor = void 0;
      if (direction2 === "upward" && y + minY <= coordinateBBox.minY) {
        textBaseline = "top";
        factor = 1;
      } else {
        textBaseline = "bottom";
        factor = -1;
      }
      textShape.attr("textBaseline", textBaseline);
      if (lineShape) {
        lineShape.attr("path", [
          ["M", 0, 0],
          ["L", 0, lineLength * factor]
        ]);
      }
      applyTranslate(textGroup, textGroup.attr("x"), (lineLength + 2) * factor);
    }
  };
  DataMarkerAnnotation2.prototype.getShapeAttrs = function() {
    var lineDisplay = get(this.get("line"), "display");
    var pointStyle = get(this.get("point"), "style", {});
    var lineStyle = get(this.get("line"), "style", {});
    var textStyle2 = get(this.get("text"), "style", {});
    var direction2 = this.get("direction");
    var lineLength = lineDisplay ? get(this.get("line"), "length", 0) : 0;
    var factor = direction2 === "upward" ? -1 : 1;
    return {
      point: __assign$1({ x: 0, y: 0 }, pointStyle),
      line: __assign$1({ path: [
        ["M", 0, 0],
        ["L", 0, lineLength * factor]
      ] }, lineStyle),
      text: __assign$1({ x: 0, y: (lineLength + 2) * factor, text: get(this.get("text"), "content", ""), textBaseline: direction2 === "upward" ? "bottom" : "top" }, textStyle2)
    };
  };
  return DataMarkerAnnotation2;
}(GroupComponent);
var DataRegionAnnotation = function(_super) {
  __extends$2(DataRegionAnnotation2, _super);
  function DataRegionAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataRegionAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "dataRegion", locationType: "points", points: [], lineLength: 0, region: {}, text: {}, defaultCfg: {
      region: {
        style: {
          lineWidth: 0,
          fill: Theme.regionColor,
          opacity: 0.4
        }
      },
      text: {
        content: "",
        style: {
          textAlign: "center",
          textBaseline: "bottom",
          fontSize: 12,
          fill: Theme.textColor,
          fontFamily: Theme.fontFamily
        }
      }
    } });
  };
  DataRegionAnnotation2.prototype.renderInner = function(group2) {
    var regionStyle = get(this.get("region"), "style", {});
    get(this.get("text"), "style", {});
    var lineLength = this.get("lineLength") || 0;
    var points = this.get("points");
    if (!points.length) {
      return;
    }
    var bbox = pointsToBBox(points);
    var path2 = [];
    path2.push(["M", points[0].x, bbox.minY - lineLength]);
    points.forEach(function(point2) {
      path2.push(["L", point2.x, point2.y]);
    });
    path2.push(["L", points[points.length - 1].x, points[points.length - 1].y - lineLength]);
    this.addShape(group2, {
      type: "path",
      id: this.getElementId("region"),
      name: "annotation-region",
      attrs: __assign$1({ path: path2 }, regionStyle)
    });
    var textCfg = __assign$1({ id: this.getElementId("text"), name: "annotation-text", x: (bbox.minX + bbox.maxX) / 2, y: bbox.minY - lineLength }, this.get("text"));
    renderTag$1(group2, textCfg);
  };
  return DataRegionAnnotation2;
}(GroupComponent);
var RegionFilterAnnotation = function(_super) {
  __extends$2(RegionFilterAnnotation2, _super);
  function RegionFilterAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RegionFilterAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "regionFilter", locationType: "region", start: null, end: null, color: null, shape: [] });
  };
  RegionFilterAnnotation2.prototype.renderInner = function(group2) {
    var _this = this;
    var start = this.get("start");
    var end = this.get("end");
    var layer = this.addGroup(group2, {
      id: this.getElementId("region-filter"),
      capture: false
    });
    each$1(this.get("shapes"), function(shape, shapeIdx) {
      var type = shape.get("type");
      var attrs = clone(shape.attr());
      _this.adjustShapeAttrs(attrs);
      _this.addShape(layer, {
        id: _this.getElementId("shape-" + type + "-" + shapeIdx),
        capture: false,
        type,
        attrs
      });
    });
    var clipBBox = regionToBBox({ start, end });
    layer.setClip({
      type: "rect",
      attrs: {
        x: clipBBox.minX,
        y: clipBBox.minY,
        width: clipBBox.width,
        height: clipBBox.height
      }
    });
  };
  RegionFilterAnnotation2.prototype.adjustShapeAttrs = function(attr) {
    var color2 = this.get("color");
    if (attr.fill) {
      attr.fill = attr.fillStyle = color2;
    }
    attr.stroke = attr.strokeStyle = color2;
  };
  return RegionFilterAnnotation2;
}(GroupComponent);
var ShapeAnnotation = function(_super) {
  __extends$2(ShapeAnnotation2, _super);
  function ShapeAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShapeAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "shape", draw: noop });
  };
  ShapeAnnotation2.prototype.renderInner = function(group2) {
    var render = this.get("render");
    if (isFunction(render)) {
      render(group2);
    }
  };
  return ShapeAnnotation2;
}(GroupComponent);
var HtmlComponent = function(_super) {
  __extends$2(HtmlComponent2, _super);
  function HtmlComponent2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HtmlComponent2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { container: null, containerTpl: "<div></div>", updateAutoRender: true, containerClassName: "", parent: null });
  };
  HtmlComponent2.prototype.getContainer = function() {
    return this.get("container");
  };
  HtmlComponent2.prototype.show = function() {
    var container = this.get("container");
    container.style.display = "";
    this.set("visible", true);
  };
  HtmlComponent2.prototype.hide = function() {
    var container = this.get("container");
    container.style.display = "none";
    this.set("visible", false);
  };
  HtmlComponent2.prototype.setCapture = function(capture) {
    var container = this.getContainer();
    var value2 = capture ? "auto" : "none";
    container.style.pointerEvents = value2;
    this.set("capture", capture);
  };
  HtmlComponent2.prototype.getBBox = function() {
    var container = this.getContainer();
    var x = parseFloat(container.style.left) || 0;
    var y = parseFloat(container.style.top) || 0;
    return createBBox(x, y, container.clientWidth, container.clientHeight);
  };
  HtmlComponent2.prototype.clear = function() {
    var container = this.get("container");
    clearDom(container);
  };
  HtmlComponent2.prototype.destroy = function() {
    this.removeEvent();
    this.removeDom();
    _super.prototype.destroy.call(this);
  };
  HtmlComponent2.prototype.init = function() {
    _super.prototype.init.call(this);
    this.initContainer();
    this.initDom();
    this.resetStyles();
    this.applyStyles();
    this.initEvent();
    this.initCapture();
    this.initVisible();
  };
  HtmlComponent2.prototype.initCapture = function() {
    this.setCapture(this.get("capture"));
  };
  HtmlComponent2.prototype.initVisible = function() {
    if (!this.get("visible")) {
      this.hide();
    } else {
      this.show();
    }
  };
  HtmlComponent2.prototype.initDom = function() {
  };
  HtmlComponent2.prototype.initContainer = function() {
    var container = this.get("container");
    if (isNil(container)) {
      container = this.createDom();
      var parent_1 = this.get("parent");
      if (isString(parent_1)) {
        parent_1 = document.getElementById(parent_1);
        this.set("parent", parent_1);
      }
      parent_1.appendChild(container);
      this.set("container", container);
    } else if (isString(container)) {
      container = document.getElementById(container);
      this.set("container", container);
    }
    if (!this.get("parent")) {
      this.set("parent", container.parentNode);
    }
  };
  HtmlComponent2.prototype.resetStyles = function() {
    var style = this.get("domStyles");
    var defaultStyles = this.get("defaultStyles");
    if (!style) {
      style = defaultStyles;
    } else {
      style = deepMix({}, defaultStyles, style);
    }
    this.set("domStyles", style);
  };
  HtmlComponent2.prototype.applyStyles = function() {
    var domStyles = this.get("domStyles");
    if (!domStyles) {
      return;
    }
    var container = this.getContainer();
    this.applyChildrenStyles(container, domStyles);
    var containerClassName = this.get("containerClassName");
    if (containerClassName && hasClass(container, containerClassName)) {
      var containerCss = domStyles[containerClassName];
      modifyCSS(container, containerCss);
    }
  };
  HtmlComponent2.prototype.applyChildrenStyles = function(element, styles) {
    each$1(styles, function(style, name) {
      var elements = element.getElementsByClassName(name);
      each$1(elements, function(el) {
        modifyCSS(el, style);
      });
    });
  };
  HtmlComponent2.prototype.applyStyle = function(cssName, dom) {
    var domStyles = this.get("domStyles");
    modifyCSS(dom, domStyles[cssName]);
  };
  HtmlComponent2.prototype.createDom = function() {
    var containerTpl = this.get("containerTpl");
    return createDom$1(containerTpl);
  };
  HtmlComponent2.prototype.initEvent = function() {
  };
  HtmlComponent2.prototype.removeDom = function() {
    var container = this.get("container");
    container && container.parentNode && container.parentNode.removeChild(container);
  };
  HtmlComponent2.prototype.removeEvent = function() {
  };
  HtmlComponent2.prototype.updateInner = function(cfg) {
    if (has(cfg, "domStyles")) {
      this.resetStyles();
      this.applyStyles();
    }
    this.resetPosition();
  };
  HtmlComponent2.prototype.resetPosition = function() {
  };
  return HtmlComponent2;
}(Component);
var HtmlAnnotation = function(_super) {
  __extends$2(HtmlAnnotation2, _super);
  function HtmlAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HtmlAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "html", locationType: "point", x: 0, y: 0, containerTpl: '<div class="g2-html-annotation"></div>', alignX: "left", alignY: "top", html: "", zIndex: 7 });
  };
  HtmlAnnotation2.prototype.render = function() {
    var container = this.getContainer();
    var html = this.get("html");
    clearDom(container);
    var rst = isFunction(html) ? html(container) : html;
    if (isElement(rst)) {
      container.appendChild(rst);
    } else if (isString(rst)) {
      container.appendChild(createDom$1(rst));
    }
    this.resetPosition();
  };
  HtmlAnnotation2.prototype.resetPosition = function() {
    var container = this.getContainer();
    var _a2 = this.getLocation(), x = _a2.x, y = _a2.y;
    var alignX = this.get("alignX");
    var alignY = this.get("alignY");
    var offsetX = this.get("offsetX");
    var offsetY = this.get("offsetY");
    var domWidth = getOuterWidth(container);
    var domHeight = getOuterHeight(container);
    var position = {
      x,
      y
    };
    if (alignX === "middle") {
      position.x -= Math.round(domWidth / 2);
    } else if (alignX === "right") {
      position.x -= Math.round(domWidth);
    }
    if (alignY === "middle") {
      position.y -= Math.round(domHeight / 2);
    } else if (alignY === "bottom") {
      position.y -= Math.round(domHeight);
    }
    if (offsetX) {
      position.x += offsetX;
    }
    if (offsetY) {
      position.y += offsetY;
    }
    modifyCSS(container, {
      position: "absolute",
      left: position.x + "px",
      top: position.y + "px",
      zIndex: this.get("zIndex")
    });
  };
  return HtmlAnnotation2;
}(HtmlComponent);
var AnnotationComponent = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  Line: LineAnnotation,
  Text: TextAnnotation,
  Arc: ArcAnnotation,
  Region: RegionAnnotation,
  Image: ImageAnnotation,
  DataMarker: DataMarkerAnnotation,
  DataRegion: DataRegionAnnotation,
  RegionFilter: RegionFilterAnnotation,
  Shape: ShapeAnnotation,
  Html: HtmlAnnotation
});
function getStatesStyle(item, elementName, stateStyles) {
  var styleName = elementName + "Style";
  var styles = null;
  each$1(stateStyles, function(v, state2) {
    if (item[state2] && v[styleName]) {
      if (!styles) {
        styles = {};
      }
      mix(styles, v[styleName]);
    }
  });
  return styles;
}
var AxisBase = function(_super) {
  __extends$2(AxisBase2, _super);
  function AxisBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AxisBase2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), {
      name: "axis",
      ticks: [],
      line: {},
      tickLine: {},
      subTickLine: null,
      title: null,
      label: {},
      verticalFactor: 1,
      verticalLimitLength: null,
      overlapOrder: ["autoRotate", "autoEllipsis", "autoHide"],
      tickStates: {},
      optimize: {},
      defaultCfg: {
        line: {
          style: {
            lineWidth: 1,
            stroke: Theme.lineColor
          }
        },
        tickLine: {
          style: {
            lineWidth: 1,
            stroke: Theme.lineColor
          },
          alignTick: true,
          length: 5,
          displayWithLabel: true
        },
        subTickLine: {
          style: {
            lineWidth: 1,
            stroke: Theme.lineColor
          },
          count: 4,
          length: 2
        },
        label: {
          autoRotate: true,
          autoHide: false,
          autoEllipsis: false,
          style: {
            fontSize: 12,
            fill: Theme.textColor,
            fontFamily: Theme.fontFamily,
            fontWeight: "normal"
          },
          offset: 10,
          offsetX: 0,
          offsetY: 0
        },
        title: {
          autoRotate: true,
          spacing: 5,
          position: "center",
          style: {
            fontSize: 12,
            fill: Theme.textColor,
            textBaseline: "middle",
            fontFamily: Theme.fontFamily,
            textAlign: "center"
          }
        },
        tickStates: {
          active: {
            labelStyle: {
              fontWeight: 500
            },
            tickLineStyle: {
              lineWidth: 2
            }
          },
          inactive: {
            labelStyle: {
              fill: Theme.uncheckedColor
            }
          }
        },
        optimize: {
          enable: true,
          threshold: 400
        }
      },
      theme: {}
    });
  };
  AxisBase2.prototype.renderInner = function(group2) {
    if (this.get("line")) {
      this.drawLine(group2);
    }
    this.drawTicks(group2);
    if (this.get("title")) {
      this.drawTitle(group2);
    }
  };
  AxisBase2.prototype.isList = function() {
    return true;
  };
  AxisBase2.prototype.getItems = function() {
    return this.get("ticks");
  };
  AxisBase2.prototype.setItems = function(items) {
    this.update({
      ticks: items
    });
  };
  AxisBase2.prototype.updateItem = function(item, cfg) {
    mix(item, cfg);
    this.clear();
    this.render();
  };
  AxisBase2.prototype.clearItems = function() {
    var itemGroup = this.getElementByLocalId("label-group");
    itemGroup && itemGroup.clear();
  };
  AxisBase2.prototype.setItemState = function(item, state2, value2) {
    item[state2] = value2;
    this.updateTickStates(item);
  };
  AxisBase2.prototype.hasState = function(item, state2) {
    return !!item[state2];
  };
  AxisBase2.prototype.getItemStates = function(item) {
    var tickStates = this.get("tickStates");
    var rst = [];
    each$1(tickStates, function(v, k) {
      if (item[k]) {
        rst.push(k);
      }
    });
    return rst;
  };
  AxisBase2.prototype.clearItemsState = function(state2) {
    var _this = this;
    var items = this.getItemsByState(state2);
    each$1(items, function(item) {
      _this.setItemState(item, state2, false);
    });
  };
  AxisBase2.prototype.getItemsByState = function(state2) {
    var _this = this;
    var items = this.getItems();
    return filter(items, function(item) {
      return _this.hasState(item, state2);
    });
  };
  AxisBase2.prototype.getSidePoint = function(point2, offset) {
    var self = this;
    var vector = self.getSideVector(offset, point2);
    return {
      x: point2.x + vector[0],
      y: point2.y + vector[1]
    };
  };
  AxisBase2.prototype.getTextAnchor = function(vector) {
    var align;
    if (isNumberEqual$1(vector[0], 0)) {
      align = "center";
    } else if (vector[0] > 0) {
      align = "start";
    } else if (vector[0] < 0) {
      align = "end";
    }
    return align;
  };
  AxisBase2.prototype.getTextBaseline = function(vector) {
    var base;
    if (isNumberEqual$1(vector[1], 0)) {
      base = "middle";
    } else if (vector[1] > 0) {
      base = "top";
    } else if (vector[1] < 0) {
      base = "bottom";
    }
    return base;
  };
  AxisBase2.prototype.processOverlap = function(labelGroup) {
  };
  AxisBase2.prototype.drawLine = function(group2) {
    var path2 = this.getLinePath();
    var line2 = this.get("line");
    this.addShape(group2, {
      type: "path",
      id: this.getElementId("line"),
      name: "axis-line",
      attrs: mix({
        path: path2
      }, line2.style)
    });
  };
  AxisBase2.prototype.getTickLineItems = function(ticks) {
    var _this = this;
    var tickLineItems = [];
    var tickLine = this.get("tickLine");
    var alignTick = tickLine.alignTick;
    var tickLineLength = tickLine.length;
    var tickSegment = 1;
    var tickCount = ticks.length;
    if (tickCount >= 2) {
      tickSegment = ticks[1].value - ticks[0].value;
    }
    each$1(ticks, function(tick) {
      var point2 = tick.point;
      if (!alignTick) {
        point2 = _this.getTickPoint(tick.value - tickSegment / 2);
      }
      var endPoint = _this.getSidePoint(point2, tickLineLength);
      tickLineItems.push({
        startPoint: point2,
        tickValue: tick.value,
        endPoint,
        tickId: tick.id,
        id: "tickline-" + tick.id
      });
    });
    return tickLineItems;
  };
  AxisBase2.prototype.getSubTickLineItems = function(tickLineItems) {
    var subTickLineItems = [];
    var subTickLine = this.get("subTickLine");
    var subCount = subTickLine.count;
    var tickLineCount = tickLineItems.length;
    if (tickLineCount >= 2) {
      for (var i = 0; i < tickLineCount - 1; i++) {
        var pre = tickLineItems[i];
        var next = tickLineItems[i + 1];
        for (var j = 0; j < subCount; j++) {
          var percent2 = (j + 1) / (subCount + 1);
          var tickValue = (1 - percent2) * pre.tickValue + percent2 * next.tickValue;
          var point2 = this.getTickPoint(tickValue);
          var endPoint = this.getSidePoint(point2, subTickLine.length);
          subTickLineItems.push({
            startPoint: point2,
            endPoint,
            tickValue,
            id: "sub-" + pre.id + "-" + j
          });
        }
      }
    }
    return subTickLineItems;
  };
  AxisBase2.prototype.getTickLineAttrs = function(tickItem, type, index2, tickItems) {
    var style = this.get(type).style;
    var item = {
      points: [tickItem.startPoint, tickItem.endPoint]
    };
    var defaultTickLineStyle = get(this.get("theme"), ["tickLine", "style"], {});
    style = isFunction(style) ? mix({}, defaultTickLineStyle, style(item, index2, tickItems)) : style;
    var startPoint = tickItem.startPoint, endPoint = tickItem.endPoint;
    return __assign$1({ x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y }, style);
  };
  AxisBase2.prototype.drawTick = function(tickItem, tickLineGroup, type, index2, tickItems) {
    this.addShape(tickLineGroup, {
      type: "line",
      id: this.getElementId(tickItem.id),
      name: "axis-" + type,
      attrs: this.getTickLineAttrs(tickItem, type, index2, tickItems)
    });
  };
  AxisBase2.prototype.drawTickLines = function(group2) {
    var _this = this;
    var ticks = this.get("ticks");
    var subTickLine = this.get("subTickLine");
    var tickLineItems = this.getTickLineItems(ticks);
    var tickLineGroup = this.addGroup(group2, {
      name: "axis-tickline-group",
      id: this.getElementId("tickline-group")
    });
    var tickCfg = this.get("tickLine");
    each$1(tickLineItems, function(item, index2) {
      if (tickCfg.displayWithLabel) {
        var labelId = _this.getElementId("label-" + item.tickId);
        if (group2.findById(labelId)) {
          _this.drawTick(item, tickLineGroup, "tickLine", index2, tickLineItems);
        }
      } else {
        _this.drawTick(item, tickLineGroup, "tickLine", index2, tickLineItems);
      }
    });
    if (subTickLine) {
      var subTickLineItems_1 = this.getSubTickLineItems(tickLineItems);
      each$1(subTickLineItems_1, function(item, index2) {
        _this.drawTick(item, tickLineGroup, "subTickLine", index2, subTickLineItems_1);
      });
    }
  };
  AxisBase2.prototype.processTicks = function() {
    var _this = this;
    var ticks = this.get("ticks");
    each$1(ticks, function(tick) {
      tick.point = _this.getTickPoint(tick.value);
      if (isNil(tick.id)) {
        tick.id = tick.name;
      }
    });
  };
  AxisBase2.prototype.drawTicks = function(group2) {
    var _this = this;
    this.optimizeTicks();
    this.processTicks();
    if (this.get("label")) {
      this.drawLabels(group2);
    }
    if (this.get("tickLine")) {
      this.drawTickLines(group2);
    }
    var ticks = this.get("ticks");
    each$1(ticks, function(tick) {
      _this.applyTickStates(tick, group2);
    });
  };
  AxisBase2.prototype.optimizeTicks = function() {
    var optimize = this.get("optimize");
    var ticks = this.get("ticks");
    if (optimize && optimize.enable && optimize.threshold > 0) {
      var len = size(ticks);
      if (len > optimize.threshold) {
        var page_1 = Math.ceil(len / optimize.threshold);
        var optimizedTicks = ticks.filter(function(tick, idx) {
          return idx % page_1 === 0;
        });
        this.set("ticks", optimizedTicks);
        this.set("originalTicks", ticks);
      }
    }
  };
  AxisBase2.prototype.getLabelAttrs = function(tick, index2, ticks) {
    var labelCfg = this.get("label");
    var offset = labelCfg.offset, offsetX = labelCfg.offsetX, offsetY = labelCfg.offsetY, rotate2 = labelCfg.rotate, formatter = labelCfg.formatter;
    var point2 = this.getSidePoint(tick.point, offset);
    var vector = this.getSideVector(offset, point2);
    var text2 = formatter ? formatter(tick.name, tick, index2) : tick.name;
    var style = labelCfg.style;
    style = isFunction(style) ? get(this.get("theme"), ["label", "style"], {}) : style;
    var attrs = mix({
      x: point2.x + offsetX,
      y: point2.y + offsetY,
      text: text2,
      textAlign: this.getTextAnchor(vector),
      textBaseline: this.getTextBaseline(vector)
    }, style);
    if (rotate2) {
      attrs.matrix = getMatrixByAngle(point2, rotate2);
    }
    return attrs;
  };
  AxisBase2.prototype.drawLabels = function(group2) {
    var _this = this;
    var ticks = this.get("ticks");
    var labelGroup = this.addGroup(group2, {
      name: "axis-label-group",
      id: this.getElementId("label-group")
    });
    each$1(ticks, function(tick, index2) {
      _this.addShape(labelGroup, {
        type: "text",
        name: "axis-label",
        id: _this.getElementId("label-" + tick.id),
        attrs: _this.getLabelAttrs(tick, index2, ticks),
        delegateObject: {
          tick,
          item: tick,
          index: index2
        }
      });
    });
    this.processOverlap(labelGroup);
    var labels = labelGroup.getChildren();
    var defaultLabelStyle = get(this.get("theme"), ["label", "style"], {});
    var _a2 = this.get("label"), style = _a2.style, formatter = _a2.formatter;
    if (isFunction(style)) {
      var afterProcessTicks_1 = labels.map(function(label2) {
        return get(label2.get("delegateObject"), "tick");
      });
      each$1(labels, function(label2, index2) {
        var tick = label2.get("delegateObject").tick;
        var text2 = formatter ? formatter(tick.name, tick, index2) : tick.name;
        var newStyle = mix({}, defaultLabelStyle, style(text2, index2, afterProcessTicks_1));
        label2.attr(newStyle);
      });
    }
  };
  AxisBase2.prototype.getTitleAttrs = function() {
    var titleCfg = this.get("title");
    var style = titleCfg.style, position = titleCfg.position, offset = titleCfg.offset, _a2 = titleCfg.spacing, spacing = _a2 === void 0 ? 0 : _a2, autoRotate2 = titleCfg.autoRotate;
    var titleHeight = style.fontSize;
    var percent2 = 0.5;
    if (position === "start") {
      percent2 = 0;
    } else if (position === "end") {
      percent2 = 1;
    }
    var point2 = this.getTickPoint(percent2);
    var titlePoint = this.getSidePoint(point2, offset || spacing + titleHeight / 2);
    var attrs = mix({
      x: titlePoint.x,
      y: titlePoint.y,
      text: titleCfg.text
    }, style);
    var rotate2 = titleCfg.rotate;
    var angle2 = rotate2;
    if (isNil(rotate2) && autoRotate2) {
      var vector = this.getAxisVector(point2);
      var v1 = [1, 0];
      angle2 = angleTo(vector, v1, true);
    }
    if (angle2) {
      var matrix = getMatrixByAngle(titlePoint, angle2);
      attrs.matrix = matrix;
    }
    return attrs;
  };
  AxisBase2.prototype.drawTitle = function(group2) {
    this.addShape(group2, {
      type: "text",
      id: this.getElementId("title"),
      name: "axis-title",
      attrs: this.getTitleAttrs()
    });
  };
  AxisBase2.prototype.applyTickStates = function(tick, group2) {
    var states = this.getItemStates(tick);
    if (states.length) {
      var tickStates = this.get("tickStates");
      var labelId = this.getElementId("label-" + tick.id);
      var labelShape = group2.findById(labelId);
      if (labelShape) {
        var labelStateStyle = getStatesStyle(tick, "label", tickStates);
        labelStateStyle && labelShape.attr(labelStateStyle);
      }
      var tickLineId = this.getElementId("tickline-" + tick.id);
      var tickLineShape = group2.findById(tickLineId);
      if (tickLineShape) {
        var tickLineStateStyle = getStatesStyle(tick, "tickLine", tickStates);
        tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
      }
    }
  };
  AxisBase2.prototype.updateTickStates = function(tick) {
    var states = this.getItemStates(tick);
    var tickStates = this.get("tickStates");
    var labelCfg = this.get("label");
    var labelShape = this.getElementByLocalId("label-" + tick.id);
    var tickLineCfg = this.get("tickLine");
    var tickLineShape = this.getElementByLocalId("tickline-" + tick.id);
    if (states.length) {
      if (labelShape) {
        var labelStateStyle = getStatesStyle(tick, "label", tickStates);
        labelStateStyle && labelShape.attr(labelStateStyle);
      }
      if (tickLineShape) {
        var tickLineStateStyle = getStatesStyle(tick, "tickLine", tickStates);
        tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
      }
    } else {
      if (labelShape) {
        labelShape.attr(labelCfg.style);
      }
      if (tickLineShape) {
        tickLineShape.attr(tickLineCfg.style);
      }
    }
  };
  return AxisBase2;
}(GroupComponent);
function ellipseLabels(isVertical2, labelGroup, limitLength, position) {
  var children = labelGroup.getChildren();
  var ellipsisFlag = false;
  each$1(children, function(label2) {
    var rst = ellipsisLabel(isVertical2, label2, limitLength, position);
    ellipsisFlag = ellipsisFlag || rst;
  });
  return ellipsisFlag;
}
function getDefault$2() {
  return ellipsisTail;
}
function ellipsisHead(isVertical2, labelGroup, limitLength) {
  return ellipseLabels(isVertical2, labelGroup, limitLength, "head");
}
function ellipsisTail(isVertical2, labelGroup, limitLength) {
  return ellipseLabels(isVertical2, labelGroup, limitLength, "tail");
}
function ellipsisMiddle(isVertical2, labelGroup, limitLength) {
  return ellipseLabels(isVertical2, labelGroup, limitLength, "middle");
}
var autoEllipsis = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getDefault: getDefault$2,
  ellipsisHead,
  ellipsisTail,
  ellipsisMiddle
});
function isRotate(label2) {
  var matrix = label2.attr("matrix");
  return matrix && matrix[0] !== 1;
}
function getRotateAngle(label2) {
  var angle2 = isRotate(label2) ? getAngleByMatrix(label2.attr("matrix")) : 0;
  return angle2 % 360;
}
function isOverlap(isVertical2, first, second, minGap) {
  var overlap2 = false;
  var angle2 = getRotateAngle(first);
  var distance2 = isVertical2 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
  var prevBBox = (isVertical2 ? second.attr("y") > first.attr("y") : second.attr("x") > first.attr("x")) ? first.getBBox() : second.getBBox();
  if (isVertical2) {
    var ratio = Math.abs(Math.cos(angle2));
    if (near(ratio, 0, Math.PI / 180)) {
      overlap2 = prevBBox.width + minGap > distance2;
    } else {
      overlap2 = prevBBox.height / ratio + minGap > distance2;
    }
  } else {
    var ratio = Math.abs(Math.sin(angle2));
    if (near(ratio, 0, Math.PI / 180)) {
      overlap2 = prevBBox.width + minGap > distance2;
    } else {
      overlap2 = prevBBox.height / ratio + minGap > distance2;
    }
  }
  return overlap2;
}
function reserveOne(isVertical2, labelsGroup, reversed, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice().filter(function(item) {
    return item.get("visible");
  });
  if (!labels.length) {
    return false;
  }
  var hasHide = false;
  if (reversed) {
    labels.reverse();
  }
  var count = labels.length;
  var first = labels[0];
  var prev = first;
  for (var i = 1; i < count; i++) {
    var label2 = labels[i];
    label2.getBBox();
    var isHide = isOverlap(isVertical2, prev, label2, minGap);
    if (isHide) {
      label2.hide();
      hasHide = true;
    } else {
      prev = label2;
    }
  }
  return hasHide;
}
function parityHide(isVertical2, labelsGroup, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice();
  if (labels.length < 2) {
    return false;
  }
  var hasHide = false;
  var first = labels[0];
  var firstBBox = first.getBBox();
  var second = labels[1];
  var count = labels.length;
  var angle2 = getRotateAngle(first);
  var distance2 = isVertical2 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
  var interval2 = 0;
  if (isVertical2) {
    var ratio = Math.abs(Math.cos(angle2));
    if (near(ratio, 0, Math.PI / 180)) {
      var maxWidth = getMaxLabelWidth(labels);
      interval2 = (maxWidth + minGap) / distance2;
    } else {
      interval2 = (firstBBox.height / ratio + minGap) / distance2;
    }
  } else {
    var ratio = Math.abs(Math.sin(angle2));
    if (near(ratio, 0, Math.PI / 180)) {
      var maxWidth = getMaxLabelWidth(labels);
      interval2 = (maxWidth + minGap) / distance2;
    } else {
      interval2 = (firstBBox.height / ratio + minGap) / distance2;
    }
  }
  if (interval2 > 1) {
    interval2 = Math.ceil(interval2);
    for (var i = 0; i < count; i++) {
      if (i % interval2 !== 0) {
        labels[i].hide();
        hasHide = true;
      }
    }
  }
  return hasHide;
}
function getDefault$1() {
  return equidistance;
}
function reserveFirst(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  return reserveOne(isVertical2, labelsGroup, false, autoHideCfg);
}
function reserveLast(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  return reserveOne(isVertical2, labelsGroup, true, autoHideCfg);
}
function reserveBoth(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice();
  if (labels.length <= 2) {
    return false;
  }
  var hasHide = false;
  var count = labels.length;
  var first = labels[0];
  var last2 = labels[count - 1];
  var preLabel = first;
  for (var i = 1; i < count - 1; i++) {
    var label2 = labels[i];
    label2.getBBox();
    var isHide = isOverlap(isVertical2, preLabel, label2, minGap);
    if (isHide) {
      label2.hide();
      hasHide = true;
    } else {
      preLabel = label2;
    }
  }
  var overlap2 = isOverlap(isVertical2, preLabel, last2, minGap);
  if (overlap2) {
    preLabel.hide();
    hasHide = true;
  }
  return hasHide;
}
function equidistance(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  var hasHide = parityHide(isVertical2, labelsGroup, autoHideCfg);
  if (reserveOne(isVertical2, labelsGroup, false)) {
    hasHide = true;
  }
  return hasHide;
}
function equidistanceWithReverseBoth(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  var labels = labelsGroup.getChildren().slice();
  var hasHide = parityHide(isVertical2, labelsGroup, autoHideCfg);
  if (labels.length > 2) {
    var first = labels[0];
    var last2 = labels[labels.length - 1];
    if (!first.get("visible")) {
      first.show();
      if (reserveOne(isVertical2, labelsGroup, false, autoHideCfg)) {
        hasHide = true;
      }
    }
    if (!last2.get("visible")) {
      last2.show();
      if (reserveOne(isVertical2, labelsGroup, true, autoHideCfg)) {
        hasHide = true;
      }
    }
  }
  return hasHide;
}
var autoHide = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getDefault: getDefault$1,
  reserveFirst,
  reserveLast,
  reserveBoth,
  equidistance,
  equidistanceWithReverseBoth
});
function setLabelsAngle(labels, angle2) {
  each$1(labels, function(label2) {
    var x = label2.attr("x");
    var y = label2.attr("y");
    var matrix = getMatrixByAngle({ x, y }, angle2);
    label2.attr("matrix", matrix);
  });
}
function labelRotate(isVertical2, labelsGroup, limitLength, getAngle2) {
  var labels = labelsGroup.getChildren();
  if (!labels.length) {
    return false;
  }
  if (!isVertical2 && labels.length < 2) {
    return false;
  }
  var maxWidth = getMaxLabelWidth(labels);
  var isOverlap2 = false;
  if (isVertical2) {
    isOverlap2 = !!limitLength && maxWidth > limitLength;
  } else {
    var tickWidth = Math.abs(labels[1].attr("x") - labels[0].attr("x"));
    isOverlap2 = maxWidth > tickWidth;
  }
  if (isOverlap2) {
    var angle2 = getAngle2(limitLength, maxWidth);
    setLabelsAngle(labels, angle2);
  }
  return isOverlap2;
}
function getDefault() {
  return fixedAngle;
}
function fixedAngle(isVertical2, labelsGroup, limitLength, customRotate) {
  return labelRotate(isVertical2, labelsGroup, limitLength, function() {
    if (isNumber$1(customRotate)) {
      return customRotate;
    }
    return isVertical2 ? Theme.verticalAxisRotate : Theme.horizontalAxisRotate;
  });
}
function unfixedAngle(isVertical2, labelsGroup, limitLength) {
  return labelRotate(isVertical2, labelsGroup, limitLength, function(length2, maxWidth) {
    if (!length2) {
      return isVertical2 ? Theme.verticalAxisRotate : Theme.horizontalAxisRotate;
    }
    if (isVertical2) {
      return -Math.acos(length2 / maxWidth);
    } else {
      var angle2 = 0;
      if (length2 > maxWidth) {
        angle2 = Math.PI / 4;
      } else {
        angle2 = Math.asin(length2 / maxWidth);
        if (angle2 > Math.PI / 4) {
          angle2 = Math.PI / 4;
        }
      }
      return angle2;
    }
  });
}
var autoRotate = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getDefault,
  fixedAngle,
  unfixedAngle
});
var OverlapUtil = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  autoHide,
  autoRotate,
  autoEllipsis
});
var Line$7 = function(_super) {
  __extends$2(Line2, _super);
  function Line2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Line2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), {
      type: "line",
      locationType: "region",
      start: null,
      end: null
    });
  };
  Line2.prototype.getLinePath = function() {
    var start = this.get("start");
    var end = this.get("end");
    var path2 = [];
    path2.push(["M", start.x, start.y]);
    path2.push(["L", end.x, end.y]);
    return path2;
  };
  Line2.prototype.getInnerLayoutBBox = function() {
    var start = this.get("start");
    var end = this.get("end");
    var bbox = _super.prototype.getInnerLayoutBBox.call(this);
    var minX = Math.min(start.x, end.x, bbox.x);
    var minY = Math.min(start.y, end.y, bbox.y);
    var maxX = Math.max(start.x, end.x, bbox.maxX);
    var maxY = Math.max(start.y, end.y, bbox.maxY);
    return {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  };
  Line2.prototype.isVertical = function() {
    var start = this.get("start");
    var end = this.get("end");
    return isNumberEqual$1(start.x, end.x);
  };
  Line2.prototype.isHorizontal = function() {
    var start = this.get("start");
    var end = this.get("end");
    return isNumberEqual$1(start.y, end.y);
  };
  Line2.prototype.getTickPoint = function(tickValue) {
    var self = this;
    var start = self.get("start");
    var end = self.get("end");
    var regionX = end.x - start.x;
    var regionY = end.y - start.y;
    return {
      x: start.x + regionX * tickValue,
      y: start.y + regionY * tickValue
    };
  };
  Line2.prototype.getSideVector = function(offset) {
    var axisVector = this.getAxisVector();
    var normal = normalize([0, 0], axisVector);
    var factor = this.get("verticalFactor");
    var verticalVector = [normal[1], normal[0] * -1];
    return scale$2([0, 0], verticalVector, offset * factor);
  };
  Line2.prototype.getAxisVector = function() {
    var start = this.get("start");
    var end = this.get("end");
    return [end.x - start.x, end.y - start.y];
  };
  Line2.prototype.processOverlap = function(labelGroup) {
    var _this = this;
    var isVertical2 = this.isVertical();
    var isHorizontal2 = this.isHorizontal();
    if (!isVertical2 && !isHorizontal2) {
      return;
    }
    var labelCfg = this.get("label");
    var titleCfg = this.get("title");
    var verticalLimitLength = this.get("verticalLimitLength");
    var labelOffset = labelCfg.offset;
    var limitLength = verticalLimitLength;
    var titleHeight = 0;
    var titleSpacing = 0;
    if (titleCfg) {
      titleHeight = titleCfg.style.fontSize;
      titleSpacing = titleCfg.spacing;
    }
    if (limitLength) {
      limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
    }
    var overlapOrder = this.get("overlapOrder");
    each$1(overlapOrder, function(name) {
      if (labelCfg[name] && _this.canProcessOverlap(name)) {
        _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
      }
    });
    if (titleCfg) {
      if (isNil(titleCfg.offset)) {
        var bbox = labelGroup.getCanvasBBox();
        var length_1 = isVertical2 ? bbox.width : bbox.height;
        titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
      }
    }
  };
  Line2.prototype.canProcessOverlap = function(name) {
    var labelCfg = this.get("label");
    if (name === "autoRotate") {
      return isNil(labelCfg.rotate);
    }
    return true;
  };
  Line2.prototype.autoProcessOverlap = function(name, value2, labelGroup, limitLength) {
    var _this = this;
    var isVertical2 = this.isVertical();
    var hasAdjusted = false;
    var util = OverlapUtil[name];
    if (value2 === true) {
      this.get("label");
      hasAdjusted = util.getDefault()(isVertical2, labelGroup, limitLength);
    } else if (isFunction(value2)) {
      hasAdjusted = value2(isVertical2, labelGroup, limitLength);
    } else if (isObject(value2)) {
      var overlapCfg = value2;
      if (util[overlapCfg.type]) {
        hasAdjusted = util[overlapCfg.type](isVertical2, labelGroup, limitLength, overlapCfg.cfg);
      }
    } else if (util[value2]) {
      hasAdjusted = util[value2](isVertical2, labelGroup, limitLength);
    }
    if (name === "autoRotate") {
      if (hasAdjusted) {
        var labels = labelGroup.getChildren();
        var verticalFactor_1 = this.get("verticalFactor");
        each$1(labels, function(label2) {
          var textAlign = label2.attr("textAlign");
          if (textAlign === "center") {
            var newAlign = verticalFactor_1 > 0 ? "end" : "start";
            label2.attr("textAlign", newAlign);
          }
        });
      }
    } else if (name === "autoHide") {
      var children = labelGroup.getChildren().slice(0);
      each$1(children, function(label2) {
        if (!label2.get("visible")) {
          if (_this.get("isRegister")) {
            _this.unregisterElement(label2);
          }
          label2.remove();
        }
      });
    }
  };
  return Line2;
}(AxisBase);
var Circle$6 = function(_super) {
  __extends$2(Circle2, _super);
  function Circle2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Circle2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { type: "circle", locationType: "circle", center: null, radius: null, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2 });
  };
  Circle2.prototype.getLinePath = function() {
    var center2 = this.get("center");
    var x = center2.x;
    var y = center2.y;
    var rx = this.get("radius");
    var ry = rx;
    var startAngle = this.get("startAngle");
    var endAngle = this.get("endAngle");
    var path2 = [];
    if (Math.abs(endAngle - startAngle) === Math.PI * 2) {
      path2 = [["M", x, y - ry], ["A", rx, ry, 0, 1, 1, x, y + ry], ["A", rx, ry, 0, 1, 1, x, y - ry], ["Z"]];
    } else {
      var startPoint = this.getCirclePoint(startAngle);
      var endPoint = this.getCirclePoint(endAngle);
      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
      var sweep = startAngle > endAngle ? 0 : 1;
      path2 = [
        ["M", x, y],
        ["L", startPoint.x, startPoint.y],
        ["A", rx, ry, 0, large, sweep, endPoint.x, endPoint.y],
        ["L", x, y]
      ];
    }
    return path2;
  };
  Circle2.prototype.getTickPoint = function(tickValue) {
    var startAngle = this.get("startAngle");
    var endAngle = this.get("endAngle");
    var angle2 = startAngle + (endAngle - startAngle) * tickValue;
    return this.getCirclePoint(angle2);
  };
  Circle2.prototype.getSideVector = function(offset, point2) {
    var center2 = this.get("center");
    var vector = [point2.x - center2.x, point2.y - center2.y];
    var factor = this.get("verticalFactor");
    var vecLen = length(vector);
    scale$2(vector, vector, factor * offset / vecLen);
    return vector;
  };
  Circle2.prototype.getAxisVector = function(point2) {
    var center2 = this.get("center");
    var vector = [point2.x - center2.x, point2.y - center2.y];
    return [vector[1], -1 * vector[0]];
  };
  Circle2.prototype.getCirclePoint = function(angle2, radius) {
    var center2 = this.get("center");
    radius = radius || this.get("radius");
    return {
      x: center2.x + Math.cos(angle2) * radius,
      y: center2.y + Math.sin(angle2) * radius
    };
  };
  Circle2.prototype.canProcessOverlap = function(name) {
    var labelCfg = this.get("label");
    if (name === "autoRotate") {
      return isNil(labelCfg.rotate);
    }
    return true;
  };
  Circle2.prototype.processOverlap = function(labelGroup) {
    var _this = this;
    var labelCfg = this.get("label");
    var titleCfg = this.get("title");
    var verticalLimitLength = this.get("verticalLimitLength");
    var labelOffset = labelCfg.offset;
    var limitLength = verticalLimitLength;
    var titleHeight = 0;
    var titleSpacing = 0;
    if (titleCfg) {
      titleHeight = titleCfg.style.fontSize;
      titleSpacing = titleCfg.spacing;
    }
    if (limitLength) {
      limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
    }
    var overlapOrder = this.get("overlapOrder");
    each$1(overlapOrder, function(name) {
      if (labelCfg[name] && _this.canProcessOverlap(name)) {
        _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
      }
    });
    if (titleCfg) {
      if (isNil(titleCfg.offset)) {
        var length_1 = labelGroup.getCanvasBBox().height;
        titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
      }
    }
  };
  Circle2.prototype.autoProcessOverlap = function(name, value2, labelGroup, limitLength) {
    var _this = this;
    var hasAdjusted = false;
    var util = OverlapUtil[name];
    if (limitLength > 0) {
      if (value2 === true) {
        hasAdjusted = util.getDefault()(false, labelGroup, limitLength);
      } else if (isFunction(value2)) {
        hasAdjusted = value2(false, labelGroup, limitLength);
      } else if (isObject(value2)) {
        var overlapCfg = value2;
        if (util[overlapCfg.type]) {
          hasAdjusted = util[overlapCfg.type](false, labelGroup, limitLength, overlapCfg.cfg);
        }
      } else if (util[value2]) {
        hasAdjusted = util[value2](false, labelGroup, limitLength);
      }
    }
    if (name === "autoRotate") {
      if (hasAdjusted) {
        var labels = labelGroup.getChildren();
        var verticalFactor_1 = this.get("verticalFactor");
        each$1(labels, function(label2) {
          var textAlign = label2.attr("textAlign");
          if (textAlign === "center") {
            var newAlign = verticalFactor_1 > 0 ? "end" : "start";
            label2.attr("textAlign", newAlign);
          }
        });
      }
    } else if (name === "autoHide") {
      var children = labelGroup.getChildren().slice(0);
      each$1(children, function(label2) {
        if (!label2.get("visible")) {
          if (_this.get("isRegister")) {
            _this.unregisterElement(label2);
          }
          label2.remove();
        }
      });
    }
  };
  return Circle2;
}(AxisBase);
var CrosshairBase = function(_super) {
  __extends$2(CrosshairBase2, _super);
  function CrosshairBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CrosshairBase2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "crosshair", type: "base", line: {}, text: null, textBackground: {}, capture: false, defaultCfg: {
      line: {
        style: {
          lineWidth: 1,
          stroke: Theme.lineColor
        }
      },
      text: {
        position: "start",
        offset: 10,
        autoRotate: false,
        content: null,
        style: {
          fill: Theme.textColor,
          textAlign: "center",
          textBaseline: "middle",
          fontFamily: Theme.fontFamily
        }
      },
      textBackground: {
        padding: 5,
        style: {
          stroke: Theme.lineColor
        }
      }
    } });
  };
  CrosshairBase2.prototype.renderInner = function(group2) {
    if (this.get("line")) {
      this.renderLine(group2);
    }
    if (this.get("text")) {
      this.renderText(group2);
      this.renderBackground(group2);
    }
  };
  CrosshairBase2.prototype.renderText = function(group2) {
    var text2 = this.get("text");
    var style = text2.style, autoRotate2 = text2.autoRotate, content = text2.content;
    if (!isNil(content)) {
      var textPoint = this.getTextPoint();
      var matrix = null;
      if (autoRotate2) {
        var angle2 = this.getRotateAngle();
        matrix = getMatrixByAngle(textPoint, angle2);
      }
      this.addShape(group2, {
        type: "text",
        name: "crosshair-text",
        id: this.getElementId("text"),
        attrs: __assign$1(__assign$1(__assign$1({}, textPoint), { text: content, matrix }), style)
      });
    }
  };
  CrosshairBase2.prototype.renderLine = function(group2) {
    var path2 = this.getLinePath();
    var line2 = this.get("line");
    var style = line2.style;
    this.addShape(group2, {
      type: "path",
      name: "crosshair-line",
      id: this.getElementId("line"),
      attrs: __assign$1({ path: path2 }, style)
    });
  };
  CrosshairBase2.prototype.renderBackground = function(group2) {
    var textId = this.getElementId("text");
    var textShape = group2.findById(textId);
    var textBackground = this.get("textBackground");
    if (textBackground && textShape) {
      var textBBox = textShape.getBBox();
      var padding2 = formatPadding(textBackground.padding);
      var style = textBackground.style;
      var backgroundShape = this.addShape(group2, {
        type: "rect",
        name: "crosshair-text-background",
        id: this.getElementId("text-background"),
        attrs: __assign$1({ x: textBBox.x - padding2[3], y: textBBox.y - padding2[0], width: textBBox.width + padding2[1] + padding2[3], height: textBBox.height + padding2[0] + padding2[2], matrix: textShape.attr("matrix") }, style)
      });
      backgroundShape.toBack();
    }
  };
  return CrosshairBase2;
}(GroupComponent);
var LineCrosshair$1 = function(_super) {
  __extends$2(LineCrosshair2, _super);
  function LineCrosshair2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LineCrosshair2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { type: "line", locationType: "region", start: null, end: null });
  };
  LineCrosshair2.prototype.getRotateAngle = function() {
    var _a2 = this.getLocation(), start = _a2.start, end = _a2.end;
    var position = this.get("text").position;
    var angle2 = Math.atan2(end.y - start.y, end.x - start.x);
    var tangentAngle = position === "start" ? angle2 - Math.PI / 2 : angle2 + Math.PI / 2;
    return tangentAngle;
  };
  LineCrosshair2.prototype.getTextPoint = function() {
    var _a2 = this.getLocation(), start = _a2.start, end = _a2.end;
    var _b = this.get("text"), position = _b.position, offset = _b.offset;
    return getTextPoint(start, end, position, offset);
  };
  LineCrosshair2.prototype.getLinePath = function() {
    var _a2 = this.getLocation(), start = _a2.start, end = _a2.end;
    return [
      ["M", start.x, start.y],
      ["L", end.x, end.y]
    ];
  };
  return LineCrosshair2;
}(CrosshairBase);
var LineCrosshair = function(_super) {
  __extends$2(LineCrosshair2, _super);
  function LineCrosshair2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LineCrosshair2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { type: "circle", locationType: "circle", center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2 });
  };
  LineCrosshair2.prototype.getRotateAngle = function() {
    var _a2 = this.getLocation(), startAngle = _a2.startAngle, endAngle = _a2.endAngle;
    var position = this.get("text").position;
    var tangentAngle = position === "start" ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;
    return tangentAngle;
  };
  LineCrosshair2.prototype.getTextPoint = function() {
    var text2 = this.get("text");
    var position = text2.position, offset = text2.offset;
    var _a2 = this.getLocation(), center2 = _a2.center, radius = _a2.radius, startAngle = _a2.startAngle, endAngle = _a2.endAngle;
    var angle2 = position === "start" ? startAngle : endAngle;
    var tangentAngle = this.getRotateAngle() - Math.PI;
    var point2 = getCirclePoint(center2, radius, angle2);
    var offsetX = Math.cos(tangentAngle) * offset;
    var offsetY = Math.sin(tangentAngle) * offset;
    return {
      x: point2.x + offsetX,
      y: point2.y + offsetY
    };
  };
  LineCrosshair2.prototype.getLinePath = function() {
    var _a2 = this.getLocation(), center2 = _a2.center, radius = _a2.radius, startAngle = _a2.startAngle, endAngle = _a2.endAngle;
    var path2 = null;
    if (endAngle - startAngle === Math.PI * 2) {
      var x = center2.x, y = center2.y;
      path2 = [
        ["M", x, y - radius],
        ["A", radius, radius, 0, 1, 1, x, y + radius],
        ["A", radius, radius, 0, 1, 1, x, y - radius],
        ["Z"]
      ];
    } else {
      var startPoint = getCirclePoint(center2, radius, startAngle);
      var endPoint = getCirclePoint(center2, radius, endAngle);
      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
      var sweep = startAngle > endAngle ? 0 : 1;
      path2 = [
        ["M", startPoint.x, startPoint.y],
        ["A", radius, radius, 0, large, sweep, endPoint.x, endPoint.y]
      ];
    }
    return path2;
  };
  return LineCrosshair2;
}(CrosshairBase);
var CONTAINER_CLASS$1 = "g2-crosshair";
var CROSSHAIR_LINE = CONTAINER_CLASS$1 + "-line";
var CROSSHAIR_TEXT = CONTAINER_CLASS$1 + "-text";
var _a$4;
var HtmlTheme = (_a$4 = {}, _a$4["" + CONTAINER_CLASS$1] = {
  position: "relative"
}, _a$4["" + CROSSHAIR_LINE] = {
  position: "absolute",
  backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a$4["" + CROSSHAIR_TEXT] = {
  position: "absolute",
  color: Theme.textColor,
  fontFamily: Theme.fontFamily
}, _a$4);
var HtmlCrosshair = function(_super) {
  __extends$2(HtmlCrosshair2, _super);
  function HtmlCrosshair2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HtmlCrosshair2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "crosshair", type: "html", locationType: "region", start: { x: 0, y: 0 }, end: { x: 0, y: 0 }, capture: false, text: null, containerTpl: '<div class="' + CONTAINER_CLASS$1 + '"></div>', crosshairTpl: '<div class="' + CROSSHAIR_LINE + '"></div>', textTpl: '<span class="' + CROSSHAIR_TEXT + '">{content}</span>', domStyles: null, containerClassName: CONTAINER_CLASS$1, defaultStyles: HtmlTheme, defaultCfg: {
      text: {
        position: "start",
        content: null,
        align: "center",
        offset: 10
      }
    } });
  };
  HtmlCrosshair2.prototype.render = function() {
    this.resetText();
    this.resetPosition();
  };
  HtmlCrosshair2.prototype.initCrossHair = function() {
    var container = this.getContainer();
    var crosshairTpl = this.get("crosshairTpl");
    var crosshairEl = createDom$1(crosshairTpl);
    container.appendChild(crosshairEl);
    this.applyStyle(CROSSHAIR_LINE, crosshairEl);
    this.set("crosshairEl", crosshairEl);
  };
  HtmlCrosshair2.prototype.getTextPoint = function() {
    var _a2 = this.getLocation(), start = _a2.start, end = _a2.end;
    var _b = this.get("text"), position = _b.position, offset = _b.offset;
    return getTextPoint(start, end, position, offset);
  };
  HtmlCrosshair2.prototype.resetText = function() {
    var text2 = this.get("text");
    var textEl = this.get("textEl");
    if (text2) {
      var content = text2.content;
      if (!textEl) {
        var container = this.getContainer();
        var textTpl = substitute(this.get("textTpl"), text2);
        textEl = createDom$1(textTpl);
        container.appendChild(textEl);
        this.applyStyle(CROSSHAIR_TEXT, textEl);
        this.set("textEl", textEl);
      }
      textEl.innerHTML = content;
    } else if (textEl) {
      textEl.remove();
    }
  };
  HtmlCrosshair2.prototype.isVertical = function(start, end) {
    return start.x === end.x;
  };
  HtmlCrosshair2.prototype.resetPosition = function() {
    var crosshairEl = this.get("crosshairEl");
    if (!crosshairEl) {
      this.initCrossHair();
      crosshairEl = this.get("crosshairEl");
    }
    var start = this.get("start");
    var end = this.get("end");
    var minX = Math.min(start.x, end.x);
    var minY = Math.min(start.y, end.y);
    if (this.isVertical(start, end)) {
      modifyCSS(crosshairEl, {
        width: "1px",
        height: toPx(Math.abs(end.y - start.y))
      });
    } else {
      modifyCSS(crosshairEl, {
        height: "1px",
        width: toPx(Math.abs(end.x - start.x))
      });
    }
    modifyCSS(crosshairEl, {
      top: toPx(minY),
      left: toPx(minX)
    });
    this.alignText();
  };
  HtmlCrosshair2.prototype.alignText = function() {
    var textEl = this.get("textEl");
    if (textEl) {
      var align = this.get("text").align;
      var clientWidth = textEl.clientWidth;
      var point2 = this.getTextPoint();
      switch (align) {
        case "center":
          point2.x = point2.x - clientWidth / 2;
          break;
        case "right":
          point2.x = point2.x - clientWidth;
      }
      modifyCSS(textEl, {
        top: toPx(point2.y),
        left: toPx(point2.x)
      });
    }
  };
  HtmlCrosshair2.prototype.updateInner = function(cfg) {
    if (has(cfg, "text")) {
      this.resetText();
    }
    _super.prototype.updateInner.call(this, cfg);
  };
  return HtmlCrosshair2;
}(HtmlComponent);
var Crosshair = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  Line: LineCrosshair$1,
  Circle: LineCrosshair,
  Base: CrosshairBase,
  Html: HtmlCrosshair
});
var GridBase = function(_super) {
  __extends$2(GridBase2, _super);
  function GridBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GridBase2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "grid", line: {}, alternateColor: null, capture: false, items: [], closed: false, defaultCfg: {
      line: {
        type: "line",
        style: {
          lineWidth: 1,
          stroke: Theme.lineColor
        }
      }
    } });
  };
  GridBase2.prototype.getLineType = function() {
    var line2 = this.get("line") || this.get("defaultCfg").line;
    return line2.type;
  };
  GridBase2.prototype.renderInner = function(group2) {
    this.drawGrid(group2);
  };
  GridBase2.prototype.getAlternatePath = function(prePoints, points) {
    var regionPath = this.getGridPath(prePoints);
    var reversePoints = points.slice(0).reverse();
    var nextPath = this.getGridPath(reversePoints, true);
    var closed = this.get("closed");
    if (closed) {
      regionPath = regionPath.concat(nextPath);
    } else {
      nextPath[0][0] = "L";
      regionPath = regionPath.concat(nextPath);
      regionPath.push(["Z"]);
    }
    return regionPath;
  };
  GridBase2.prototype.getPathStyle = function() {
    return this.get("line").style;
  };
  GridBase2.prototype.drawGrid = function(group2) {
    var _this = this;
    var line2 = this.get("line");
    var items = this.get("items");
    var alternateColor = this.get("alternateColor");
    var preItem = null;
    each$1(items, function(item, index2) {
      var id = item.id || index2;
      if (line2) {
        var style = _this.getPathStyle();
        style = isFunction(style) ? style(item, index2, items) : style;
        var lineId = _this.getElementId("line-" + id);
        var gridPath = _this.getGridPath(item.points);
        _this.addShape(group2, {
          type: "path",
          name: "grid-line",
          id: lineId,
          attrs: mix({
            path: gridPath
          }, style)
        });
      }
      if (alternateColor && index2 > 0) {
        var regionId = _this.getElementId("region-" + id);
        var isEven = index2 % 2 === 0;
        if (isString(alternateColor)) {
          if (isEven) {
            _this.drawAlternateRegion(regionId, group2, preItem.points, item.points, alternateColor);
          }
        } else {
          var color2 = isEven ? alternateColor[1] : alternateColor[0];
          _this.drawAlternateRegion(regionId, group2, preItem.points, item.points, color2);
        }
      }
      preItem = item;
    });
  };
  GridBase2.prototype.drawAlternateRegion = function(id, group2, prePoints, points, color2) {
    var regionPath = this.getAlternatePath(prePoints, points);
    this.addShape(group2, {
      type: "path",
      id,
      name: "grid-region",
      attrs: {
        path: regionPath,
        fill: color2
      }
    });
  };
  return GridBase2;
}(GroupComponent);
function distance$3(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}
var Circle$5 = function(_super) {
  __extends$2(Circle2, _super);
  function Circle2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Circle2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), {
      type: "circle",
      center: null,
      closed: true
    });
  };
  Circle2.prototype.getGridPath = function(points, reversed) {
    var lineType = this.getLineType();
    var closed = this.get("closed");
    var path2 = [];
    if (points.length) {
      if (lineType === "circle") {
        var center2 = this.get("center");
        var firstPoint = points[0];
        var radius_1 = distance$3(center2.x, center2.y, firstPoint.x, firstPoint.y);
        var sweepFlag_1 = reversed ? 0 : 1;
        if (closed) {
          path2.push(["M", center2.x, center2.y - radius_1]);
          path2.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, center2.x, center2.y + radius_1]);
          path2.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, center2.x, center2.y - radius_1]);
          path2.push(["Z"]);
        } else {
          each$1(points, function(point2, index2) {
            if (index2 === 0) {
              path2.push(["M", point2.x, point2.y]);
            } else {
              path2.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, point2.x, point2.y]);
            }
          });
        }
      } else {
        each$1(points, function(point2, index2) {
          if (index2 === 0) {
            path2.push(["M", point2.x, point2.y]);
          } else {
            path2.push(["L", point2.x, point2.y]);
          }
        });
        if (closed) {
          path2.push(["Z"]);
        }
      }
    }
    return path2;
  };
  return Circle2;
}(GridBase);
var Line$6 = function(_super) {
  __extends$2(Line2, _super);
  function Line2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Line2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { type: "line" });
  };
  Line2.prototype.getGridPath = function(points) {
    var path2 = [];
    each$1(points, function(point2, index2) {
      if (index2 === 0) {
        path2.push(["M", point2.x, point2.y]);
      } else {
        path2.push(["L", point2.x, point2.y]);
      }
    });
    return path2;
  };
  return Line2;
}(GridBase);
var LegendBase = function(_super) {
  __extends$2(LegendBase2, _super);
  function LegendBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LegendBase2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), {
      name: "legend",
      layout: "horizontal",
      locationType: "point",
      x: 0,
      y: 0,
      offsetX: 0,
      offsetY: 0,
      title: null,
      background: null
    });
  };
  LegendBase2.prototype.getLayoutBBox = function() {
    var bbox = _super.prototype.getLayoutBBox.call(this);
    var maxWidth = this.get("maxWidth");
    var maxHeight = this.get("maxHeight");
    var width = bbox.width, height = bbox.height;
    if (maxWidth) {
      width = Math.min(width, maxWidth);
    }
    if (maxHeight) {
      height = Math.min(height, maxHeight);
    }
    return createBBox(bbox.minX, bbox.minY, width, height);
  };
  LegendBase2.prototype.setLocation = function(cfg) {
    this.set("x", cfg.x);
    this.set("y", cfg.y);
    this.resetLocation();
  };
  LegendBase2.prototype.resetLocation = function() {
    var x = this.get("x");
    var y = this.get("y");
    var offsetX = this.get("offsetX");
    var offsetY = this.get("offsetY");
    this.moveElementTo(this.get("group"), {
      x: x + offsetX,
      y: y + offsetY
    });
  };
  LegendBase2.prototype.applyOffset = function() {
    this.resetLocation();
  };
  LegendBase2.prototype.getDrawPoint = function() {
    return this.get("currentPoint");
  };
  LegendBase2.prototype.setDrawPoint = function(point2) {
    return this.set("currentPoint", point2);
  };
  LegendBase2.prototype.renderInner = function(group2) {
    this.resetDraw();
    if (this.get("title")) {
      this.drawTitle(group2);
    }
    this.drawLegendContent(group2);
    if (this.get("background")) {
      this.drawBackground(group2);
    }
  };
  LegendBase2.prototype.drawBackground = function(group2) {
    var background = this.get("background");
    var bbox = group2.getBBox();
    var padding2 = formatPadding(background.padding);
    var attrs = __assign$1({
      x: 0,
      y: 0,
      width: bbox.width + padding2[1] + padding2[3],
      height: bbox.height + padding2[0] + padding2[2]
    }, background.style);
    var backgroundShape = this.addShape(group2, {
      type: "rect",
      id: this.getElementId("background"),
      name: "legend-background",
      attrs
    });
    backgroundShape.toBack();
  };
  LegendBase2.prototype.drawTitle = function(group2) {
    var currentPoint = this.get("currentPoint");
    var titleCfg = this.get("title");
    var spacing = titleCfg.spacing, style = titleCfg.style, text2 = titleCfg.text;
    var shape = this.addShape(group2, {
      type: "text",
      id: this.getElementId("title"),
      name: "legend-title",
      attrs: __assign$1({ text: text2, x: currentPoint.x, y: currentPoint.y }, style)
    });
    var bbox = shape.getBBox();
    this.set("currentPoint", { x: currentPoint.x, y: bbox.maxY + spacing });
  };
  LegendBase2.prototype.resetDraw = function() {
    var background = this.get("background");
    var currentPoint = { x: 0, y: 0 };
    if (background) {
      var padding2 = formatPadding(background.padding);
      currentPoint.x = padding2[3];
      currentPoint.y = padding2[0];
    }
    this.set("currentPoint", currentPoint);
  };
  return LegendBase2;
}(GroupComponent);
var DEFAULT_PAGE_NAVIGATOR = {
  marker: {
    style: {
      inactiveFill: "#000",
      inactiveOpacity: 0.45,
      fill: "#000",
      opacity: 1,
      size: 12
    }
  },
  text: {
    style: {
      fill: "#ccc",
      fontSize: 12
    }
  }
};
var textStyle = {
  fill: Theme.textColor,
  fontSize: 12,
  textAlign: "start",
  textBaseline: "middle",
  fontFamily: Theme.fontFamily,
  fontWeight: "normal",
  lineHeight: 12
};
var Category = function(_super) {
  __extends$2(Category2, _super);
  function Category2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.currentPageIndex = 1;
    _this.totalPagesCnt = 1;
    _this.pageWidth = 0;
    _this.pageHeight = 0;
    _this.startX = 0;
    _this.startY = 0;
    _this.onNavigationBack = function() {
      var itemGroup = _this.getElementByLocalId("item-group");
      if (_this.currentPageIndex > 1) {
        _this.currentPageIndex -= 1;
        _this.updateNavigation();
        var matrix = _this.getCurrentNavigationMatrix();
        if (_this.get("animate")) {
          itemGroup.animate({
            matrix
          }, 100);
        } else {
          itemGroup.attr({ matrix });
        }
      }
    };
    _this.onNavigationAfter = function() {
      var itemGroup = _this.getElementByLocalId("item-group");
      if (_this.currentPageIndex < _this.totalPagesCnt) {
        _this.currentPageIndex += 1;
        _this.updateNavigation();
        var matrix = _this.getCurrentNavigationMatrix();
        if (_this.get("animate")) {
          itemGroup.animate({
            matrix
          }, 100);
        } else {
          itemGroup.attr({ matrix });
        }
      }
    };
    return _this;
  }
  Category2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "legend", type: "category", itemSpacing: 24, itemMarginBottom: 8, maxItemWidth: null, itemWidth: null, itemHeight: null, itemName: {}, itemValue: null, maxWidth: null, maxHeight: null, marker: {}, items: [], itemStates: {}, itemBackground: {}, pageNavigator: {}, defaultCfg: {
      title: {
        spacing: 5,
        style: {
          fill: Theme.textColor,
          fontSize: 12,
          textAlign: "start",
          textBaseline: "top"
        }
      },
      background: {
        padding: 5,
        style: {
          stroke: Theme.lineColor
        }
      },
      itemBackground: {
        style: {
          opacity: 0,
          fill: "#fff"
        }
      },
      pageNavigator: DEFAULT_PAGE_NAVIGATOR,
      itemName: {
        spacing: 16,
        style: textStyle
      },
      marker: {
        spacing: 8,
        style: {
          r: 6,
          symbol: "circle"
        }
      },
      itemValue: {
        alignRight: false,
        formatter: null,
        style: textStyle
      },
      itemStates: {
        active: {
          nameStyle: {
            opacity: 0.8
          }
        },
        unchecked: {
          nameStyle: {
            fill: Theme.uncheckedColor
          },
          markerStyle: {
            fill: Theme.uncheckedColor,
            stroke: Theme.uncheckedColor
          }
        },
        inactive: {
          nameStyle: {
            fill: Theme.uncheckedColor
          },
          markerStyle: {
            opacity: 0.2
          }
        }
      }
    } });
  };
  Category2.prototype.isList = function() {
    return true;
  };
  Category2.prototype.getItems = function() {
    return this.get("items");
  };
  Category2.prototype.setItems = function(items) {
    this.update({
      items
    });
  };
  Category2.prototype.updateItem = function(item, cfg) {
    mix(item, cfg);
    this.clear();
    this.render();
  };
  Category2.prototype.clearItems = function() {
    var itemGroup = this.getElementByLocalId("item-group");
    itemGroup && itemGroup.clear();
  };
  Category2.prototype.setItemState = function(item, state2, value2) {
    item[state2] = value2;
    var itemElement = this.getElementByLocalId("item-" + item.id);
    if (itemElement) {
      var items = this.getItems();
      var index2 = items.indexOf(item);
      var offsetGroup = this.createOffScreenGroup();
      var newElement = this.drawItem(item, index2, this.getItemHeight(), offsetGroup);
      this.updateElements(newElement, itemElement);
      this.clearUpdateStatus(itemElement);
    }
  };
  Category2.prototype.hasState = function(item, state2) {
    return !!item[state2];
  };
  Category2.prototype.getItemStates = function(item) {
    var itemStates = this.get("itemStates");
    var rst = [];
    each$1(itemStates, function(v, k) {
      if (item[k]) {
        rst.push(k);
      }
    });
    return rst;
  };
  Category2.prototype.clearItemsState = function(state2) {
    var _this = this;
    var items = this.getItemsByState(state2);
    each$1(items, function(item) {
      _this.setItemState(item, state2, false);
    });
  };
  Category2.prototype.getItemsByState = function(state2) {
    var _this = this;
    var items = this.getItems();
    return filter(items, function(item) {
      return _this.hasState(item, state2);
    });
  };
  Category2.prototype.drawLegendContent = function(group2) {
    this.processItems();
    this.drawItems(group2);
  };
  Category2.prototype.processItems = function() {
    var items = this.get("items");
    each$1(items, function(item) {
      if (!item.id) {
        item.id = item.name;
      }
    });
  };
  Category2.prototype.drawItems = function(group2) {
    var _this = this;
    var itemContainerGroup = this.addGroup(group2, {
      id: this.getElementId("item-container-group"),
      name: "legend-item-container-group"
    });
    var itemGroup = this.addGroup(itemContainerGroup, {
      id: this.getElementId("item-group"),
      name: "legend-item-group"
    });
    var itemHeight = this.getItemHeight();
    var itemWidth = this.get("itemWidth");
    var itemSpacing = this.get("itemSpacing");
    var itemMarginBottom = this.get("itemMarginBottom");
    var currentPoint = this.get("currentPoint");
    var startX = currentPoint.x;
    var startY = currentPoint.y;
    var layout = this.get("layout");
    var items = this.get("items");
    var wrapped = false;
    var pageWidth = 0;
    var maxWidth = this.get("maxWidth");
    var maxHeight = this.get("maxHeight");
    each$1(items, function(item, index2) {
      var subGroup = _this.drawItem(item, index2, itemHeight, itemGroup);
      var bbox = subGroup.getBBox();
      var width = itemWidth || bbox.width;
      if (width > pageWidth) {
        pageWidth = width;
      }
      if (layout === "horizontal") {
        if (maxWidth && maxWidth < currentPoint.x + width - startX) {
          wrapped = true;
          currentPoint.x = startX;
          currentPoint.y += itemHeight + itemMarginBottom;
        }
        _this.moveElementTo(subGroup, currentPoint);
        currentPoint.x += width + itemSpacing;
      } else {
        if (maxHeight && maxHeight < currentPoint.y + itemHeight + itemMarginBottom - startY) {
          wrapped = true;
          currentPoint.x += pageWidth + itemSpacing;
          currentPoint.y = startY;
          pageWidth = 0;
        }
        _this.moveElementTo(subGroup, currentPoint);
        currentPoint.y += itemHeight + itemMarginBottom;
      }
    });
    if (wrapped && this.get("flipPage")) {
      this.pageHeight = 0;
      this.pageWidth = 0;
      this.totalPagesCnt = 1;
      this.startX = startX;
      this.startY = startY;
      this.adjustNavigation(group2, itemGroup);
    }
  };
  Category2.prototype.getItemHeight = function() {
    var itemHeight = this.get("itemHeight");
    if (!itemHeight) {
      var style_1 = (this.get("itemName") || {}).style;
      if (isFunction(style_1)) {
        var items_1 = this.getItems();
        items_1.forEach(function(item, index2) {
          var fontSize = __assign$1(__assign$1({}, textStyle), style_1(item, index2, items_1)).fontSize;
          if (itemHeight < fontSize) {
            itemHeight = fontSize;
          }
        });
      } else if (style_1) {
        itemHeight = style_1.fontSize;
      }
    }
    return itemHeight;
  };
  Category2.prototype.drawMarker = function(container, markerCfg, item, itemHeight) {
    var markerAttrs = __assign$1(__assign$1(__assign$1({ x: 0, y: itemHeight / 2 }, markerCfg.style), { symbol: get(item.marker, "symbol", "circle") }), get(item.marker, "style", {}));
    var shape = this.addShape(container, {
      type: "marker",
      id: this.getElementId("item-" + item.id + "-marker"),
      name: "legend-item-marker",
      attrs: markerAttrs
    });
    var bbox = shape.getBBox();
    shape.attr("x", bbox.width / 2);
    var _a2 = shape.attr(), stroke = _a2.stroke, fill = _a2.fill;
    if (stroke) {
      shape.set("isStroke", true);
    }
    if (fill) {
      shape.set("isFill", true);
    }
    return shape;
  };
  Category2.prototype.drawItemText = function(container, textName, cfg, item, itemHeight, xPosition, index2) {
    var formatter = cfg.formatter;
    var style = cfg.style;
    var attrs = __assign$1(__assign$1({ x: xPosition, y: itemHeight / 2, text: formatter ? formatter(item[textName], item, index2) : item[textName] }, textStyle), isFunction(style) ? style(item, index2, this.getItems()) : style);
    return this.addShape(container, {
      type: "text",
      id: this.getElementId("item-" + item.id + "-" + textName),
      name: "legend-item-" + textName,
      attrs
    });
  };
  Category2.prototype.drawItem = function(item, index2, itemHeight, itemGroup) {
    var groupId = "item-" + item.id;
    var subContainer = this.addGroup(itemGroup, {
      name: "legend-item-container",
      id: this.getElementId("item-container-" + groupId),
      delegateObject: {
        item,
        index: index2
      }
    });
    var subGroup = this.addGroup(subContainer, {
      name: "legend-item",
      id: this.getElementId(groupId),
      delegateObject: {
        item,
        index: index2
      }
    });
    var marker = this.get("marker");
    var itemName = this.get("itemName");
    var itemValue = this.get("itemValue");
    var itemBackground = this.get("itemBackground");
    var itemWidth = this.getLimitItemWidth();
    var curX = 0;
    if (marker) {
      var markerShape = this.drawMarker(subGroup, marker, item, itemHeight);
      var spacing = marker.spacing;
      var itemMarkerSpacing = get(item, ["marker", "spacing"]);
      if (isNumber$1(itemMarkerSpacing)) {
        spacing = itemMarkerSpacing;
      }
      curX = markerShape.getBBox().maxX + spacing;
    }
    if (itemName) {
      var nameShape = this.drawItemText(subGroup, "name", itemName, item, itemHeight, curX, index2);
      if (itemWidth) {
        ellipsisLabel(true, nameShape, clamp(itemWidth - curX, 0, itemWidth));
      }
      curX = nameShape.getBBox().maxX + itemName.spacing;
    }
    if (itemValue) {
      var valueShape = this.drawItemText(subGroup, "value", itemValue, item, itemHeight, curX, index2);
      if (itemWidth) {
        if (itemValue.alignRight) {
          valueShape.attr({
            textAlign: "right",
            x: itemWidth
          });
          ellipsisLabel(true, valueShape, clamp(itemWidth - curX, 0, itemWidth), "head");
        } else {
          ellipsisLabel(true, valueShape, clamp(itemWidth - curX, 0, itemWidth));
        }
      }
    }
    if (itemBackground) {
      var bbox = subGroup.getBBox();
      var backShape = this.addShape(subGroup, {
        type: "rect",
        name: "legend-item-background",
        id: this.getElementId(groupId + "-background"),
        attrs: __assign$1({ x: 0, y: 0, width: bbox.width, height: itemHeight }, itemBackground.style)
      });
      backShape.toBack();
    }
    this.applyItemStates(item, subGroup);
    return subGroup;
  };
  Category2.prototype.adjustNavigation = function(container, itemGroup) {
    var _this = this;
    var startX = this.startX;
    var startY = this.startY;
    var layout = this.get("layout");
    var subGroups = itemGroup.findAll(function(item) {
      return item.get("name") === "legend-item";
    });
    var maxWidth = this.get("maxWidth");
    var maxHeight = this.get("maxHeight");
    var itemWidth = this.get("itemWidth");
    var itemSpacing = this.get("itemSpacing");
    var itemHeight = this.getItemHeight();
    var pageNavigator = deepMix({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator"));
    var navigation = this.drawNavigation(container, layout, "00/00", pageNavigator);
    var navigationBBox = navigation.getBBox();
    var currentPoint = { x: startX, y: startY };
    var pages = 1;
    var widthLimit = 0;
    var pageWidth = 0;
    var maxItemWidth = 0;
    var itemMarginBottom = this.get("itemMarginBottom");
    if (layout === "horizontal") {
      var maxRow = this.get("maxRow") || 1;
      var maxRowHeight_1 = itemHeight + (maxRow === 1 ? 0 : itemMarginBottom);
      this.pageHeight = maxRowHeight_1 * maxRow;
      each$1(subGroups, function(item) {
        var bbox = item.getBBox();
        var width = itemWidth || bbox.width;
        if (widthLimit && widthLimit < currentPoint.x + width + itemSpacing || maxWidth < currentPoint.x + width + itemSpacing + navigationBBox.width) {
          if (pages === 1) {
            widthLimit = currentPoint.x + itemSpacing;
            _this.pageWidth = widthLimit;
            _this.moveElementTo(navigation, {
              x: maxWidth - itemSpacing - navigationBBox.width - navigationBBox.minX,
              y: currentPoint.y + itemHeight / 2 - navigationBBox.height / 2 - navigationBBox.minY
            });
          }
          pages += 1;
          currentPoint.x = startX;
          currentPoint.y += maxRowHeight_1;
        }
        _this.moveElementTo(item, currentPoint);
        item.getParent().setClip({
          type: "rect",
          attrs: {
            x: currentPoint.x,
            y: currentPoint.y,
            width: width + itemSpacing,
            height: itemHeight
          }
        });
        currentPoint.x += width + itemSpacing;
      });
    } else {
      each$1(subGroups, function(item) {
        var bbox = item.getBBox();
        if (bbox.width > pageWidth) {
          pageWidth = bbox.width;
        }
      });
      maxItemWidth = pageWidth;
      pageWidth += itemSpacing;
      if (maxWidth) {
        pageWidth = Math.min(maxWidth, pageWidth);
        maxItemWidth = Math.min(maxWidth, maxItemWidth);
      }
      this.pageWidth = pageWidth;
      this.pageHeight = maxHeight - Math.max(navigationBBox.height, itemHeight + itemMarginBottom);
      var cntPerPage_1 = Math.floor(this.pageHeight / (itemHeight + itemMarginBottom));
      each$1(subGroups, function(item, index2) {
        if (index2 !== 0 && index2 % cntPerPage_1 === 0) {
          pages += 1;
          currentPoint.x += pageWidth;
          currentPoint.y = startY;
        }
        _this.moveElementTo(item, currentPoint);
        item.getParent().setClip({
          type: "rect",
          attrs: {
            x: currentPoint.x,
            y: currentPoint.y,
            width: pageWidth,
            height: itemHeight
          }
        });
        currentPoint.y += itemHeight + itemMarginBottom;
      });
      this.totalPagesCnt = pages;
      this.moveElementTo(navigation, {
        x: startX + maxItemWidth / 2 - navigationBBox.width / 2 - navigationBBox.minX,
        y: maxHeight - navigationBBox.height - navigationBBox.minY
      });
    }
    if (this.pageHeight && this.pageWidth) {
      itemGroup.getParent().setClip({
        type: "rect",
        attrs: {
          x: this.startX,
          y: this.startY,
          width: this.pageWidth,
          height: this.pageHeight
        }
      });
    }
    if (layout === "horizontal" && this.get("maxRow")) {
      this.totalPagesCnt = Math.ceil(pages / this.get("maxRow"));
    } else {
      this.totalPagesCnt = pages;
    }
    if (this.currentPageIndex > this.totalPagesCnt) {
      this.currentPageIndex = 1;
    }
    this.updateNavigation(navigation);
    itemGroup.attr("matrix", this.getCurrentNavigationMatrix());
  };
  Category2.prototype.drawNavigation = function(group2, layout, text2, styleCfg) {
    var currentPoint = { x: 0, y: 0 };
    var subGroup = this.addGroup(group2, {
      id: this.getElementId("navigation-group"),
      name: "legend-navigation"
    });
    var _a2 = get(styleCfg.marker, "style", {}), _b = _a2.size, size2 = _b === void 0 ? 12 : _b, arrowStyle = __rest(_a2, ["size"]);
    var leftArrow = this.drawArrow(subGroup, currentPoint, "navigation-arrow-left", layout === "horizontal" ? "up" : "left", size2, arrowStyle);
    leftArrow.on("click", this.onNavigationBack);
    var leftArrowBBox = leftArrow.getBBox();
    currentPoint.x += leftArrowBBox.width + 2;
    var textShape = this.addShape(subGroup, {
      type: "text",
      id: this.getElementId("navigation-text"),
      name: "navigation-text",
      attrs: __assign$1({ x: currentPoint.x, y: currentPoint.y + size2 / 2, text: text2, textBaseline: "middle" }, get(styleCfg.text, "style"))
    });
    var textBBox = textShape.getBBox();
    currentPoint.x += textBBox.width + 2;
    var rightArrow = this.drawArrow(subGroup, currentPoint, "navigation-arrow-right", layout === "horizontal" ? "down" : "right", size2, arrowStyle);
    rightArrow.on("click", this.onNavigationAfter);
    return subGroup;
  };
  Category2.prototype.updateNavigation = function(navigation) {
    var pageNavigator = deepMix({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator"));
    var _a2 = pageNavigator.marker.style, fill = _a2.fill, opacity = _a2.opacity, inactiveFill = _a2.inactiveFill, inactiveOpacity = _a2.inactiveOpacity;
    var text2 = this.currentPageIndex + "/" + this.totalPagesCnt;
    var textShape = navigation ? navigation.getChildren()[1] : this.getElementByLocalId("navigation-text");
    var leftArrow = navigation ? navigation.findById(this.getElementId("navigation-arrow-left")) : this.getElementByLocalId("navigation-arrow-left");
    var rightArrow = navigation ? navigation.findById(this.getElementId("navigation-arrow-right")) : this.getElementByLocalId("navigation-arrow-right");
    var origBBox = textShape.getBBox();
    textShape.attr("text", text2);
    var newBBox = textShape.getBBox();
    textShape.attr("x", textShape.attr("x") - (newBBox.width - origBBox.width) / 2);
    leftArrow.attr("opacity", this.currentPageIndex === 1 ? inactiveOpacity : opacity);
    leftArrow.attr("fill", this.currentPageIndex === 1 ? inactiveFill : fill);
    leftArrow.attr("cursor", this.currentPageIndex === 1 ? "not-allowed" : "pointer");
    rightArrow.attr("opacity", this.currentPageIndex === this.totalPagesCnt ? inactiveOpacity : opacity);
    rightArrow.attr("fill", this.currentPageIndex === this.totalPagesCnt ? inactiveFill : fill);
    rightArrow.attr("cursor", this.currentPageIndex === this.totalPagesCnt ? "not-allowed" : "pointer");
  };
  Category2.prototype.drawArrow = function(group2, currentPoint, name, direction2, size2, style) {
    var x = currentPoint.x, y = currentPoint.y;
    var rotateMap = {
      right: 90 * Math.PI / 180,
      left: (360 - 90) * Math.PI / 180,
      up: 0,
      down: 180 * Math.PI / 180
    };
    var shape = this.addShape(group2, {
      type: "path",
      id: this.getElementId(name),
      name,
      attrs: __assign$1({ path: [["M", x + size2 / 2, y], ["L", x, y + size2], ["L", x + size2, y + size2], ["Z"]], cursor: "pointer" }, style)
    });
    shape.attr("matrix", getMatrixByAngle({ x: x + size2 / 2, y: y + size2 / 2 }, rotateMap[direction2]));
    return shape;
  };
  Category2.prototype.getCurrentNavigationMatrix = function() {
    var _a2 = this, currentPageIndex = _a2.currentPageIndex, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
    var layout = this.get("layout");
    var translate2 = layout === "horizontal" ? {
      x: 0,
      y: pageHeight * (1 - currentPageIndex)
    } : {
      x: pageWidth * (1 - currentPageIndex),
      y: 0
    };
    return getMatrixByTranslate(translate2);
  };
  Category2.prototype.applyItemStates = function(item, subGroup) {
    var states = this.getItemStates(item);
    var hasStates = states.length > 0;
    if (hasStates) {
      var children = subGroup.getChildren();
      var itemStates_1 = this.get("itemStates");
      each$1(children, function(element) {
        var name = element.get("name");
        var elName = name.split("-")[2];
        var statesStyle = getStatesStyle(item, elName, itemStates_1);
        if (statesStyle) {
          element.attr(statesStyle);
          if (elName === "marker" && !(element.get("isStroke") && element.get("isFill"))) {
            if (element.get("isStroke")) {
              element.attr("fill", null);
            }
            if (element.get("isFill")) {
              element.attr("stroke", null);
            }
          }
        }
      });
    }
  };
  Category2.prototype.getLimitItemWidth = function() {
    var itemWidth = this.get("itemWidth");
    var maxItemWidth = this.get("maxItemWidth");
    if (maxItemWidth) {
      if (itemWidth) {
        maxItemWidth = itemWidth <= maxItemWidth ? itemWidth : maxItemWidth;
      }
    } else if (itemWidth) {
      maxItemWidth = itemWidth;
    }
    return maxItemWidth;
  };
  return Category2;
}(LegendBase);
var HANDLER_HEIGHT_RATIO = 1.4;
var HANDLER_TRIANGLE_RATIO = 0.4;
var ContinueLegend = function(_super) {
  __extends$2(ContinueLegend2, _super);
  function ContinueLegend2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ContinueLegend2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { type: "continue", min: 0, max: 100, value: null, colors: [], track: {}, rail: {}, label: {}, handler: {}, slidable: true, tip: null, step: null, maxWidth: null, maxHeight: null, defaultCfg: {
      label: {
        align: "rail",
        spacing: 5,
        formatter: null,
        style: {
          fontSize: 12,
          fill: Theme.textColor,
          textBaseline: "middle",
          fontFamily: Theme.fontFamily
        }
      },
      handler: {
        size: 10,
        style: {
          fill: "#fff",
          stroke: "#333"
        }
      },
      track: {},
      rail: {
        type: "color",
        size: 20,
        defaultLength: 100,
        style: {
          fill: "#DCDEE2"
        }
      },
      title: {
        spacing: 5,
        style: {
          fill: Theme.textColor,
          fontSize: 12,
          textAlign: "start",
          textBaseline: "top"
        }
      }
    } });
  };
  ContinueLegend2.prototype.isSlider = function() {
    return true;
  };
  ContinueLegend2.prototype.getValue = function() {
    return this.getCurrentValue();
  };
  ContinueLegend2.prototype.getRange = function() {
    return {
      min: this.get("min"),
      max: this.get("max")
    };
  };
  ContinueLegend2.prototype.setRange = function(min2, max2) {
    this.update({
      min: min2,
      max: max2
    });
  };
  ContinueLegend2.prototype.setValue = function(value2) {
    var originValue = this.getValue();
    this.set("value", value2);
    var group2 = this.get("group");
    this.resetTrackClip();
    if (this.get("slidable")) {
      this.resetHandlers(group2);
    }
    this.delegateEmit("valuechanged", {
      originValue,
      value: value2
    });
  };
  ContinueLegend2.prototype.initEvent = function() {
    var group2 = this.get("group");
    this.bindSliderEvent(group2);
    this.bindRailEvent(group2);
    this.bindTrackEvent(group2);
  };
  ContinueLegend2.prototype.drawLegendContent = function(group2) {
    this.drawRail(group2);
    this.drawLabels(group2);
    this.fixedElements(group2);
    this.resetTrack(group2);
    this.resetTrackClip(group2);
    if (this.get("slidable")) {
      this.resetHandlers(group2);
    }
  };
  ContinueLegend2.prototype.bindSliderEvent = function(group2) {
    this.bindHandlersEvent(group2);
  };
  ContinueLegend2.prototype.bindHandlersEvent = function(group2) {
    var _this = this;
    group2.on("legend-handler-min:drag", function(ev) {
      var minValue = _this.getValueByCanvasPoint(ev.x, ev.y);
      var currentValue = _this.getCurrentValue();
      var maxValue = currentValue[1];
      if (maxValue < minValue) {
        maxValue = minValue;
      }
      _this.setValue([minValue, maxValue]);
    });
    group2.on("legend-handler-max:drag", function(ev) {
      var maxValue = _this.getValueByCanvasPoint(ev.x, ev.y);
      var currentValue = _this.getCurrentValue();
      var minValue = currentValue[0];
      if (minValue > maxValue) {
        minValue = maxValue;
      }
      _this.setValue([minValue, maxValue]);
    });
  };
  ContinueLegend2.prototype.bindRailEvent = function(group2) {
  };
  ContinueLegend2.prototype.bindTrackEvent = function(group2) {
    var _this = this;
    var prePoint = null;
    group2.on("legend-track:dragstart", function(ev) {
      prePoint = {
        x: ev.x,
        y: ev.y
      };
    });
    group2.on("legend-track:drag", function(ev) {
      if (!prePoint) {
        return;
      }
      var preValue = _this.getValueByCanvasPoint(prePoint.x, prePoint.y);
      var curValue = _this.getValueByCanvasPoint(ev.x, ev.y);
      var currentValue = _this.getCurrentValue();
      var curDiff = currentValue[1] - currentValue[0];
      var range = _this.getRange();
      var dValue = curValue - preValue;
      if (dValue < 0) {
        if (currentValue[0] + dValue > range.min) {
          _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
        } else {
          _this.setValue([range.min, range.min + curDiff]);
        }
      } else if (dValue > 0) {
        if (dValue > 0 && currentValue[1] + dValue < range.max) {
          _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
        } else {
          _this.setValue([range.max - curDiff, range.max]);
        }
      }
      prePoint = {
        x: ev.x,
        y: ev.y
      };
    });
    group2.on("legend-track:dragend", function(ev) {
      prePoint = null;
    });
  };
  ContinueLegend2.prototype.drawLabels = function(group2) {
    this.drawLabel("min", group2);
    this.drawLabel("max", group2);
  };
  ContinueLegend2.prototype.drawLabel = function(name, group2) {
    var labelCfg = this.get("label");
    var style = labelCfg.style;
    var labelAlign = labelCfg.align;
    var labelFormatter = labelCfg.formatter;
    var value2 = this.get(name);
    var alignAttrs = this.getLabelAlignAttrs(name, labelAlign);
    var localId = "label-" + name;
    this.addShape(group2, {
      type: "text",
      id: this.getElementId(localId),
      name: "legend-label-" + name,
      attrs: __assign$1(__assign$1({ x: 0, y: 0, text: isFunction(labelFormatter) ? labelFormatter(value2) : value2 }, style), alignAttrs)
    });
  };
  ContinueLegend2.prototype.getLabelAlignAttrs = function(name, align) {
    var isVertical2 = this.isVertical();
    var textAlign = "center";
    var textBaseline = "middle";
    if (isVertical2) {
      textAlign = "start";
      if (align !== "rail") {
        if (name === "min") {
          textBaseline = "top";
        } else {
          textBaseline = "bottom";
        }
      } else {
        textBaseline = "top";
      }
    } else {
      if (align !== "rail") {
        textBaseline = "top";
        if (name === "min") {
          textAlign = "start";
        } else {
          textAlign = "end";
        }
      } else {
        textAlign = "start";
        textBaseline = "middle";
      }
    }
    return {
      textAlign,
      textBaseline
    };
  };
  ContinueLegend2.prototype.getRailPath = function(x, y, w, h) {
    var railCfg = this.get("rail");
    var size2 = railCfg.size, defaultLength = railCfg.defaultLength, type = railCfg.type;
    var isVertical2 = this.isVertical();
    var length2 = defaultLength;
    var width = w;
    var height = h;
    if (!width) {
      width = isVertical2 ? size2 : length2;
    }
    if (!height) {
      height = isVertical2 ? length2 : size2;
    }
    var path2 = [];
    if (type === "color") {
      path2.push(["M", x, y]);
      path2.push(["L", x + width, y]);
      path2.push(["L", x + width, y + height]);
      path2.push(["L", x, y + height]);
      path2.push(["Z"]);
    } else {
      path2.push(["M", x + width, y]);
      path2.push(["L", x + width, y + height]);
      path2.push(["L", x, y + height]);
      path2.push(["Z"]);
    }
    return path2;
  };
  ContinueLegend2.prototype.drawRail = function(group2) {
    var railCfg = this.get("rail");
    var style = railCfg.style;
    this.addShape(group2, {
      type: "path",
      id: this.getElementId("rail"),
      name: "legend-rail",
      attrs: __assign$1({ path: this.getRailPath(0, 0) }, style)
    });
  };
  ContinueLegend2.prototype.getTrackColor = function(colors) {
    var count = colors.length;
    if (!count) {
      return null;
    }
    if (count === 1) {
      return colors[0];
    }
    var color2;
    if (this.isVertical()) {
      color2 = "l(90)";
    } else {
      color2 = "l(0)";
    }
    for (var i = 0; i < count; i++) {
      var percent2 = i / (count - 1);
      color2 += " " + percent2 + ":" + colors[i];
    }
    return color2;
  };
  ContinueLegend2.prototype.getTrackPath = function(group2) {
    var railShape = this.getRailShape(group2);
    var path2 = railShape.attr("path");
    return clone(path2);
  };
  ContinueLegend2.prototype.getClipTrackAttrs = function(group2) {
    var value2 = this.getCurrentValue();
    var min2 = value2[0], max2 = value2[1];
    var railBBox = this.getRailBBox(group2);
    var startPoint = this.getPointByValue(min2, group2);
    var endPoint = this.getPointByValue(max2, group2);
    var isVertical2 = this.isVertical();
    var x;
    var y;
    var width;
    var height;
    if (isVertical2) {
      x = railBBox.minX;
      y = startPoint.y;
      width = railBBox.width;
      height = endPoint.y - startPoint.y;
    } else {
      x = startPoint.x;
      y = railBBox.minY;
      width = endPoint.x - startPoint.x;
      height = railBBox.height;
    }
    return {
      x,
      y,
      width,
      height
    };
  };
  ContinueLegend2.prototype.getTrackAttrs = function(group2) {
    var trackCfg = this.get("track");
    var colors = this.get("colors");
    var path2 = this.getTrackPath(group2);
    return mix({
      path: path2,
      fill: this.getTrackColor(colors)
    }, trackCfg.style);
  };
  ContinueLegend2.prototype.resetTrackClip = function(group2) {
    var container = group2 || this.get("group");
    var trackId = this.getElementId("track");
    var trackShape = container.findById(trackId);
    var clipShape = trackShape.getClip();
    var attrs = this.getClipTrackAttrs(group2);
    if (!clipShape) {
      trackShape.setClip({
        type: "rect",
        attrs
      });
    } else {
      clipShape.attr(attrs);
    }
  };
  ContinueLegend2.prototype.resetTrack = function(group2) {
    var trackId = this.getElementId("track");
    var trackShape = group2.findById(trackId);
    var trackAttrs = this.getTrackAttrs(group2);
    if (trackShape) {
      trackShape.attr(trackAttrs);
    } else {
      this.addShape(group2, {
        type: "path",
        id: trackId,
        draggable: this.get("slidable"),
        name: "legend-track",
        attrs: trackAttrs
      });
    }
  };
  ContinueLegend2.prototype.getPointByValue = function(value2, group2) {
    var _a2 = this.getRange(), min2 = _a2.min, max2 = _a2.max;
    var percent2 = (value2 - min2) / (max2 - min2);
    var bbox = this.getRailBBox(group2);
    var isVertcal = this.isVertical();
    var point2 = { x: 0, y: 0 };
    if (isVertcal) {
      point2.x = bbox.minX + bbox.width / 2;
      point2.y = getValueByPercent(bbox.minY, bbox.maxY, percent2);
    } else {
      point2.x = getValueByPercent(bbox.minX, bbox.maxX, percent2);
      point2.y = bbox.minY + bbox.height / 2;
    }
    return point2;
  };
  ContinueLegend2.prototype.getRailShape = function(group2) {
    var container = group2 || this.get("group");
    return container.findById(this.getElementId("rail"));
  };
  ContinueLegend2.prototype.getRailBBox = function(group2) {
    var railShape = this.getRailShape(group2);
    var bbox = railShape.getBBox();
    return bbox;
  };
  ContinueLegend2.prototype.getRailCanvasBBox = function() {
    var container = this.get("group");
    var railShape = container.findById(this.getElementId("rail"));
    var bbox = railShape.getCanvasBBox();
    return bbox;
  };
  ContinueLegend2.prototype.isVertical = function() {
    return this.get("layout") === "vertical";
  };
  ContinueLegend2.prototype.getValueByCanvasPoint = function(x, y) {
    var _a2 = this.getRange(), min2 = _a2.min, max2 = _a2.max;
    var bbox = this.getRailCanvasBBox();
    var isVertcal = this.isVertical();
    var step = this.get("step");
    var percent2;
    if (isVertcal) {
      percent2 = (y - bbox.minY) / bbox.height;
    } else {
      percent2 = (x - bbox.minX) / bbox.width;
    }
    var value2 = getValueByPercent(min2, max2, percent2);
    if (step) {
      var count = Math.round((value2 - min2) / step);
      value2 = min2 + count * step;
    }
    if (value2 > max2) {
      value2 = max2;
    }
    if (value2 < min2) {
      value2 = min2;
    }
    return value2;
  };
  ContinueLegend2.prototype.getCurrentValue = function() {
    var value2 = this.get("value");
    if (!value2) {
      var values2 = this.get("values");
      if (!values2) {
        return [this.get("min"), this.get("max")];
      }
      return [Math.max(Math.min.apply(Math, __spreadArrays(values2, [this.get("max")])), this.get("min")), Math.min(Math.max.apply(Math, __spreadArrays(values2, [this.get("min")])), this.get("max"))];
    }
    return value2;
  };
  ContinueLegend2.prototype.resetHandlers = function(group2) {
    var currentValue = this.getCurrentValue();
    var min2 = currentValue[0], max2 = currentValue[1];
    this.resetHandler(group2, "min", min2);
    this.resetHandler(group2, "max", max2);
  };
  ContinueLegend2.prototype.getHandlerPath = function(handlerCfg, point2) {
    var isVertical2 = this.isVertical();
    var path2 = [];
    var width = handlerCfg.size;
    var x = point2.x, y = point2.y;
    var height = width * HANDLER_HEIGHT_RATIO;
    var halfWidth = width / 2;
    var oneSixthWidth = width / 6;
    if (isVertical2) {
      var triangleX = x + height * HANDLER_TRIANGLE_RATIO;
      path2.push(["M", x, y]);
      path2.push(["L", triangleX, y + halfWidth]);
      path2.push(["L", x + height, y + halfWidth]);
      path2.push(["L", x + height, y - halfWidth]);
      path2.push(["L", triangleX, y - halfWidth]);
      path2.push(["Z"]);
      path2.push(["M", triangleX, y + oneSixthWidth]);
      path2.push(["L", x + height - 2, y + oneSixthWidth]);
      path2.push(["M", triangleX, y - oneSixthWidth]);
      path2.push(["L", x + height - 2, y - oneSixthWidth]);
    } else {
      var triangleY = y + height * HANDLER_TRIANGLE_RATIO;
      path2.push(["M", x, y]);
      path2.push(["L", x - halfWidth, triangleY]);
      path2.push(["L", x - halfWidth, y + height]);
      path2.push(["L", x + halfWidth, y + height]);
      path2.push(["L", x + halfWidth, triangleY]);
      path2.push(["Z"]);
      path2.push(["M", x - oneSixthWidth, triangleY]);
      path2.push(["L", x - oneSixthWidth, y + height - 2]);
      path2.push(["M", x + oneSixthWidth, triangleY]);
      path2.push(["L", x + oneSixthWidth, y + height - 2]);
    }
    return path2;
  };
  ContinueLegend2.prototype.resetHandler = function(group2, name, value2) {
    var point2 = this.getPointByValue(value2, group2);
    var handlerCfg = this.get("handler");
    var path2 = this.getHandlerPath(handlerCfg, point2);
    var id = this.getElementId("handler-" + name);
    var handlerShape = group2.findById(id);
    var isVertical2 = this.isVertical();
    if (handlerShape) {
      handlerShape.attr("path", path2);
    } else {
      this.addShape(group2, {
        type: "path",
        name: "legend-handler-" + name,
        draggable: true,
        id,
        attrs: __assign$1(__assign$1({ path: path2 }, handlerCfg.style), { cursor: isVertical2 ? "ns-resize" : "ew-resize" })
      });
    }
  };
  ContinueLegend2.prototype.fixedElements = function(group2) {
    var railShape = group2.findById(this.getElementId("rail"));
    var minLabel = group2.findById(this.getElementId("label-min"));
    var maxLabel = group2.findById(this.getElementId("label-max"));
    var startPoint = this.getDrawPoint();
    if (this.isVertical()) {
      this.fixedVertail(minLabel, maxLabel, railShape, startPoint);
    } else {
      this.fixedHorizontal(minLabel, maxLabel, railShape, startPoint);
    }
  };
  ContinueLegend2.prototype.fitRailLength = function(minLabelBBox, maxLabelBBox, railBBox, railShape) {
    var isVertical2 = this.isVertical();
    var lengthField = isVertical2 ? "height" : "width";
    var labelCfg = this.get("label");
    var labelAlign = labelCfg.align;
    var spacing = labelCfg.spacing;
    var maxLength = this.get("max" + upperFirst(lengthField));
    if (maxLength) {
      var elementsLength = labelAlign === "rail" ? railBBox[lengthField] + minLabelBBox[lengthField] + maxLabelBBox[lengthField] + spacing * 2 : railBBox[lengthField];
      var diff2 = elementsLength - maxLength;
      if (diff2 > 0) {
        this.changeRailLength(railShape, lengthField, railBBox[lengthField] - diff2);
      }
    }
  };
  ContinueLegend2.prototype.changeRailLength = function(railShape, lengthField, length2) {
    var bbox = railShape.getBBox();
    var path2;
    if (lengthField === "height") {
      path2 = this.getRailPath(bbox.x, bbox.y, bbox.width, length2);
    } else {
      path2 = this.getRailPath(bbox.x, bbox.y, length2, bbox.height);
    }
    railShape.attr("path", path2);
  };
  ContinueLegend2.prototype.changeRailPosition = function(railShape, x, y) {
    var bbox = railShape.getBBox();
    var path2 = this.getRailPath(x, y, bbox.width, bbox.height);
    railShape.attr("path", path2);
  };
  ContinueLegend2.prototype.fixedHorizontal = function(minLabel, maxLabel, railShape, startPoint) {
    var labelCfg = this.get("label");
    var labelAlign = labelCfg.align;
    var spacing = labelCfg.spacing;
    var railBBox = railShape.getBBox();
    var minLabelBBox = minLabel.getBBox();
    var maxLabelBBox = maxLabel.getBBox();
    var railHeight = railBBox.height;
    this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
    railBBox = railShape.getBBox();
    if (labelAlign === "rail") {
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y + railHeight / 2
      });
      this.changeRailPosition(railShape, startPoint.x + minLabelBBox.width + spacing, startPoint.y);
      maxLabel.attr({
        x: startPoint.x + minLabelBBox.width + railBBox.width + spacing * 2,
        y: startPoint.y + railHeight / 2
      });
    } else if (labelAlign === "top") {
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y
      });
      maxLabel.attr({
        x: startPoint.x + railBBox.width,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
    } else {
      this.changeRailPosition(railShape, startPoint.x, startPoint.y);
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y + railBBox.height + spacing
      });
      maxLabel.attr({
        x: startPoint.x + railBBox.width,
        y: startPoint.y + railBBox.height + spacing
      });
    }
  };
  ContinueLegend2.prototype.fixedVertail = function(minLabel, maxLabel, railShape, startPoint) {
    var labelCfg = this.get("label");
    var labelAlign = labelCfg.align;
    var spacing = labelCfg.spacing;
    var railBBox = railShape.getBBox();
    var minLabelBBox = minLabel.getBBox();
    var maxLabelBBox = maxLabel.getBBox();
    this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
    railBBox = railShape.getBBox();
    if (labelAlign === "rail") {
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
      maxLabel.attr({
        x: startPoint.x,
        y: startPoint.y + minLabelBBox.height + railBBox.height + spacing * 2
      });
    } else if (labelAlign === "right") {
      minLabel.attr({
        x: startPoint.x + railBBox.width + spacing,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x, startPoint.y);
      maxLabel.attr({
        x: startPoint.x + railBBox.width + spacing,
        y: startPoint.y + railBBox.height
      });
    } else {
      var maxLabelWidth = Math.max(minLabelBBox.width, maxLabelBBox.width);
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x + maxLabelWidth + spacing, startPoint.y);
      maxLabel.attr({
        x: startPoint.x,
        y: startPoint.y + railBBox.height
      });
    }
  };
  return ContinueLegend2;
}(LegendBase);
var CONTAINER_CLASS = "g2-tooltip";
var TITLE_CLASS = "g2-tooltip-title";
var LIST_CLASS = "g2-tooltip-list";
var LIST_ITEM_CLASS = "g2-tooltip-list-item";
var MARKER_CLASS = "g2-tooltip-marker";
var VALUE_CLASS = "g2-tooltip-value";
var NAME_CLASS = "g2-tooltip-name";
var CROSSHAIR_X = "g2-tooltip-crosshair-x";
var CROSSHAIR_Y = "g2-tooltip-crosshair-y";
var CssConst = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  CONTAINER_CLASS,
  TITLE_CLASS,
  LIST_CLASS,
  LIST_ITEM_CLASS,
  MARKER_CLASS,
  VALUE_CLASS,
  NAME_CLASS,
  CROSSHAIR_X,
  CROSSHAIR_Y
});
var _a$3;
var TooltipTheme = (_a$3 = {}, _a$3["" + CONTAINER_CLASS] = {
  position: "absolute",
  visibility: "visible",
  zIndex: 8,
  transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
  backgroundColor: "rgba(255, 255, 255, 0.9)",
  boxShadow: "0px 0px 10px #aeaeae",
  borderRadius: "3px",
  color: "rgb(87, 87, 87)",
  fontSize: "12px",
  fontFamily: Theme.fontFamily,
  lineHeight: "20px",
  padding: "10px 10px 6px 10px"
}, _a$3["" + TITLE_CLASS] = {
  marginBottom: "4px"
}, _a$3["" + LIST_CLASS] = {
  margin: "0px",
  listStyleType: "none",
  padding: "0px"
}, _a$3["" + LIST_ITEM_CLASS] = {
  listStyleType: "none",
  marginBottom: "4px"
}, _a$3["" + MARKER_CLASS] = {
  width: "8px",
  height: "8px",
  borderRadius: "50%",
  display: "inline-block",
  marginRight: "8px"
}, _a$3["" + VALUE_CLASS] = {
  display: "inline-block",
  float: "right",
  marginLeft: "30px"
}, _a$3["" + CROSSHAIR_X] = {
  position: "absolute",
  width: "1px",
  backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a$3["" + CROSSHAIR_Y] = {
  position: "absolute",
  height: "1px",
  backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a$3);
function getOutSides(x, y, width, height, limitBox) {
  var hits = {
    left: x < limitBox.x,
    right: x + width > limitBox.x + limitBox.width,
    top: y < limitBox.y,
    bottom: y + height > limitBox.y + limitBox.height
  };
  return hits;
}
function getPointByPosition(x, y, offset, width, height, position) {
  var px = x;
  var py = y;
  switch (position) {
    case "left":
      px = x - width - offset;
      py = y - height / 2;
      break;
    case "right":
      px = x + offset;
      py = y - height / 2;
      break;
    case "top":
      px = x - width / 2;
      py = y - height - offset;
      break;
    case "bottom":
      px = x - width / 2;
      py = y + offset;
      break;
    default:
      px = x + offset;
      py = y - height - offset;
      break;
  }
  return {
    x: px,
    y: py
  };
}
function getAlignPoint(x, y, offset, width, height, position, limitBox) {
  var point2 = getPointByPosition(x, y, offset, width, height, position);
  if (limitBox) {
    var outSides = getOutSides(point2.x, point2.y, width, height, limitBox);
    if (position === "auto") {
      if (outSides.right) {
        point2.x = Math.max(0, x - width - offset);
      }
      if (outSides.top) {
        point2.y = Math.max(0, y - height - offset);
      }
    } else if (position === "top" || position === "bottom") {
      if (outSides.left) {
        point2.x = limitBox.x;
      }
      if (outSides.right) {
        point2.x = limitBox.x + limitBox.width - width;
      }
      if (position === "top" && outSides.top) {
        point2.y = y + offset;
      }
      if (position === "bottom" && outSides.bottom) {
        point2.y = y - height - offset;
      }
    } else {
      if (outSides.top) {
        point2.y = limitBox.y;
      }
      if (outSides.bottom) {
        point2.y = limitBox.y + limitBox.height - height;
      }
      if (position === "left" && outSides.left) {
        point2.x = x + offset;
      }
      if (position === "right" && outSides.right) {
        point2.x = x - width - offset;
      }
    }
  }
  return point2;
}
function hasOneKey(obj, keys2) {
  var result = false;
  each$1(keys2, function(key) {
    if (has(obj, key)) {
      result = true;
      return false;
    }
  });
  return result;
}
var Tooltip$1 = function(_super) {
  __extends$2(Tooltip2, _super);
  function Tooltip2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Tooltip2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), {
      name: "tooltip",
      type: "html",
      x: 0,
      y: 0,
      items: [],
      customContent: null,
      containerTpl: '<div class="' + CONTAINER_CLASS + '"><div class="' + TITLE_CLASS + '"></div><ul class="' + LIST_CLASS + '"></ul></div>',
      itemTpl: '<li class="' + LIST_ITEM_CLASS + '" data-index={index}>\n          <span class="' + MARKER_CLASS + '" style="background:{color}"></span>\n          <span class="' + NAME_CLASS + '">{name}</span>:\n          <span class="' + VALUE_CLASS + '">{value}</span>\n        </li>',
      xCrosshairTpl: '<div class="' + CROSSHAIR_X + '"></div>',
      yCrosshairTpl: '<div class="' + CROSSHAIR_Y + '"></div>',
      title: null,
      showTitle: true,
      region: null,
      crosshairsRegion: null,
      containerClassName: CONTAINER_CLASS,
      crosshairs: null,
      offset: 10,
      position: "right",
      domStyles: null,
      defaultStyles: TooltipTheme
    });
  };
  Tooltip2.prototype.render = function() {
    if (this.get("customContent")) {
      this.renderCustomContent();
    } else {
      this.resetTitle();
      this.renderItems();
    }
    this.resetPosition();
  };
  Tooltip2.prototype.clear = function() {
    this.clearCrosshairs();
    this.setTitle("");
    this.clearItemDoms();
  };
  Tooltip2.prototype.show = function() {
    var container = this.getContainer();
    if (!container || this.destroyed) {
      return;
    }
    this.set("visible", true);
    modifyCSS(container, {
      visibility: "visible"
    });
    this.setCrossHairsVisible(true);
  };
  Tooltip2.prototype.hide = function() {
    var container = this.getContainer();
    if (!container || this.destroyed) {
      return;
    }
    this.set("visible", false);
    modifyCSS(container, {
      visibility: "hidden"
    });
    this.setCrossHairsVisible(false);
  };
  Tooltip2.prototype.getLocation = function() {
    return { x: this.get("x"), y: this.get("y") };
  };
  Tooltip2.prototype.setLocation = function(point2) {
    this.set("x", point2.x);
    this.set("y", point2.y);
    this.resetPosition();
  };
  Tooltip2.prototype.setCrossHairsVisible = function(visible) {
    var display = visible ? "" : "none";
    var xCrosshairDom = this.get("xCrosshairDom");
    var yCrosshairDom = this.get("yCrosshairDom");
    xCrosshairDom && modifyCSS(xCrosshairDom, {
      display
    });
    yCrosshairDom && modifyCSS(yCrosshairDom, {
      display
    });
  };
  Tooltip2.prototype.initContainer = function() {
    _super.prototype.initContainer.call(this);
    if (this.get("customContent")) {
      if (this.get("container")) {
        this.get("container").remove();
      }
      var container = this.getHtmlContentNode();
      this.get("parent").appendChild(container);
      this.set("container", container);
      this.resetStyles();
      this.applyStyles();
    }
  };
  Tooltip2.prototype.updateInner = function(cfg) {
    if (this.get("customContent")) {
      this.renderCustomContent();
    } else {
      if (hasOneKey(cfg, ["title", "showTitle"])) {
        this.resetTitle();
      }
      if (has(cfg, "items")) {
        this.renderItems();
      }
    }
    _super.prototype.updateInner.call(this, cfg);
  };
  Tooltip2.prototype.initDom = function() {
    this.cacheDoms();
  };
  Tooltip2.prototype.removeDom = function() {
    _super.prototype.removeDom.call(this);
    this.clearCrosshairs();
  };
  Tooltip2.prototype.resetPosition = function() {
    var x = this.get("x");
    var y = this.get("y");
    var offset = this.get("offset");
    var _a2 = this.getOffset(), offsetX = _a2.offsetX, offsetY = _a2.offsetY;
    var position = this.get("position");
    var region = this.get("region");
    var container = this.getContainer();
    var bbox = this.getBBox();
    var width = bbox.width, height = bbox.height;
    var limitBox;
    if (region) {
      limitBox = regionToBBox(region);
    }
    var point2 = getAlignPoint(x, y, offset, width, height, position, limitBox);
    modifyCSS(container, {
      left: toPx(point2.x + offsetX),
      top: toPx(point2.y + offsetY)
    });
    this.resetCrosshairs();
  };
  Tooltip2.prototype.renderCustomContent = function() {
    var node = this.getHtmlContentNode();
    var parent = this.get("parent");
    var curContainer = this.get("container");
    if (curContainer && curContainer.parentNode === parent) {
      parent.replaceChild(node, curContainer);
    } else {
      parent.appendChild(node);
    }
    this.set("container", node);
    this.resetStyles();
    this.applyStyles();
  };
  Tooltip2.prototype.getHtmlContentNode = function() {
    var node;
    var customContent = this.get("customContent");
    if (customContent) {
      var elem = customContent(this.get("title"), this.get("items"));
      if (isElement(elem)) {
        node = elem;
      } else {
        node = createDom$1(elem);
      }
    }
    return node;
  };
  Tooltip2.prototype.cacheDoms = function() {
    var container = this.getContainer();
    var titleDom = container.getElementsByClassName(TITLE_CLASS)[0];
    var listDom = container.getElementsByClassName(LIST_CLASS)[0];
    this.set("titleDom", titleDom);
    this.set("listDom", listDom);
  };
  Tooltip2.prototype.resetTitle = function() {
    var title = this.get("title");
    var showTitle = this.get("showTitle");
    if (showTitle && title) {
      this.setTitle(title);
    } else {
      this.setTitle("");
    }
  };
  Tooltip2.prototype.setTitle = function(text2) {
    var titleDom = this.get("titleDom");
    if (titleDom) {
      titleDom.innerText = text2;
    }
  };
  Tooltip2.prototype.resetCrosshairs = function() {
    var crosshairsRegion = this.get("crosshairsRegion");
    var crosshairs = this.get("crosshairs");
    if (!crosshairsRegion || !crosshairs) {
      this.clearCrosshairs();
    } else {
      var crosshairBox = regionToBBox(crosshairsRegion);
      var xCrosshairDom = this.get("xCrosshairDom");
      var yCrosshairDom = this.get("yCrosshairDom");
      if (crosshairs === "x") {
        this.resetCrosshair("x", crosshairBox);
        if (yCrosshairDom) {
          yCrosshairDom.remove();
          this.set("yCrosshairDom", null);
        }
      } else if (crosshairs === "y") {
        this.resetCrosshair("y", crosshairBox);
        if (xCrosshairDom) {
          xCrosshairDom.remove();
          this.set("xCrosshairDom", null);
        }
      } else {
        this.resetCrosshair("x", crosshairBox);
        this.resetCrosshair("y", crosshairBox);
      }
      this.setCrossHairsVisible(this.get("visible"));
    }
  };
  Tooltip2.prototype.resetCrosshair = function(name, bbox) {
    var croshairDom = this.checkCrosshair(name);
    var value2 = this.get(name);
    if (name === "x") {
      modifyCSS(croshairDom, {
        left: toPx(value2),
        top: toPx(bbox.y),
        height: toPx(bbox.height)
      });
    } else {
      modifyCSS(croshairDom, {
        top: toPx(value2),
        left: toPx(bbox.x),
        width: toPx(bbox.width)
      });
    }
  };
  Tooltip2.prototype.checkCrosshair = function(name) {
    var domName = name + "CrosshairDom";
    var tplName = name + "CrosshairTpl";
    var constName = "CROSSHAIR_" + name.toUpperCase();
    var styleName = CssConst[constName];
    var croshairDom = this.get(domName);
    var parent = this.get("parent");
    if (!croshairDom) {
      croshairDom = createDom$1(this.get(tplName));
      this.applyStyle(styleName, croshairDom);
      parent.appendChild(croshairDom);
      this.set(domName, croshairDom);
    }
    return croshairDom;
  };
  Tooltip2.prototype.renderItems = function() {
    this.clearItemDoms();
    var items = this.get("items");
    var itemTpl = this.get("itemTpl");
    var listDom = this.get("listDom");
    if (listDom) {
      each$1(items, function(item) {
        var color2 = colorUtil.toCSSGradient(item.color);
        var substituteObj = __assign$1(__assign$1({}, item), { color: color2 });
        var domStr = substitute(itemTpl, substituteObj);
        var itemDom = createDom$1(domStr);
        listDom.appendChild(itemDom);
      });
      this.applyChildrenStyles(listDom, this.get("domStyles"));
    }
  };
  Tooltip2.prototype.clearItemDoms = function() {
    if (this.get("listDom")) {
      clearDom(this.get("listDom"));
    }
  };
  Tooltip2.prototype.clearCrosshairs = function() {
    var xCrosshairDom = this.get("xCrosshairDom");
    var yCrosshairDom = this.get("yCrosshairDom");
    xCrosshairDom && xCrosshairDom.remove();
    yCrosshairDom && yCrosshairDom.remove();
    this.set("xCrosshairDom", null);
    this.set("yCrosshairDom", null);
  };
  return Tooltip2;
}(HtmlComponent);
var BACKGROUND_STYLE$1 = {
  opacity: 0
};
var LINE_STYLE = {
  stroke: "#C5C5C5",
  strokeOpacity: 0.85
};
var AREA_STYLE = {
  fill: "#CACED4",
  opacity: 0.85
};
function pointsToPath(points) {
  return map$2(points, function(p, idx) {
    var command = idx === 0 ? "M" : "L";
    var x = p[0], y = p[1];
    return [command, x, y];
  });
}
function getLinePath$1(points) {
  return pointsToPath(points);
}
function getSmoothLinePath(points) {
  if (points.length <= 2) {
    return getLinePath$1(points);
  }
  var data2 = [];
  each$1(points, function(p) {
    if (!isEqual$2(p, data2.slice(data2.length - 2))) {
      data2.push(p[0], p[1]);
    }
  });
  var path2 = catmullRom2Bezier(data2, false);
  var _a2 = head(points), x = _a2[0], y = _a2[1];
  path2.unshift(["M", x, y]);
  return path2;
}
function dataToPath(data2, width, height, smooth) {
  if (smooth === void 0) {
    smooth = true;
  }
  var y = new Linear({
    values: data2
  });
  var x = new Category$1({
    values: map$2(data2, function(v, idx) {
      return idx;
    })
  });
  var points = map$2(data2, function(v, idx) {
    return [x.scale(idx) * width, height - y.scale(v) * height];
  });
  return smooth ? getSmoothLinePath(points) : getLinePath$1(points);
}
function getAreaLineY(data2, height) {
  var y = new Linear({
    values: data2
  });
  var lineY = Math.max(0, y.min);
  return height - y.scale(lineY) * height;
}
function linePathToAreaPath(path2, width, height, data2) {
  var areaPath = __spreadArrays(path2);
  var lineYPx = getAreaLineY(data2, height);
  areaPath.push(["L", width, lineYPx]);
  areaPath.push(["L", 0, lineYPx]);
  areaPath.push(["Z"]);
  return areaPath;
}
var Trend = function(_super) {
  __extends$2(Trend2, _super);
  function Trend2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Trend2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "trend", x: 0, y: 0, width: 200, height: 16, smooth: true, isArea: false, data: [], backgroundStyle: BACKGROUND_STYLE$1, lineStyle: LINE_STYLE, areaStyle: AREA_STYLE });
  };
  Trend2.prototype.renderInner = function(group2) {
    var _a2 = this.cfg, width = _a2.width, height = _a2.height, data2 = _a2.data, smooth = _a2.smooth, isArea = _a2.isArea, backgroundStyle = _a2.backgroundStyle, lineStyle = _a2.lineStyle, areaStyle = _a2.areaStyle;
    this.addShape(group2, {
      id: this.getElementId("background"),
      type: "rect",
      attrs: __assign$1({
        x: 0,
        y: 0,
        width,
        height
      }, backgroundStyle)
    });
    var path2 = dataToPath(data2, width, height, smooth);
    this.addShape(group2, {
      id: this.getElementId("line"),
      type: "path",
      attrs: __assign$1({ path: path2 }, lineStyle)
    });
    if (isArea) {
      var areaPath = linePathToAreaPath(path2, width, height, data2);
      this.addShape(group2, {
        id: this.getElementId("area"),
        type: "path",
        attrs: __assign$1({ path: areaPath }, areaStyle)
      });
    }
  };
  Trend2.prototype.applyOffset = function() {
    var _a2 = this.cfg, x = _a2.x, y = _a2.y;
    this.moveElementTo(this.get("group"), {
      x,
      y
    });
  };
  return Trend2;
}(GroupComponent);
var DEFAULT_HANDLER_STYLE = {
  fill: "#F7F7F7",
  stroke: "#BFBFBF",
  radius: 2,
  opacity: 1,
  cursor: "ew-resize",
  highLightFill: "#FFF"
};
var Handler = function(_super) {
  __extends$2(Handler2, _super);
  function Handler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Handler2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "handler", x: 0, y: 0, width: 10, height: 24, style: DEFAULT_HANDLER_STYLE });
  };
  Handler2.prototype.renderInner = function(group2) {
    var _a2 = this.cfg, width = _a2.width, height = _a2.height, style = _a2.style;
    var fill = style.fill, stroke = style.stroke, radius = style.radius, opacity = style.opacity, cursor = style.cursor;
    this.addShape(group2, {
      type: "rect",
      id: this.getElementId("background"),
      attrs: {
        x: 0,
        y: 0,
        width,
        height,
        fill,
        stroke,
        radius,
        opacity,
        cursor
      }
    });
    var x1 = 1 / 3 * width;
    var x2 = 2 / 3 * width;
    var y1 = 1 / 4 * height;
    var y2 = 3 / 4 * height;
    this.addShape(group2, {
      id: this.getElementId("line-left"),
      type: "line",
      attrs: {
        x1,
        y1,
        x2: x1,
        y2,
        stroke,
        cursor
      }
    });
    this.addShape(group2, {
      id: this.getElementId("line-right"),
      type: "line",
      attrs: {
        x1: x2,
        y1,
        x2,
        y2,
        stroke,
        cursor
      }
    });
  };
  Handler2.prototype.applyOffset = function() {
    this.moveElementTo(this.get("group"), {
      x: this.get("x"),
      y: this.get("y")
    });
  };
  Handler2.prototype.initEvent = function() {
    this.bindEvents();
  };
  Handler2.prototype.bindEvents = function() {
    var _this = this;
    this.get("group").on("mouseenter", function() {
      var highLightFill = _this.get("style").highLightFill;
      _this.getElementByLocalId("background").attr("fill", highLightFill);
      _this.draw();
    });
    this.get("group").on("mouseleave", function() {
      var fill = _this.get("style").fill;
      _this.getElementByLocalId("background").attr("fill", fill);
      _this.draw();
    });
  };
  Handler2.prototype.draw = function() {
    var canvas = this.get("container").get("canvas");
    if (canvas) {
      canvas.draw();
    }
  };
  return Handler2;
}(GroupComponent);
var BACKGROUND_STYLE = {
  fill: "#416180",
  opacity: 0.05
};
var FOREGROUND_STYLE = {
  fill: "#5B8FF9",
  opacity: 0.15,
  cursor: "move"
};
var DEFAULT_HANDLER_WIDTH = 10;
var HANDLER_STYLE = {
  width: DEFAULT_HANDLER_WIDTH,
  height: 24
};
var TEXT_STYLE = {
  textBaseline: "middle",
  fill: "#000",
  opacity: 0.45
};
var SLIDER_CHANGE = "sliderchange";
var Slider$1 = function(_super) {
  __extends$2(Slider2, _super);
  function Slider2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onMouseDown = function(target) {
      return function(e) {
        _this.currentTarget = target;
        var event = e.originalEvent;
        event.stopPropagation();
        event.preventDefault();
        _this.prevX = get(event, "touches.0.pageX", event.pageX);
        _this.prevY = get(event, "touches.0.pageY", event.pageY);
        var containerDOM = _this.getContainerDOM();
        containerDOM.addEventListener("mousemove", _this.onMouseMove);
        containerDOM.addEventListener("mouseup", _this.onMouseUp);
        containerDOM.addEventListener("mouseleave", _this.onMouseUp);
        containerDOM.addEventListener("touchmove", _this.onMouseMove);
        containerDOM.addEventListener("touchend", _this.onMouseUp);
        containerDOM.addEventListener("touchcancel", _this.onMouseUp);
      };
    };
    _this.onMouseMove = function(event) {
      var width = _this.cfg.width;
      var originValue = [_this.get("start"), _this.get("end")];
      event.stopPropagation();
      event.preventDefault();
      var x = get(event, "touches.0.pageX", event.pageX);
      var y = get(event, "touches.0.pageY", event.pageY);
      var offsetX = x - _this.prevX;
      var offsetXRange = _this.adjustOffsetRange(offsetX / width);
      _this.updateStartEnd(offsetXRange);
      _this.updateUI(_this.getElementByLocalId("foreground"), _this.getElementByLocalId("minText"), _this.getElementByLocalId("maxText"));
      _this.prevX = x;
      _this.prevY = y;
      _this.draw();
      _this.emit(SLIDER_CHANGE, [_this.get("start"), _this.get("end")].sort());
      _this.delegateEmit("valuechanged", {
        originValue,
        value: [_this.get("start"), _this.get("end")]
      });
    };
    _this.onMouseUp = function() {
      if (_this.currentTarget) {
        _this.currentTarget = void 0;
      }
      var containerDOM = _this.getContainerDOM();
      if (containerDOM) {
        containerDOM.removeEventListener("mousemove", _this.onMouseMove);
        containerDOM.removeEventListener("mouseup", _this.onMouseUp);
        containerDOM.removeEventListener("mouseleave", _this.onMouseUp);
        containerDOM.removeEventListener("touchmove", _this.onMouseMove);
        containerDOM.removeEventListener("touchend", _this.onMouseUp);
        containerDOM.removeEventListener("touchcancel", _this.onMouseUp);
      }
    };
    return _this;
  }
  Slider2.prototype.setRange = function(min2, max2) {
    this.set("minLimit", min2);
    this.set("maxLimit", max2);
    var oldStart = this.get("start");
    var oldEnd = this.get("end");
    var newStart = clamp(oldStart, min2, max2);
    var newEnd = clamp(oldEnd, min2, max2);
    if (!this.get("isInit") && (oldStart !== newStart || oldEnd !== newEnd)) {
      this.setValue([newStart, newEnd]);
    }
  };
  Slider2.prototype.getRange = function() {
    return {
      min: this.get("minLimit") || 0,
      max: this.get("maxLimit") || 1
    };
  };
  Slider2.prototype.setValue = function(value2) {
    var range = this.getRange();
    if (isArray$1(value2) && value2.length === 2) {
      var originValue = [this.get("start"), this.get("end")];
      this.update({
        start: clamp(value2[0], range.min, range.max),
        end: clamp(value2[1], range.min, range.max)
      });
      if (!this.get("updateAutoRender")) {
        this.render();
      }
      this.delegateEmit("valuechanged", {
        originValue,
        value: value2
      });
    }
  };
  Slider2.prototype.getValue = function() {
    return [this.get("start"), this.get("end")];
  };
  Slider2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "slider", x: 0, y: 0, width: 100, height: 16, backgroundStyle: {}, foregroundStyle: {}, handlerStyle: {}, textStyle: {}, defaultCfg: {
      backgroundStyle: BACKGROUND_STYLE,
      foregroundStyle: FOREGROUND_STYLE,
      handlerStyle: HANDLER_STYLE,
      textStyle: TEXT_STYLE
    } });
  };
  Slider2.prototype.update = function(cfg) {
    var start = cfg.start, end = cfg.end;
    var validCfg = __assign$1({}, cfg);
    if (!isNil(start)) {
      validCfg.start = clamp(start, 0, 1);
    }
    if (!isNil(end)) {
      validCfg.end = clamp(end, 0, 1);
    }
    _super.prototype.update.call(this, validCfg);
    this.minHandler = this.getChildComponentById(this.getElementId("minHandler"));
    this.maxHandler = this.getChildComponentById(this.getElementId("maxHandler"));
    this.trend = this.getChildComponentById(this.getElementId("trend"));
  };
  Slider2.prototype.init = function() {
    this.set("start", clamp(this.get("start"), 0, 1));
    this.set("end", clamp(this.get("end"), 0, 1));
    _super.prototype.init.call(this);
  };
  Slider2.prototype.render = function() {
    _super.prototype.render.call(this);
    this.updateUI(this.getElementByLocalId("foreground"), this.getElementByLocalId("minText"), this.getElementByLocalId("maxText"));
  };
  Slider2.prototype.renderInner = function(group2) {
    var _a2 = this.cfg;
    _a2.start;
    _a2.end;
    var width = _a2.width, height = _a2.height, _b = _a2.trendCfg, trendCfg = _b === void 0 ? {} : _b, minText = _a2.minText, maxText = _a2.maxText, _c = _a2.backgroundStyle, backgroundStyle = _c === void 0 ? {} : _c, _d = _a2.foregroundStyle, foregroundStyle = _d === void 0 ? {} : _d, _e = _a2.textStyle, textStyle2 = _e === void 0 ? {} : _e;
    var handlerStyle = deepMix({}, DEFAULT_HANDLER_STYLE, this.cfg.handlerStyle);
    if (size(get(trendCfg, "data"))) {
      this.trend = this.addComponent(group2, __assign$1({
        component: Trend,
        id: this.getElementId("trend"),
        x: 0,
        y: 0,
        width,
        height
      }, trendCfg));
    }
    this.addShape(group2, {
      id: this.getElementId("background"),
      type: "rect",
      attrs: __assign$1({
        x: 0,
        y: 0,
        width,
        height
      }, backgroundStyle)
    });
    this.addShape(group2, {
      id: this.getElementId("minText"),
      type: "text",
      attrs: __assign$1({
        y: height / 2,
        textAlign: "right",
        text: minText,
        silent: false
      }, textStyle2)
    });
    this.addShape(group2, {
      id: this.getElementId("maxText"),
      type: "text",
      attrs: __assign$1({
        y: height / 2,
        textAlign: "left",
        text: maxText,
        silent: false
      }, textStyle2)
    });
    this.addShape(group2, {
      id: this.getElementId("foreground"),
      name: "foreground",
      type: "rect",
      attrs: __assign$1({
        y: 0,
        height
      }, foregroundStyle)
    });
    var handlerWidth = get(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
    var handlerHeight = get(handlerStyle, "height", 24);
    this.minHandler = this.addComponent(group2, {
      component: Handler,
      id: this.getElementId("minHandler"),
      name: "handler-min",
      x: 0,
      y: (height - handlerHeight) / 2,
      width: handlerWidth,
      height: handlerHeight,
      cursor: "ew-resize",
      style: handlerStyle
    });
    this.maxHandler = this.addComponent(group2, {
      component: Handler,
      id: this.getElementId("maxHandler"),
      name: "handler-max",
      x: 0,
      y: (height - handlerHeight) / 2,
      width: handlerWidth,
      height: handlerHeight,
      cursor: "ew-resize",
      style: handlerStyle
    });
  };
  Slider2.prototype.applyOffset = function() {
    this.moveElementTo(this.get("group"), {
      x: this.get("x"),
      y: this.get("y")
    });
  };
  Slider2.prototype.initEvent = function() {
    this.bindEvents();
  };
  Slider2.prototype.updateUI = function(foregroundShape, minTextShape, maxTextShape) {
    var _a2 = this.cfg, start = _a2.start, end = _a2.end, width = _a2.width, minText = _a2.minText, maxText = _a2.maxText, handlerStyle = _a2.handlerStyle, height = _a2.height;
    var min2 = start * width;
    var max2 = end * width;
    if (this.trend) {
      this.trend.update({
        width,
        height
      });
      if (!this.get("updateAutoRender")) {
        this.trend.render();
      }
    }
    foregroundShape.attr("x", min2);
    foregroundShape.attr("width", max2 - min2);
    var handlerWidth = get(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
    minTextShape.attr("text", minText);
    maxTextShape.attr("text", maxText);
    var _b = this._dodgeText([min2, max2], minTextShape, maxTextShape), minAttrs = _b[0], maxAttrs = _b[1];
    if (this.minHandler) {
      this.minHandler.update({
        x: min2 - handlerWidth / 2
      });
      if (!this.get("updateAutoRender")) {
        this.minHandler.render();
      }
    }
    each$1(minAttrs, function(v, k) {
      return minTextShape.attr(k, v);
    });
    if (this.maxHandler) {
      this.maxHandler.update({
        x: max2 - handlerWidth / 2
      });
      if (!this.get("updateAutoRender")) {
        this.maxHandler.render();
      }
    }
    each$1(maxAttrs, function(v, k) {
      return maxTextShape.attr(k, v);
    });
  };
  Slider2.prototype.bindEvents = function() {
    var group2 = this.get("group");
    group2.on("handler-min:mousedown", this.onMouseDown("minHandler"));
    group2.on("handler-min:touchstart", this.onMouseDown("minHandler"));
    group2.on("handler-max:mousedown", this.onMouseDown("maxHandler"));
    group2.on("handler-max:touchstart", this.onMouseDown("maxHandler"));
    var foreground = group2.findById(this.getElementId("foreground"));
    foreground.on("mousedown", this.onMouseDown("foreground"));
    foreground.on("touchstart", this.onMouseDown("foreground"));
  };
  Slider2.prototype.adjustOffsetRange = function(offsetRange) {
    var _a2 = this.cfg, start = _a2.start, end = _a2.end;
    switch (this.currentTarget) {
      case "minHandler": {
        var min2 = 0 - start;
        var max2 = 1 - start;
        return Math.min(max2, Math.max(min2, offsetRange));
      }
      case "maxHandler": {
        var min2 = 0 - end;
        var max2 = 1 - end;
        return Math.min(max2, Math.max(min2, offsetRange));
      }
      case "foreground": {
        var min2 = 0 - start;
        var max2 = 1 - end;
        return Math.min(max2, Math.max(min2, offsetRange));
      }
    }
  };
  Slider2.prototype.updateStartEnd = function(offsetRange) {
    var _a2 = this.cfg, start = _a2.start, end = _a2.end;
    switch (this.currentTarget) {
      case "minHandler":
        start += offsetRange;
        break;
      case "maxHandler":
        end += offsetRange;
        break;
      case "foreground":
        start += offsetRange;
        end += offsetRange;
        break;
    }
    this.set("start", start);
    this.set("end", end);
  };
  Slider2.prototype._dodgeText = function(range, minTextShape, maxTextShape) {
    var _a2, _b;
    var _c = this.cfg, handlerStyle = _c.handlerStyle, width = _c.width;
    var PADDING2 = 2;
    var handlerWidth = get(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
    var min2 = range[0], max2 = range[1];
    var sorted = false;
    if (min2 > max2) {
      _a2 = [max2, min2], min2 = _a2[0], max2 = _a2[1];
      _b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];
      sorted = true;
    }
    var minBBox = minTextShape.getBBox();
    var maxBBox = maxTextShape.getBBox();
    var minAttrs = minBBox.width > min2 - PADDING2 ? { x: min2 + handlerWidth / 2 + PADDING2, textAlign: "left" } : { x: min2 - handlerWidth / 2 - PADDING2, textAlign: "right" };
    var maxAttrs = maxBBox.width > width - max2 - PADDING2 ? { x: max2 - handlerWidth / 2 - PADDING2, textAlign: "right" } : { x: max2 + handlerWidth / 2 + PADDING2, textAlign: "left" };
    return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];
  };
  Slider2.prototype.draw = function() {
    var container = this.get("container");
    var canvas = container && container.get("canvas");
    if (canvas) {
      canvas.draw();
    }
  };
  Slider2.prototype.getContainerDOM = function() {
    var container = this.get("container");
    var canvas = container && container.get("canvas");
    return canvas && canvas.get("container");
  };
  return Slider2;
}(GroupComponent);
var DEFAULT_STYLE = {
  trackColor: "rgba(0,0,0,0)",
  thumbColor: "rgba(0,0,0,0.15)",
  size: 8,
  lineCap: "round"
};
var DEFAULT_THEME = {
  default: DEFAULT_STYLE,
  hover: {
    thumbColor: "rgba(0,0,0,0.2)"
  }
};
var Scrollbar$1 = function(_super) {
  __extends$2(Scrollbar2, _super);
  function Scrollbar2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.clearEvents = noop;
    _this.onStartEvent = function(isMobile) {
      return function(e) {
        _this.isMobile = isMobile;
        e.originalEvent.preventDefault();
        var clientX = isMobile ? get(e.originalEvent, "touches.0.clientX") : e.clientX;
        var clientY = isMobile ? get(e.originalEvent, "touches.0.clientY") : e.clientY;
        _this.startPos = _this.cfg.isHorizontal ? clientX : clientY;
        _this.bindLaterEvent();
      };
    };
    _this.bindLaterEvent = function() {
      var containerDOM = _this.getContainerDOM();
      var events = [];
      if (_this.isMobile) {
        events = [
          addEventListener(containerDOM, "touchmove", _this.onMouseMove),
          addEventListener(containerDOM, "touchend", _this.onMouseUp),
          addEventListener(containerDOM, "touchcancel", _this.onMouseUp)
        ];
      } else {
        events = [
          addEventListener(containerDOM, "mousemove", _this.onMouseMove),
          addEventListener(containerDOM, "mouseup", _this.onMouseUp),
          addEventListener(containerDOM, "mouseleave", _this.onMouseUp)
        ];
      }
      _this.clearEvents = function() {
        events.forEach(function(e) {
          e.remove();
        });
      };
    };
    _this.onMouseMove = function(e) {
      var _a2 = _this.cfg, isHorizontal2 = _a2.isHorizontal, thumbOffset = _a2.thumbOffset;
      e.preventDefault();
      var clientX = _this.isMobile ? get(e, "touches.0.clientX") : e.clientX;
      var clientY = _this.isMobile ? get(e, "touches.0.clientY") : e.clientY;
      var endPos = isHorizontal2 ? clientX : clientY;
      var diff2 = endPos - _this.startPos;
      _this.startPos = endPos;
      _this.updateThumbOffset(thumbOffset + diff2);
    };
    _this.onMouseUp = function(e) {
      e.preventDefault();
      _this.clearEvents();
    };
    _this.onTrackClick = function(e) {
      var _a2 = _this.cfg, isHorizontal2 = _a2.isHorizontal, x = _a2.x, y = _a2.y, thumbLen = _a2.thumbLen;
      var containerDOM = _this.getContainerDOM();
      var rect2 = containerDOM.getBoundingClientRect();
      var clientX = e.clientX, clientY = e.clientY;
      var offset = isHorizontal2 ? clientX - rect2.left - x - thumbLen / 2 : clientY - rect2.top - y - thumbLen / 2;
      var newOffset = _this.validateRange(offset);
      _this.updateThumbOffset(newOffset);
    };
    _this.onThumbMouseOver = function() {
      var thumbColor = _this.cfg.theme.hover.thumbColor;
      _this.getElementByLocalId("thumb").attr("stroke", thumbColor);
      _this.draw();
    };
    _this.onThumbMouseOut = function() {
      var thumbColor = _this.cfg.theme.default.thumbColor;
      _this.getElementByLocalId("thumb").attr("stroke", thumbColor);
      _this.draw();
    };
    return _this;
  }
  Scrollbar2.prototype.setRange = function(min2, max2) {
    this.set("minLimit", min2);
    this.set("maxLimit", max2);
    var curValue = this.getValue();
    var newValue = clamp(curValue, min2, max2);
    if (curValue !== newValue && !this.get("isInit")) {
      this.setValue(newValue);
    }
  };
  Scrollbar2.prototype.getRange = function() {
    var min2 = this.get("minLimit") || 0;
    var max2 = this.get("maxLimit") || 1;
    return { min: min2, max: max2 };
  };
  Scrollbar2.prototype.setValue = function(value2) {
    var range = this.getRange();
    var originalValue = this.getValue();
    this.update({
      thumbOffset: (this.get("trackLen") - this.get("thumbLen")) * clamp(value2, range.min, range.max)
    });
    this.delegateEmit("valuechange", {
      originalValue,
      value: this.getValue()
    });
  };
  Scrollbar2.prototype.getValue = function() {
    return clamp(this.get("thumbOffset") / (this.get("trackLen") - this.get("thumbLen")), 0, 1);
  };
  Scrollbar2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$1(__assign$1({}, cfg), { name: "scrollbar", isHorizontal: true, minThumbLen: 20, thumbOffset: 0, theme: DEFAULT_THEME });
  };
  Scrollbar2.prototype.renderInner = function(group2) {
    this.renderTrackShape(group2);
    this.renderThumbShape(group2);
  };
  Scrollbar2.prototype.applyOffset = function() {
    this.moveElementTo(this.get("group"), {
      x: this.get("x"),
      y: this.get("y")
    });
  };
  Scrollbar2.prototype.initEvent = function() {
    this.bindEvents();
  };
  Scrollbar2.prototype.renderTrackShape = function(group2) {
    var _a2 = this.cfg, trackLen = _a2.trackLen, _b = _a2.theme, theme2 = _b === void 0 ? { default: {} } : _b;
    var _c = deepMix({}, DEFAULT_THEME, theme2).default, lineCap = _c.lineCap, trackColor = _c.trackColor, themeSize = _c.size;
    var size2 = get(this.cfg, "size", themeSize);
    var attrs = this.get("isHorizontal") ? {
      x1: 0 + size2 / 2,
      y1: size2 / 2,
      x2: trackLen - size2 / 2,
      y2: size2 / 2,
      lineWidth: size2,
      stroke: trackColor,
      lineCap
    } : {
      x1: size2 / 2,
      y1: 0 + size2 / 2,
      x2: size2 / 2,
      y2: trackLen - size2 / 2,
      lineWidth: size2,
      stroke: trackColor,
      lineCap
    };
    return this.addShape(group2, {
      id: this.getElementId("track"),
      name: "track",
      type: "line",
      attrs
    });
  };
  Scrollbar2.prototype.renderThumbShape = function(group2) {
    var _a2 = this.cfg, thumbOffset = _a2.thumbOffset, thumbLen = _a2.thumbLen, theme2 = _a2.theme;
    var _b = deepMix({}, DEFAULT_THEME, theme2).default, themeSize = _b.size, lineCap = _b.lineCap, thumbColor = _b.thumbColor;
    var size2 = get(this.cfg, "size", themeSize);
    var attrs = this.get("isHorizontal") ? {
      x1: thumbOffset + size2 / 2,
      y1: size2 / 2,
      x2: thumbOffset + thumbLen - size2 / 2,
      y2: size2 / 2,
      lineWidth: size2,
      stroke: thumbColor,
      lineCap,
      cursor: "default"
    } : {
      x1: size2 / 2,
      y1: thumbOffset + size2 / 2,
      x2: size2 / 2,
      y2: thumbOffset + thumbLen - size2 / 2,
      lineWidth: size2,
      stroke: thumbColor,
      lineCap,
      cursor: "default"
    };
    return this.addShape(group2, {
      id: this.getElementId("thumb"),
      name: "thumb",
      type: "line",
      attrs
    });
  };
  Scrollbar2.prototype.bindEvents = function() {
    var group2 = this.get("group");
    group2.on("mousedown", this.onStartEvent(false));
    group2.on("mouseup", this.onMouseUp);
    group2.on("touchstart", this.onStartEvent(true));
    group2.on("touchend", this.onMouseUp);
    var trackShape = group2.findById(this.getElementId("track"));
    trackShape.on("click", this.onTrackClick);
    var thumbShape = group2.findById(this.getElementId("thumb"));
    thumbShape.on("mouseover", this.onThumbMouseOver);
    thumbShape.on("mouseout", this.onThumbMouseOut);
  };
  Scrollbar2.prototype.getContainerDOM = function() {
    var container = this.get("container");
    var canvas = container && container.get("canvas");
    return canvas && canvas.get("container");
  };
  Scrollbar2.prototype.validateRange = function(offset) {
    var _a2 = this.cfg, thumbLen = _a2.thumbLen, trackLen = _a2.trackLen;
    var newOffset = offset;
    if (offset + thumbLen > trackLen) {
      newOffset = trackLen - thumbLen;
    } else if (offset + thumbLen < thumbLen) {
      newOffset = 0;
    }
    return newOffset;
  };
  Scrollbar2.prototype.draw = function() {
    var container = this.get("container");
    var canvas = container && container.get("canvas");
    if (canvas) {
      canvas.draw();
    }
  };
  Scrollbar2.prototype.updateThumbOffset = function(offset) {
    var _a2 = this.cfg, thumbOffset = _a2.thumbOffset, isHorizontal2 = _a2.isHorizontal, thumbLen = _a2.thumbLen, size2 = _a2.size;
    var newOffset = this.validateRange(offset);
    if (newOffset === thumbOffset) {
      return;
    }
    var thumbShape = this.getElementByLocalId("thumb");
    if (isHorizontal2) {
      thumbShape.attr({
        x1: newOffset + size2 / 2,
        x2: newOffset + thumbLen - size2 / 2
      });
    } else {
      thumbShape.attr({
        y1: newOffset + size2 / 2,
        y2: newOffset + thumbLen - size2 / 2
      });
    }
    this.emitOffsetChange(newOffset);
  };
  Scrollbar2.prototype.emitOffsetChange = function(offset) {
    var _a2 = this.cfg, originalValue = _a2.thumbOffset, trackLen = _a2.trackLen, thumbLen = _a2.thumbLen;
    this.cfg.thumbOffset = offset;
    this.emit("scrollchange", {
      thumbOffset: offset,
      ratio: clamp(offset / (trackLen - thumbLen), 0, 1)
    });
    this.delegateEmit("valuechange", {
      originalValue,
      value: offset
    });
  };
  return Scrollbar2;
}(GroupComponent);
var LineAxis = Line$7, CircleAxis = Circle$6;
var LineGrid = Line$6, CircleGrid = Circle$5;
var CategoryLegend = Category, ContinuousLegend = ContinueLegend;
var HtmlTooltip = Tooltip$1;
function getPointsBox(points) {
  if (isEmpty(points)) {
    return null;
  }
  var minX = points[0].x;
  var maxX = points[0].x;
  var minY = points[0].y;
  var maxY = points[0].y;
  each$1(points, function(point2) {
    minX = minX > point2.x ? point2.x : minX;
    maxX = maxX < point2.x ? point2.x : maxX;
    minY = minY > point2.y ? point2.y : minY;
    maxY = maxY < point2.y ? point2.y : maxY;
  });
  return {
    minX,
    maxX,
    minY,
    maxY,
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2
  };
}
function uniqueValues(array) {
  return Array.from(new Set(array)).length === 1;
}
function mid(array) {
  return (min$1(array) + max$1(array)) / 2;
}
function polarToCartesian(centerX, centerY, radius, angleInRadian) {
  return {
    x: centerX + radius * Math.cos(angleInRadian),
    y: centerY + radius * Math.sin(angleInRadian)
  };
}
function getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {
  if (innerRadius === void 0) {
    innerRadius = 0;
  }
  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
  var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);
  var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);
  if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {
    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
    var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);
    var circlePathCommands = [
      ["M", start.x, start.y],
      ["A", radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
      ["A", radius, radius, 0, 1, 1, end.x, end.y],
      ["M", innerStart.x, innerStart.y]
    ];
    if (innerRadius) {
      circlePathCommands.push(["A", innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);
      circlePathCommands.push(["A", innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);
    }
    circlePathCommands.push(["M", start.x, start.y]);
    circlePathCommands.push(["Z"]);
    return circlePathCommands;
  }
  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
  var sectorPathCommands = [
    ["M", start.x, start.y],
    ["A", radius, radius, 0, arcSweep, 1, end.x, end.y],
    ["L", innerEnd.x, innerEnd.y]
  ];
  if (innerRadius) {
    sectorPathCommands.push(["A", innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);
  }
  sectorPathCommands.push(["L", start.x, start.y]);
  sectorPathCommands.push(["Z"]);
  return sectorPathCommands;
}
function getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {
  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
  if (isNumberEqual$1(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {
    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
    return [
      ["M", start.x, start.y],
      ["A", radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
      ["A", radius, radius, 0, 1, 1, start.x, start.y],
      ["A", radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y],
      ["A", radius, radius, 0, 1, 0, start.x, start.y],
      ["Z"]
    ];
  }
  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
  return [
    ["M", start.x, start.y],
    ["A", radius, radius, 0, arcSweep, 1, end.x, end.y]
  ];
}
function getAngle$1(shapeModel, coordinate2) {
  var points = shapeModel.points;
  var box2 = getPointsBox(points);
  var endAngle;
  var startAngle;
  var coordStartAngle = coordinate2.startAngle, coordEndAngle = coordinate2.endAngle;
  var diffAngle = coordEndAngle - coordStartAngle;
  if (coordinate2.isTransposed) {
    endAngle = box2.maxY * diffAngle;
    startAngle = box2.minY * diffAngle;
  } else {
    endAngle = box2.maxX * diffAngle;
    startAngle = box2.minX * diffAngle;
  }
  endAngle += coordStartAngle;
  startAngle += coordStartAngle;
  return {
    startAngle,
    endAngle
  };
}
function getPolygonCentroid(xs, ys) {
  if (isNumber$1(xs) && isNumber$1(ys)) {
    return [xs, ys];
  }
  xs = xs;
  ys = ys;
  if (uniqueValues(xs) || uniqueValues(ys))
    return [mid(xs), mid(ys)];
  var i = -1;
  var x = 0;
  var y = 0;
  var former;
  var current = xs.length - 1;
  var diff2;
  var k = 0;
  while (++i < xs.length) {
    former = current;
    current = i;
    k += diff2 = xs[former] * ys[current] - xs[current] * ys[former];
    x += (xs[former] + xs[current]) * diff2;
    y += (ys[former] + ys[current]) * diff2;
  }
  k *= 3;
  return [x / k, y / k];
}
function getReplaceAttrs(sourceShape, targetShape) {
  var originAttrs = sourceShape.attr();
  var newAttrs = targetShape.attr();
  each$1(originAttrs, function(v, k) {
    if (newAttrs[k] === void 0) {
      newAttrs[k] = void 0;
    }
  });
  return newAttrs;
}
function isBetween$1(value2, start, end) {
  var min2 = Math.min(start, end);
  var max2 = Math.max(start, end);
  return value2 >= min2 && value2 <= max2;
}
function padEnd(source, targetLength, padValue) {
  if (isString(source)) {
    return source.padEnd(targetLength, padValue);
  } else if (isArray$1(source)) {
    var sourceLength = source.length;
    if (sourceLength < targetLength) {
      var diff2 = targetLength - sourceLength;
      for (var i = 0; i < diff2; i++) {
        source.push(padValue);
      }
    }
  }
  return source;
}
function omit(obj, keys2) {
  if (typeof obj === "object") {
    keys2.forEach(function(key) {
      delete obj[key];
    });
  }
  return obj;
}
function uniq$1(sourceArray, targetArray, map2) {
  if (targetArray === void 0) {
    targetArray = [];
  }
  if (map2 === void 0) {
    map2 = new Map();
  }
  for (var _i = 0, sourceArray_1 = sourceArray; _i < sourceArray_1.length; _i++) {
    var source = sourceArray_1[_i];
    if (!map2.has(source)) {
      targetArray.push(source);
      map2.set(source, true);
    }
  }
  return targetArray;
}
var BBox = function() {
  function BBox2(x, y, width, height) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    this.x = x;
    this.y = y;
    this.height = height;
    this.width = width;
  }
  BBox2.fromRange = function(minX, minY, maxX, maxY) {
    return new BBox2(minX, minY, maxX - minX, maxY - minY);
  };
  BBox2.fromObject = function(bbox) {
    return new BBox2(bbox.minX, bbox.minY, bbox.width, bbox.height);
  };
  Object.defineProperty(BBox2.prototype, "minX", {
    get: function() {
      return this.x;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "maxX", {
    get: function() {
      return this.x + this.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "minY", {
    get: function() {
      return this.y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "maxY", {
    get: function() {
      return this.y + this.height;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "tl", {
    get: function() {
      return { x: this.x, y: this.y };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "tr", {
    get: function() {
      return { x: this.maxX, y: this.y };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "bl", {
    get: function() {
      return { x: this.x, y: this.maxY };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "br", {
    get: function() {
      return { x: this.maxX, y: this.maxY };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "top", {
    get: function() {
      return {
        x: this.x + this.width / 2,
        y: this.minY
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "right", {
    get: function() {
      return {
        x: this.maxX,
        y: this.y + this.height / 2
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "bottom", {
    get: function() {
      return {
        x: this.x + this.width / 2,
        y: this.maxY
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "left", {
    get: function() {
      return {
        x: this.minX,
        y: this.y + this.height / 2
      };
    },
    enumerable: false,
    configurable: true
  });
  BBox2.prototype.isEqual = function(bbox) {
    return this.x === bbox.x && this.y === bbox.y && this.width === bbox.width && this.height === bbox.height;
  };
  BBox2.prototype.contains = function(child) {
    return child.minX >= this.minX && child.maxX <= this.maxX && child.minY >= this.minY && child.maxY <= this.maxY;
  };
  BBox2.prototype.clone = function() {
    return new BBox2(this.x, this.y, this.width, this.height);
  };
  BBox2.prototype.add = function() {
    var subBBox = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      subBBox[_i] = arguments[_i];
    }
    var bbox = this.clone();
    each$1(subBBox, function(b) {
      bbox.x = Math.min(b.x, bbox.x);
      bbox.y = Math.min(b.y, bbox.y);
      bbox.width = Math.max(b.maxX, bbox.maxX) - bbox.x;
      bbox.height = Math.max(b.maxY, bbox.maxY) - bbox.y;
    });
    return bbox;
  };
  BBox2.prototype.merge = function() {
    var subBBox = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      subBBox[_i] = arguments[_i];
    }
    var bbox = this.clone();
    each$1(subBBox, function(b) {
      bbox.x = Math.max(b.x, bbox.x);
      bbox.y = Math.max(b.y, bbox.y);
      bbox.width = Math.min(b.maxX, bbox.maxX) - bbox.x;
      bbox.height = Math.min(b.maxY, bbox.maxY) - bbox.y;
    });
    return bbox;
  };
  BBox2.prototype.cut = function(subBBox, direction2) {
    var width = subBBox.width;
    var height = subBBox.height;
    switch (direction2) {
      case DIRECTION.TOP:
      case DIRECTION.TOP_LEFT:
      case DIRECTION.TOP_RIGHT:
        return BBox2.fromRange(this.minX, this.minY + height, this.maxX, this.maxY);
      case DIRECTION.RIGHT:
      case DIRECTION.RIGHT_TOP:
      case DIRECTION.RIGHT_BOTTOM:
        return BBox2.fromRange(this.minX, this.minY, this.maxX - width, this.maxY);
      case DIRECTION.BOTTOM:
      case DIRECTION.BOTTOM_LEFT:
      case DIRECTION.BOTTOM_RIGHT:
        return BBox2.fromRange(this.minX, this.minY, this.maxX, this.maxY - height);
      case DIRECTION.LEFT:
      case DIRECTION.LEFT_TOP:
      case DIRECTION.LEFT_BOTTOM:
        return BBox2.fromRange(this.minX + width, this.minY, this.maxX, this.maxY);
      default:
        return this;
    }
  };
  BBox2.prototype.shrink = function(gap) {
    var top = gap[0], right2 = gap[1], bottom = gap[2], left2 = gap[3];
    return new BBox2(this.x + left2, this.y + top, this.width - left2 - right2, this.height - top - bottom);
  };
  BBox2.prototype.expand = function(gap) {
    var top = gap[0], right2 = gap[1], bottom = gap[2], left2 = gap[3];
    return new BBox2(this.x - left2, this.y - top, this.width + left2 + right2, this.height + top + bottom);
  };
  BBox2.prototype.exceed = function(bbox) {
    return [
      Math.max(-this.minY + bbox.minY, 0),
      Math.max(this.maxX - bbox.maxX, 0),
      Math.max(this.maxY - bbox.maxY, 0),
      Math.max(-this.minX + bbox.minX, 0)
    ];
  };
  BBox2.prototype.collide = function(bbox) {
    return this.minX < bbox.maxX && this.maxX > bbox.minX && this.minY < bbox.maxY && this.maxY > bbox.minY;
  };
  BBox2.prototype.size = function() {
    return this.width * this.height;
  };
  BBox2.prototype.isPointIn = function(p) {
    return p.x >= this.minX && p.x <= this.maxX && p.y >= this.minY && p.y <= this.maxY;
  };
  return BBox2;
}();
function toPoints(bbox) {
  return [
    [bbox.minX, bbox.minY],
    [bbox.maxX, bbox.minY],
    [bbox.maxX, bbox.maxY],
    [bbox.minX, bbox.maxY]
  ];
}
function getXDimensionLength(coordinate2) {
  if (coordinate2.isPolar && !coordinate2.isTransposed) {
    return (coordinate2.endAngle - coordinate2.startAngle) * coordinate2.getRadius();
  }
  var start = coordinate2.convert({ x: 0, y: 0 });
  var end = coordinate2.convert({ x: 1, y: 0 });
  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
}
function isFullCircle(coordinate2) {
  if (coordinate2.isPolar) {
    var startAngle = coordinate2.startAngle, endAngle = coordinate2.endAngle;
    return endAngle - startAngle === Math.PI * 2;
  }
  return false;
}
function getDistanceToCenter(coordinate2, point2) {
  var center2 = coordinate2.getCenter();
  return Math.sqrt(Math.pow(point2.x - center2.x, 2) + Math.pow(point2.y - center2.y, 2));
}
function isPointInCoordinate(coordinate2, point2) {
  var result = false;
  if (coordinate2) {
    if (coordinate2.type === "theta") {
      var start = coordinate2.start, end = coordinate2.end;
      result = isBetween$1(point2.x, start.x, end.x) && isBetween$1(point2.y, start.y, end.y);
    } else {
      var invertPoint = coordinate2.invert(point2);
      result = isBetween$1(invertPoint.x, 0, 1) && isBetween$1(invertPoint.y, 0, 1);
    }
  }
  return result;
}
function getAngleByPoint(coordinate2, point2) {
  var center2 = coordinate2.getCenter();
  return Math.atan2(point2.y - center2.y, point2.x - center2.x);
}
function getCoordinateClipCfg(coordinate2, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var start = coordinate2.start, end = coordinate2.end;
  var width = coordinate2.getWidth();
  var height = coordinate2.getHeight();
  if (coordinate2.isPolar) {
    var startAngle_1 = coordinate2.startAngle, endAngle_1 = coordinate2.endAngle;
    var center_1 = coordinate2.getCenter();
    var radius_1 = coordinate2.getRadius();
    return {
      type: "path",
      startState: {
        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1)
      },
      endState: function(ratio) {
        var diff2 = (endAngle_1 - startAngle_1) * ratio + startAngle_1;
        var path2 = getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff2);
        return {
          path: path2
        };
      },
      attrs: {
        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1)
      }
    };
  }
  var endState;
  if (coordinate2.isTransposed) {
    endState = {
      height: height + margin * 2
    };
  } else {
    endState = {
      width: width + margin * 2
    };
  }
  return {
    type: "rect",
    startState: {
      x: start.x - margin,
      y: end.y - margin,
      width: coordinate2.isTransposed ? width + margin * 2 : 0,
      height: coordinate2.isTransposed ? 0 : height + margin * 2
    },
    endState,
    attrs: {
      x: start.x - margin,
      y: end.y - margin,
      width: width + margin * 2,
      height: height + margin * 2
    }
  };
}
function getCoordinateBBox(coordinate2, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var start = coordinate2.start, end = coordinate2.end;
  var width = coordinate2.getWidth();
  var height = coordinate2.getHeight();
  var minX = Math.min(start.x, end.x);
  var minY = Math.min(start.y, end.y);
  return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);
}
var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
function getDefaultType(value2) {
  var type = "linear";
  if (dateRegex.test(value2)) {
    type = "timeCat";
  } else if (isString(value2)) {
    type = "cat";
  }
  return type;
}
function createScaleByField(field2, data2, scaleDef) {
  var validData = data2 || [];
  if (isNumber$1(field2) || isNil(firstValue(validData, field2)) && isEmpty(scaleDef)) {
    var Identity2 = getClass("identity");
    return new Identity2({
      field: field2.toString(),
      values: [field2]
    });
  }
  var values2 = valuesOfKey(validData, field2);
  var type = get(scaleDef, "type", getDefaultType(values2[0]));
  var ScaleCtor = getClass(type);
  return new ScaleCtor(__assign$1({ field: field2, values: values2 }, scaleDef));
}
function syncScale(scale2, newScale) {
  if (scale2.type !== "identity" && newScale.type !== "identity") {
    var obj = {};
    for (var k in newScale) {
      if (Object.prototype.hasOwnProperty.call(newScale, k)) {
        obj[k] = newScale[k];
      }
    }
    scale2.change(obj);
  }
}
function getName(scale2) {
  return scale2.alias || scale2.field;
}
function getDefaultCategoryScaleRange(scale2, coordinate2, theme2) {
  var values2 = scale2.values;
  var count = values2.length;
  var range;
  if (count === 1) {
    range = [0.5, 1];
  } else {
    var widthRatio = 1;
    var offset = 0;
    if (isFullCircle(coordinate2)) {
      if (!coordinate2.isTransposed) {
        range = [0, 1 - 1 / count];
      } else {
        widthRatio = get(theme2, "widthRatio.multiplePie", 1 / 1.3);
        offset = 1 / count * widthRatio;
        range = [offset / 2, 1 - offset / 2];
      }
    } else {
      offset = 1 / count / 2;
      range = [offset, 1 - offset];
    }
  }
  return range;
}
function getMaxScale(scale2) {
  var values2 = scale2.values.filter(function(item) {
    return !isNil(item) && !isNaN(item);
  });
  return Math.max.apply(Math, __spreadArray(__spreadArray([], values2, false), [isNil(scale2.max) ? -Infinity : scale2.max], false));
}
function getLineAxisRelativeRegion(direction2) {
  var start;
  var end;
  switch (direction2) {
    case DIRECTION.TOP:
      start = { x: 0, y: 1 };
      end = { x: 1, y: 1 };
      break;
    case DIRECTION.RIGHT:
      start = { x: 1, y: 0 };
      end = { x: 1, y: 1 };
      break;
    case DIRECTION.BOTTOM:
      start = { x: 0, y: 0 };
      end = { x: 1, y: 0 };
      break;
    case DIRECTION.LEFT:
      start = { x: 0, y: 0 };
      end = { x: 0, y: 1 };
      break;
    default:
      start = end = { x: 0, y: 0 };
  }
  return { start, end };
}
function getCircleAxisRelativeRegion(coordinate2) {
  var start;
  var end;
  if (coordinate2.isTransposed) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  }
  return { start, end };
}
function getAxisRegion(coordinate2, direction2) {
  var region = { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } };
  if (coordinate2.isRect) {
    region = getLineAxisRelativeRegion(direction2);
  } else if (coordinate2.isPolar) {
    region = getCircleAxisRelativeRegion(coordinate2);
  }
  var start = region.start, end = region.end;
  return {
    start: coordinate2.convert(start),
    end: coordinate2.convert(end)
  };
}
function isVertical(region) {
  var start = region.start, end = region.end;
  return start.x === end.x;
}
function getAxisFactorByRegion(region, center2) {
  var start = region.start, end = region.end;
  var isAxisVertical = isVertical(region);
  if (isAxisVertical) {
    if ((start.y - end.y) * (center2.x - start.x) > 0) {
      return 1;
    } else {
      return -1;
    }
  } else {
    if ((end.x - start.x) * (start.y - center2.y) > 0) {
      return -1;
    } else {
      return 1;
    }
  }
}
function getAxisThemeCfg(theme2, direction2) {
  var axisTheme = get(theme2, ["components", "axis"], {});
  return deepMix({}, get(axisTheme, ["common"], {}), deepMix({}, get(axisTheme, [direction2], {})));
}
function getAxisTitleOptions(theme2, direction2, axisOptions) {
  var axisTheme = get(theme2, ["components", "axis"], {});
  return deepMix({}, get(axisTheme, ["common", "title"], {}), deepMix({}, get(axisTheme, [direction2, "title"], {})), axisOptions);
}
function getCircleAxisCenterRadius(coordinate2) {
  var x = coordinate2.x, y = coordinate2.y, center2 = coordinate2.circleCenter;
  var isReflectY = y.start > y.end;
  var start = coordinate2.isTransposed ? coordinate2.convert({
    x: isReflectY ? 0 : 1,
    y: 0
  }) : coordinate2.convert({
    x: 0,
    y: isReflectY ? 0 : 1
  });
  var startVector = [start.x - center2.x, start.y - center2.y];
  var normalVector = [1, 0];
  var startAngle = start.y > center2.y ? angle(startVector, normalVector) : angle(startVector, normalVector) * -1;
  var endAngle = startAngle + (x.end - x.start);
  var radius = Math.sqrt(Math.pow(start.x - center2.x, 2) + Math.pow(start.y - center2.y, 2));
  return {
    center: center2,
    radius,
    startAngle,
    endAngle
  };
}
function getAxisOption(axes, field2) {
  if (isBoolean(axes)) {
    return axes === false ? false : {};
  }
  return get(axes, [field2]);
}
function getAxisDirection(axisOption, def) {
  return get(axisOption, "position", def);
}
function getAxisTitleText(scale2, axisOption) {
  return get(axisOption, ["title", "text"], getName(scale2));
}
var Facet = function() {
  function Facet2(view, cfg) {
    this.destroyed = false;
    this.facets = [];
    this.view = view;
    this.cfg = deepMix({}, this.getDefaultCfg(), cfg);
  }
  Facet2.prototype.init = function() {
    if (!this.container) {
      this.container = this.createContainer();
    }
    var data2 = this.view.getData();
    this.facets = this.generateFacets(data2);
  };
  Facet2.prototype.render = function() {
    this.renderViews();
  };
  Facet2.prototype.update = function() {
  };
  Facet2.prototype.clear = function() {
    this.clearFacetViews();
  };
  Facet2.prototype.destroy = function() {
    this.clear();
    if (this.container) {
      this.container.remove(true);
      this.container = void 0;
    }
    this.destroyed = true;
    this.view = void 0;
    this.facets = [];
  };
  Facet2.prototype.facetToView = function(facet) {
    var region = facet.region, data2 = facet.data, _a2 = facet.padding, padding2 = _a2 === void 0 ? this.cfg.padding : _a2;
    var view = this.view.createView({
      region,
      padding: padding2
    });
    view.data(data2 || []);
    facet.view = view;
    this.beforeEachView(view, facet);
    var eachView = this.cfg.eachView;
    if (eachView) {
      eachView(view, facet);
    }
    this.afterEachView(view, facet);
    return view;
  };
  Facet2.prototype.createContainer = function() {
    var foregroundGroup = this.view.getLayer(LAYER.FORE);
    return foregroundGroup.addGroup();
  };
  Facet2.prototype.renderViews = function() {
    this.createFacetViews();
  };
  Facet2.prototype.createFacetViews = function() {
    var _this = this;
    return this.facets.map(function(facet) {
      return _this.facetToView(facet);
    });
  };
  Facet2.prototype.clearFacetViews = function() {
    var _this = this;
    each$1(this.facets, function(facet) {
      if (facet.view) {
        _this.view.removeView(facet.view);
        facet.view = void 0;
      }
    });
  };
  Facet2.prototype.parseSpacing = function() {
    var _a2 = this.view.viewBBox, width = _a2.width, height = _a2.height;
    var spacing = this.cfg.spacing;
    return spacing.map(function(s, idx) {
      if (isNumber$1(s))
        return s / (idx === 0 ? width : height);
      else
        return parseFloat(s) / 100;
    });
  };
  Facet2.prototype.getFieldValues = function(data2, field2) {
    var rst = [];
    var cache2 = {};
    each$1(data2, function(d) {
      var value2 = d[field2];
      if (!isNil(value2) && !cache2[value2]) {
        rst.push(value2);
        cache2[value2] = true;
      }
    });
    return rst;
  };
  Facet2.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
    var _a2 = this.parseSpacing(), xSpacing = _a2[0], ySpacing = _a2[1];
    var xRatio = (1 + xSpacing) / (cols === 0 ? 1 : cols) - xSpacing;
    var yRatio = (1 + ySpacing) / (rows === 0 ? 1 : rows) - ySpacing;
    var start = {
      x: (xRatio + xSpacing) * xIndex,
      y: (yRatio + ySpacing) * yIndex
    };
    var end = {
      x: start.x + xRatio,
      y: start.y + yRatio
    };
    return { start, end };
  };
  Facet2.prototype.getDefaultCfg = function() {
    return {
      eachView: void 0,
      showTitle: true,
      spacing: [0, 0],
      padding: 10,
      fields: []
    };
  };
  Facet2.prototype.getDefaultTitleCfg = function() {
    var fontFamily = this.view.getTheme().fontFamily;
    return {
      style: {
        fontSize: 14,
        fill: "#666",
        fontFamily
      }
    };
  };
  Facet2.prototype.processAxis = function(view, facet) {
    var options = view.getOptions();
    var coordinateOption = options.coordinate;
    var geometries = view.geometries;
    var coordinateType = get(coordinateOption, "type", "rect");
    if (coordinateType === "rect" && geometries.length) {
      if (isNil(options.axes)) {
        options.axes = {};
      }
      var axes = options.axes;
      var _a2 = geometries[0].getXYFields(), x = _a2[0], y = _a2[1];
      var xOption = getAxisOption(axes, x);
      var yOption = getAxisOption(axes, y);
      if (xOption !== false) {
        options.axes[x] = this.getXAxisOption(x, axes, xOption, facet);
      }
      if (yOption !== false) {
        options.axes[y] = this.getYAxisOption(y, axes, yOption, facet);
      }
    }
  };
  Facet2.prototype.getFacetDataFilter = function(conditions) {
    return function(datum) {
      return every(conditions, function(condition) {
        var field2 = condition.field, value2 = condition.value;
        if (!isNil(value2) && field2) {
          return datum[field2] === value2;
        }
        return true;
      });
    };
  };
  return Facet2;
}();
var Facets = {};
var getFacet = function(type) {
  return Facets[lowerCase(type)];
};
var registerFacet = function(type, ctor) {
  Facets[lowerCase(type)] = ctor;
};
var Action = function() {
  function Action2(context, cfg) {
    this.context = context;
    this.cfg = cfg;
    context.addAction(this);
  }
  Action2.prototype.applyCfg = function(cfg) {
    mix(this, cfg);
  };
  Action2.prototype.init = function() {
    this.applyCfg(this.cfg);
  };
  Action2.prototype.destroy = function() {
    this.context.removeAction(this);
    this.context = null;
  };
  return Action2;
}();
var CallbackAction = function(_super) {
  __extends$2(CallbackAction2, _super);
  function CallbackAction2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CallbackAction2.prototype.execute = function() {
    if (this.callback) {
      this.callback(this.context);
    }
  };
  CallbackAction2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.callback = null;
  };
  return CallbackAction2;
}(Action);
var ActionCache = {};
function createAction(actionName, context) {
  var actionOption = ActionCache[actionName];
  var action = null;
  if (actionOption) {
    var ActionClass = actionOption.ActionClass, cfg = actionOption.cfg;
    action = new ActionClass(context, cfg);
    action.name = actionName;
    action.init();
  }
  return action;
}
function getActionClass(actionName) {
  var actionOption = ActionCache[actionName];
  return get(actionOption, "ActionClass");
}
function registerAction(actionName, ActionClass, cfg) {
  ActionCache[actionName] = {
    ActionClass,
    cfg
  };
}
function createCallbackAction(callback, context) {
  var action = new CallbackAction(context);
  action.callback = callback;
  action.name = "callback";
  return action;
}
function _points2path(points, isInCircle) {
  var path2 = [];
  if (points.length) {
    path2.push(["M", points[0].x, points[0].y]);
    for (var i = 1, length_1 = points.length; i < length_1; i += 1) {
      var item = points[i];
      path2.push(["L", item.x, item.y]);
    }
    if (isInCircle) {
      path2.push(["Z"]);
    }
  }
  return path2;
}
function _convertArr(arr, coord2) {
  var tmp = [arr[0]];
  for (var i = 1, len = arr.length; i < len; i = i + 2) {
    var point2 = coord2.convert({
      x: arr[i],
      y: arr[i + 1]
    });
    tmp.push(point2.x, point2.y);
  }
  return tmp;
}
function _convertArcPath(path2, coord2) {
  var isTransposed = coord2.isTransposed;
  var r = path2[1];
  var x = path2[6];
  var y = path2[7];
  var point2 = coord2.convert({ x, y });
  var direction2 = isTransposed ? 0 : 1;
  return ["A", r, r, 0, 0, direction2, point2.x, point2.y];
}
function _convertPolarPath(pre, cur, coord2) {
  var isTransposed = coord2.isTransposed, startAngle = coord2.startAngle, endAngle = coord2.endAngle;
  var prePoint = pre[0].toLowerCase() === "a" ? {
    x: pre[6],
    y: pre[7]
  } : {
    x: pre[1],
    y: pre[2]
  };
  var curPoint = {
    x: cur[1],
    y: cur[2]
  };
  var rst = [];
  var xDim = isTransposed ? "y" : "x";
  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);
  var direction2 = curPoint[xDim] >= prePoint[xDim] ? 1 : 0;
  var flag = angleRange > Math.PI ? 1 : 0;
  var convertPoint = coord2.convert(curPoint);
  var r = getDistanceToCenter(coord2, convertPoint);
  if (r >= 0.5) {
    if (angleRange === Math.PI * 2) {
      var middlePoint = {
        x: (curPoint.x + prePoint.x) / 2,
        y: (curPoint.y + prePoint.y) / 2
      };
      var middleConvertPoint = coord2.convert(middlePoint);
      rst.push(["A", r, r, 0, flag, direction2, middleConvertPoint.x, middleConvertPoint.y]);
      rst.push(["A", r, r, 0, flag, direction2, convertPoint.x, convertPoint.y]);
    } else {
      rst.push(["A", r, r, 0, flag, direction2, convertPoint.x, convertPoint.y]);
    }
  }
  return rst;
}
function _filterFullCirleLine(path2) {
  each$1(path2, function(subPath, index2) {
    var cur = subPath;
    if (cur[0].toLowerCase() === "a") {
      var pre = path2[index2 - 1];
      var next = path2[index2 + 1];
      if (next && next[0].toLowerCase() === "a") {
        if (pre && pre[0].toLowerCase() === "l") {
          pre[0] = "M";
        }
      } else if (pre && pre[0].toLowerCase() === "a") {
        if (next && next[0].toLowerCase() === "l") {
          next[0] = "M";
        }
      }
    }
  });
}
var smoothBezier$1 = function(points, smooth, isLoop, constraint) {
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min2;
  var max2;
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    min2 = constraint[0], max2 = constraint[1];
    for (var i = 0, l = points.length; i < l; i++) {
      var point2 = points[i];
      min2 = min$2([0, 0], min2, point2);
      max2 = max$2([0, 0], max2, point2);
    }
  }
  for (var i = 0, len = points.length; i < len; i++) {
    var point2 = points[i];
    if (i === 0 && !isLoop) {
      cp0 = point2;
    } else if (i === len - 1 && !isLoop) {
      cp1 = point2;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      prevPoint = points[isLoop ? i ? i - 1 : len - 1 : i - 1];
      nextPoint = points[isLoop ? (i + 1) % len : i + 1];
      var v = [0, 0];
      v = sub(v, nextPoint, prevPoint);
      v = scale$2(v, v, smooth);
      var d0 = distance$6(point2, prevPoint);
      var d1 = distance$6(point2, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      var v1 = scale$2([0, 0], v, -d0);
      var v2 = scale$2([0, 0], v, d1);
      cp1 = add([0, 0], point2, v1);
      nextCp0 = add([0, 0], point2, v2);
      nextCp0 = min$2([0, 0], nextCp0, max$2([0, 0], nextPoint, point2));
      nextCp0 = max$2([0, 0], nextCp0, min$2([0, 0], nextPoint, point2));
      v1 = sub([0, 0], nextCp0, point2);
      v1 = scale$2([0, 0], v1, -d0 / d1);
      cp1 = add([0, 0], point2, v1);
      cp1 = min$2([0, 0], cp1, max$2([0, 0], prevPoint, point2));
      cp1 = max$2([0, 0], cp1, min$2([0, 0], prevPoint, point2));
      v2 = sub([0, 0], point2, cp1);
      v2 = scale$2([0, 0], v2, d1 / d0);
      nextCp0 = add([0, 0], point2, v2);
      if (hasConstraint) {
        cp1 = max$2([0, 0], cp1, min2);
        cp1 = min$2([0, 0], cp1, max2);
        nextCp0 = max$2([0, 0], nextCp0, min2);
        nextCp0 = min$2([0, 0], nextCp0, max2);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
};
function catmullRom2bezier$1(crp, z, constraint) {
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = smoothBezier$1(pointList, 0.4, isLoop, constraint);
  var len = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len - 1; i++) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len];
    cp2 = controlPointList[len + 1];
    p = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  return d1;
}
function getLinePath(points, isInCircle) {
  return _points2path(points, isInCircle);
}
function getSplinePath$1(points, isInCircle, constaint) {
  var data2 = [];
  var first = points[0];
  var prePoint = null;
  if (points.length <= 2) {
    return getLinePath(points, isInCircle);
  }
  for (var i = 0, len = points.length; i < len; i++) {
    var point2 = points[i];
    if (!prePoint || !(prePoint.x === point2.x && prePoint.y === point2.y)) {
      data2.push(point2.x);
      data2.push(point2.y);
      prePoint = point2;
    }
  }
  var constraint = constaint || [
    [0, 0],
    [1, 1]
  ];
  var splinePath2 = catmullRom2bezier$1(data2, isInCircle, constraint);
  splinePath2.unshift(["M", first.x, first.y]);
  return splinePath2;
}
function convertNormalPath(coord2, path2) {
  var tmp = [];
  each$1(path2, function(subPath) {
    var action = subPath[0];
    switch (action.toLowerCase()) {
      case "m":
      case "l":
      case "c":
        tmp.push(_convertArr(subPath, coord2));
        break;
      case "a":
        tmp.push(_convertArcPath(subPath, coord2));
        break;
      case "z":
      default:
        tmp.push(subPath);
        break;
    }
  });
  return tmp;
}
function convertPolarPath(coord2, path2) {
  var tmp = [];
  var pre;
  var cur;
  var transposed;
  var equals;
  each$1(path2, function(subPath, index2) {
    var action = subPath[0];
    switch (action.toLowerCase()) {
      case "m":
      case "c":
      case "q":
        tmp.push(_convertArr(subPath, coord2));
        break;
      case "l":
        pre = path2[index2 - 1];
        cur = subPath;
        transposed = coord2.isTransposed;
        equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];
        if (equals) {
          tmp = tmp.concat(_convertPolarPath(pre, cur, coord2));
        } else {
          tmp.push(_convertArr(subPath, coord2));
        }
        break;
      case "a":
        tmp.push(_convertArcPath(subPath, coord2));
        break;
      case "z":
      default:
        tmp.push(subPath);
        break;
    }
  });
  _filterFullCirleLine(tmp);
  return tmp;
}
function getMaskBBox(context, tolerance2) {
  var event = context.event;
  var maskShape = event.target;
  var maskBBox = maskShape.getCanvasBBox();
  if (!(maskBBox.width >= tolerance2 || maskBBox.height >= tolerance2)) {
    return null;
  }
  return maskBBox;
}
function getMaskPath(context, tolerance2) {
  var event = context.event;
  var maskShape = event.target;
  var maskBBox = maskShape.getCanvasBBox();
  if (!(maskBBox.width >= tolerance2 || maskBBox.height >= tolerance2)) {
    return null;
  }
  return maskShape.attr("path");
}
function getCurrentElement$1(context) {
  var event = context.event;
  var element;
  var target = event.target;
  if (target) {
    element = target.get("element");
  }
  return element;
}
function getDelegationObject(context) {
  var event = context.event;
  var target = event.target;
  var delegateObject;
  if (target) {
    delegateObject = target.get("delegateObject");
  }
  return delegateObject;
}
function isElementChange(context) {
  var event = context.event.gEvent;
  if (event && event.fromShape && event.toShape && event.fromShape.get("element") === event.toShape.get("element")) {
    return false;
  }
  return true;
}
function isList(delegateObject) {
  return delegateObject && delegateObject.component && delegateObject.component.isList();
}
function isSlider(delegateObject) {
  return delegateObject && delegateObject.component && delegateObject.component.isSlider();
}
function isMask(context) {
  var event = context.event;
  var target = event.target;
  return target && target.get("name") === "mask";
}
function getMaskedElements(context, tolerance2) {
  var target = context.event.target;
  if (target.get("type") === "path") {
    var maskPath = getMaskPath(context, tolerance2);
    if (!maskPath) {
      return;
    }
    return getElementsByPath(context.view, maskPath);
  }
  var maskBBox = getMaskBBox(context, tolerance2);
  if (!maskBBox) {
    return null;
  }
  return getIntersectElements(context.view, maskBBox);
}
function getSiblingMaskElements(context, sibling, tolerance2) {
  var maskBBox = getMaskBBox(context, tolerance2);
  if (!maskBBox) {
    return null;
  }
  var view = context.view;
  var start = getSiblingPoint(view, sibling, { x: maskBBox.x, y: maskBBox.y });
  var end = getSiblingPoint(view, sibling, { x: maskBBox.maxX, y: maskBBox.maxY });
  var box2 = {
    minX: start.x,
    minY: start.y,
    maxX: end.x,
    maxY: end.y
  };
  return getIntersectElements(sibling, box2);
}
function getElements(view) {
  var geometries = view.geometries;
  var rst = [];
  each$1(geometries, function(geom) {
    var elements = geom.elements;
    rst = rst.concat(elements);
  });
  if (view.views && view.views.length) {
    each$1(view.views, function(subView) {
      rst = rst.concat(getElements(subView));
    });
  }
  return rst;
}
function getElementsByField(view, field2, value2) {
  var elements = getElements(view);
  return elements.filter(function(el) {
    return getElementValue$1(el, field2) === value2;
  });
}
function getElementsByState(view, stateName) {
  var geometries = view.geometries;
  var rst = [];
  each$1(geometries, function(geom) {
    var elements = geom.getElementsBy(function(el) {
      return el.hasState(stateName);
    });
    rst = rst.concat(elements);
  });
  return rst;
}
function getElementValue$1(element, field2) {
  var model = element.getModel();
  var record = model.data;
  var value2;
  if (isArray$1(record)) {
    value2 = record[0][field2];
  } else {
    value2 = record[field2];
  }
  return value2;
}
function intersectRect$1(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function getIntersectElements(view, box2) {
  var elements = getElements(view);
  var rst = [];
  each$1(elements, function(el) {
    var shape = el.shape;
    var shapeBBox = shape.getCanvasBBox();
    if (intersectRect$1(box2, shapeBBox)) {
      rst.push(el);
    }
  });
  return rst;
}
function pathToPoints(path2) {
  var points = [];
  each$1(path2, function(seg) {
    var command = seg[0];
    if (command !== "A") {
      for (var i = 1; i < seg.length; i = i + 2) {
        points.push([seg[i], seg[i + 1]]);
      }
    } else {
      var length_1 = seg.length;
      points.push([seg[length_1 - 2], seg[length_1 - 1]]);
    }
  });
  return points;
}
function getElementsByPath(view, path2) {
  var elements = getElements(view);
  var points = pathToPoints(path2);
  var rst = elements.filter(function(el) {
    var shape = el.shape;
    var shapePoints;
    if (shape.get("type") === "path") {
      shapePoints = pathToPoints(shape.attr("path"));
    } else {
      var shapeBBox = shape.getCanvasBBox();
      shapePoints = toPoints(shapeBBox);
    }
    return isPolygonsIntersect(points, shapePoints);
  });
  return rst;
}
function getComponents(view) {
  return view.getComponents().map(function(co) {
    return co.component;
  });
}
function distance$2(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function getSpline(points, z) {
  if (points.length <= 2) {
    return getLinePath(points, false);
  }
  var first = points[0];
  var arr = [];
  each$1(points, function(point2) {
    arr.push(point2.x);
    arr.push(point2.y);
  });
  var path2 = catmullRom2bezier$1(arr, z, null);
  path2.unshift(["M", first.x, first.y]);
  return path2;
}
function isInBox(box2, point2) {
  return box2.x <= point2.x && box2.maxX >= point2.x && box2.y <= point2.y && box2.maxY > point2.y;
}
function getSilbings(view) {
  var parent = view.parent;
  var siblings = null;
  if (parent) {
    siblings = parent.views.filter(function(sub2) {
      return sub2 !== view;
    });
  }
  return siblings;
}
function point2Normalize(view, point2) {
  var coord2 = view.getCoordinate();
  return coord2.invert(point2);
}
function getSiblingPoint(view, sibling, point2) {
  var normalPoint = point2Normalize(view, point2);
  return sibling.getCoordinate().convert(normalPoint);
}
function isInRecords(records, record, xFiled, yField) {
  var isIn = false;
  each$1(records, function(r) {
    if (r[xFiled] === record[xFiled] && r[yField] === record[yField]) {
      isIn = true;
      return false;
    }
  });
  return isIn;
}
function getScaleByField(view, field2) {
  var scale2 = view.getScaleByField(field2);
  if (!scale2 && view.views) {
    each$1(view.views, function(subView) {
      scale2 = getScaleByField(subView, field2);
      if (scale2) {
        return false;
      }
    });
  }
  return scale2;
}
var Context = function() {
  function Context2(view) {
    this.actions = [];
    this.event = null;
    this.cacheMap = {};
    this.view = view;
  }
  Context2.prototype.cache = function() {
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    if (params.length === 1) {
      return this.cacheMap[params[0]];
    } else if (params.length === 2) {
      this.cacheMap[params[0]] = params[1];
    }
  };
  Context2.prototype.getAction = function(name) {
    return this.actions.find(function(action) {
      return action.name === name;
    });
  };
  Context2.prototype.addAction = function(action) {
    this.actions.push(action);
  };
  Context2.prototype.removeAction = function(action) {
    var actions = this.actions;
    var index2 = this.actions.indexOf(action);
    if (index2 >= 0) {
      actions.splice(index2, 1);
    }
  };
  Context2.prototype.getCurrentPoint = function() {
    var event = this.event;
    if (event) {
      if (event.target instanceof HTMLElement) {
        var canvas = this.view.getCanvas();
        var point2 = canvas.getPointByClient(event.clientX, event.clientY);
        return point2;
      } else {
        return {
          x: event.x,
          y: event.y
        };
      }
    }
    return null;
  };
  Context2.prototype.getCurrentShape = function() {
    return get(this.event, ["gEvent", "shape"]);
  };
  Context2.prototype.isInPlot = function() {
    var point2 = this.getCurrentPoint();
    if (point2) {
      return this.view.isPointInPlot(point2);
    }
    return false;
  };
  Context2.prototype.isInShape = function(name) {
    var shape = this.getCurrentShape();
    if (shape) {
      return shape.get("name") === name;
    }
    return false;
  };
  Context2.prototype.isInComponent = function(name) {
    var components = getComponents(this.view);
    var point2 = this.getCurrentPoint();
    if (point2) {
      return !!components.find(function(component2) {
        var bbox = component2.getBBox();
        if (name) {
          return component2.get("name") === name && isInBox(bbox, point2);
        } else {
          return isInBox(bbox, point2);
        }
      });
    }
    return false;
  };
  Context2.prototype.destroy = function() {
    each$1(this.actions.slice(), function(action) {
      action.destroy();
    });
    this.view = null;
    this.event = null;
    this.actions = null;
    this.cacheMap = null;
  };
  return Context2;
}();
var Interaction = function() {
  function Interaction2(view, cfg) {
    this.view = view;
    this.cfg = cfg;
  }
  Interaction2.prototype.init = function() {
    this.initEvents();
  };
  Interaction2.prototype.initEvents = function() {
  };
  Interaction2.prototype.clearEvents = function() {
  };
  Interaction2.prototype.destroy = function() {
    this.clearEvents();
  };
  return Interaction2;
}();
function parseAction(actionStr, context, arg) {
  var arr = actionStr.split(":");
  var actionName = arr[0];
  var action = context.getAction(actionName) || createAction(actionName, context);
  if (!action) {
    throw new Error("There is no action named " + actionName);
  }
  var methodName = arr[1];
  return {
    action,
    methodName,
    arg
  };
}
function executeAction(actionObject) {
  var action = actionObject.action, methodName = actionObject.methodName, arg = actionObject.arg;
  if (action[methodName]) {
    action[methodName](arg);
  } else {
    throw new Error("Action(" + action.name + ") doesn't have a method called " + methodName);
  }
}
var STEP_NAMES = {
  START: "start",
  SHOW_ENABLE: "showEnable",
  END: "end",
  ROLLBACK: "rollback",
  PROCESSING: "processing"
};
var GrammarInteraction = function(_super) {
  __extends$2(GrammarInteraction2, _super);
  function GrammarInteraction2(view, steps) {
    var _this = _super.call(this, view, steps) || this;
    _this.callbackCaches = {};
    _this.emitCaches = {};
    _this.steps = steps;
    return _this;
  }
  GrammarInteraction2.prototype.init = function() {
    this.initContext();
    _super.prototype.init.call(this);
  };
  GrammarInteraction2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.steps = null;
    if (this.context) {
      this.context.destroy();
      this.context = null;
    }
    this.callbackCaches = null;
    this.view = null;
  };
  GrammarInteraction2.prototype.initEvents = function() {
    var _this = this;
    each$1(this.steps, function(stepArr, stepName) {
      each$1(stepArr, function(step) {
        var callback = _this.getActionCallback(stepName, step);
        if (callback) {
          _this.bindEvent(step.trigger, callback);
        }
      });
    });
  };
  GrammarInteraction2.prototype.clearEvents = function() {
    var _this = this;
    each$1(this.steps, function(stepArr, stepName) {
      each$1(stepArr, function(step) {
        var callback = _this.getActionCallback(stepName, step);
        if (callback) {
          _this.offEvent(step.trigger, callback);
        }
      });
    });
  };
  GrammarInteraction2.prototype.initContext = function() {
    var view = this.view;
    var context = new Context(view);
    this.context = context;
    var steps = this.steps;
    each$1(steps, function(subSteps) {
      each$1(subSteps, function(step) {
        if (isFunction(step.action)) {
          step.actionObject = {
            action: createCallbackAction(step.action, context),
            methodName: "execute"
          };
        } else if (isString(step.action)) {
          step.actionObject = parseAction(step.action, context, step.arg);
        } else if (isArray$1(step.action)) {
          var actionArr = step.action;
          var argArr_1 = isArray$1(step.arg) ? step.arg : [step.arg];
          step.actionObject = [];
          each$1(actionArr, function(actionStr, idx) {
            step.actionObject.push(parseAction(actionStr, context, argArr_1[idx]));
          });
        }
      });
    });
  };
  GrammarInteraction2.prototype.isAllowStep = function(stepName) {
    var currentStepName = this.currentStepName;
    var steps = this.steps;
    if (currentStepName === stepName) {
      return true;
    }
    if (stepName === STEP_NAMES.SHOW_ENABLE) {
      return true;
    }
    if (stepName === STEP_NAMES.PROCESSING) {
      return currentStepName === STEP_NAMES.START;
    }
    if (stepName === STEP_NAMES.START) {
      return currentStepName !== STEP_NAMES.PROCESSING;
    }
    if (stepName === STEP_NAMES.END) {
      return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;
    }
    if (stepName === STEP_NAMES.ROLLBACK) {
      if (steps[STEP_NAMES.END]) {
        return currentStepName === STEP_NAMES.END;
      } else if (currentStepName === STEP_NAMES.START) {
        return true;
      }
    }
    return false;
  };
  GrammarInteraction2.prototype.isAllowExecute = function(stepName, step) {
    if (this.isAllowStep(stepName)) {
      var key = this.getKey(stepName, step);
      if (step.once && this.emitCaches[key]) {
        return false;
      }
      if (step.isEnable) {
        return step.isEnable(this.context);
      }
      return true;
    }
    return false;
  };
  GrammarInteraction2.prototype.enterStep = function(stepName) {
    this.currentStepName = stepName;
    this.emitCaches = {};
  };
  GrammarInteraction2.prototype.afterExecute = function(stepName, step) {
    if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {
      this.enterStep(stepName);
    }
    var key = this.getKey(stepName, step);
    this.emitCaches[key] = true;
  };
  GrammarInteraction2.prototype.getKey = function(stepName, step) {
    return stepName + step.trigger + step.action;
  };
  GrammarInteraction2.prototype.getActionCallback = function(stepName, step) {
    var _this = this;
    var context = this.context;
    var callbackCaches = this.callbackCaches;
    var actionObject = step.actionObject;
    if (step.action && actionObject) {
      var key = this.getKey(stepName, step);
      if (!callbackCaches[key]) {
        var actionCallback = function(event) {
          context.event = event;
          if (_this.isAllowExecute(stepName, step)) {
            if (isArray$1(actionObject)) {
              each$1(actionObject, function(obj) {
                context.event = event;
                executeAction(obj);
              });
            } else {
              context.event = event;
              executeAction(actionObject);
            }
            _this.afterExecute(stepName, step);
            if (step.callback) {
              context.event = event;
              step.callback(context);
            }
          } else {
            context.event = null;
          }
        };
        if (step.debounce) {
          callbackCaches[key] = debounce(actionCallback, step.debounce.wait, step.debounce.immediate);
        } else if (step.throttle) {
          callbackCaches[key] = throttle(actionCallback, step.throttle.wait, {
            leading: step.throttle.leading,
            trailing: step.throttle.trailing
          });
        } else {
          callbackCaches[key] = actionCallback;
        }
      }
      return callbackCaches[key];
    }
    return null;
  };
  GrammarInteraction2.prototype.bindEvent = function(eventName, callback) {
    var nameArr = eventName.split(":");
    if (nameArr[0] === "window") {
      window.addEventListener(nameArr[1], callback);
    } else if (nameArr[0] === "document") {
      document.addEventListener(nameArr[1], callback);
    } else {
      this.view.on(eventName, callback);
    }
  };
  GrammarInteraction2.prototype.offEvent = function(eventName, callback) {
    var nameArr = eventName.split(":");
    if (nameArr[0] === "window") {
      window.removeEventListener(nameArr[1], callback);
    } else if (nameArr[0] === "document") {
      document.removeEventListener(nameArr[1], callback);
    } else {
      this.view.off(eventName, callback);
    }
  };
  return GrammarInteraction2;
}(Interaction);
var Interactions = {};
function getInteraction(name) {
  return Interactions[lowerCase(name)];
}
function registerInteraction(name, interaction2) {
  Interactions[lowerCase(name)] = interaction2;
}
function createInteraction(name, view, cfg) {
  var interaciton = getInteraction(name);
  if (!interaciton) {
    return null;
  }
  if (isPlainObject$1(interaciton)) {
    var steps = mix(clone(interaciton), cfg);
    return new GrammarInteraction(view, steps);
  } else {
    var cls = interaciton;
    return new cls(view, cfg);
  }
}
function createAxisStyles(styleSheet) {
  return {
    title: {
      autoRotate: true,
      position: "center",
      spacing: styleSheet.axisTitleSpacing,
      style: {
        fill: styleSheet.axisTitleTextFillColor,
        fontSize: styleSheet.axisTitleTextFontSize,
        lineHeight: styleSheet.axisTitleTextLineHeight,
        textBaseline: "middle",
        fontFamily: styleSheet.fontFamily
      }
    },
    label: {
      autoRotate: false,
      autoEllipsis: false,
      autoHide: { type: "equidistance", cfg: { minGap: 6 } },
      offset: styleSheet.axisLabelOffset,
      style: {
        fill: styleSheet.axisLabelFillColor,
        fontSize: styleSheet.axisLabelFontSize,
        lineHeight: styleSheet.axisLabelLineHeight,
        fontFamily: styleSheet.fontFamily
      }
    },
    line: {
      style: {
        lineWidth: styleSheet.axisLineBorder,
        stroke: styleSheet.axisLineBorderColor
      }
    },
    grid: {
      line: {
        type: "line",
        style: {
          stroke: styleSheet.axisGridBorderColor,
          lineWidth: styleSheet.axisGridBorder,
          lineDash: styleSheet.axisGridLineDash
        }
      },
      alignTick: true,
      animate: true
    },
    tickLine: {
      style: {
        lineWidth: styleSheet.axisTickLineBorder,
        stroke: styleSheet.axisTickLineBorderColor
      },
      alignTick: true,
      length: styleSheet.axisTickLineLength
    },
    subTickLine: null,
    animate: true
  };
}
function createLegendStyles(styleSheet) {
  return {
    title: null,
    marker: {
      symbol: "circle",
      spacing: styleSheet.legendMarkerSpacing,
      style: {
        r: styleSheet.legendCircleMarkerSize,
        fill: styleSheet.legendMarkerColor
      }
    },
    itemName: {
      spacing: 5,
      style: {
        fill: styleSheet.legendItemNameFillColor,
        fontFamily: styleSheet.fontFamily,
        fontSize: styleSheet.legendItemNameFontSize,
        lineHeight: styleSheet.legendItemNameLineHeight,
        fontWeight: styleSheet.legendItemNameFontWeight,
        textAlign: "start",
        textBaseline: "middle"
      }
    },
    itemStates: {
      active: {
        nameStyle: {
          opacity: 0.8
        }
      },
      unchecked: {
        nameStyle: {
          fill: "#D8D8D8"
        },
        markerStyle: {
          fill: "#D8D8D8",
          stroke: "#D8D8D8"
        }
      },
      inactive: {
        nameStyle: {
          fill: "#D8D8D8"
        },
        markerStyle: {
          opacity: 0.2
        }
      }
    },
    flipPage: true,
    pageNavigator: {
      marker: {
        style: {
          size: styleSheet.legendPageNavigatorMarkerSize,
          inactiveFill: styleSheet.legendPageNavigatorMarkerInactiveFillColor,
          inactiveOpacity: styleSheet.legendPageNavigatorMarkerInactiveFillOpacity,
          fill: styleSheet.legendPageNavigatorMarkerFillColor,
          opacity: styleSheet.legendPageNavigatorMarkerFillOpacity
        }
      },
      text: {
        style: {
          fill: styleSheet.legendPageNavigatorTextFillColor,
          fontSize: styleSheet.legendPageNavigatorTextFontSize
        }
      }
    },
    animate: false,
    maxItemWidth: 200,
    itemSpacing: styleSheet.legendItemSpacing,
    itemMarginBottom: styleSheet.legendItemMarginBottom,
    padding: styleSheet.legendPadding
  };
}
function createThemeByStyleSheet(styleSheet) {
  var _a2;
  var shapeStyles = {
    point: {
      default: {
        fill: styleSheet.pointFillColor,
        r: styleSheet.pointSize,
        stroke: styleSheet.pointBorderColor,
        lineWidth: styleSheet.pointBorder,
        fillOpacity: styleSheet.pointFillOpacity
      },
      active: {
        stroke: styleSheet.pointActiveBorderColor,
        lineWidth: styleSheet.pointActiveBorder
      },
      selected: {
        stroke: styleSheet.pointSelectedBorderColor,
        lineWidth: styleSheet.pointSelectedBorder
      },
      inactive: {
        fillOpacity: styleSheet.pointInactiveFillOpacity,
        strokeOpacity: styleSheet.pointInactiveBorderOpacity
      }
    },
    hollowPoint: {
      default: {
        fill: styleSheet.hollowPointFillColor,
        lineWidth: styleSheet.hollowPointBorder,
        stroke: styleSheet.hollowPointBorderColor,
        strokeOpacity: styleSheet.hollowPointBorderOpacity,
        r: styleSheet.hollowPointSize
      },
      active: {
        stroke: styleSheet.hollowPointActiveBorderColor,
        strokeOpacity: styleSheet.hollowPointActiveBorderOpacity
      },
      selected: {
        lineWidth: styleSheet.hollowPointSelectedBorder,
        stroke: styleSheet.hollowPointSelectedBorderColor,
        strokeOpacity: styleSheet.hollowPointSelectedBorderOpacity
      },
      inactive: {
        strokeOpacity: styleSheet.hollowPointInactiveBorderOpacity
      }
    },
    area: {
      default: {
        fill: styleSheet.areaFillColor,
        fillOpacity: styleSheet.areaFillOpacity,
        stroke: null
      },
      active: {
        fillOpacity: styleSheet.areaActiveFillOpacity
      },
      selected: {
        fillOpacity: styleSheet.areaSelectedFillOpacity
      },
      inactive: {
        fillOpacity: styleSheet.areaInactiveFillOpacity
      }
    },
    hollowArea: {
      default: {
        fill: null,
        stroke: styleSheet.hollowAreaBorderColor,
        lineWidth: styleSheet.hollowAreaBorder,
        strokeOpacity: styleSheet.hollowAreaBorderOpacity
      },
      active: {
        fill: null,
        lineWidth: styleSheet.hollowAreaActiveBorder
      },
      selected: {
        fill: null,
        lineWidth: styleSheet.hollowAreaSelectedBorder
      },
      inactive: {
        strokeOpacity: styleSheet.hollowAreaInactiveBorderOpacity
      }
    },
    interval: {
      default: {
        fill: styleSheet.intervalFillColor,
        fillOpacity: styleSheet.intervalFillOpacity
      },
      active: {
        stroke: styleSheet.intervalActiveBorderColor,
        lineWidth: styleSheet.intervalActiveBorder
      },
      selected: {
        stroke: styleSheet.intervalSelectedBorderColor,
        lineWidth: styleSheet.intervalSelectedBorder
      },
      inactive: {
        fillOpacity: styleSheet.intervalInactiveFillOpacity,
        strokeOpacity: styleSheet.intervalInactiveBorderOpacity
      }
    },
    hollowInterval: {
      default: {
        fill: styleSheet.hollowIntervalFillColor,
        stroke: styleSheet.hollowIntervalBorderColor,
        lineWidth: styleSheet.hollowIntervalBorder,
        strokeOpacity: styleSheet.hollowIntervalBorderOpacity
      },
      active: {
        stroke: styleSheet.hollowIntervalActiveBorderColor,
        lineWidth: styleSheet.hollowIntervalActiveBorder,
        strokeOpacity: styleSheet.hollowIntervalActiveBorderOpacity
      },
      selected: {
        stroke: styleSheet.hollowIntervalSelectedBorderColor,
        lineWidth: styleSheet.hollowIntervalSelectedBorder,
        strokeOpacity: styleSheet.hollowIntervalSelectedBorderOpacity
      },
      inactive: {
        stroke: styleSheet.hollowIntervalInactiveBorderColor,
        lineWidth: styleSheet.hollowIntervalInactiveBorder,
        strokeOpacity: styleSheet.hollowIntervalInactiveBorderOpacity
      }
    },
    line: {
      default: {
        stroke: styleSheet.lineBorderColor,
        lineWidth: styleSheet.lineBorder,
        strokeOpacity: styleSheet.lineBorderOpacity,
        fill: null,
        lineAppendWidth: 10,
        lineCap: "round",
        lineJoin: "round"
      },
      active: {
        lineWidth: styleSheet.lineActiveBorder
      },
      selected: {
        lineWidth: styleSheet.lineSelectedBorder
      },
      inactive: {
        strokeOpacity: styleSheet.lineInactiveBorderOpacity
      }
    }
  };
  var axisStyles = createAxisStyles(styleSheet);
  var legendStyles = createLegendStyles(styleSheet);
  return {
    background: styleSheet.backgroundColor,
    defaultColor: styleSheet.brandColor,
    subColor: styleSheet.subColor,
    semanticRed: styleSheet.paletteSemanticRed,
    semanticGreen: styleSheet.paletteSemanticGreen,
    padding: "auto",
    fontFamily: styleSheet.fontFamily,
    columnWidthRatio: 1 / 2,
    maxColumnWidth: null,
    minColumnWidth: null,
    roseWidthRatio: 0.9999999,
    multiplePieWidthRatio: 1 / 1.3,
    colors10: styleSheet.paletteQualitative10,
    colors20: styleSheet.paletteQualitative20,
    sequenceColors: styleSheet.paletteSequence,
    shapes: {
      point: [
        "hollow-circle",
        "hollow-square",
        "hollow-bowtie",
        "hollow-diamond",
        "hollow-hexagon",
        "hollow-triangle",
        "hollow-triangle-down",
        "circle",
        "square",
        "bowtie",
        "diamond",
        "hexagon",
        "triangle",
        "triangle-down",
        "cross",
        "tick",
        "plus",
        "hyphen",
        "line"
      ],
      line: ["line", "dash", "dot", "smooth"],
      area: ["area", "smooth", "line", "smooth-line"],
      interval: ["rect", "hollow-rect", "line", "tick"]
    },
    sizes: [1, 10],
    geometries: {
      interval: {
        rect: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: function(element) {
              var coordinate2 = element.geometry.coordinate;
              if (coordinate2.isPolar && coordinate2.isTransposed) {
                var _a3 = getAngle$1(element.getModel(), coordinate2), startAngle = _a3.startAngle, endAngle = _a3.endAngle;
                var middleAngle = (startAngle + endAngle) / 2;
                var r = 7.5;
                var x = r * Math.cos(middleAngle);
                var y = r * Math.sin(middleAngle);
                return {
                  matrix: transform$7(null, [["t", x, y]])
                };
              }
              return shapeStyles.interval.selected;
            }
          }
        },
        "hollow-rect": {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        tick: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        funnel: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        },
        pyramid: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        }
      },
      line: {
        line: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        dot: {
          default: {
            style: __assign$1(__assign$1({}, shapeStyles.line.default), { lineCap: null, lineDash: [1, 1] })
          },
          active: {
            style: __assign$1(__assign$1({}, shapeStyles.line.active), { lineCap: null, lineDash: [1, 1] })
          },
          inactive: {
            style: __assign$1(__assign$1({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [1, 1] })
          },
          selected: {
            style: __assign$1(__assign$1({}, shapeStyles.line.selected), { lineCap: null, lineDash: [1, 1] })
          }
        },
        dash: {
          default: {
            style: __assign$1(__assign$1({}, shapeStyles.line.default), { lineCap: null, lineDash: [5.5, 1] })
          },
          active: {
            style: __assign$1(__assign$1({}, shapeStyles.line.active), { lineCap: null, lineDash: [5.5, 1] })
          },
          inactive: {
            style: __assign$1(__assign$1({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [5.5, 1] })
          },
          selected: {
            style: __assign$1(__assign$1({}, shapeStyles.line.selected), { lineCap: null, lineDash: [5.5, 1] })
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vh: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hvh: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vhv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        }
      },
      polygon: {
        polygon: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        }
      },
      point: {
        circle: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        square: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        bowtie: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        diamond: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        hexagon: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        triangle: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        "triangle-down": {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        "hollow-circle": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-square": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-bowtie": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-diamond": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-hexagon": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-triangle": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-triangle-down": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        cross: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        tick: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        plus: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        hyphen: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        }
      },
      area: {
        area: {
          default: {
            style: shapeStyles.area.default
          },
          active: {
            style: shapeStyles.area.active
          },
          inactive: {
            style: shapeStyles.area.inactive
          },
          selected: {
            style: shapeStyles.area.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.area.default
          },
          active: {
            style: shapeStyles.area.active
          },
          inactive: {
            style: shapeStyles.area.inactive
          },
          selected: {
            style: shapeStyles.area.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        },
        "smooth-line": {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        }
      },
      schema: {
        candle: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        box: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        }
      },
      edge: {
        line: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vhv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        arc: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        }
      },
      violin: {
        violin: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hollow: {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        },
        "hollow-smooth": {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        }
      }
    },
    components: {
      axis: {
        common: axisStyles,
        top: {
          position: "top",
          grid: null,
          title: null,
          verticalLimitLength: 1 / 2
        },
        bottom: {
          position: "bottom",
          grid: null,
          title: null,
          verticalLimitLength: 1 / 2
        },
        left: {
          position: "left",
          title: null,
          line: null,
          tickLine: null,
          verticalLimitLength: 1 / 3
        },
        right: {
          position: "right",
          title: null,
          line: null,
          tickLine: null,
          verticalLimitLength: 1 / 3
        },
        circle: {
          title: null,
          grid: deepMix({}, axisStyles.grid, { line: { type: "line" } })
        },
        radius: {
          title: null,
          grid: deepMix({}, axisStyles.grid, { line: { type: "circle" } })
        }
      },
      legend: {
        common: legendStyles,
        right: {
          layout: "vertical",
          padding: styleSheet.legendVerticalPadding
        },
        left: {
          layout: "vertical",
          padding: styleSheet.legendVerticalPadding
        },
        top: {
          layout: "horizontal",
          padding: styleSheet.legendHorizontalPadding
        },
        bottom: {
          layout: "horizontal",
          padding: styleSheet.legendHorizontalPadding
        },
        continuous: {
          title: null,
          background: null,
          track: {},
          rail: {
            type: "color",
            size: styleSheet.sliderRailHeight,
            defaultLength: styleSheet.sliderRailWidth,
            style: {
              fill: styleSheet.sliderRailFillColor,
              stroke: styleSheet.sliderRailBorderColor,
              lineWidth: styleSheet.sliderRailBorder
            }
          },
          label: {
            align: "rail",
            spacing: 4,
            formatter: null,
            style: {
              fill: styleSheet.sliderLabelTextFillColor,
              fontSize: styleSheet.sliderLabelTextFontSize,
              lineHeight: styleSheet.sliderLabelTextLineHeight,
              textBaseline: "middle",
              fontFamily: styleSheet.fontFamily
            }
          },
          handler: {
            size: styleSheet.sliderHandlerWidth,
            style: {
              fill: styleSheet.sliderHandlerFillColor,
              stroke: styleSheet.sliderHandlerBorderColor
            }
          },
          slidable: true,
          padding: legendStyles.padding
        }
      },
      tooltip: {
        showContent: true,
        follow: true,
        showCrosshairs: false,
        showMarkers: true,
        shared: false,
        enterable: false,
        position: "auto",
        marker: {
          symbol: "circle",
          stroke: "#fff",
          shadowBlur: 10,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          shadowColor: "rgba(0,0,0,0.09)",
          lineWidth: 2,
          r: 4
        },
        crosshairs: {
          line: {
            style: {
              stroke: styleSheet.tooltipCrosshairsBorderColor,
              lineWidth: styleSheet.tooltipCrosshairsBorder
            }
          },
          text: null,
          textBackground: {
            padding: 2,
            style: {
              fill: "rgba(0, 0, 0, 0.25)",
              lineWidth: 0,
              stroke: null
            }
          },
          follow: false
        },
        domStyles: (_a2 = {}, _a2["" + CONTAINER_CLASS] = {
          position: "absolute",
          visibility: "hidden",
          zIndex: 8,
          transition: "left 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s, top 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s",
          backgroundColor: styleSheet.tooltipContainerFillColor,
          opacity: styleSheet.tooltipContainerFillOpacity,
          boxShadow: styleSheet.tooltipContainerShadow,
          borderRadius: styleSheet.tooltipContainerBorderRadius + "px",
          color: styleSheet.tooltipTextFillColor,
          fontSize: styleSheet.tooltipTextFontSize + "px",
          fontFamily: styleSheet.fontFamily,
          lineHeight: styleSheet.tooltipTextLineHeight + "px",
          padding: "0 12px 0 12px"
        }, _a2["" + TITLE_CLASS] = {
          marginBottom: "12px",
          marginTop: "12px"
        }, _a2["" + LIST_CLASS] = {
          margin: 0,
          listStyleType: "none",
          padding: 0
        }, _a2["" + LIST_ITEM_CLASS] = {
          listStyleType: "none",
          padding: 0,
          marginBottom: "12px",
          marginTop: "12px",
          marginLeft: 0,
          marginRight: 0
        }, _a2["" + MARKER_CLASS] = {
          width: "8px",
          height: "8px",
          borderRadius: "50%",
          display: "inline-block",
          marginRight: "8px"
        }, _a2["" + VALUE_CLASS] = {
          display: "inline-block",
          float: "right",
          marginLeft: "30px"
        }, _a2)
      },
      annotation: {
        arc: {
          style: {
            stroke: styleSheet.annotationArcBorderColor,
            lineWidth: styleSheet.annotationArcBorder
          },
          animate: true
        },
        line: {
          style: {
            stroke: styleSheet.annotationLineBorderColor,
            lineDash: styleSheet.annotationLineDash,
            lineWidth: styleSheet.annotationLineBorder
          },
          text: {
            position: "start",
            autoRotate: true,
            style: {
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              textAlign: "start",
              fontFamily: styleSheet.fontFamily,
              textBaseline: "bottom"
            }
          },
          animate: true
        },
        text: {
          style: {
            fill: styleSheet.annotationTextFillColor,
            stroke: styleSheet.annotationTextBorderColor,
            lineWidth: styleSheet.annotationTextBorder,
            fontSize: styleSheet.annotationTextFontSize,
            textBaseline: "middle",
            textAlign: "start",
            fontFamily: styleSheet.fontFamily
          },
          animate: true
        },
        region: {
          top: false,
          style: {
            lineWidth: styleSheet.annotationRegionBorder,
            stroke: styleSheet.annotationRegionBorderColor,
            fill: styleSheet.annotationRegionFillColor,
            fillOpacity: styleSheet.annotationRegionFillOpacity
          },
          animate: true
        },
        image: {
          top: false,
          animate: true
        },
        dataMarker: {
          top: true,
          point: {
            style: {
              r: 3,
              stroke: styleSheet.brandColor,
              lineWidth: 2
            }
          },
          line: {
            style: {
              stroke: styleSheet.annotationLineBorderColor,
              lineWidth: styleSheet.annotationLineBorder
            },
            length: styleSheet.annotationDataMarkerLineLength
          },
          text: {
            style: {
              textAlign: "start",
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              fontFamily: styleSheet.fontFamily
            }
          },
          direction: "upward",
          autoAdjust: true,
          animate: true
        },
        dataRegion: {
          style: {
            region: {
              fill: styleSheet.annotationRegionFillColor,
              fillOpacity: styleSheet.annotationRegionFillOpacity
            },
            text: {
              textAlign: "center",
              textBaseline: "bottom",
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              fontFamily: styleSheet.fontFamily
            }
          },
          animate: true
        }
      },
      slider: {
        common: {
          padding: [8, 8, 8, 8],
          backgroundStyle: {
            fill: styleSheet.cSliderBackgroundFillColor,
            opacity: styleSheet.cSliderBackgroundFillOpacity
          },
          foregroundStyle: {
            fill: styleSheet.cSliderForegroundFillColor,
            opacity: styleSheet.cSliderForegroundFillOpacity
          },
          handlerStyle: {
            width: styleSheet.cSliderHandlerWidth,
            height: styleSheet.cSliderHandlerHeight,
            fill: styleSheet.cSliderHandlerFillColor,
            opacity: styleSheet.cSliderHandlerFillOpacity,
            stroke: styleSheet.cSliderHandlerBorderColor,
            lineWidth: styleSheet.cSliderHandlerBorder,
            radius: styleSheet.cSliderHandlerBorderRadius,
            highLightFill: styleSheet.cSliderHandlerHighlightFillColor
          },
          textStyle: {
            fill: styleSheet.cSliderTextFillColor,
            opacity: styleSheet.cSliderTextFillOpacity,
            fontSize: styleSheet.cSliderTextFontSize,
            lineHeight: styleSheet.cSliderTextLineHeight,
            fontWeight: styleSheet.cSliderTextFontWeight,
            stroke: styleSheet.cSliderTextBorderColor,
            lineWidth: styleSheet.cSliderTextBorder
          }
        }
      },
      scrollbar: {
        common: {
          padding: [8, 8, 8, 8]
        },
        default: {
          style: {
            trackColor: styleSheet.scrollbarTrackFillColor,
            thumbColor: styleSheet.scrollbarThumbFillColor
          }
        },
        hover: {
          style: {
            thumbColor: styleSheet.scrollbarThumbHighlightFillColor
          }
        }
      }
    },
    labels: {
      offset: 12,
      style: {
        fill: styleSheet.labelFillColor,
        fontSize: styleSheet.labelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.labelBorderColor,
        lineWidth: styleSheet.labelBorder
      },
      fillColorDark: styleSheet.labelFillColorDark,
      fillColorLight: styleSheet.labelFillColorLight,
      autoRotate: true
    },
    innerLabels: {
      style: {
        fill: styleSheet.innerLabelFillColor,
        fontSize: styleSheet.innerLabelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.innerLabelBorderColor,
        lineWidth: styleSheet.innerLabelBorder
      },
      autoRotate: true
    },
    overflowLabels: {
      style: {
        fill: styleSheet.overflowLabelFillColor,
        fontSize: styleSheet.overflowLabelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.overflowLabelBorderColor,
        lineWidth: styleSheet.overflowLabelBorder
      }
    },
    pieLabels: {
      labelHeight: 14,
      offset: 10,
      labelLine: {
        style: {
          lineWidth: styleSheet.labelLineBorder
        }
      },
      autoRotate: true
    }
  };
}
var BLACK_COLORS$1 = {
  100: "#000",
  95: "#0D0D0D",
  85: "#262626",
  65: "#595959",
  45: "#8C8C8C",
  25: "#BFBFBF",
  15: "#D9D9D9",
  6: "#F0F0F0"
};
var WHITE_COLORS$1 = {
  100: "#FFFFFF",
  95: "#F2F2F2",
  85: "#D9D9D9",
  65: "#A6A6A6",
  45: "#737373",
  25: "#404040",
  15: "#262626",
  6: "#0F0F0F"
};
var QUALITATIVE_10$1 = [
  "#5B8FF9",
  "#5AD8A6",
  "#5D7092",
  "#F6BD16",
  "#6F5EF9",
  "#6DC8EC",
  "#945FB9",
  "#FF9845",
  "#1E9493",
  "#FF99C3"
];
var QUALITATIVE_20$1 = [
  "#5B8FF9",
  "#CDDDFD",
  "#5AD8A6",
  "#CDF3E4",
  "#5D7092",
  "#CED4DE",
  "#F6BD16",
  "#FCEBB9",
  "#6F5EF9",
  "#D3CEFD",
  "#6DC8EC",
  "#D3EEF9",
  "#945FB9",
  "#DECFEA",
  "#FF9845",
  "#FFE0C7",
  "#1E9493",
  "#BBDEDE",
  "#FF99C3",
  "#FFE0ED"
];
var SINGLE_SEQUENCE$1 = [
  "#B8E1FF",
  "#9AC5FF",
  "#7DAAFF",
  "#5B8FF9",
  "#3D76DD",
  "#085EC0",
  "#0047A5",
  "#00318A",
  "#001D70"
];
var createLightStyleSheet = function(cfg) {
  if (cfg === void 0) {
    cfg = {};
  }
  var _a2 = cfg.backgroundColor, backgroundColor = _a2 === void 0 ? "transparent" : _a2, _b = cfg.subColor, subColor = _b === void 0 ? "rgba(0,0,0,0.05)" : _b, _c = cfg.paletteQualitative10, paletteQualitative10 = _c === void 0 ? QUALITATIVE_10$1 : _c, _d = cfg.paletteQualitative20, paletteQualitative20 = _d === void 0 ? QUALITATIVE_20$1 : _d, _e = cfg.paletteSemanticRed, paletteSemanticRed = _e === void 0 ? "#F4664A" : _e, _f = cfg.paletteSemanticGreen, paletteSemanticGreen = _f === void 0 ? "#30BF78" : _f, _g = cfg.paletteSemanticYellow, paletteSemanticYellow = _g === void 0 ? "#FAAD14" : _g, _h = cfg.paletteSequence, paletteSequence = _h === void 0 ? SINGLE_SEQUENCE$1 : _h, _j = cfg.fontFamily, fontFamily = _j === void 0 ? '"Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"' : _j;
  var _k = cfg.brandColor, brandColor = _k === void 0 ? paletteQualitative10[0] : _k;
  return {
    backgroundColor,
    brandColor,
    subColor,
    paletteQualitative10,
    paletteQualitative20,
    paletteSemanticRed,
    paletteSemanticGreen,
    paletteSemanticYellow,
    paletteSequence,
    fontFamily,
    axisLineBorderColor: BLACK_COLORS$1[25],
    axisLineBorder: 1,
    axisLineDash: null,
    axisTitleTextFillColor: BLACK_COLORS$1[65],
    axisTitleTextFontSize: 12,
    axisTitleTextLineHeight: 12,
    axisTitleTextFontWeight: "normal",
    axisTitleSpacing: 12,
    axisTickLineBorderColor: BLACK_COLORS$1[25],
    axisTickLineLength: 4,
    axisTickLineBorder: 1,
    axisSubTickLineBorderColor: BLACK_COLORS$1[15],
    axisSubTickLineLength: 2,
    axisSubTickLineBorder: 1,
    axisLabelFillColor: BLACK_COLORS$1[45],
    axisLabelFontSize: 12,
    axisLabelLineHeight: 12,
    axisLabelFontWeight: "normal",
    axisLabelOffset: 8,
    axisGridBorderColor: BLACK_COLORS$1[15],
    axisGridBorder: 1,
    axisGridLineDash: null,
    legendTitleTextFillColor: BLACK_COLORS$1[45],
    legendTitleTextFontSize: 12,
    legendTitleTextLineHeight: 21,
    legendTitleTextFontWeight: "normal",
    legendMarkerColor: brandColor,
    legendMarkerSpacing: 8,
    legendMarkerSize: 4,
    legendCircleMarkerSize: 4,
    legendSquareMarkerSize: 4,
    legendLineMarkerSize: 5,
    legendItemNameFillColor: BLACK_COLORS$1[65],
    legendItemNameFontSize: 12,
    legendItemNameLineHeight: 12,
    legendItemNameFontWeight: "normal",
    legendItemSpacing: 24,
    legendItemMarginBottom: 12,
    legendPadding: [8, 8, 8, 8],
    legendHorizontalPadding: [8, 0, 8, 0],
    legendVerticalPadding: [0, 8, 0, 8],
    legendPageNavigatorMarkerSize: 12,
    legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS$1[100],
    legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
    legendPageNavigatorMarkerFillColor: BLACK_COLORS$1[100],
    legendPageNavigatorMarkerFillOpacity: 1,
    legendPageNavigatorTextFillColor: BLACK_COLORS$1[45],
    legendPageNavigatorTextFontSize: 12,
    sliderRailFillColor: BLACK_COLORS$1[15],
    sliderRailBorder: 0,
    sliderRailBorderColor: null,
    sliderRailWidth: 100,
    sliderRailHeight: 12,
    sliderLabelTextFillColor: BLACK_COLORS$1[45],
    sliderLabelTextFontSize: 12,
    sliderLabelTextLineHeight: 12,
    sliderLabelTextFontWeight: "normal",
    sliderHandlerFillColor: BLACK_COLORS$1[6],
    sliderHandlerWidth: 10,
    sliderHandlerHeight: 14,
    sliderHandlerBorder: 1,
    sliderHandlerBorderColor: BLACK_COLORS$1[25],
    annotationArcBorderColor: BLACK_COLORS$1[15],
    annotationArcBorder: 1,
    annotationLineBorderColor: BLACK_COLORS$1[25],
    annotationLineBorder: 1,
    annotationLineDash: null,
    annotationTextFillColor: BLACK_COLORS$1[65],
    annotationTextFontSize: 12,
    annotationTextLineHeight: 12,
    annotationTextFontWeight: "normal",
    annotationTextBorderColor: null,
    annotationTextBorder: 0,
    annotationRegionFillColor: BLACK_COLORS$1[100],
    annotationRegionFillOpacity: 0.06,
    annotationRegionBorder: 0,
    annotationRegionBorderColor: null,
    annotationDataMarkerLineLength: 16,
    tooltipCrosshairsBorderColor: BLACK_COLORS$1[25],
    tooltipCrosshairsBorder: 1,
    tooltipCrosshairsLineDash: null,
    tooltipContainerFillColor: "rgb(255, 255, 255)",
    tooltipContainerFillOpacity: 0.95,
    tooltipContainerShadow: "0px 0px 10px #aeaeae",
    tooltipContainerBorderRadius: 3,
    tooltipTextFillColor: BLACK_COLORS$1[65],
    tooltipTextFontSize: 12,
    tooltipTextLineHeight: 12,
    tooltipTextFontWeight: "bold",
    labelFillColor: BLACK_COLORS$1[65],
    labelFillColorDark: "#2c3542",
    labelFillColorLight: "#ffffff",
    labelFontSize: 12,
    labelLineHeight: 12,
    labelFontWeight: "normal",
    labelBorderColor: null,
    labelBorder: 0,
    innerLabelFillColor: WHITE_COLORS$1[100],
    innerLabelFontSize: 12,
    innerLabelLineHeight: 12,
    innerLabelFontWeight: "normal",
    innerLabelBorderColor: null,
    innerLabelBorder: 0,
    overflowLabelFillColor: BLACK_COLORS$1[65],
    overflowLabelFontSize: 12,
    overflowLabelLineHeight: 12,
    overflowLabelFontWeight: "normal",
    overflowLabelBorderColor: WHITE_COLORS$1[100],
    overflowLabelBorder: 1,
    labelLineBorder: 1,
    labelLineBorderColor: BLACK_COLORS$1[25],
    cSliderRailHieght: 16,
    cSliderBackgroundFillColor: "#416180",
    cSliderBackgroundFillOpacity: 0.05,
    cSliderForegroundFillColor: "#5B8FF9",
    cSliderForegroundFillOpacity: 0.15,
    cSliderHandlerHeight: 24,
    cSliderHandlerWidth: 10,
    cSliderHandlerFillColor: "#F7F7F7",
    cSliderHandlerFillOpacity: 1,
    cSliderHandlerHighlightFillColor: "#FFF",
    cSliderHandlerBorderColor: "#BFBFBF",
    cSliderHandlerBorder: 1,
    cSliderHandlerBorderRadius: 2,
    cSliderTextFillColor: "#000",
    cSliderTextFillOpacity: 0.45,
    cSliderTextFontSize: 12,
    cSliderTextLineHeight: 12,
    cSliderTextFontWeight: "normal",
    cSliderTextBorderColor: null,
    cSliderTextBorder: 0,
    scrollbarTrackFillColor: "rgba(0,0,0,0)",
    scrollbarThumbFillColor: "rgba(0,0,0,0.15)",
    scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.2)",
    pointFillColor: brandColor,
    pointFillOpacity: 0.95,
    pointSize: 4,
    pointBorder: 1,
    pointBorderColor: WHITE_COLORS$1[100],
    pointBorderOpacity: 1,
    pointActiveBorderColor: BLACK_COLORS$1[100],
    pointSelectedBorder: 2,
    pointSelectedBorderColor: BLACK_COLORS$1[100],
    pointInactiveFillOpacity: 0.3,
    pointInactiveBorderOpacity: 0.3,
    hollowPointSize: 4,
    hollowPointBorder: 1,
    hollowPointBorderColor: brandColor,
    hollowPointBorderOpacity: 0.95,
    hollowPointFillColor: WHITE_COLORS$1[100],
    hollowPointActiveBorder: 1,
    hollowPointActiveBorderColor: BLACK_COLORS$1[100],
    hollowPointActiveBorderOpacity: 1,
    hollowPointSelectedBorder: 2,
    hollowPointSelectedBorderColor: BLACK_COLORS$1[100],
    hollowPointSelectedBorderOpacity: 1,
    hollowPointInactiveBorderOpacity: 0.3,
    lineBorder: 2,
    lineBorderColor: brandColor,
    lineBorderOpacity: 1,
    lineActiveBorder: 3,
    lineSelectedBorder: 3,
    lineInactiveBorderOpacity: 0.3,
    areaFillColor: brandColor,
    areaFillOpacity: 0.25,
    areaActiveFillColor: brandColor,
    areaActiveFillOpacity: 0.5,
    areaSelectedFillColor: brandColor,
    areaSelectedFillOpacity: 0.5,
    areaInactiveFillOpacity: 0.3,
    hollowAreaBorderColor: brandColor,
    hollowAreaBorder: 2,
    hollowAreaBorderOpacity: 1,
    hollowAreaActiveBorder: 3,
    hollowAreaActiveBorderColor: BLACK_COLORS$1[100],
    hollowAreaSelectedBorder: 3,
    hollowAreaSelectedBorderColor: BLACK_COLORS$1[100],
    hollowAreaInactiveBorderOpacity: 0.3,
    intervalFillColor: brandColor,
    intervalFillOpacity: 0.95,
    intervalActiveBorder: 1,
    intervalActiveBorderColor: BLACK_COLORS$1[100],
    intervalActiveBorderOpacity: 1,
    intervalSelectedBorder: 2,
    intervalSelectedBorderColor: BLACK_COLORS$1[100],
    intervalSelectedBorderOpacity: 1,
    intervalInactiveBorderOpacity: 0.3,
    intervalInactiveFillOpacity: 0.3,
    hollowIntervalBorder: 2,
    hollowIntervalBorderColor: brandColor,
    hollowIntervalBorderOpacity: 1,
    hollowIntervalFillColor: WHITE_COLORS$1[100],
    hollowIntervalActiveBorder: 2,
    hollowIntervalActiveBorderColor: BLACK_COLORS$1[100],
    hollowIntervalSelectedBorder: 3,
    hollowIntervalSelectedBorderColor: BLACK_COLORS$1[100],
    hollowIntervalSelectedBorderOpacity: 1,
    hollowIntervalInactiveBorderOpacity: 0.3
  };
};
createLightStyleSheet();
function createTheme(themeCfg) {
  var _a2 = themeCfg.styleSheet, styleSheetCfg = _a2 === void 0 ? {} : _a2, themeObject = __rest(themeCfg, ["styleSheet"]);
  var styleSheet = createLightStyleSheet(styleSheetCfg);
  return deepMix({}, createThemeByStyleSheet(styleSheet), themeObject);
}
var defaultTheme = createTheme({});
var Themes = {
  default: defaultTheme
};
function getTheme(theme2) {
  return get(Themes, lowerCase(theme2), Themes.default);
}
function registerTheme(theme2, value2) {
  Themes[lowerCase(theme2)] = createTheme(value2);
}
function snapEqual(v1, v2, scale2) {
  var value1 = scale2.translate(v1);
  var value2 = scale2.translate(v2);
  return isNumberEqual$1(value1, value2);
}
function getXValueByPoint(point2, geometry2) {
  var coordinate2 = geometry2.coordinate;
  var xScale = geometry2.getXScale();
  var range = xScale.range;
  var rangeMax = range[range.length - 1];
  var rangeMin = range[0];
  var invertPoint = coordinate2.invert(point2);
  var xValue = invertPoint.x;
  if (coordinate2.isPolar && xValue > (1 + rangeMax) / 2) {
    xValue = rangeMin;
  }
  return xScale.translate(xScale.invert(xValue));
}
function filterYValue(data2, point2, geometry2) {
  var coordinate2 = geometry2.coordinate;
  var yScale = geometry2.getYScale();
  var yField = yScale.field;
  var invertPoint = coordinate2.invert(point2);
  var yValue = yScale.invert(invertPoint.y);
  var result = find$1(data2, function(obj) {
    var originData = obj[FIELD_ORIGIN];
    return originData[yField][0] <= yValue && originData[yField][1] >= yValue;
  });
  return result || data2[data2.length - 1];
}
var getXDistance = memoize(function(scale2) {
  if (scale2.isCategory) {
    return 1;
  }
  var scaleValues = scale2.values;
  var length2 = scaleValues.length;
  var min2 = scale2.translate(scaleValues[0]);
  var max2 = min2;
  for (var index2 = 0; index2 < length2; index2++) {
    var value2 = scaleValues[index2];
    var numericValue = scale2.translate(value2);
    if (numericValue < min2) {
      min2 = numericValue;
    }
    if (numericValue > max2) {
      max2 = numericValue;
    }
  }
  return (max2 - min2) / (length2 - 1);
});
function getTooltipTitle(originData, geometry2, title) {
  var positionAttr = geometry2.getAttribute("position");
  var fields = positionAttr.getFields();
  var scales = geometry2.scales;
  var titleField = isFunction(title) || !title ? fields[0] : title;
  var titleScale = scales[titleField];
  var tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;
  return isFunction(title) ? title(tooltipTitle, originData) : tooltipTitle;
}
function getAttributesForLegend(geometry2) {
  var attributes = values(geometry2.attributes);
  return filter(attributes, function(attribute) {
    return contains(GROUP_ATTRS, attribute.type);
  });
}
function getTooltipValueScale(geometry2) {
  var attributes = getAttributesForLegend(geometry2);
  var scale2;
  for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
    var attribute = attributes_1[_i];
    var tmpScale = attribute.getScale(attribute.type);
    if (tmpScale && tmpScale.isLinear) {
      scale2 = tmpScale;
      break;
    }
  }
  var xScale = geometry2.getXScale();
  var yScale = geometry2.getYScale();
  return scale2 || yScale || xScale;
}
function getTooltipValue(originData, valueScale) {
  var field2 = valueScale.field;
  var value2 = originData[field2];
  if (isArray$1(value2)) {
    var texts = value2.map(function(eachValue) {
      return valueScale.getText(eachValue);
    });
    return texts.join("-");
  }
  return valueScale.getText(value2);
}
function getTooltipName(originData, geometry2) {
  var nameScale;
  var groupScales = geometry2.getGroupScales();
  if (groupScales.length) {
    nameScale = groupScales[0];
  }
  if (nameScale) {
    var field2 = nameScale.field;
    return nameScale.getText(originData[field2]);
  }
  var valueScale = getTooltipValueScale(geometry2);
  return getName(valueScale);
}
function findDataByPoint(point2, data2, geometry2) {
  if (data2.length === 0) {
    return null;
  }
  var geometryType = geometry2.type;
  var xScale = geometry2.getXScale();
  var yScale = geometry2.getYScale();
  var xField = xScale.field;
  var yField = yScale.field;
  var rst = null;
  if (geometryType === "heatmap" || geometryType === "point") {
    var coordinate2 = geometry2.coordinate;
    var invertPoint = coordinate2.invert(point2);
    var x = xScale.invert(invertPoint.x);
    var y = yScale.invert(invertPoint.y);
    var min2 = Infinity;
    for (var index2 = 0; index2 < data2.length; index2++) {
      var obj = data2[index2];
      var originData = obj[FIELD_ORIGIN];
      var range = Math.pow(originData[xField] - x, 2) + Math.pow(originData[yField] - y, 2);
      if (range < min2) {
        min2 = range;
        rst = obj;
      }
    }
    return rst;
  }
  var first = data2[0];
  var last2 = data2[data2.length - 1];
  var xValue = getXValueByPoint(point2, geometry2);
  var firstXValue = first[FIELD_ORIGIN][xField];
  var firstYValue = first[FIELD_ORIGIN][yField];
  var lastXValue = last2[FIELD_ORIGIN][xField];
  var isYArray = yScale.isLinear && isArray$1(firstYValue);
  if (isArray$1(firstXValue)) {
    for (var index2 = 0; index2 < data2.length; index2++) {
      var record = data2[index2];
      var originData = record[FIELD_ORIGIN];
      if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {
        if (isYArray) {
          if (!isArray$1(rst)) {
            rst = [];
          }
          rst.push(record);
        } else {
          rst = record;
          break;
        }
      }
    }
    if (isArray$1(rst)) {
      rst = filterYValue(rst, point2, geometry2);
    }
  } else {
    var next = void 0;
    if (!xScale.isLinear && xScale.type !== "timeCat") {
      for (var index2 = 0; index2 < data2.length; index2++) {
        var record = data2[index2];
        var originData = record[FIELD_ORIGIN];
        if (snapEqual(originData[xField], xValue, xScale)) {
          if (isYArray) {
            if (!isArray$1(rst)) {
              rst = [];
            }
            rst.push(record);
          } else {
            rst = record;
            break;
          }
        } else if (xScale.translate(originData[xField]) <= xValue) {
          last2 = record;
          next = data2[index2 + 1];
        }
      }
      if (isArray$1(rst)) {
        rst = filterYValue(rst, point2, geometry2);
      }
    } else {
      if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) && (xValue > xScale.max || xValue < xScale.min)) {
        return null;
      }
      var firstIdx = 0;
      var lastIdx = data2.length - 1;
      var middleIdx = void 0;
      while (firstIdx <= lastIdx) {
        middleIdx = Math.floor((firstIdx + lastIdx) / 2);
        var item = data2[middleIdx][FIELD_ORIGIN][xField];
        if (snapEqual(item, xValue, xScale)) {
          return data2[middleIdx];
        }
        if (xScale.translate(item) <= xScale.translate(xValue)) {
          firstIdx = middleIdx + 1;
          last2 = data2[middleIdx];
          next = data2[middleIdx + 1];
        } else {
          if (lastIdx === 0) {
            last2 = data2[0];
          }
          lastIdx = middleIdx - 1;
        }
      }
    }
    if (last2 && next) {
      if (Math.abs(xScale.translate(last2[FIELD_ORIGIN][xField]) - xValue) > Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)) {
        last2 = next;
      }
    }
  }
  var distance2 = getXDistance(geometry2.getXScale());
  if (!rst && Math.abs(xScale.translate(last2[FIELD_ORIGIN][xField]) - xValue) <= distance2 / 2) {
    rst = last2;
  }
  return rst;
}
function getTooltipItems(data2, geometry2, title, showNil) {
  if (title === void 0) {
    title = "";
  }
  if (showNil === void 0) {
    showNil = false;
  }
  var originData = data2[FIELD_ORIGIN];
  var tooltipTitle = getTooltipTitle(originData, geometry2, title);
  var tooltipOption = geometry2.tooltipOption;
  var defaultColor = geometry2.theme.defaultColor;
  var items = [];
  var name;
  var value2;
  function addItem(itemName, itemValue) {
    if (showNil || !isNil(itemValue) && itemValue !== "") {
      var item = {
        title: tooltipTitle,
        data: originData,
        mappingData: data2,
        name: itemName,
        value: itemValue,
        color: data2.color || defaultColor,
        marker: true
      };
      items.push(item);
    }
  }
  if (isObject(tooltipOption)) {
    var fields = tooltipOption.fields, callback = tooltipOption.callback;
    if (callback) {
      var callbackParams = fields.map(function(field3) {
        return data2[FIELD_ORIGIN][field3];
      });
      var cfg = callback.apply(void 0, callbackParams);
      var itemCfg = __assign$1({ data: data2[FIELD_ORIGIN], mappingData: data2, title: tooltipTitle, color: data2.color || defaultColor, marker: true }, cfg);
      items.push(itemCfg);
    } else {
      var scales = geometry2.scales;
      for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
        var field2 = fields_1[_i];
        if (!isNil(originData[field2])) {
          var scale2 = scales[field2];
          name = getName(scale2);
          value2 = scale2.getText(originData[field2]);
          addItem(name, value2);
        }
      }
    }
  } else {
    var valueScale = getTooltipValueScale(geometry2);
    value2 = getTooltipValue(originData, valueScale);
    name = getTooltipName(originData, geometry2);
    addItem(name, value2);
  }
  return items;
}
function getTooltipItemsByFindData(geometry2, point2, title, tooltipCfg) {
  var showNil = tooltipCfg.showNil;
  var result = [];
  var dataArray = geometry2.dataArray;
  if (!isEmpty(dataArray)) {
    geometry2.sort(dataArray);
    for (var _i = 0, dataArray_1 = dataArray; _i < dataArray_1.length; _i++) {
      var data2 = dataArray_1[_i];
      var record = findDataByPoint(point2, data2, geometry2);
      if (record) {
        var elementId = geometry2.getElementId(record);
        var element = geometry2.elementsMap[elementId];
        if (geometry2.type === "heatmap" || element.visible) {
          var items = getTooltipItems(record, geometry2, title, showNil);
          if (items.length) {
            result.push(items);
          }
        }
      }
    }
  }
  return result;
}
function getTooltipItemsByHitShape(geometry2, point2, title, tooltipCfg) {
  var showNil = tooltipCfg.showNil;
  var result = [];
  var container = geometry2.container;
  var shape = container.getShape(point2.x, point2.y);
  if (shape && shape.get("visible") && shape.get("origin")) {
    var mappingData = shape.get("origin").mappingData;
    var items = getTooltipItems(mappingData, geometry2, title, showNil);
    if (items.length) {
      result.push(items);
    }
  }
  return result;
}
function findItemsFromView(view, point2, tooltipCfg) {
  var result = [];
  var geometries = view.geometries;
  var shared = tooltipCfg.shared, title = tooltipCfg.title, reversed = tooltipCfg.reversed;
  for (var _i = 0, geometries_1 = geometries; _i < geometries_1.length; _i++) {
    var geometry2 = geometries_1[_i];
    if (geometry2.visible && geometry2.tooltipOption !== false) {
      var geometryType = geometry2.type;
      var tooltipItems = void 0;
      if (["point", "edge", "polygon"].includes(geometryType)) {
        tooltipItems = getTooltipItemsByHitShape(geometry2, point2, title, tooltipCfg);
      } else if (["area", "line", "path", "heatmap"].includes(geometryType)) {
        tooltipItems = getTooltipItemsByFindData(geometry2, point2, title, tooltipCfg);
      } else {
        if (shared !== false) {
          tooltipItems = getTooltipItemsByFindData(geometry2, point2, title, tooltipCfg);
        } else {
          tooltipItems = getTooltipItemsByHitShape(geometry2, point2, title, tooltipCfg);
        }
      }
      if (tooltipItems.length) {
        if (reversed) {
          tooltipItems.reverse();
        }
        result.push(tooltipItems);
      }
    }
  }
  return result;
}
function findItemsFromViewRecurisive(view, point2, tooltipCfg) {
  var result = findItemsFromView(view, point2, tooltipCfg);
  for (var _i = 0, _a2 = view.views; _i < _a2.length; _i++) {
    var childView = _a2[_i];
    result = result.concat(findItemsFromView(childView, point2, tooltipCfg));
  }
  return result;
}
function isAutoPadding(padding2) {
  return !isNumber$1(padding2) && !isArray$1(padding2);
}
function parsePadding(padding2) {
  if (padding2 === void 0) {
    padding2 = 0;
  }
  var paddingArray = isArray$1(padding2) ? padding2 : [padding2];
  switch (paddingArray.length) {
    case 0:
      paddingArray = [0, 0, 0, 0];
      break;
    case 1:
      paddingArray = new Array(4).fill(paddingArray[0]);
      break;
    case 2:
      paddingArray = __spreadArray(__spreadArray([], paddingArray, true), paddingArray, true);
      break;
    case 3:
      paddingArray = __spreadArray(__spreadArray([], paddingArray, true), [paddingArray[1]], false);
      break;
    default:
      paddingArray = paddingArray.slice(0, 4);
      break;
  }
  return paddingArray;
}
var LOAD_COMPONENT_CONTROLLERS = {};
function registerComponentController(name, plugin) {
  LOAD_COMPONENT_CONTROLLERS[name] = plugin;
}
function getComponentControllerNames() {
  return Object.keys(LOAD_COMPONENT_CONTROLLERS);
}
function getComponentController(name) {
  return LOAD_COMPONENT_CONTROLLERS[name];
}
var CoordinateController = function() {
  function CoordinateController2(option) {
    this.option = this.wrapperOption(option);
  }
  CoordinateController2.prototype.update = function(option) {
    this.option = this.wrapperOption(option);
    return this;
  };
  CoordinateController2.prototype.hasAction = function(actionName) {
    var actions = this.option.actions;
    return some(actions, function(action) {
      return action[0] === actionName;
    });
  };
  CoordinateController2.prototype.create = function(start, end) {
    var _a2 = this.option, type = _a2.type, cfg = _a2.cfg;
    var isTheta = type === "theta";
    var props = __assign$1({ start, end }, cfg);
    var C = getCoordinate(isTheta ? "polar" : type);
    this.coordinate = new C(props);
    this.coordinate.type = type;
    if (isTheta) {
      if (!this.hasAction("transpose")) {
        this.transpose();
      }
    }
    this.execActions();
    return this.coordinate;
  };
  CoordinateController2.prototype.adjust = function(start, end) {
    this.coordinate.update({
      start,
      end
    });
    this.coordinate.resetMatrix();
    this.execActions(["scale", "rotate", "translate"]);
    return this.coordinate;
  };
  CoordinateController2.prototype.rotate = function(angle2) {
    this.option.actions.push(["rotate", angle2]);
    return this;
  };
  CoordinateController2.prototype.reflect = function(dim) {
    this.option.actions.push(["reflect", dim]);
    return this;
  };
  CoordinateController2.prototype.scale = function(sx, sy) {
    this.option.actions.push(["scale", sx, sy]);
    return this;
  };
  CoordinateController2.prototype.transpose = function() {
    this.option.actions.push(["transpose"]);
    return this;
  };
  CoordinateController2.prototype.getOption = function() {
    return this.option;
  };
  CoordinateController2.prototype.getCoordinate = function() {
    return this.coordinate;
  };
  CoordinateController2.prototype.wrapperOption = function(option) {
    return __assign$1({ type: "rect", actions: [], cfg: {} }, option);
  };
  CoordinateController2.prototype.execActions = function(includeActions) {
    var _this = this;
    var actions = this.option.actions;
    each$1(actions, function(action) {
      var _a2;
      var actionName = action[0], args = action.slice(1);
      var shouldExec = isNil(includeActions) ? true : includeActions.includes(actionName);
      if (shouldExec) {
        (_a2 = _this.coordinate)[actionName].apply(_a2, args);
      }
    });
  };
  return CoordinateController2;
}();
var Event = function() {
  function Event2(view, gEvent, data2) {
    this.view = view;
    this.gEvent = gEvent;
    this.data = data2;
    this.type = gEvent.type;
  }
  Event2.fromData = function(view, type, data2) {
    return new Event2(view, new GraphEvent$1(type, {}), data2);
  };
  Object.defineProperty(Event2.prototype, "target", {
    get: function() {
      return this.gEvent.target;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event2.prototype, "event", {
    get: function() {
      return this.gEvent.originalEvent;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event2.prototype, "x", {
    get: function() {
      return this.gEvent.x;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event2.prototype, "y", {
    get: function() {
      return this.gEvent.y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event2.prototype, "clientX", {
    get: function() {
      return this.gEvent.clientX;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event2.prototype, "clientY", {
    get: function() {
      return this.gEvent.clientY;
    },
    enumerable: false,
    configurable: true
  });
  Event2.prototype.toString = function() {
    return "[Event (type=" + this.type + ")]";
  };
  Event2.prototype.clone = function() {
    return new Event2(this.view, this.gEvent, this.data);
  };
  return Event2;
}();
function defaultLayout(view) {
  var axis2 = view.getController("axis");
  var legend2 = view.getController("legend");
  var annotation2 = view.getController("annotation");
  var slider2 = view.getController("slider");
  var scrollbar2 = view.getController("scrollbar");
  [axis2, slider2, scrollbar2, legend2, annotation2].forEach(function(controller) {
    if (controller) {
      controller.layout();
    }
  });
}
var ScalePool = function() {
  function ScalePool2() {
    this.scales = new Map();
    this.syncScales = new Map();
  }
  ScalePool2.prototype.createScale = function(field2, data2, scaleDef, key) {
    var finalScaleDef = scaleDef;
    var cacheScaleMeta = this.getScaleMeta(key);
    if (data2.length === 0 && cacheScaleMeta) {
      var cacheScale = cacheScaleMeta.scale;
      var cacheScaleDef = {
        type: cacheScale.type
      };
      if (cacheScale.isCategory) {
        cacheScaleDef.values = cacheScale.values;
      }
      finalScaleDef = deepMix(cacheScaleDef, cacheScaleMeta.scaleDef, scaleDef);
    }
    var scale2 = createScaleByField(field2, data2, finalScaleDef);
    this.cacheScale(scale2, scaleDef, key);
    return scale2;
  };
  ScalePool2.prototype.sync = function(coordinate2, theme2) {
    var _this = this;
    this.syncScales.forEach(function(scaleKeys, syncKey) {
      var min2 = Number.MAX_SAFE_INTEGER;
      var max2 = Number.MIN_SAFE_INTEGER;
      var values2 = [];
      each$1(scaleKeys, function(key) {
        var scale2 = _this.getScale(key);
        max2 = isNumber$1(scale2.max) ? Math.max(max2, scale2.max) : max2;
        min2 = isNumber$1(scale2.min) ? Math.min(min2, scale2.min) : min2;
        each$1(scale2.values, function(v) {
          if (!values2.includes(v)) {
            values2.push(v);
          }
        });
      });
      each$1(scaleKeys, function(key) {
        var scale2 = _this.getScale(key);
        if (scale2.isContinuous) {
          scale2.change({
            min: min2,
            max: max2,
            values: values2
          });
        } else if (scale2.isCategory) {
          var range = scale2.range;
          var cacheScaleMeta = _this.getScaleMeta(key);
          if (values2 && !get(cacheScaleMeta, ["scaleDef", "range"])) {
            range = getDefaultCategoryScaleRange(deepMix({}, scale2, {
              values: values2
            }), coordinate2, theme2);
          }
          scale2.change({
            values: values2,
            range
          });
        }
      });
    });
  };
  ScalePool2.prototype.cacheScale = function(scale2, scaleDef, key) {
    var sm = this.getScaleMeta(key);
    if (sm && sm.scale.type === scale2.type) {
      syncScale(sm.scale, scale2);
      sm.scaleDef = scaleDef;
    } else {
      sm = {
        key,
        scale: scale2,
        scaleDef
      };
      this.scales.set(key, sm);
    }
    var syncKey = this.getSyncKey(sm);
    sm.syncKey = syncKey;
    this.removeFromSyncScales(key);
    if (syncKey) {
      var scaleKeys = this.syncScales.get(syncKey);
      if (!scaleKeys) {
        scaleKeys = [];
        this.syncScales.set(syncKey, scaleKeys);
      }
      scaleKeys.push(key);
    }
  };
  ScalePool2.prototype.getScale = function(key) {
    var scaleMeta = this.getScaleMeta(key);
    if (!scaleMeta) {
      var field2 = last(key.split("-"));
      var scaleKeys = this.syncScales.get(field2);
      if (scaleKeys && scaleKeys.length) {
        scaleMeta = this.getScaleMeta(scaleKeys[0]);
      }
    }
    return scaleMeta && scaleMeta.scale;
  };
  ScalePool2.prototype.deleteScale = function(key) {
    var scaleMeta = this.getScaleMeta(key);
    if (scaleMeta) {
      var syncKey = scaleMeta.syncKey;
      var scaleKeys = this.syncScales.get(syncKey);
      if (scaleKeys && scaleKeys.length) {
        var idx = scaleKeys.indexOf(key);
        if (idx !== -1) {
          scaleKeys.splice(idx, 1);
        }
      }
    }
    this.scales.delete(key);
  };
  ScalePool2.prototype.clear = function() {
    this.scales.clear();
    this.syncScales.clear();
  };
  ScalePool2.prototype.removeFromSyncScales = function(key) {
    var _this = this;
    this.syncScales.forEach(function(scaleKeys, syncKey) {
      var idx = scaleKeys.indexOf(key);
      if (idx !== -1) {
        scaleKeys.splice(idx, 1);
        if (scaleKeys.length === 0) {
          _this.syncScales.delete(syncKey);
        }
        return false;
      }
    });
  };
  ScalePool2.prototype.getSyncKey = function(sm) {
    var scale2 = sm.scale, scaleDef = sm.scaleDef;
    var field2 = scale2.field;
    var sync = get(scaleDef, ["sync"]);
    return sync === true ? field2 : sync === false ? void 0 : sync;
  };
  ScalePool2.prototype.getScaleMeta = function(key) {
    return this.scales.get(key);
  };
  return ScalePool2;
}();
var PaddingCal = function() {
  function PaddingCal2(top, right2, bottom, left2) {
    if (top === void 0) {
      top = 0;
    }
    if (right2 === void 0) {
      right2 = 0;
    }
    if (bottom === void 0) {
      bottom = 0;
    }
    if (left2 === void 0) {
      left2 = 0;
    }
    this.top = top;
    this.right = right2;
    this.bottom = bottom;
    this.left = left2;
  }
  PaddingCal2.instance = function(top, right2, bottom, left2) {
    if (top === void 0) {
      top = 0;
    }
    if (right2 === void 0) {
      right2 = 0;
    }
    if (bottom === void 0) {
      bottom = 0;
    }
    if (left2 === void 0) {
      left2 = 0;
    }
    return new PaddingCal2(top, right2, bottom, left2);
  };
  PaddingCal2.prototype.max = function(padding2) {
    var top = padding2[0], right2 = padding2[1], bottom = padding2[2], left2 = padding2[3];
    this.top = Math.max(this.top, top);
    this.right = Math.max(this.right, right2);
    this.bottom = Math.max(this.bottom, bottom);
    this.left = Math.max(this.left, left2);
    return this;
  };
  PaddingCal2.prototype.shrink = function(padding2) {
    var top = padding2[0], right2 = padding2[1], bottom = padding2[2], left2 = padding2[3];
    this.top += top;
    this.right += right2;
    this.bottom += bottom;
    this.left += left2;
    return this;
  };
  PaddingCal2.prototype.inc = function(bbox, direction2) {
    var width = bbox.width, height = bbox.height;
    switch (direction2) {
      case DIRECTION.TOP:
      case DIRECTION.TOP_LEFT:
      case DIRECTION.TOP_RIGHT:
        this.top += height;
        break;
      case DIRECTION.RIGHT:
      case DIRECTION.RIGHT_TOP:
      case DIRECTION.RIGHT_BOTTOM:
        this.right += width;
        break;
      case DIRECTION.BOTTOM:
      case DIRECTION.BOTTOM_LEFT:
      case DIRECTION.BOTTOM_RIGHT:
        this.bottom += height;
        break;
      case DIRECTION.LEFT:
      case DIRECTION.LEFT_TOP:
      case DIRECTION.LEFT_BOTTOM:
        this.left += width;
        break;
    }
    return this;
  };
  PaddingCal2.prototype.getPadding = function() {
    return [this.top, this.right, this.bottom, this.left];
  };
  PaddingCal2.prototype.clone = function() {
    return new (PaddingCal2.bind.apply(PaddingCal2, __spreadArray([void 0], this.getPadding(), false)))();
  };
  return PaddingCal2;
}();
function calculatePadding(view) {
  var padding2 = view.padding;
  if (!isAutoPadding(padding2)) {
    return new (PaddingCal.bind.apply(PaddingCal, __spreadArray([void 0], parsePadding(padding2), false)))();
  }
  var viewBBox = view.viewBBox;
  var paddingCal = new PaddingCal();
  var axisComponents = [];
  var paddingComponents = [];
  var otherComponents = [];
  each$1(view.getComponents(), function(co) {
    var type = co.type;
    if (type === COMPONENT_TYPE.AXIS) {
      axisComponents.push(co);
    } else if ([COMPONENT_TYPE.LEGEND, COMPONENT_TYPE.SLIDER, COMPONENT_TYPE.SCROLLBAR].includes(type)) {
      paddingComponents.push(co);
    } else if (type !== COMPONENT_TYPE.GRID && type !== COMPONENT_TYPE.TOOLTIP) {
      otherComponents.push(co);
    }
  });
  each$1(axisComponents, function(co) {
    var component2 = co.component;
    var bboxObject = component2.getLayoutBBox();
    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
    var exceed = componentBBox.exceed(viewBBox);
    paddingCal.max(exceed);
  });
  each$1(paddingComponents, function(co) {
    var component2 = co.component, direction2 = co.direction;
    var bboxObject = component2.getLayoutBBox();
    var componentPadding = component2.get("padding");
    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(componentPadding);
    paddingCal.inc(componentBBox, direction2);
  });
  each$1(otherComponents, function(co) {
    var component2 = co.component, direction2 = co.direction;
    var bboxObject = component2.getLayoutBBox();
    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
    paddingCal.inc(componentBBox, direction2);
  });
  return paddingCal;
}
function defaultSyncViewPadding(chart, views, PC) {
  var syncPadding = PC.instance();
  views.forEach(function(v) {
    v.autoPadding = syncPadding.max(v.autoPadding.getPadding());
  });
}
var View = function(_super) {
  __extends$2(View2, _super);
  function View2(props) {
    var _this = _super.call(this, { visible: props.visible }) || this;
    _this.views = [];
    _this.geometries = [];
    _this.controllers = [];
    _this.interactions = {};
    _this.limitInPlot = false;
    _this.options = {
      data: [],
      animate: true
    };
    _this.usedControllers = getComponentControllerNames();
    _this.scalePool = new ScalePool();
    _this.layoutFunc = defaultLayout;
    _this.isPreMouseInPlot = false;
    _this.isDataChanged = false;
    _this.isCoordinateChanged = false;
    _this.createdScaleKeys = new Map();
    _this.onCanvasEvent = function(evt) {
      var name = evt.name;
      if (!name.includes(":")) {
        var e = _this.createViewEvent(evt);
        _this.doPlotEvent(e);
        _this.emit(name, e);
      }
    };
    _this.onDelegateEvents = function(evt) {
      var name = evt.name;
      if (!name.includes(":")) {
        return;
      }
      var e = _this.createViewEvent(evt);
      _this.emit(name, e);
    };
    var _a2 = props.id, id = _a2 === void 0 ? uniqueId("view") : _a2, parent = props.parent, canvas = props.canvas, backgroundGroup = props.backgroundGroup, middleGroup = props.middleGroup, foregroundGroup = props.foregroundGroup, _b = props.region, region = _b === void 0 ? { start: { x: 0, y: 0 }, end: { x: 1, y: 1 } } : _b, padding2 = props.padding, appendPadding = props.appendPadding, theme2 = props.theme, options = props.options, limitInPlot2 = props.limitInPlot, syncViewPadding2 = props.syncViewPadding;
    _this.parent = parent;
    _this.canvas = canvas;
    _this.backgroundGroup = backgroundGroup;
    _this.middleGroup = middleGroup;
    _this.foregroundGroup = foregroundGroup;
    _this.region = region;
    _this.padding = padding2;
    _this.appendPadding = appendPadding;
    _this.options = __assign$1(__assign$1({}, _this.options), options);
    _this.limitInPlot = limitInPlot2;
    _this.id = id;
    _this.syncViewPadding = syncViewPadding2;
    _this.themeObject = isObject(theme2) ? deepMix({}, getTheme("default"), createTheme(theme2)) : getTheme(theme2);
    _this.init();
    return _this;
  }
  View2.prototype.setLayout = function(layout) {
    this.layoutFunc = layout;
  };
  View2.prototype.init = function() {
    this.calculateViewBBox();
    this.initEvents();
    this.initComponentController();
    this.initOptions();
  };
  View2.prototype.render = function(isUpdate, payload) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_RENDER, Event.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_RENDER, payload));
    this.paint(isUpdate);
    this.emit(VIEW_LIFE_CIRCLE.AFTER_RENDER, Event.fromData(this, VIEW_LIFE_CIRCLE.AFTER_RENDER, payload));
    if (this.visible === false) {
      this.changeVisible(false);
    }
  };
  View2.prototype.clear = function() {
    var _this = this;
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_CLEAR);
    this.filteredData = [];
    this.coordinateInstance = void 0;
    this.isDataChanged = false;
    this.isCoordinateChanged = false;
    var geometries = this.geometries;
    for (var i = 0; i < geometries.length; i++) {
      geometries[i].clear();
      geometries[i].container.remove(true);
      geometries[i].labelsContainer.remove(true);
    }
    this.geometries = [];
    var controllers = this.controllers;
    for (var i = 0; i < controllers.length; i++) {
      if (controllers[i].name === "annotation") {
        controllers[i].clear(true);
      } else {
        controllers[i].clear();
      }
    }
    this.createdScaleKeys.forEach(function(v, k) {
      _this.getRootView().scalePool.deleteScale(k);
    });
    this.createdScaleKeys.clear();
    var views = this.views;
    for (var i = 0; i < views.length; i++) {
      views[i].clear();
    }
    this.emit(VIEW_LIFE_CIRCLE.AFTER_CLEAR);
  };
  View2.prototype.destroy = function() {
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_DESTROY);
    var interactions = this.interactions;
    each$1(interactions, function(interaction2) {
      if (interaction2) {
        interaction2.destroy();
      }
    });
    this.clear();
    var controllers = this.controllers;
    for (var i = 0, len = controllers.length; i < len; i++) {
      var controller = controllers[i];
      controller.destroy();
    }
    this.backgroundGroup.remove(true);
    this.middleGroup.remove(true);
    this.foregroundGroup.remove(true);
    _super.prototype.destroy.call(this);
  };
  View2.prototype.changeVisible = function(visible) {
    _super.prototype.changeVisible.call(this, visible);
    var geometries = this.geometries;
    for (var i = 0, len = geometries.length; i < len; i++) {
      var geometry2 = geometries[i];
      geometry2.changeVisible(visible);
    }
    var controllers = this.controllers;
    for (var i = 0, len = controllers.length; i < len; i++) {
      var controller = controllers[i];
      controller.changeVisible(visible);
    }
    this.foregroundGroup.set("visible", visible);
    this.middleGroup.set("visible", visible);
    this.backgroundGroup.set("visible", visible);
    this.getCanvas().draw();
    return this;
  };
  View2.prototype.data = function(data2) {
    set(this.options, "data", data2);
    this.isDataChanged = true;
    return this;
  };
  View2.prototype.source = function(data2) {
    console.warn("This method will be removed at G2 V4.1. Please use chart.data() instead.");
    return this.data(data2);
  };
  View2.prototype.filter = function(field2, condition) {
    if (isFunction(condition)) {
      set(this.options, ["filters", field2], condition);
      return this;
    }
    if (!condition && get(this.options, ["filters", field2])) {
      delete this.options.filters[field2];
    }
    return this;
  };
  View2.prototype.axis = function(field2, axisOption) {
    if (isBoolean(field2)) {
      set(this.options, ["axes"], field2);
    } else {
      set(this.options, ["axes", field2], axisOption);
    }
    return this;
  };
  View2.prototype.legend = function(field2, legendOption) {
    if (isBoolean(field2)) {
      set(this.options, ["legends"], field2);
    } else if (isString(field2)) {
      set(this.options, ["legends", field2], legendOption);
      if (isPlainObject$1(legendOption) && (legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected)) {
        set(this.options, ["filters", field2], function(name) {
          var _a2;
          return (_a2 = legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected[name]) !== null && _a2 !== void 0 ? _a2 : true;
        });
      }
    } else {
      set(this.options, ["legends"], field2);
    }
    return this;
  };
  View2.prototype.scale = function(field2, scaleOption) {
    var _this = this;
    if (isString(field2)) {
      set(this.options, ["scales", field2], scaleOption);
    } else if (isObject(field2)) {
      each$1(field2, function(v, k) {
        set(_this.options, ["scales", k], v);
      });
    }
    return this;
  };
  View2.prototype.tooltip = function(cfg) {
    set(this.options, "tooltip", cfg);
    return this;
  };
  View2.prototype.annotation = function() {
    return this.getController("annotation");
  };
  View2.prototype.guide = function() {
    console.warn("This method will be removed at G2 V4.1. Please use chart.annotation() instead.");
    return this.annotation();
  };
  View2.prototype.coordinate = function(type, coordinateCfg) {
    if (isString(type)) {
      set(this.options, "coordinate", { type, cfg: coordinateCfg });
    } else {
      set(this.options, "coordinate", type);
    }
    this.coordinateController.update(this.options.coordinate);
    return this.coordinateController;
  };
  View2.prototype.coord = function(type, coordinateCfg) {
    console.warn("This method will be removed at G2 V4.1. Please use chart.coordinate() instead.");
    return this.coordinate(type, coordinateCfg);
  };
  View2.prototype.facet = function(type, cfg) {
    if (this.facetInstance) {
      this.facetInstance.destroy();
    }
    var Ctor = getFacet(type);
    if (!Ctor) {
      throw new Error("facet '" + type + "' is not exist!");
    }
    this.facetInstance = new Ctor(this, __assign$1(__assign$1({}, cfg), { type }));
    return this;
  };
  View2.prototype.animate = function(status) {
    set(this.options, "animate", status);
    return this;
  };
  View2.prototype.updateOptions = function(options) {
    this.clear();
    mix(this.options, options);
    this.views.forEach(function(view) {
      return view.destroy();
    });
    this.views = [];
    this.initOptions();
    this.coordinateBBox = this.viewBBox;
    return this;
  };
  View2.prototype.option = function(name, opt) {
    if (View2.prototype[name]) {
      throw new Error(`Can't use built in variable name "` + name + '", please change another one.');
    }
    set(this.options, name, opt);
    return this;
  };
  View2.prototype.theme = function(theme2) {
    this.themeObject = isObject(theme2) ? deepMix({}, this.themeObject, createTheme(theme2)) : getTheme(theme2);
    return this;
  };
  View2.prototype.interaction = function(name, cfg) {
    var existInteraction = this.interactions[name];
    if (existInteraction) {
      existInteraction.destroy();
    }
    var interaction2 = createInteraction(name, this, cfg);
    if (interaction2) {
      interaction2.init();
      this.interactions[name] = interaction2;
    }
    return this;
  };
  View2.prototype.removeInteraction = function(name) {
    var existInteraction = this.interactions[name];
    if (existInteraction) {
      existInteraction.destroy();
      this.interactions[name] = void 0;
    }
  };
  View2.prototype.changeData = function(data2) {
    this.isDataChanged = true;
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    this.data(data2);
    this.paint(true);
    var views = this.views;
    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      view.changeData(data2);
    }
    this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  View2.prototype.createView = function(cfg) {
    if (this.parent && this.parent.parent) {
      console.warn("The view nesting recursive feature will be removed at G2 V4.1. Please avoid to use it.");
    }
    var sharedOptions = {
      data: this.options.data,
      scales: clone(this.options.scales),
      axes: clone(this.options.axes),
      coordinate: clone(this.coordinateController.getOption()),
      tooltip: clone(this.options.tooltip),
      legends: clone(this.options.legends),
      animate: this.options.animate,
      visible: this.visible
    };
    var v = new View2(__assign$1(__assign$1({
      parent: this,
      canvas: this.canvas,
      backgroundGroup: this.backgroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
      middleGroup: this.middleGroup.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
      foregroundGroup: this.foregroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
      theme: this.themeObject,
      padding: this.padding
    }, cfg), { options: __assign$1(__assign$1({}, sharedOptions), get(cfg, "options", {})) }));
    this.views.push(v);
    return v;
  };
  View2.prototype.view = function(cfg) {
    console.warn("This method will be removed at G2 V4.1. Please use chart.createView() instead.");
    return this.createView(cfg);
  };
  View2.prototype.removeView = function(view) {
    var removedView = remove(this.views, function(v) {
      return v === view;
    })[0];
    if (removedView) {
      removedView.destroy();
    }
    return removedView;
  };
  View2.prototype.getCoordinate = function() {
    return this.coordinateInstance;
  };
  View2.prototype.getTheme = function() {
    return this.themeObject;
  };
  View2.prototype.getXScale = function() {
    var g = this.geometries[0];
    return g ? g.getXScale() : null;
  };
  View2.prototype.getYScales = function() {
    var tmpMap = {};
    var yScales = [];
    this.geometries.forEach(function(g) {
      var yScale = g.getYScale();
      var field2 = yScale.field;
      if (!tmpMap[field2]) {
        tmpMap[field2] = true;
        yScales.push(yScale);
      }
    });
    return yScales;
  };
  View2.prototype.getScalesByDim = function(dimType) {
    var geometries = this.geometries;
    var scales = {};
    for (var i = 0, len = geometries.length; i < len; i++) {
      var geometry2 = geometries[i];
      var scale2 = dimType === "x" ? geometry2.getXScale() : geometry2.getYScale();
      if (scale2 && !scales[scale2.field]) {
        scales[scale2.field] = scale2;
      }
    }
    return scales;
  };
  View2.prototype.getScale = function(field2, key) {
    var defaultKey = key ? key : this.getScaleKey(field2);
    return this.getRootView().scalePool.getScale(defaultKey);
  };
  View2.prototype.getScaleByField = function(field2, key) {
    return this.getScale(field2, key);
  };
  View2.prototype.getOptions = function() {
    return this.options;
  };
  View2.prototype.getData = function() {
    return this.filteredData;
  };
  View2.prototype.getOriginalData = function() {
    return this.options.data;
  };
  View2.prototype.getPadding = function() {
    return this.autoPadding.getPadding();
  };
  View2.prototype.getGeometries = function() {
    return this.geometries;
  };
  View2.prototype.getElements = function() {
    return reduce(this.geometries, function(elements, geometry2) {
      return elements.concat(geometry2.getElements());
    }, []);
  };
  View2.prototype.getElementsBy = function(condition) {
    return this.getElements().filter(function(el) {
      return condition(el);
    });
  };
  View2.prototype.getLayer = function(layer) {
    return layer === LAYER.BG ? this.backgroundGroup : layer === LAYER.MID ? this.middleGroup : layer === LAYER.FORE ? this.foregroundGroup : this.foregroundGroup;
  };
  View2.prototype.isPointInPlot = function(point2) {
    return isPointInCoordinate(this.getCoordinate(), point2);
  };
  View2.prototype.getLegendAttributes = function() {
    return flatten(this.geometries.map(function(g) {
      return g.getGroupAttributes();
    }));
  };
  View2.prototype.getGroupScales = function() {
    var scales = this.geometries.map(function(g) {
      return g.getGroupScales();
    });
    return uniq$1(flatten(scales));
  };
  View2.prototype.getCanvas = function() {
    return this.getRootView().canvas;
  };
  View2.prototype.getRootView = function() {
    var v = this;
    while (true) {
      if (v.parent) {
        v = v.parent;
        continue;
      }
      break;
    }
    return v;
  };
  View2.prototype.getXY = function(data2) {
    var coordinate2 = this.getCoordinate();
    var xScales = this.getScalesByDim("x");
    var yScales = this.getScalesByDim("y");
    var x;
    var y;
    each$1(data2, function(value2, key) {
      if (xScales[key]) {
        x = xScales[key].scale(value2);
      }
      if (yScales[key]) {
        y = yScales[key].scale(value2);
      }
    });
    if (!isNil(x) && !isNil(y)) {
      return coordinate2.convert({ x, y });
    }
  };
  View2.prototype.getController = function(name) {
    return find$1(this.controllers, function(c) {
      return c.name === name;
    });
  };
  View2.prototype.showTooltip = function(point2) {
    var tooltip2 = this.getController("tooltip");
    if (tooltip2) {
      tooltip2.showTooltip(point2);
    }
    return this;
  };
  View2.prototype.hideTooltip = function() {
    var tooltip2 = this.getController("tooltip");
    if (tooltip2) {
      tooltip2.hideTooltip();
    }
    return this;
  };
  View2.prototype.lockTooltip = function() {
    var tooltip2 = this.getController("tooltip");
    if (tooltip2) {
      tooltip2.lockTooltip();
    }
    return this;
  };
  View2.prototype.unlockTooltip = function() {
    var tooltip2 = this.getController("tooltip");
    if (tooltip2) {
      tooltip2.unlockTooltip();
    }
    return this;
  };
  View2.prototype.isTooltipLocked = function() {
    var tooltip2 = this.getController("tooltip");
    return tooltip2 && tooltip2.isTooltipLocked();
  };
  View2.prototype.getTooltipItems = function(point2) {
    var tooltip2 = this.getController("tooltip");
    return tooltip2 ? tooltip2.getTooltipItems(point2) : [];
  };
  View2.prototype.getSnapRecords = function(point2) {
    var geometries = this.geometries;
    var rst = [];
    for (var i = 0, len = geometries.length; i < len; i++) {
      var geom = geometries[i];
      var dataArray = geom.dataArray;
      geom.sort(dataArray);
      var record = void 0;
      for (var j = 0, dataLen = dataArray.length; j < dataLen; j++) {
        var data2 = dataArray[j];
        record = findDataByPoint(point2, data2, geom);
        if (record) {
          rst.push(record);
        }
      }
    }
    var views = this.views;
    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      var snapRecords = view.getSnapRecords(point2);
      rst = rst.concat(snapRecords);
    }
    return rst;
  };
  View2.prototype.getComponents = function() {
    var components = [];
    var controllers = this.controllers;
    for (var i = 0, len = controllers.length; i < len; i++) {
      var controller = controllers[i];
      components = components.concat(controller.getComponents());
    }
    return components;
  };
  View2.prototype.filterData = function(data2) {
    var filters = this.options.filters;
    if (size(filters) === 0) {
      return data2;
    }
    return filter(data2, function(datum, idx) {
      var fields = Object.keys(filters);
      return fields.every(function(field2) {
        var condition = filters[field2];
        return condition(datum[field2], datum, idx);
      });
    });
  };
  View2.prototype.filterFieldData = function(field2, data2) {
    var filters = this.options.filters;
    var condition = get(filters, field2);
    if (isUndefined(condition)) {
      return data2;
    }
    return data2.filter(function(datum, idx) {
      return condition(datum[field2], datum, idx);
    });
  };
  View2.prototype.adjustCoordinate = function() {
    var _a2 = this.getCoordinate(), curStart = _a2.start, curEnd = _a2.end;
    var start = this.coordinateBBox.bl;
    var end = this.coordinateBBox.tr;
    if (isEqual$2(curStart, start) && isEqual$2(curEnd, end)) {
      this.isCoordinateChanged = false;
      return;
    }
    this.isCoordinateChanged = true;
    this.coordinateInstance = this.coordinateController.adjust(start, end);
  };
  View2.prototype.paint = function(isUpdate) {
    this.renderDataRecursive(isUpdate);
    this.syncScale();
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_PAINT);
    this.renderPaddingRecursive(isUpdate);
    this.renderLayoutRecursive(isUpdate);
    this.renderBackgroundStyleShape();
    this.renderPaintRecursive(isUpdate);
    this.emit(VIEW_LIFE_CIRCLE.AFTER_PAINT);
    this.isDataChanged = false;
  };
  View2.prototype.renderBackgroundStyleShape = function() {
    if (this.parent) {
      return;
    }
    var background = get(this.themeObject, "background");
    if (background) {
      if (!this.backgroundStyleRectShape) {
        this.backgroundStyleRectShape = this.backgroundGroup.addShape("rect", {
          attrs: {},
          zIndex: -1,
          capture: false
        });
        this.backgroundStyleRectShape.toBack();
      }
      var _a2 = this.viewBBox, x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
      this.backgroundStyleRectShape.attr({
        fill: background,
        x,
        y,
        width,
        height
      });
    } else {
      if (this.backgroundStyleRectShape) {
        this.backgroundStyleRectShape.remove(true);
        this.backgroundStyleRectShape = void 0;
      }
    }
  };
  View2.prototype.renderPaddingRecursive = function(isUpdate) {
    this.calculateViewBBox();
    this.adjustCoordinate();
    this.initComponents(isUpdate);
    this.autoPadding = calculatePadding(this).shrink(parsePadding(this.appendPadding));
    this.coordinateBBox = this.viewBBox.shrink(this.autoPadding.getPadding());
    this.adjustCoordinate();
    var views = this.views;
    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      view.renderPaddingRecursive(isUpdate);
    }
  };
  View2.prototype.renderLayoutRecursive = function(isUpdate) {
    var syncViewPaddingFn = this.syncViewPadding === true ? defaultSyncViewPadding : isFunction(this.syncViewPadding) ? this.syncViewPadding : void 0;
    if (syncViewPaddingFn) {
      syncViewPaddingFn(this, this.views, PaddingCal);
      this.views.forEach(function(v) {
        v.coordinateBBox = v.viewBBox.shrink(v.autoPadding.getPadding());
        v.adjustCoordinate();
      });
    }
    this.doLayout();
    var views = this.views;
    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      view.renderLayoutRecursive(isUpdate);
    }
  };
  View2.prototype.renderPaintRecursive = function(isUpdate) {
    var middleGroup = this.middleGroup;
    if (this.limitInPlot) {
      var _a2 = getCoordinateClipCfg(this.coordinateInstance), type = _a2.type, attrs = _a2.attrs;
      middleGroup.setClip({
        type,
        attrs
      });
    } else {
      middleGroup.setClip(void 0);
    }
    this.paintGeometries(isUpdate);
    this.renderComponents(isUpdate);
    var views = this.views;
    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      view.renderPaintRecursive(isUpdate);
    }
  };
  View2.prototype.createScale = function(field2, data2, scaleDef, key) {
    var currentScaleDef = get(this.options.scales, [field2]);
    var mergedScaleDef = __assign$1(__assign$1({}, currentScaleDef), scaleDef);
    if (this.parent) {
      return this.parent.createScale(field2, data2, mergedScaleDef, key);
    }
    return this.scalePool.createScale(field2, data2, mergedScaleDef, key);
  };
  View2.prototype.renderDataRecursive = function(isUpdate) {
    this.doFilterData();
    this.createCoordinate();
    this.initGeometries(isUpdate);
    this.renderFacet(isUpdate);
    var views = this.views;
    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      view.renderDataRecursive(isUpdate);
    }
  };
  View2.prototype.calculateViewBBox = function() {
    var x;
    var y;
    var width;
    var height;
    if (this.parent) {
      var bbox = this.parent.coordinateBBox;
      x = bbox.x;
      y = bbox.y;
      width = bbox.width;
      height = bbox.height;
    } else {
      x = 0;
      y = 0;
      width = this.canvas.get("width");
      height = this.canvas.get("height");
    }
    var _a2 = this.region, start = _a2.start, end = _a2.end;
    var viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
    if (!this.viewBBox || !this.viewBBox.isEqual(viewBBox)) {
      this.viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
    }
    this.coordinateBBox = this.viewBBox;
  };
  View2.prototype.initEvents = function() {
    this.foregroundGroup.on("*", this.onDelegateEvents);
    this.middleGroup.on("*", this.onDelegateEvents);
    this.backgroundGroup.on("*", this.onDelegateEvents);
    this.canvas.on("*", this.onCanvasEvent);
  };
  View2.prototype.initComponentController = function() {
    var usedControllers = this.usedControllers;
    for (var i = 0, len = usedControllers.length; i < len; i++) {
      var controllerName = usedControllers[i];
      var Ctor = getComponentController(controllerName);
      if (Ctor) {
        this.controllers.push(new Ctor(this));
      }
    }
  };
  View2.prototype.createViewEvent = function(evt) {
    var shape = evt.shape, name = evt.name;
    var data2 = shape ? shape.get("origin") : null;
    var e = new Event(this, evt, data2);
    e.type = name;
    return e;
  };
  View2.prototype.doPlotEvent = function(e) {
    var type = e.type, x = e.x, y = e.y;
    var point2 = { x, y };
    var ALL_EVENTS = [
      "mousedown",
      "mouseup",
      "mousemove",
      "mouseleave",
      "mousewheel",
      "touchstart",
      "touchmove",
      "touchend",
      "touchcancel",
      "click",
      "dblclick",
      "contextmenu"
    ];
    if (ALL_EVENTS.includes(type)) {
      var currentInPlot = this.isPointInPlot(point2);
      var newEvent = e.clone();
      if (currentInPlot) {
        var TYPE = "plot:" + type;
        newEvent.type = TYPE;
        this.emit(TYPE, newEvent);
        if (type === "mouseleave" || type === "touchend") {
          this.isPreMouseInPlot = false;
        }
      }
      if (type === "mousemove" || type === "touchmove") {
        if (this.isPreMouseInPlot && !currentInPlot) {
          if (type === "mousemove") {
            newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
            this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
          }
          newEvent.type = PLOT_EVENTS.LEAVE;
          this.emit(PLOT_EVENTS.LEAVE, newEvent);
        } else if (!this.isPreMouseInPlot && currentInPlot) {
          if (type === "mousemove") {
            newEvent.type = PLOT_EVENTS.MOUSE_ENTER;
            this.emit(PLOT_EVENTS.MOUSE_ENTER, newEvent);
          }
          newEvent.type = PLOT_EVENTS.ENTER;
          this.emit(PLOT_EVENTS.ENTER, newEvent);
        }
        this.isPreMouseInPlot = currentInPlot;
      } else if (type === "mouseleave" || type === "touchend") {
        if (this.isPreMouseInPlot) {
          if (type === "mouseleave") {
            newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
            this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
          }
          newEvent.type = PLOT_EVENTS.LEAVE;
          this.emit(PLOT_EVENTS.LEAVE, newEvent);
          this.isPreMouseInPlot = false;
        }
      }
    }
  };
  View2.prototype.doFilterData = function() {
    var data2 = this.options.data;
    this.filteredData = this.filterData(data2);
  };
  View2.prototype.initGeometries = function(isUpdate) {
    this.createOrUpdateScales();
    var coordinate2 = this.getCoordinate();
    var scaleDefs = get(this.options, "scales", {});
    var geometries = this.geometries;
    for (var i = 0, len = geometries.length; i < len; i++) {
      var geometry2 = geometries[i];
      geometry2.scales = this.getGeometryScales();
      var cfg = {
        coordinate: coordinate2,
        scaleDefs,
        data: this.filteredData,
        theme: this.themeObject,
        isDataChanged: this.isDataChanged,
        isCoordinateChanged: this.isCoordinateChanged
      };
      if (isUpdate) {
        geometry2.update(cfg);
      } else {
        geometry2.init(cfg);
      }
    }
    this.adjustScales();
  };
  View2.prototype.createOrUpdateScales = function() {
    var fields = this.getScaleFields();
    var groupedFields = this.getGroupedFields();
    var _a2 = this.getOptions(), data2 = _a2.data, _b = _a2.scales, scales = _b === void 0 ? {} : _b;
    var filteredData = this.filteredData;
    for (var i = 0, len = fields.length; i < len; i++) {
      var field2 = fields[i];
      var scaleDef = scales[field2];
      var key = this.getScaleKey(field2);
      this.createScale(field2, groupedFields.includes(field2) ? data2 : filteredData, scaleDef, key);
      this.createdScaleKeys.set(key, true);
    }
  };
  View2.prototype.syncScale = function() {
    this.getRootView().scalePool.sync(this.getCoordinate(), this.theme);
  };
  View2.prototype.getGeometryScales = function() {
    var fields = this.getScaleFields();
    var scales = {};
    for (var i = 0; i < fields.length; i++) {
      var field2 = fields[i];
      scales[field2] = this.getScaleByField(field2);
    }
    return scales;
  };
  View2.prototype.getScaleFields = function() {
    var fields = [];
    var tmpMap = new Map();
    var geometries = this.geometries;
    for (var i = 0; i < geometries.length; i++) {
      var geometry2 = geometries[i];
      var geometryScales = geometry2.getScaleFields();
      uniq$1(geometryScales, fields, tmpMap);
    }
    return fields;
  };
  View2.prototype.getGroupedFields = function() {
    var fields = [];
    var tmpMap = new Map();
    var geometries = this.geometries;
    for (var i = 0; i < geometries.length; i++) {
      var geometry2 = geometries[i];
      var groupFields = geometry2.getGroupFields();
      uniq$1(groupFields, fields, tmpMap);
    }
    return fields;
  };
  View2.prototype.adjustScales = function() {
    this.adjustCategoryScaleRange();
  };
  View2.prototype.adjustCategoryScaleRange = function() {
    var _this = this;
    var xyScales = __spreadArray([this.getXScale()], this.getYScales(), true).filter(function(e) {
      return !!e;
    });
    var coordinate2 = this.getCoordinate();
    var scaleOptions = this.options.scales;
    each$1(xyScales, function(scale2) {
      var field2 = scale2.field, values2 = scale2.values, isCategory = scale2.isCategory, isIdentity = scale2.isIdentity;
      if (isCategory || isIdentity) {
        if (values2 && !get(scaleOptions, [field2, "range"])) {
          scale2.range = getDefaultCategoryScaleRange(scale2, coordinate2, _this.theme);
        }
      }
    });
  };
  View2.prototype.initComponents = function(isUpdate) {
    var controllers = this.controllers;
    for (var i = 0; i < controllers.length; i++) {
      var controller = controllers[i];
      if (isUpdate) {
        controller.update();
      } else {
        controller.clear();
        controller.render();
      }
    }
  };
  View2.prototype.doLayout = function() {
    this.layoutFunc(this);
  };
  View2.prototype.createCoordinate = function() {
    var start = this.coordinateBBox.bl;
    var end = this.coordinateBBox.tr;
    this.coordinateInstance = this.coordinateController.create(start, end);
  };
  View2.prototype.paintGeometries = function(isUpdate) {
    var doAnimation = this.options.animate;
    var coordinate2 = this.getCoordinate();
    var canvasRegion = {
      x: this.viewBBox.x,
      y: this.viewBBox.y,
      minX: this.viewBBox.minX,
      minY: this.viewBBox.minY,
      maxX: this.viewBBox.maxX,
      maxY: this.viewBBox.maxY,
      width: this.viewBBox.width,
      height: this.viewBBox.height
    };
    var geometries = this.geometries;
    for (var i = 0; i < geometries.length; i++) {
      var geometry2 = geometries[i];
      geometry2.coordinate = coordinate2;
      geometry2.canvasRegion = canvasRegion;
      if (!doAnimation) {
        geometry2.animate(false);
      }
      geometry2.paint(isUpdate);
    }
  };
  View2.prototype.renderComponents = function(isUpdate) {
    for (var i = 0; i < this.getComponents().length; i++) {
      var co = this.getComponents()[i];
      co.component.render();
    }
  };
  View2.prototype.renderFacet = function(isUpdate) {
    if (this.facetInstance) {
      if (isUpdate) {
        this.facetInstance.update();
      } else {
        this.facetInstance.clear();
        this.facetInstance.init();
        this.facetInstance.render();
      }
    }
  };
  View2.prototype.initOptions = function() {
    var _this = this;
    var _a2 = this.options, _b = _a2.geometries, geometries = _b === void 0 ? [] : _b, _c = _a2.interactions, interactions = _c === void 0 ? [] : _c, _d = _a2.views, views = _d === void 0 ? [] : _d, _e = _a2.annotations, annotations = _e === void 0 ? [] : _e, coordinate2 = _a2.coordinate, events = _a2.events, facets = _a2.facets;
    if (this.coordinateController) {
      coordinate2 && this.coordinateController.update(coordinate2);
    } else {
      this.coordinateController = new CoordinateController(coordinate2);
    }
    for (var i = 0; i < geometries.length; i++) {
      var geometryOption = geometries[i];
      this.createGeometry(geometryOption);
    }
    for (var j = 0; j < interactions.length; j++) {
      var interactionOption = interactions[j];
      var type = interactionOption.type, cfg = interactionOption.cfg;
      this.interaction(type, cfg);
    }
    for (var k = 0; k < views.length; k++) {
      var viewOption = views[k];
      this.createView(viewOption);
    }
    var annotationComponent = this.getController("annotation");
    for (var l = 0; l < annotations.length; l++) {
      var annotationOption = annotations[l];
      annotationComponent.annotation(annotationOption);
    }
    if (events) {
      each$1(events, function(eventCallback, eventName) {
        _this.on(eventName, eventCallback);
      });
    }
    if (facets) {
      each$1(facets, function(facet) {
        var type2 = facet.type, rest = __rest(facet, ["type"]);
        _this.facet(type2, rest);
      });
    }
  };
  View2.prototype.createGeometry = function(geometryOption) {
    var type = geometryOption.type, _a2 = geometryOption.cfg, cfg = _a2 === void 0 ? {} : _a2;
    if (this[type]) {
      var geometry_1 = this[type](cfg);
      each$1(geometryOption, function(v, k) {
        if (isFunction(geometry_1[k])) {
          geometry_1[k](v);
        }
      });
    }
  };
  View2.prototype.getScaleKey = function(field2) {
    return this.id + "-" + field2;
  };
  return View2;
}(Base$2);
function registerGeometry(name, Ctor) {
  View.prototype[name.toLowerCase()] = function(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    var props = __assign$1({
      container: this.middleGroup.addGroup(),
      labelsContainer: this.foregroundGroup.addGroup()
    }, cfg);
    var geometry2 = new Ctor(props);
    this.geometries.push(geometry2);
    return geometry2;
  };
}
var Chart = function(_super) {
  __extends$2(Chart2, _super);
  function Chart2(props) {
    var _this = this;
    var container = props.container, width = props.width, height = props.height, _a2 = props.autoFit, autoFit = _a2 === void 0 ? false : _a2, padding2 = props.padding, appendPadding = props.appendPadding, _b = props.renderer, renderer = _b === void 0 ? "canvas" : _b, pixelRatio = props.pixelRatio, _c = props.localRefresh, localRefresh = _c === void 0 ? true : _c, _d = props.visible, visible = _d === void 0 ? true : _d, _e = props.supportCSSTransform, supportCSSTransform = _e === void 0 ? false : _e, _f = props.defaultInteractions, defaultInteractions = _f === void 0 ? ["tooltip", "legend-filter", "legend-active", "continuous-filter", "ellipsis-text"] : _f, options = props.options, limitInPlot2 = props.limitInPlot, theme2 = props.theme, syncViewPadding2 = props.syncViewPadding;
    var ele = isString(container) ? document.getElementById(container) : container;
    var wrapperElement = createDom$1('<div style="position:relative;"></div>');
    ele.appendChild(wrapperElement);
    var size2 = getChartSize(ele, autoFit, width, height);
    var G = getEngine(renderer);
    var canvas = new G.Canvas(__assign$1({ container: wrapperElement, pixelRatio, localRefresh, supportCSSTransform }, size2));
    _this = _super.call(this, {
      parent: null,
      canvas,
      backgroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
      middleGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
      foregroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
      padding: padding2,
      appendPadding,
      visible,
      options,
      limitInPlot: limitInPlot2,
      theme: theme2,
      syncViewPadding: syncViewPadding2
    }) || this;
    _this.onResize = debounce(function() {
      _this.forceFit();
    }, 300);
    _this.ele = ele;
    _this.canvas = canvas;
    _this.width = size2.width;
    _this.height = size2.height;
    _this.autoFit = autoFit;
    _this.localRefresh = localRefresh;
    _this.renderer = renderer;
    _this.wrapperElement = wrapperElement;
    _this.updateCanvasStyle();
    _this.bindAutoFit();
    _this.initDefaultInteractions(defaultInteractions);
    return _this;
  }
  Chart2.prototype.initDefaultInteractions = function(interactions) {
    var _this = this;
    each$1(interactions, function(interaction2) {
      _this.interaction(interaction2);
    });
  };
  Chart2.prototype.aria = function(ariaOption) {
    var ATTR = "aria-label";
    if (ariaOption === false) {
      this.ele.removeAttribute(ATTR);
    } else {
      this.ele.setAttribute(ATTR, ariaOption.label);
    }
  };
  Chart2.prototype.changeSize = function(width, height) {
    if (this.width === width && this.height === height) {
      return this;
    }
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE);
    this.width = width;
    this.height = height;
    this.canvas.changeSize(width, height);
    this.render(true);
    this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_SIZE);
    return this;
  };
  Chart2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this.aria(false);
  };
  Chart2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.unbindAutoFit();
    this.canvas.destroy();
    removeDom(this.wrapperElement);
    this.wrapperElement = null;
  };
  Chart2.prototype.changeVisible = function(visible) {
    _super.prototype.changeVisible.call(this, visible);
    this.wrapperElement.style.display = visible ? "" : "none";
    return this;
  };
  Chart2.prototype.forceFit = function() {
    if (!this.destroyed) {
      var _a2 = getChartSize(this.ele, true, this.width, this.height), width = _a2.width, height = _a2.height;
      this.changeSize(width, height);
    }
  };
  Chart2.prototype.updateCanvasStyle = function() {
    modifyCSS(this.canvas.get("el"), {
      display: "inline-block",
      verticalAlign: "middle"
    });
  };
  Chart2.prototype.bindAutoFit = function() {
    if (this.autoFit) {
      window.addEventListener("resize", this.onResize);
    }
  };
  Chart2.prototype.unbindAutoFit = function() {
    if (this.autoFit) {
      window.removeEventListener("resize", this.onResize);
    }
  };
  return Chart2;
}(View);
var Controller = function() {
  function Controller2(view) {
    this.visible = true;
    this.components = [];
    this.view = view;
  }
  Controller2.prototype.clear = function(includeOption) {
    each$1(this.components, function(co) {
      co.component.destroy();
    });
    this.components = [];
  };
  Controller2.prototype.destroy = function() {
    this.clear();
  };
  Controller2.prototype.getComponents = function() {
    return this.components;
  };
  Controller2.prototype.changeVisible = function(visible) {
    if (this.visible === visible) {
      return;
    }
    this.components.forEach(function(co) {
      if (visible) {
        co.component.show();
      } else {
        co.component.hide();
      }
    });
    this.visible = visible;
  };
  return Controller2;
}();
function uniq(items) {
  var uniqItems = [];
  var _loop_1 = function(index3) {
    var item = items[index3];
    var result = find$1(uniqItems, function(subItem) {
      return subItem.color === item.color && subItem.name === item.name && subItem.value === item.value && subItem.title === item.title;
    });
    if (!result) {
      uniqItems.push(item);
    }
  };
  for (var index2 = 0; index2 < items.length; index2++) {
    _loop_1(index2);
  }
  return uniqItems;
}
var Tooltip = function(_super) {
  __extends$2(Tooltip2, _super);
  function Tooltip2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.isLocked = false;
    return _this;
  }
  Object.defineProperty(Tooltip2.prototype, "name", {
    get: function() {
      return "tooltip";
    },
    enumerable: false,
    configurable: true
  });
  Tooltip2.prototype.init = function() {
  };
  Tooltip2.prototype.isVisible = function() {
    var option = this.view.getOptions().tooltip;
    return option !== false;
  };
  Tooltip2.prototype.render = function() {
  };
  Tooltip2.prototype.showTooltip = function(point2) {
    this.point = point2;
    if (!this.isVisible()) {
      return;
    }
    var view = this.view;
    var items = this.getTooltipItems(point2);
    if (!items.length) {
      this.hideTooltip();
      return;
    }
    var title = this.getTitle(items);
    var dataPoint = {
      x: items[0].x,
      y: items[0].y
    };
    view.emit("tooltip:show", Event.fromData(view, "tooltip:show", __assign$1({ items, title }, point2)));
    var cfg = this.getTooltipCfg();
    var follow = cfg.follow, showMarkers = cfg.showMarkers, showCrosshairs = cfg.showCrosshairs, showContent = cfg.showContent, marker = cfg.marker;
    var lastItems = this.items;
    var lastTitle = this.title;
    if (!isEqual$2(lastTitle, title) || !isEqual$2(lastItems, items)) {
      view.emit("tooltip:change", Event.fromData(view, "tooltip:change", __assign$1({ items, title }, point2)));
      if (isFunction(showContent) ? showContent(items) : showContent) {
        if (!this.tooltip) {
          this.renderTooltip();
        }
        this.tooltip.update(mix({}, cfg, {
          items: this.getItemsAfterProcess(items),
          title
        }, follow ? point2 : {}));
        this.tooltip.show();
      }
      if (showMarkers) {
        this.renderTooltipMarkers(items, marker);
      }
    } else {
      if (this.tooltip && follow) {
        this.tooltip.update(point2);
        this.tooltip.show();
      }
      if (this.tooltipMarkersGroup) {
        this.tooltipMarkersGroup.show();
      }
    }
    this.items = items;
    this.title = title;
    if (showCrosshairs) {
      var isCrosshairsFollowCursor = get(cfg, ["crosshairs", "follow"], false);
      this.renderCrosshairs(isCrosshairsFollowCursor ? point2 : dataPoint, cfg);
    }
  };
  Tooltip2.prototype.hideTooltip = function() {
    var follow = this.getTooltipCfg().follow;
    if (!follow) {
      this.point = null;
      return;
    }
    var tooltipMarkersGroup = this.tooltipMarkersGroup;
    if (tooltipMarkersGroup) {
      tooltipMarkersGroup.hide();
    }
    var xCrosshair = this.xCrosshair;
    var yCrosshair = this.yCrosshair;
    if (xCrosshair) {
      xCrosshair.hide();
    }
    if (yCrosshair) {
      yCrosshair.hide();
    }
    var tooltip2 = this.tooltip;
    if (tooltip2) {
      tooltip2.hide();
    }
    this.view.emit("tooltip:hide", Event.fromData(this.view, "tooltip:hide", {}));
    this.point = null;
  };
  Tooltip2.prototype.lockTooltip = function() {
    this.isLocked = true;
    if (this.tooltip) {
      this.tooltip.setCapture(true);
    }
  };
  Tooltip2.prototype.unlockTooltip = function() {
    this.isLocked = false;
    var cfg = this.getTooltipCfg();
    if (this.tooltip) {
      this.tooltip.setCapture(cfg.capture);
    }
  };
  Tooltip2.prototype.isTooltipLocked = function() {
    return this.isLocked;
  };
  Tooltip2.prototype.clear = function() {
    var _a2 = this, tooltip2 = _a2.tooltip, xCrosshair = _a2.xCrosshair, yCrosshair = _a2.yCrosshair, tooltipMarkersGroup = _a2.tooltipMarkersGroup;
    if (tooltip2) {
      tooltip2.hide();
      tooltip2.clear();
    }
    if (xCrosshair) {
      xCrosshair.clear();
    }
    if (yCrosshair) {
      yCrosshair.clear();
    }
    if (tooltipMarkersGroup) {
      tooltipMarkersGroup.clear();
    }
    if (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.get("customContent")) {
      this.tooltip.destroy();
      this.tooltip = null;
    }
    this.title = null;
    this.items = null;
  };
  Tooltip2.prototype.destroy = function() {
    if (this.tooltip) {
      this.tooltip.destroy();
    }
    if (this.xCrosshair) {
      this.xCrosshair.destroy();
    }
    if (this.yCrosshair) {
      this.yCrosshair.destroy();
    }
    if (this.guideGroup) {
      this.guideGroup.remove(true);
    }
    this.reset();
  };
  Tooltip2.prototype.reset = function() {
    this.items = null;
    this.title = null;
    this.tooltipMarkersGroup = null;
    this.tooltipCrosshairsGroup = null;
    this.xCrosshair = null;
    this.yCrosshair = null;
    this.tooltip = null;
    this.guideGroup = null;
    this.isLocked = false;
    this.point = null;
  };
  Tooltip2.prototype.changeVisible = function(visible) {
    if (this.visible === visible) {
      return;
    }
    var _a2 = this, tooltip2 = _a2.tooltip, tooltipMarkersGroup = _a2.tooltipMarkersGroup, xCrosshair = _a2.xCrosshair, yCrosshair = _a2.yCrosshair;
    if (visible) {
      if (tooltip2) {
        tooltip2.show();
      }
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.show();
      }
      if (xCrosshair) {
        xCrosshair.show();
      }
      if (yCrosshair) {
        yCrosshair.show();
      }
    } else {
      if (tooltip2) {
        tooltip2.hide();
      }
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.hide();
      }
      if (xCrosshair) {
        xCrosshair.hide();
      }
      if (yCrosshair) {
        yCrosshair.hide();
      }
    }
    this.visible = visible;
  };
  Tooltip2.prototype.getTooltipItems = function(point2) {
    var items = this.findItemsFromView(this.view, point2);
    if (items.length) {
      items = flatten(items);
      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
        var itemArr = items_1[_i];
        for (var _a2 = 0, itemArr_1 = itemArr; _a2 < itemArr_1.length; _a2++) {
          var item = itemArr_1[_a2];
          var _b = item.mappingData, x = _b.x, y = _b.y;
          item.x = isArray$1(x) ? x[x.length - 1] : x;
          item.y = isArray$1(y) ? y[y.length - 1] : y;
        }
      }
      var shared = this.getTooltipCfg().shared;
      if (shared === false && items.length > 1) {
        var snapItem = items[0];
        var min2 = Math.abs(point2.y - snapItem[0].y);
        for (var _c = 0, items_2 = items; _c < items_2.length; _c++) {
          var aItem = items_2[_c];
          var yDistance = Math.abs(point2.y - aItem[0].y);
          if (yDistance <= min2) {
            snapItem = aItem;
            min2 = yDistance;
          }
        }
        items = [snapItem];
      }
      return uniq(flatten(items));
    }
    return [];
  };
  Tooltip2.prototype.layout = function() {
  };
  Tooltip2.prototype.update = function() {
    if (this.point) {
      this.showTooltip(this.point);
    }
    if (this.tooltip) {
      var canvas = this.view.getCanvas();
      this.tooltip.set("region", {
        start: { x: 0, y: 0 },
        end: { x: canvas.get("width"), y: canvas.get("height") }
      });
    }
  };
  Tooltip2.prototype.isCursorEntered = function(point2) {
    if (this.tooltip) {
      var el = this.tooltip.getContainer();
      var capture = this.tooltip.get("capture");
      if (el && capture) {
        var _a2 = el.getBoundingClientRect(), x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
        return new BBox(x, y, width, height).isPointIn(point2);
      }
    }
    return false;
  };
  Tooltip2.prototype.getTooltipCfg = function() {
    var view = this.view;
    var option = view.getOptions().tooltip;
    var processOption = this.processCustomContent(option);
    var theme2 = view.getTheme();
    var defaultCfg = get(theme2, ["components", "tooltip"], {});
    var enterable = get(processOption, "enterable", defaultCfg.enterable);
    return deepMix({}, defaultCfg, processOption, {
      capture: enterable || this.isLocked ? true : false
    });
  };
  Tooltip2.prototype.processCustomContent = function(option) {
    if (isBoolean(option) || !get(option, "customContent")) {
      return option;
    }
    var currentCustomContent = option.customContent;
    var customContent = function(title, items) {
      var content = currentCustomContent(title, items) || "";
      return isString(content) ? '<div class="g2-tooltip">' + content + "</div>" : content;
    };
    return __assign$1(__assign$1({}, option), { customContent });
  };
  Tooltip2.prototype.getTitle = function(items) {
    var title = items[0].title || items[0].name;
    this.title = title;
    return title;
  };
  Tooltip2.prototype.renderTooltip = function() {
    var canvas = this.view.getCanvas();
    var region = {
      start: { x: 0, y: 0 },
      end: { x: canvas.get("width"), y: canvas.get("height") }
    };
    var cfg = this.getTooltipCfg();
    var tooltip2 = new HtmlTooltip(__assign$1(__assign$1({ parent: canvas.get("el").parentNode, region }, cfg), { visible: false, crosshairs: null }));
    tooltip2.init();
    this.tooltip = tooltip2;
  };
  Tooltip2.prototype.renderTooltipMarkers = function(items, marker) {
    var tooltipMarkersGroup = this.getTooltipMarkersGroup();
    for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {
      var item = items_3[_i];
      var x = item.x, y = item.y;
      var attrs = __assign$1(__assign$1({ fill: item.color, symbol: "circle", shadowColor: item.color }, marker), { x, y });
      tooltipMarkersGroup.addShape("marker", {
        attrs
      });
    }
  };
  Tooltip2.prototype.renderCrosshairs = function(point2, cfg) {
    var crosshairsType = get(cfg, ["crosshairs", "type"], "x");
    if (crosshairsType === "x") {
      if (this.yCrosshair) {
        this.yCrosshair.hide();
      }
      this.renderXCrosshairs(point2, cfg);
    } else if (crosshairsType === "y") {
      if (this.xCrosshair) {
        this.xCrosshair.hide();
      }
      this.renderYCrosshairs(point2, cfg);
    } else if (crosshairsType === "xy") {
      this.renderXCrosshairs(point2, cfg);
      this.renderYCrosshairs(point2, cfg);
    }
  };
  Tooltip2.prototype.renderXCrosshairs = function(point2, tooltipCfg) {
    var coordinate2 = this.getViewWithGeometry(this.view).getCoordinate();
    if (!isPointInCoordinate(coordinate2, point2)) {
      return;
    }
    var start;
    var end;
    if (coordinate2.isRect) {
      if (coordinate2.isTransposed) {
        start = {
          x: coordinate2.start.x,
          y: point2.y
        };
        end = {
          x: coordinate2.end.x,
          y: point2.y
        };
      } else {
        start = {
          x: point2.x,
          y: coordinate2.end.y
        };
        end = {
          x: point2.x,
          y: coordinate2.start.y
        };
      }
    } else {
      var angle2 = getAngleByPoint(coordinate2, point2);
      var center2 = coordinate2.getCenter();
      var radius = coordinate2.getRadius();
      end = polarToCartesian(center2.x, center2.y, radius, angle2);
      start = center2;
    }
    var cfg = deepMix({
      start,
      end,
      container: this.getTooltipCrosshairsGroup()
    }, get(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("x", point2, tooltipCfg));
    delete cfg.type;
    var xCrosshair = this.xCrosshair;
    if (xCrosshair) {
      xCrosshair.update(cfg);
    } else {
      xCrosshair = new LineCrosshair$1(cfg);
      xCrosshair.init();
    }
    xCrosshair.render();
    xCrosshair.show();
    this.xCrosshair = xCrosshair;
  };
  Tooltip2.prototype.renderYCrosshairs = function(point2, tooltipCfg) {
    var coordinate2 = this.getViewWithGeometry(this.view).getCoordinate();
    if (!isPointInCoordinate(coordinate2, point2)) {
      return;
    }
    var cfg;
    var type;
    if (coordinate2.isRect) {
      var start = void 0;
      var end = void 0;
      if (coordinate2.isTransposed) {
        start = {
          x: point2.x,
          y: coordinate2.end.y
        };
        end = {
          x: point2.x,
          y: coordinate2.start.y
        };
      } else {
        start = {
          x: coordinate2.start.x,
          y: point2.y
        };
        end = {
          x: coordinate2.end.x,
          y: point2.y
        };
      }
      cfg = {
        start,
        end
      };
      type = "Line";
    } else {
      cfg = {
        center: coordinate2.getCenter(),
        radius: getDistanceToCenter(coordinate2, point2),
        startAngle: coordinate2.startAngle,
        endAngle: coordinate2.endAngle
      };
      type = "Circle";
    }
    cfg = deepMix({
      container: this.getTooltipCrosshairsGroup()
    }, cfg, get(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("y", point2, tooltipCfg));
    delete cfg.type;
    var yCrosshair = this.yCrosshair;
    if (yCrosshair) {
      if (coordinate2.isRect && yCrosshair.get("type") === "circle" || !coordinate2.isRect && yCrosshair.get("type") === "line") {
        yCrosshair = new Crosshair[type](cfg);
        yCrosshair.init();
      } else {
        yCrosshair.update(cfg);
      }
    } else {
      yCrosshair = new Crosshair[type](cfg);
      yCrosshair.init();
    }
    yCrosshair.render();
    yCrosshair.show();
    this.yCrosshair = yCrosshair;
  };
  Tooltip2.prototype.getCrosshairsText = function(type, point2, tooltipCfg) {
    var textCfg = get(tooltipCfg, ["crosshairs", "text"]);
    var follow = get(tooltipCfg, ["crosshairs", "follow"]);
    var items = this.items;
    if (textCfg) {
      var view = this.getViewWithGeometry(this.view);
      var firstItem = items[0];
      var xScale = view.getXScale();
      var yScale = view.getYScales()[0];
      var xValue = void 0;
      var yValue = void 0;
      if (follow) {
        var invertPoint = this.view.getCoordinate().invert(point2);
        xValue = xScale.invert(invertPoint.x);
        yValue = yScale.invert(invertPoint.y);
      } else {
        xValue = firstItem.data[xScale.field];
        yValue = firstItem.data[yScale.field];
      }
      var content = type === "x" ? xValue : yValue;
      if (isFunction(textCfg)) {
        textCfg = textCfg(type, content, items, point2);
      } else {
        textCfg.content = content;
      }
      return {
        text: textCfg
      };
    }
  };
  Tooltip2.prototype.getGuideGroup = function() {
    if (!this.guideGroup) {
      var foregroundGroup = this.view.foregroundGroup;
      this.guideGroup = foregroundGroup.addGroup({
        name: "tooltipGuide",
        capture: false
      });
    }
    return this.guideGroup;
  };
  Tooltip2.prototype.getTooltipMarkersGroup = function() {
    var tooltipMarkersGroup = this.tooltipMarkersGroup;
    if (tooltipMarkersGroup && !tooltipMarkersGroup.destroyed) {
      tooltipMarkersGroup.clear();
      tooltipMarkersGroup.show();
    } else {
      tooltipMarkersGroup = this.getGuideGroup().addGroup({
        name: "tooltipMarkersGroup"
      });
      tooltipMarkersGroup.toFront();
      this.tooltipMarkersGroup = tooltipMarkersGroup;
    }
    return tooltipMarkersGroup;
  };
  Tooltip2.prototype.getTooltipCrosshairsGroup = function() {
    var tooltipCrosshairsGroup = this.tooltipCrosshairsGroup;
    if (!tooltipCrosshairsGroup) {
      tooltipCrosshairsGroup = this.getGuideGroup().addGroup({
        name: "tooltipCrosshairsGroup",
        capture: false
      });
      tooltipCrosshairsGroup.toBack();
      this.tooltipCrosshairsGroup = tooltipCrosshairsGroup;
    }
    return tooltipCrosshairsGroup;
  };
  Tooltip2.prototype.findItemsFromView = function(view, point2) {
    if (view.getOptions().tooltip === false) {
      return [];
    }
    var tooltipCfg = this.getTooltipCfg();
    var result = findItemsFromView(view, point2, tooltipCfg);
    for (var _i = 0, _a2 = view.views; _i < _a2.length; _i++) {
      var childView = _a2[_i];
      result = result.concat(this.findItemsFromView(childView, point2));
    }
    return result;
  };
  Tooltip2.prototype.getViewWithGeometry = function(view) {
    var _this = this;
    if (view.geometries.length) {
      return view;
    }
    return find$1(view.views, function(childView) {
      return _this.getViewWithGeometry(childView);
    });
  };
  Tooltip2.prototype.getItemsAfterProcess = function(originalItems) {
    var customItems = this.getTooltipCfg().customItems;
    var fn = customItems ? customItems : function(v) {
      return v;
    };
    return fn(originalItems);
  };
  return Tooltip2;
}(Controller);
var ANIMATIONS_MAP = {};
function getAnimation(type) {
  return ANIMATIONS_MAP[type.toLowerCase()];
}
function registerAnimation(type, animation2) {
  ANIMATIONS_MAP[type.toLowerCase()] = animation2;
}
var DEFAULT_ANIMATE_CFG = {
  appear: {
    duration: 450,
    easing: "easeQuadOut"
  },
  update: {
    duration: 400,
    easing: "easeQuadInOut"
  },
  enter: {
    duration: 400,
    easing: "easeQuadInOut"
  },
  leave: {
    duration: 350,
    easing: "easeQuadIn"
  }
};
var GEOMETRY_ANIMATE_CFG = {
  interval: function(coordinate2) {
    return {
      enter: {
        animation: coordinate2.isRect ? coordinate2.isTransposed ? "scale-in-x" : "scale-in-y" : "fade-in"
      },
      update: {
        animation: coordinate2.isPolar && coordinate2.isTransposed ? "sector-path-update" : null
      },
      leave: {
        animation: "fade-out"
      }
    };
  },
  line: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  path: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  point: {
    appear: {
      animation: "zoom-in"
    },
    enter: {
      animation: "zoom-in"
    },
    leave: {
      animation: "zoom-out"
    }
  },
  area: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  polygon: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  schema: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  edge: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  label: {
    appear: {
      animation: "fade-in",
      delay: 450
    },
    enter: {
      animation: "fade-in"
    },
    update: {
      animation: "position-update"
    },
    leave: {
      animation: "fade-out"
    }
  }
};
var GEOMETRY_GROUP_APPEAR_ANIMATION = {
  line: function() {
    return {
      animation: "wave-in"
    };
  },
  area: function() {
    return {
      animation: "wave-in"
    };
  },
  path: function() {
    return {
      animation: "fade-in"
    };
  },
  interval: function(coordinate2) {
    var animation2;
    if (coordinate2.isRect) {
      animation2 = coordinate2.isTransposed ? "grow-in-x" : "grow-in-y";
    } else {
      animation2 = "grow-in-xy";
      if (coordinate2.isPolar && coordinate2.isTransposed) {
        animation2 = "wave-in";
      }
    }
    return {
      animation: animation2
    };
  },
  schema: function(coordinate2) {
    var animation2;
    if (coordinate2.isRect) {
      animation2 = coordinate2.isTransposed ? "grow-in-x" : "grow-in-y";
    } else {
      animation2 = "grow-in-xy";
    }
    return {
      animation: animation2
    };
  },
  polygon: function() {
    return {
      animation: "fade-in",
      duration: 500
    };
  },
  edge: function() {
    return {
      animation: "fade-in"
    };
  }
};
function parseAnimateConfig(animateCfg, data2) {
  return {
    delay: isFunction(animateCfg.delay) ? animateCfg.delay(data2) : animateCfg.delay,
    easing: isFunction(animateCfg.easing) ? animateCfg.easing(data2) : animateCfg.easing,
    duration: isFunction(animateCfg.duration) ? animateCfg.duration(data2) : animateCfg.duration,
    callback: animateCfg.callback,
    repeat: animateCfg.repeat
  };
}
function getDefaultAnimateCfg(elementName, coordinate2, animateType) {
  var animateCfg = GEOMETRY_ANIMATE_CFG[elementName];
  if (animateCfg) {
    if (isFunction(animateCfg)) {
      animateCfg = animateCfg(coordinate2);
    }
    animateCfg = deepMix({}, DEFAULT_ANIMATE_CFG, animateCfg);
    if (animateType) {
      return animateCfg[animateType];
    }
  }
  return animateCfg;
}
function doAnimate(shape, animateCfg, cfg) {
  var data2 = get(shape.get("origin"), "data", FIELD_ORIGIN);
  var animation2 = animateCfg.animation;
  var parsedAnimateCfg = parseAnimateConfig(animateCfg, data2);
  if (animation2) {
    var animateFunction = getAnimation(animation2);
    if (animateFunction) {
      animateFunction(shape, parsedAnimateCfg, cfg);
    }
  } else {
    shape.animate(cfg.toAttrs, parsedAnimateCfg);
  }
}
function doGroupAppearAnimate(container, animateCfg, geometryType, coordinate2, minYPoint) {
  if (GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType]) {
    var defaultCfg = GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType](coordinate2);
    var animation2 = getAnimation(get(defaultCfg, "animation", ""));
    if (animation2) {
      var cfg = __assign$1(__assign$1(__assign$1({}, DEFAULT_ANIMATE_CFG.appear), defaultCfg), animateCfg);
      container.stopAnimate();
      animation2(container, cfg, {
        coordinate: coordinate2,
        minYPoint,
        toAttrs: null
      });
    }
  }
}
var BACKGROUND_SHAPE = "element-background";
var Element$1 = function(_super) {
  __extends$2(Element2, _super);
  function Element2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.states = [];
    var shapeFactory = cfg.shapeFactory, container = cfg.container, offscreenGroup = cfg.offscreenGroup, elementIndex = cfg.elementIndex, _a2 = cfg.visible, visible = _a2 === void 0 ? true : _a2;
    _this.shapeFactory = shapeFactory;
    _this.container = container;
    _this.offscreenGroup = offscreenGroup;
    _this.visible = visible;
    _this.elementIndex = elementIndex;
    return _this;
  }
  Element2.prototype.draw = function(model, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    this.model = model;
    this.data = model.data;
    this.shapeType = this.getShapeType(model);
    this.drawShape(model, isUpdate);
    if (this.visible === false) {
      this.changeVisible(false);
    }
  };
  Element2.prototype.update = function(model) {
    var _a2 = this, shapeFactory = _a2.shapeFactory, shape = _a2.shape;
    if (!shape) {
      return;
    }
    this.model = model;
    this.data = model.data;
    this.shapeType = this.getShapeType(model);
    this.setShapeInfo(shape, model);
    var offscreenGroup = this.getOffscreenGroup();
    var newShape = shapeFactory.drawShape(this.shapeType, model, offscreenGroup);
    newShape.cfg.data = this.data;
    newShape.cfg.origin = model;
    newShape.cfg.element = this;
    this.syncShapeStyle(shape, newShape, this.getStates(), this.getAnimateCfg("update"));
  };
  Element2.prototype.destroy = function() {
    var _a2 = this, shapeFactory = _a2.shapeFactory, shape = _a2.shape;
    if (shape) {
      var animateCfg = this.getAnimateCfg("leave");
      if (animateCfg) {
        doAnimate(shape, animateCfg, {
          coordinate: shapeFactory.coordinate,
          toAttrs: __assign$1({}, shape.attr())
        });
      } else {
        shape.remove(true);
      }
    }
    this.states = [];
    this.shapeFactory = void 0;
    this.container = void 0;
    this.shape = void 0;
    this.animate = void 0;
    this.geometry = void 0;
    this.labelShape = void 0;
    this.model = void 0;
    this.data = void 0;
    this.offscreenGroup = void 0;
    this.statesStyle = void 0;
    _super.prototype.destroy.call(this);
  };
  Element2.prototype.changeVisible = function(visible) {
    _super.prototype.changeVisible.call(this, visible);
    if (visible) {
      if (this.shape) {
        this.shape.show();
      }
      if (this.labelShape) {
        this.labelShape.forEach(function(label2) {
          label2.show();
        });
      }
    } else {
      if (this.shape) {
        this.shape.hide();
      }
      if (this.labelShape) {
        this.labelShape.forEach(function(label2) {
          label2.hide();
        });
      }
    }
  };
  Element2.prototype.setState = function(stateName, stateStatus) {
    var _a2 = this, states = _a2.states, shapeFactory = _a2.shapeFactory, model = _a2.model, shape = _a2.shape, shapeType = _a2.shapeType;
    var index2 = states.indexOf(stateName);
    if (stateStatus) {
      if (index2 > -1) {
        return;
      }
      states.push(stateName);
      if (stateName === "active" || stateName === "selected") {
        shape === null || shape === void 0 ? void 0 : shape.toFront();
      }
    } else {
      if (index2 === -1) {
        return;
      }
      states.splice(index2, 1);
      if (stateName === "active" || stateName === "selected") {
        if (this.geometry.zIndexReversed) {
          shape.setZIndex(this.geometry.elements.length - this.elementIndex);
        } else {
          shape.setZIndex(this.elementIndex);
        }
      }
    }
    var offscreenShape = shapeFactory.drawShape(shapeType, model, this.getOffscreenGroup());
    if (states.length) {
      this.syncShapeStyle(shape, offscreenShape, states, null);
    } else {
      this.syncShapeStyle(shape, offscreenShape, ["reset"], null);
    }
    offscreenShape.remove(true);
    var eventObject = {
      state: stateName,
      stateStatus,
      element: this,
      target: this.container
    };
    this.container.emit("statechange", eventObject);
    propagationDelegate(this.shape, "statechange", eventObject);
  };
  Element2.prototype.clearStates = function() {
    var _this = this;
    var states = this.states;
    each$1(states, function(state2) {
      _this.setState(state2, false);
    });
    this.states = [];
  };
  Element2.prototype.hasState = function(stateName) {
    return this.states.includes(stateName);
  };
  Element2.prototype.getStates = function() {
    return this.states;
  };
  Element2.prototype.getData = function() {
    return this.data;
  };
  Element2.prototype.getModel = function() {
    return this.model;
  };
  Element2.prototype.getBBox = function() {
    var _a2 = this, shape = _a2.shape, labelShape = _a2.labelShape;
    var bbox = {
      x: 0,
      y: 0,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    };
    if (shape) {
      bbox = shape.getCanvasBBox();
    }
    if (labelShape) {
      labelShape.forEach(function(label2) {
        var labelBBox = label2.getCanvasBBox();
        bbox.x = Math.min(labelBBox.x, bbox.x);
        bbox.y = Math.min(labelBBox.y, bbox.y);
        bbox.minX = Math.min(labelBBox.minX, bbox.minX);
        bbox.minY = Math.min(labelBBox.minY, bbox.minY);
        bbox.maxX = Math.max(labelBBox.maxX, bbox.maxX);
        bbox.maxY = Math.max(labelBBox.maxY, bbox.maxY);
      });
    }
    bbox.width = bbox.maxX - bbox.minX;
    bbox.height = bbox.maxY - bbox.minY;
    return bbox;
  };
  Element2.prototype.getStatesStyle = function() {
    if (!this.statesStyle) {
      var _a2 = this, shapeType = _a2.shapeType, geometry2 = _a2.geometry, shapeFactory = _a2.shapeFactory;
      var stateOption = geometry2.stateOption;
      var defaultShapeType = shapeFactory.defaultShapeType;
      var stateTheme = shapeFactory.theme[shapeType] || shapeFactory.theme[defaultShapeType];
      this.statesStyle = deepMix({}, stateTheme, stateOption);
    }
    return this.statesStyle;
  };
  Element2.prototype.getStateStyle = function(stateName, shapeKey) {
    var statesStyle = this.getStatesStyle();
    var stateCfg = get(statesStyle, [stateName, "style"], {});
    var shapeStyle = stateCfg[shapeKey] || stateCfg;
    if (isFunction(shapeStyle)) {
      return shapeStyle(this);
    }
    return shapeStyle;
  };
  Element2.prototype.getAnimateCfg = function(animateType) {
    var _this = this;
    var animate = this.animate;
    if (animate) {
      var cfg_1 = animate[animateType];
      if (cfg_1) {
        return __assign$1(__assign$1({}, cfg_1), { callback: function() {
          var _a2;
          isFunction(cfg_1.callback) && cfg_1.callback();
          (_a2 = _this.geometry) === null || _a2 === void 0 ? void 0 : _a2.emit(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE);
        } });
      }
      return cfg_1;
    }
    return null;
  };
  Element2.prototype.drawShape = function(model, isUpdate) {
    var _a2;
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var _b = this, shapeFactory = _b.shapeFactory, container = _b.container, shapeType = _b.shapeType;
    this.shape = shapeFactory.drawShape(shapeType, model, container);
    if (this.shape) {
      this.setShapeInfo(this.shape, model);
      var name_1 = this.shape.cfg.name;
      if (!name_1) {
        this.shape.cfg.name = ["element", this.shapeFactory.geometryType];
      } else if (isString(name_1)) {
        this.shape.cfg.name = ["element", name_1];
      }
      var animateType = isUpdate ? "enter" : "appear";
      var animateCfg = this.getAnimateCfg(animateType);
      if (animateCfg) {
        (_a2 = this.geometry) === null || _a2 === void 0 ? void 0 : _a2.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
        doAnimate(this.shape, animateCfg, {
          coordinate: shapeFactory.coordinate,
          toAttrs: __assign$1({}, this.shape.attr())
        });
      }
    }
  };
  Element2.prototype.getOffscreenGroup = function() {
    if (!this.offscreenGroup) {
      var GroupCtor = this.container.getGroupBase();
      this.offscreenGroup = new GroupCtor({});
    }
    return this.offscreenGroup;
  };
  Element2.prototype.setShapeInfo = function(shape, data2) {
    var _this = this;
    shape.cfg.origin = data2;
    shape.cfg.element = this;
    if (shape.isGroup()) {
      var children = shape.get("children");
      children.forEach(function(child) {
        _this.setShapeInfo(child, data2);
      });
    }
  };
  Element2.prototype.syncShapeStyle = function(sourceShape, targetShape, states, animateCfg, index2) {
    var _this = this;
    var _a2;
    if (states === void 0) {
      states = [];
    }
    if (index2 === void 0) {
      index2 = 0;
    }
    if (!sourceShape || !targetShape) {
      return;
    }
    var clip = sourceShape.get("clipShape");
    var newClip = targetShape.get("clipShape");
    this.syncShapeStyle(clip, newClip, states, animateCfg);
    if (sourceShape.isGroup()) {
      var children = sourceShape.get("children");
      var newChildren = targetShape.get("children");
      for (var i = 0; i < children.length; i++) {
        this.syncShapeStyle(children[i], newChildren[i], states, animateCfg, index2 + i);
      }
    } else {
      if (!isEmpty(states) && !isEqual$2(states, ["reset"])) {
        var name_2 = sourceShape.get("name");
        if (isArray$1(name_2)) {
          name_2 = name_2[1];
        }
        each$1(states, function(state2) {
          if (targetShape.get("name") !== BACKGROUND_SHAPE) {
            var style = _this.getStateStyle(state2, name_2 || index2);
            targetShape.attr(style);
          }
        });
      }
      var newAttrs = getReplaceAttrs(sourceShape, targetShape);
      if (this.animate) {
        if (animateCfg) {
          (_a2 = this.geometry) === null || _a2 === void 0 ? void 0 : _a2.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
          doAnimate(sourceShape, animateCfg, {
            coordinate: this.shapeFactory.coordinate,
            toAttrs: newAttrs,
            shapeModel: this.model
          });
        } else if (!isEmpty(states)) {
          sourceShape.stopAnimate();
          sourceShape.animate(newAttrs, {
            duration: 300
          });
        } else {
          sourceShape.attr(newAttrs);
        }
      } else {
        sourceShape.attr(newAttrs);
      }
    }
  };
  Element2.prototype.getShapeType = function(model) {
    var shape = get(model, "shape");
    return isArray$1(shape) ? shape[0] : shape;
  };
  return Element2;
}(Base$2);
var GEOMETRY_LABELS_MAP = {};
var GEOMETRY_LABELS_LAYOUT_MAP = {};
function getGeometryLabel(type) {
  return GEOMETRY_LABELS_MAP[type.toLowerCase()];
}
function registerGeometryLabel(type, ctor) {
  GEOMETRY_LABELS_MAP[type.toLowerCase()] = ctor;
}
function getGeometryLabelLayout(type) {
  return GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()];
}
function registerGeometryLabelLayout(type, layoutFn) {
  GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()] = layoutFn;
}
var ShapeFactoryBase = {
  coordinate: null,
  defaultShapeType: null,
  theme: null,
  getShapePoints: function(shapeType, shapePoint) {
    var shape = this.getShape(shapeType);
    if (shape.getPoints) {
      return shape.getPoints(shapePoint);
    }
    return this.getDefaultPoints(shapePoint);
  },
  getShape: function(shapeType) {
    var shape = this[shapeType] || this[this.defaultShapeType];
    shape.coordinate = this.coordinate;
    return shape;
  },
  getDefaultPoints: function() {
    return [];
  },
  getDefaultStyle: function(geometryTheme) {
    return get(geometryTheme, [this.defaultShapeType, "default", "style"], {});
  },
  getMarker: function(shapeType, markerCfg) {
    var shape = this.getShape(shapeType);
    if (!shape.getMarker) {
      var defaultShapeType = this.defaultShapeType;
      shape = this.getShape(defaultShapeType);
    }
    var theme2 = this.theme;
    var shapeStyle = get(theme2, [shapeType, "default"], {});
    var markerStyle = shape.getMarker(markerCfg);
    return deepMix({}, shapeStyle, markerStyle);
  },
  drawShape: function(shapeType, cfg, container) {
    var shape = this.getShape(shapeType);
    return shape.draw(cfg, container);
  }
};
var ShapeBase$4 = {
  coordinate: null,
  parsePath: function(path2) {
    var coordinate2 = this.coordinate;
    var parsedPath = parsePathString$1(path2);
    if (coordinate2.isPolar) {
      parsedPath = convertPolarPath(coordinate2, parsedPath);
    } else {
      parsedPath = convertNormalPath(coordinate2, parsedPath);
    }
    return parsedPath;
  },
  parsePoint: function(point2) {
    var coordinate2 = this.coordinate;
    return coordinate2.convert(point2);
  },
  parsePoints: function(points) {
    var coordinate2 = this.coordinate;
    return points.map(function(point2) {
      return coordinate2.convert(point2);
    });
  },
  draw: function(cfg, container) {
  }
};
var ShapeFactoryMap = {};
function registerShapeFactory(factoryName, cfg) {
  var className = upperFirst(factoryName);
  var geomObj = __assign$1(__assign$1(__assign$1({}, ShapeFactoryBase), cfg), { geometryType: factoryName });
  ShapeFactoryMap[className] = geomObj;
  return geomObj;
}
function registerShape(factoryName, shapeType, cfg) {
  var className = upperFirst(factoryName);
  var factory = ShapeFactoryMap[className];
  var shapeObj = __assign$1(__assign$1({}, ShapeBase$4), cfg);
  factory[shapeType] = shapeObj;
  return shapeObj;
}
function getShapeFactory(factoryName) {
  var className = upperFirst(factoryName);
  return ShapeFactoryMap[className];
}
function group(data2, fields, appendConditions) {
  if (appendConditions === void 0) {
    appendConditions = {};
  }
  if (!fields) {
    return [data2];
  }
  var groups = groupToMap(data2, fields);
  var array = [];
  if (fields.length === 1 && appendConditions[fields[0]]) {
    var values2 = appendConditions[fields[0]];
    for (var _i = 0, values_1 = values2; _i < values_1.length; _i++) {
      var value2 = values_1[_i];
      var arr = groups["_" + value2];
      if (arr) {
        array.push(arr);
      }
    }
  } else {
    for (var k in groups) {
      if (groups.hasOwnProperty(k)) {
        var eachGroup = groups[k];
        array.push(eachGroup);
      }
    }
  }
  return array;
}
function isModelChange(currentModel, preModel) {
  return some(["color", "shape", "size", "x", "y", "isInCircle", "data", "style", "defaultStyle", "points", "mappingData"], function(key) {
    return !isEqual$2(currentModel[key], preModel[key]);
  });
}
function parseFields(field2) {
  if (isArray$1(field2)) {
    return field2;
  }
  return field2.split("*");
}
function diff(keyItem, keys2) {
  var added = [];
  var updated = [];
  var removed = [];
  var keyIncluded = new Map();
  for (var i = 0; i < keys2.length; i++) {
    var key = keys2[i];
    if (keyItem[key])
      updated.push(key);
    else
      added.push(key);
    keyIncluded.set(key, true);
  }
  Object.keys(keyItem).forEach(function(key2) {
    if (!keyIncluded.has(key2))
      removed.push(key2);
  });
  return {
    added,
    updated,
    removed
  };
}
function filterLabelsById(id, labelsMap) {
  var labels = [];
  each$1(labelsMap, function(label2, labelId) {
    var elementId = labelId.split(" ")[0];
    if (elementId === id) {
      labels.push(label2);
    }
  });
  return labels;
}
var Geometry = function(_super) {
  __extends$2(Geometry2, _super);
  function Geometry2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "base";
    _this.attributes = {};
    _this.elements = [];
    _this.elementsMap = {};
    _this.animateOption = true;
    _this.attributeOption = {};
    _this.lastElementsMap = {};
    _this.generatePoints = false;
    _this.beforeMappingData = null;
    _this.adjusts = {};
    _this.idFields = [];
    _this.hasSorted = false;
    _this.isCoordinateChanged = false;
    var container = cfg.container, labelsContainer = cfg.labelsContainer, coordinate2 = cfg.coordinate, data2 = cfg.data, _a2 = cfg.sortable, sortable = _a2 === void 0 ? false : _a2, _b = cfg.visible, visible = _b === void 0 ? true : _b, theme2 = cfg.theme, _c = cfg.scales, scales = _c === void 0 ? {} : _c, _d = cfg.scaleDefs, scaleDefs = _d === void 0 ? {} : _d, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, roseWidthRatio = cfg.roseWidthRatio, multiplePieWidthRatio = cfg.multiplePieWidthRatio, zIndexReversed = cfg.zIndexReversed;
    _this.container = container;
    _this.labelsContainer = labelsContainer;
    _this.coordinate = coordinate2;
    _this.data = data2;
    _this.sortable = sortable;
    _this.visible = visible;
    _this.userTheme = theme2;
    _this.scales = scales;
    _this.scaleDefs = scaleDefs;
    _this.intervalPadding = intervalPadding;
    _this.dodgePadding = dodgePadding;
    _this.maxColumnWidth = maxColumnWidth;
    _this.minColumnWidth = minColumnWidth;
    _this.columnWidthRatio = columnWidthRatio;
    _this.roseWidthRatio = roseWidthRatio;
    _this.multiplePieWidthRatio = multiplePieWidthRatio;
    _this.zIndexReversed = zIndexReversed;
    return _this;
  }
  Geometry2.prototype.position = function(cfg) {
    var positionCfg = cfg;
    if (!isPlainObject$1(cfg)) {
      positionCfg = {
        fields: parseFields(cfg)
      };
    }
    var fields = get(positionCfg, "fields");
    if (fields.length === 1) {
      fields.unshift("1");
      set(positionCfg, "fields", fields);
    }
    set(this.attributeOption, "position", positionCfg);
    return this;
  };
  Geometry2.prototype.color = function(field2, cfg) {
    this.createAttrOption("color", field2, cfg);
    return this;
  };
  Geometry2.prototype.shape = function(field2, cfg) {
    this.createAttrOption("shape", field2, cfg);
    return this;
  };
  Geometry2.prototype.size = function(field2, cfg) {
    this.createAttrOption("size", field2, cfg);
    return this;
  };
  Geometry2.prototype.adjust = function(adjustCfg2) {
    var adjusts = adjustCfg2;
    if (isString(adjustCfg2) || isPlainObject$1(adjustCfg2)) {
      adjusts = [adjustCfg2];
    }
    each$1(adjusts, function(adjust2, index2) {
      if (!isObject(adjust2)) {
        adjusts[index2] = { type: adjust2 };
      }
    });
    this.adjustOption = adjusts;
    return this;
  };
  Geometry2.prototype.style = function(field2, styleFunc) {
    if (isString(field2)) {
      var fields = parseFields(field2);
      this.styleOption = {
        fields,
        callback: styleFunc
      };
    } else {
      var _a2 = field2, fields = _a2.fields, callback = _a2.callback, cfg = _a2.cfg;
      if (fields || callback || cfg) {
        this.styleOption = field2;
      } else {
        this.styleOption = {
          cfg: field2
        };
      }
    }
    return this;
  };
  Geometry2.prototype.tooltip = function(field2, cfg) {
    if (isString(field2)) {
      var fields = parseFields(field2);
      this.tooltipOption = {
        fields,
        callback: cfg
      };
    } else {
      this.tooltipOption = field2;
    }
    return this;
  };
  Geometry2.prototype.animate = function(cfg) {
    this.animateOption = cfg;
    return this;
  };
  Geometry2.prototype.label = function(field2, secondParam, thirdParam) {
    if (isString(field2)) {
      var labelOption = {};
      var fields = parseFields(field2);
      labelOption.fields = fields;
      if (isFunction(secondParam)) {
        labelOption.callback = secondParam;
      } else if (isPlainObject$1(secondParam)) {
        labelOption.cfg = secondParam;
      }
      if (thirdParam) {
        labelOption.cfg = thirdParam;
      }
      this.labelOption = labelOption;
    } else {
      this.labelOption = field2;
    }
    return this;
  };
  Geometry2.prototype.state = function(cfg) {
    this.stateOption = cfg;
    return this;
  };
  Geometry2.prototype.customInfo = function(cfg) {
    this.customOption = cfg;
    return this;
  };
  Geometry2.prototype.init = function(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    this.setCfg(cfg);
    this.initAttributes();
    this.processData(this.data);
    this.adjustScale();
  };
  Geometry2.prototype.update = function(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    var data2 = cfg.data, isDataChanged = cfg.isDataChanged, isCoordinateChanged = cfg.isCoordinateChanged;
    var _a2 = this, attributeOption = _a2.attributeOption, lastAttributeOption = _a2.lastAttributeOption;
    if (!isEqual$2(attributeOption, lastAttributeOption)) {
      this.init(cfg);
    } else if (data2 && (isDataChanged || !isEqual$2(data2, this.data))) {
      this.setCfg(cfg);
      this.initAttributes();
      this.processData(data2);
    } else {
      this.setCfg(cfg);
    }
    this.adjustScale();
    this.isCoordinateChanged = isCoordinateChanged;
  };
  Geometry2.prototype.paint = function(isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    if (this.animateOption) {
      this.animateOption = deepMix({}, getDefaultAnimateCfg(this.type, this.coordinate), this.animateOption);
    }
    this.defaultSize = void 0;
    this.elementsMap = {};
    this.elements = [];
    var offscreenGroup = this.getOffscreenGroup();
    offscreenGroup.clear();
    var beforeMappingData = this.beforeMappingData;
    var dataArray = this.beforeMapping(beforeMappingData);
    this.dataArray = new Array(dataArray.length);
    for (var i = 0; i < dataArray.length; i++) {
      var data2 = dataArray[i];
      this.dataArray[i] = this.mapping(data2);
    }
    this.updateElements(this.dataArray, isUpdate);
    this.lastElementsMap = this.elementsMap;
    if (this.canDoGroupAnimation(isUpdate)) {
      var container = this.container;
      var type = this.type;
      var coordinate2 = this.coordinate;
      var animateCfg = get(this.animateOption, "appear");
      var yScale = this.getYScale();
      var yMinPoint = coordinate2.convert({
        x: 0,
        y: yScale.scale(this.getYMinValue())
      });
      doGroupAppearAnimate(container, animateCfg, type, coordinate2, yMinPoint);
    }
    if (this.labelOption) {
      this.renderLabels(flatten(this.dataArray), isUpdate);
    }
    this.lastAttributeOption = __assign$1({}, this.attributeOption);
    if (this.visible === false) {
      this.changeVisible(false);
    }
  };
  Geometry2.prototype.clear = function() {
    var _a2 = this, container = _a2.container, geometryLabel = _a2.geometryLabel, offscreenGroup = _a2.offscreenGroup;
    if (container) {
      container.clear();
    }
    if (geometryLabel) {
      geometryLabel.clear();
    }
    if (offscreenGroup) {
      offscreenGroup.clear();
    }
    this.scaleDefs = void 0;
    this.attributes = {};
    this.scales = {};
    this.elementsMap = {};
    this.lastElementsMap = {};
    this.elements = [];
    this.adjusts = {};
    this.dataArray = null;
    this.beforeMappingData = null;
    this.lastAttributeOption = void 0;
    this.defaultSize = void 0;
    this.idFields = [];
    this.groupScales = void 0;
    this.hasSorted = false;
    this.isCoordinateChanged = false;
  };
  Geometry2.prototype.destroy = function() {
    this.clear();
    var container = this.container;
    container.remove(true);
    if (this.offscreenGroup) {
      this.offscreenGroup.remove(true);
      this.offscreenGroup = null;
    }
    if (this.geometryLabel) {
      this.geometryLabel.destroy();
      this.geometryLabel = null;
    }
    this.theme = void 0;
    this.shapeFactory = void 0;
    _super.prototype.destroy.call(this);
  };
  Geometry2.prototype.getGroupScales = function() {
    return this.groupScales;
  };
  Geometry2.prototype.getAttribute = function(name) {
    return this.attributes[name];
  };
  Geometry2.prototype.getXScale = function() {
    return this.getAttribute("position").scales[0];
  };
  Geometry2.prototype.getYScale = function() {
    return this.getAttribute("position").scales[1];
  };
  Geometry2.prototype.getGroupAttributes = function() {
    var rst = [];
    each$1(this.attributes, function(attr) {
      if (GROUP_ATTRS.includes(attr.type)) {
        rst.push(attr);
      }
    });
    return rst;
  };
  Geometry2.prototype.getDefaultValue = function(attrName) {
    var value2;
    var attr = this.getAttribute(attrName);
    if (attr && isEmpty(attr.scales)) {
      value2 = attr.values[0];
    }
    return value2;
  };
  Geometry2.prototype.getAttributeValues = function(attr, obj) {
    var params = [];
    var scales = attr.scales;
    for (var index2 = 0, length_1 = scales.length; index2 < length_1; index2++) {
      var scale2 = scales[index2];
      var field2 = scale2.field;
      if (scale2.isIdentity) {
        params.push(scale2.values);
      } else {
        params.push(obj[field2]);
      }
    }
    return attr.mapping.apply(attr, params);
  };
  Geometry2.prototype.getAdjust = function(adjustType) {
    return this.adjusts[adjustType];
  };
  Geometry2.prototype.getCoordinate = function() {
    return this.coordinate;
  };
  Geometry2.prototype.getData = function() {
    return this.data;
  };
  Geometry2.prototype.getShapeMarker = function(shapeName, cfg) {
    var shapeFactory = this.getShapeFactory();
    return shapeFactory.getMarker(shapeName, cfg);
  };
  Geometry2.prototype.getElementsBy = function(condition) {
    return this.elements.filter(function(element) {
      return condition(element);
    });
  };
  Geometry2.prototype.getElements = function() {
    return this.elements;
  };
  Geometry2.prototype.getElementId = function(data2) {
    data2 = isArray$1(data2) ? data2[0] : data2;
    var originData = data2[FIELD_ORIGIN];
    if (this.idFields.length) {
      var elementId = originData[this.idFields[0]];
      for (var index2 = 1; index2 < this.idFields.length; index2++) {
        elementId += "-" + originData[this.idFields[index2]];
      }
      return elementId;
    }
    var type = this.type;
    var xScale = this.getXScale();
    var yScale = this.getYScale();
    var xField = xScale.field || "x";
    var yField = yScale.field || "y";
    var yVal = originData[yField];
    var xVal;
    if (xScale.type === "identity") {
      xVal = xScale.values[0];
    } else {
      xVal = originData[xField];
    }
    var id;
    if (type === "interval" || type === "schema") {
      id = "" + xVal;
    } else if (type === "line" || type === "area" || type === "path") {
      id = type;
    } else {
      id = xVal + "-" + yVal;
    }
    var groupScales = this.groupScales;
    if (isEmpty(groupScales)) {
      groupScales = get(this.getAttribute("color"), "scales", []);
    }
    for (var index2 = 0, length_2 = groupScales.length; index2 < length_2; index2++) {
      var groupScale = groupScales[index2];
      var field2 = groupScale.field;
      id = id + "-" + originData[field2];
    }
    var dodgeAdjust = this.getAdjust("dodge");
    if (dodgeAdjust) {
      var dodgeBy = dodgeAdjust.dodgeBy;
      if (dodgeBy) {
        id = id + "-" + originData[dodgeBy];
      }
    }
    if (this.getAdjust("jitter")) {
      id = id + "-" + data2.x + "-" + data2.y;
    }
    return id;
  };
  Geometry2.prototype.getScaleFields = function() {
    var fields = [];
    var tmpMap = new Map();
    var _a2 = this, attributeOption = _a2.attributeOption, labelOption = _a2.labelOption, tooltipOption = _a2.tooltipOption;
    for (var attributeType in attributeOption) {
      if (attributeOption.hasOwnProperty(attributeType)) {
        var eachOpt = attributeOption[attributeType];
        if (eachOpt.fields) {
          uniq$1(eachOpt.fields, fields, tmpMap);
        } else if (eachOpt.values) {
          uniq$1(eachOpt.values, fields, tmpMap);
        }
      }
    }
    if (labelOption && labelOption.fields) {
      uniq$1(labelOption.fields, fields, tmpMap);
    }
    if (isObject(tooltipOption) && tooltipOption.fields) {
      uniq$1(tooltipOption.fields, fields, tmpMap);
    }
    return fields;
  };
  Geometry2.prototype.changeVisible = function(visible) {
    _super.prototype.changeVisible.call(this, visible);
    var elements = this.elements;
    for (var index2 = 0, length_3 = elements.length; index2 < length_3; index2++) {
      var element = elements[index2];
      element.changeVisible(visible);
    }
    if (visible) {
      if (this.container) {
        this.container.show();
      }
      if (this.labelsContainer) {
        this.labelsContainer.show();
      }
    } else {
      if (this.container) {
        this.container.hide();
      }
      if (this.labelsContainer) {
        this.labelsContainer.hide();
      }
    }
  };
  Geometry2.prototype.getFields = function() {
    var uniqMap = new Map();
    var fields = [];
    Object.values(this.attributeOption).forEach(function(cfg) {
      var fs = (cfg === null || cfg === void 0 ? void 0 : cfg.fields) || [];
      fs.forEach(function(f) {
        if (!uniqMap.has(f)) {
          fields.push(f);
        }
        uniqMap.set(f, true);
      });
    }, []);
    return fields;
  };
  Geometry2.prototype.getGroupFields = function() {
    var groupFields = [];
    var tmpMap = new Map();
    for (var index2 = 0, length_4 = GROUP_ATTRS.length; index2 < length_4; index2++) {
      var attributeName = GROUP_ATTRS[index2];
      var cfg = this.attributeOption[attributeName];
      if (cfg && cfg.fields) {
        uniq$1(cfg.fields, groupFields, tmpMap);
      }
    }
    return groupFields;
  };
  Geometry2.prototype.getXYFields = function() {
    var _a2 = this.attributeOption.position.fields, x = _a2[0], y = _a2[1];
    return [x, y];
  };
  Geometry2.prototype.getXField = function() {
    return get(this.getXYFields(), [0]);
  };
  Geometry2.prototype.getYField = function() {
    return get(this.getXYFields(), [1]);
  };
  Geometry2.prototype.getShapes = function() {
    return this.elements.map(function(element) {
      return element.shape;
    });
  };
  Geometry2.prototype.getOffscreenGroup = function() {
    if (!this.offscreenGroup) {
      var GroupCtor = this.container.getGroupBase();
      this.offscreenGroup = new GroupCtor({});
    }
    return this.offscreenGroup;
  };
  Geometry2.prototype.sort = function(mappingArray) {
    if (!this.hasSorted) {
      var xScale_1 = this.getXScale();
      var xField_1 = xScale_1.field;
      for (var index2 = 0; index2 < mappingArray.length; index2++) {
        var itemArr = mappingArray[index2];
        itemArr.sort(function(obj1, obj2) {
          return xScale_1.translate(obj1[FIELD_ORIGIN][xField_1]) - xScale_1.translate(obj2[FIELD_ORIGIN][xField_1]);
        });
      }
    }
    this.hasSorted = true;
  };
  Geometry2.prototype.adjustScale = function() {
    var yScale = this.getYScale();
    if (yScale && this.getAdjust("stack")) {
      this.updateStackRange(yScale, this.beforeMappingData);
    }
  };
  Geometry2.prototype.getShapeFactory = function() {
    var shapeType = this.shapeType;
    if (!getShapeFactory(shapeType)) {
      return;
    }
    if (!this.shapeFactory) {
      this.shapeFactory = clone(getShapeFactory(shapeType));
    }
    this.shapeFactory.coordinate = this.coordinate;
    this.shapeFactory.theme = this.theme.geometries[shapeType] || {};
    return this.shapeFactory;
  };
  Geometry2.prototype.createShapePointsCfg = function(obj) {
    var xScale = this.getXScale();
    var yScale = this.getYScale();
    var x = this.normalizeValues(obj[xScale.field], xScale);
    var y;
    if (yScale) {
      y = this.normalizeValues(obj[yScale.field], yScale);
    } else {
      y = obj.y ? obj.y : 0.1;
    }
    return {
      x,
      y,
      y0: yScale ? yScale.scale(this.getYMinValue()) : void 0
    };
  };
  Geometry2.prototype.createElement = function(mappingDatum, index2, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var container = this.container;
    var shapeCfg = this.getDrawCfg(mappingDatum);
    var shapeFactory = this.getShapeFactory();
    var element = new Element$1({
      shapeFactory,
      container,
      offscreenGroup: this.getOffscreenGroup(),
      elementIndex: index2
    });
    element.animate = this.animateOption;
    element.geometry = this;
    element.draw(shapeCfg, isUpdate);
    return element;
  };
  Geometry2.prototype.getDrawCfg = function(mappingDatum) {
    var originData = mappingDatum[FIELD_ORIGIN];
    var cfg = {
      mappingData: mappingDatum,
      data: originData,
      x: mappingDatum.x,
      y: mappingDatum.y,
      color: mappingDatum.color,
      size: mappingDatum.size,
      isInCircle: this.coordinate.isPolar,
      customInfo: this.customOption
    };
    var shapeName = mappingDatum.shape;
    if (!shapeName && this.getShapeFactory()) {
      shapeName = this.getShapeFactory().defaultShapeType;
    }
    cfg.shape = shapeName;
    var theme2 = this.theme.geometries[this.shapeType];
    cfg.defaultStyle = get(theme2, [shapeName, "default"], {}).style;
    if (!cfg.defaultStyle && this.getShapeFactory()) {
      cfg.defaultStyle = this.getShapeFactory().getDefaultStyle(theme2);
    }
    var styleOption = this.styleOption;
    if (styleOption) {
      cfg.style = this.getStyleCfg(styleOption, originData);
    }
    if (this.generatePoints) {
      cfg.points = mappingDatum.points;
      cfg.nextPoints = mappingDatum.nextPoints;
    }
    return cfg;
  };
  Geometry2.prototype.updateElements = function(mappingDataArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var keyDatum = new Map();
    var keys2 = [];
    var keyIndex = new Map();
    var index2 = 0;
    for (var i = 0; i < mappingDataArray.length; i++) {
      var mappingData = mappingDataArray[i];
      for (var j = 0; j < mappingData.length; j++) {
        var mappingDatum = mappingData[j];
        var key = this.getElementId(mappingDatum);
        var finalKey = keyDatum.has(key) ? key + "-" + i + "-" + j : key;
        keys2.push(finalKey);
        keyDatum.set(finalKey, mappingDatum);
        keyIndex.set(finalKey, index2);
        index2++;
      }
    }
    this.elements = new Array(index2);
    var _a2 = diff(this.lastElementsMap, keys2), added = _a2.added, updated = _a2.updated, removed = _a2.removed;
    for (var _i = 0, added_1 = added; _i < added_1.length; _i++) {
      var key = added_1[_i];
      var mappingDatum = keyDatum.get(key);
      var i = keyIndex.get(key);
      var element = this.createElement(mappingDatum, i, isUpdate);
      this.elements[i] = element;
      this.elementsMap[key] = element;
      if (element.shape) {
        element.shape.setZIndex(this.zIndexReversed ? this.elements.length - i : i);
      }
    }
    for (var _b = 0, updated_1 = updated; _b < updated_1.length; _b++) {
      var key = updated_1[_b];
      var element = this.lastElementsMap[key];
      var mappingDatum = keyDatum.get(key);
      var currentShapeCfg = this.getDrawCfg(mappingDatum);
      var preShapeCfg = element.getModel();
      var i = keyIndex.get(key);
      if (this.isCoordinateChanged || isModelChange(currentShapeCfg, preShapeCfg)) {
        element.animate = this.animateOption;
        element.update(currentShapeCfg);
      }
      this.elements[i] = element;
      this.elementsMap[key] = element;
      if (element.shape) {
        element.shape.setZIndex(this.zIndexReversed ? this.elements.length - i : i);
      }
    }
    for (var _c = 0, removed_1 = removed; _c < removed_1.length; _c++) {
      var key = removed_1[_c];
      var element = this.lastElementsMap[key];
      element.animate = this.animateOption;
      element.destroy();
    }
  };
  Geometry2.prototype.getLabelType = function() {
    var _a2 = this, labelOption = _a2.labelOption, coordinate2 = _a2.coordinate, type = _a2.type;
    var coordinateType = coordinate2.type, isTransposed = coordinate2.isTransposed;
    var labelType = get(labelOption, ["cfg", "type"]);
    if (!labelType) {
      if (coordinateType === "polar") {
        labelType = isTransposed ? "pie" : "polar";
      } else if (coordinateType === "theta") {
        labelType = "pie";
      } else if (type === "interval" || type === "polygon") {
        labelType = "interval";
      } else {
        labelType = "base";
      }
    }
    return labelType;
  };
  Geometry2.prototype.getYMinValue = function() {
    var yScale = this.getYScale();
    var min2 = yScale.min, max2 = yScale.max;
    var value2;
    if (min2 >= 0) {
      value2 = min2;
    } else if (max2 <= 0) {
      value2 = max2;
    } else {
      value2 = 0;
    }
    return value2;
  };
  Geometry2.prototype.createAttrOption = function(attrName, field2, cfg) {
    if (isNil(field2) || isObject(field2)) {
      if (isObject(field2) && isEqual$2(Object.keys(field2), ["values"])) {
        set(this.attributeOption, attrName, {
          fields: field2.values
        });
      } else {
        set(this.attributeOption, attrName, field2);
      }
    } else {
      var attrCfg = {};
      if (isNumber$1(field2)) {
        attrCfg.values = [field2];
      } else {
        attrCfg.fields = parseFields(field2);
      }
      if (cfg) {
        if (isFunction(cfg)) {
          attrCfg.callback = cfg;
        } else {
          attrCfg.values = cfg;
        }
      }
      set(this.attributeOption, attrName, attrCfg);
    }
  };
  Geometry2.prototype.initAttributes = function() {
    var _this = this;
    var _a2 = this, attributes = _a2.attributes, attributeOption = _a2.attributeOption, theme2 = _a2.theme, shapeType = _a2.shapeType;
    this.groupScales = [];
    var tmpMap = {};
    var _loop_1 = function(attrType2) {
      if (attributeOption.hasOwnProperty(attrType2)) {
        var option = attributeOption[attrType2];
        if (!option) {
          return { value: void 0 };
        }
        var attrCfg = __assign$1({}, option);
        var callback = attrCfg.callback, values2 = attrCfg.values, _b = attrCfg.fields, fields = _b === void 0 ? [] : _b;
        var scales = fields.map(function(field2) {
          var scale2 = _this.scales[field2];
          if (scale2.isCategory && !tmpMap[field2] && GROUP_ATTRS.includes(attrType2)) {
            _this.groupScales.push(scale2);
            tmpMap[field2] = true;
          }
          return scale2;
        });
        attrCfg.scales = scales;
        if (attrType2 !== "position" && scales.length === 1 && scales[0].type === "identity") {
          attrCfg.values = scales[0].values;
        } else if (!callback && !values2) {
          if (attrType2 === "size") {
            attrCfg.values = theme2.sizes;
          } else if (attrType2 === "shape") {
            attrCfg.values = theme2.shapes[shapeType] || [];
          } else if (attrType2 === "color") {
            if (scales.length) {
              attrCfg.values = scales[0].values.length <= 10 ? theme2.colors10 : theme2.colors20;
            } else {
              attrCfg.values = theme2.colors10;
            }
          }
        }
        var AttributeCtor = getAttribute(attrType2);
        attributes[attrType2] = new AttributeCtor(attrCfg);
      }
    };
    for (var attrType in attributeOption) {
      var state_1 = _loop_1(attrType);
      if (typeof state_1 === "object")
        return state_1.value;
    }
  };
  Geometry2.prototype.processData = function(data2) {
    this.hasSorted = false;
    var scales = this.getAttribute("position").scales;
    var categoryScales = scales.filter(function(scale3) {
      return scale3.isCategory;
    });
    var groupedArray = this.groupData(data2);
    var beforeAdjust = [];
    for (var i = 0, len = groupedArray.length; i < len; i++) {
      var subData = groupedArray[i];
      var arr = [];
      for (var j = 0, subLen = subData.length; j < subLen; j++) {
        var originData = subData[j];
        var item = {};
        for (var k in originData) {
          item[k] = originData[k];
        }
        item[FIELD_ORIGIN] = originData;
        for (var _i = 0, categoryScales_1 = categoryScales; _i < categoryScales_1.length; _i++) {
          var scale2 = categoryScales_1[_i];
          var field2 = scale2.field;
          item[field2] = scale2.translate(item[field2]);
        }
        arr.push(item);
      }
      beforeAdjust.push(arr);
    }
    var dataArray = this.adjustData(beforeAdjust);
    this.beforeMappingData = dataArray;
    return dataArray;
  };
  Geometry2.prototype.adjustData = function(dataArray) {
    var adjustOption = this.adjustOption;
    var _a2 = this, intervalPadding = _a2.intervalPadding, dodgePadding = _a2.dodgePadding, theme2 = _a2.theme;
    var maxColumnWidth = this.maxColumnWidth || theme2.maxColumnWidth;
    var minColumnWidth = this.minColumnWidth || theme2.minColumnWidth;
    var columnWidthRatio = this.columnWidthRatio || theme2.columnWidthRatio;
    var result = dataArray;
    if (adjustOption) {
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var xField = xScale.field;
      var yField = yScale ? yScale.field : null;
      var xDimensionLength = getXDimensionLength(this.coordinate);
      var groupNum = xScale.values.length;
      var sizeAttr = this.getAttribute("size");
      var defaultSize = void 0;
      if (sizeAttr) {
        defaultSize = sizeAttr.values[0];
      }
      for (var i = 0, len = adjustOption.length; i < len; i++) {
        var adjust2 = adjustOption[i];
        var adjustCfg2 = __assign$1({ xField, yField, intervalPadding, dodgePadding, xDimensionLength, groupNum, defaultSize, maxColumnWidth, minColumnWidth, columnWidthRatio }, adjust2);
        var type = adjust2.type;
        if (type === "dodge") {
          var adjustNames = [];
          if (xScale.isCategory || xScale.type === "identity") {
            adjustNames.push("x");
          } else if (!yScale) {
            adjustNames.push("y");
          } else {
            throw new Error("dodge is not support linear attribute, please use category attribute!");
          }
          adjustCfg2.adjustNames = adjustNames;
          adjustCfg2.dodgeRatio = columnWidthRatio;
        } else if (type === "stack") {
          var coordinate2 = this.coordinate;
          if (!yScale) {
            adjustCfg2.height = coordinate2.getHeight();
            var size2 = this.getDefaultValue("size") || 3;
            adjustCfg2.size = size2;
          }
          if (!coordinate2.isTransposed && isNil(adjustCfg2.reverseOrder)) {
            adjustCfg2.reverseOrder = true;
          }
        }
        var adjustCtor = getAdjust(type);
        var adjustInstance = new adjustCtor(adjustCfg2);
        result = adjustInstance.process(result);
        this.adjusts[type] = adjustInstance;
      }
    }
    return result;
  };
  Geometry2.prototype.groupData = function(data2) {
    var groupScales = this.getGroupScales();
    var scaleDefs = this.scaleDefs;
    var appendConditions = {};
    var groupFields = [];
    for (var index2 = 0; index2 < groupScales.length; index2++) {
      var scale2 = groupScales[index2];
      var field2 = scale2.field;
      groupFields.push(field2);
      if (get(scaleDefs, [field2, "values"])) {
        appendConditions[field2] = scaleDefs[field2].values;
      }
    }
    return group(data2, groupFields, appendConditions);
  };
  Geometry2.prototype.updateStackRange = function(scale2, dataArray) {
    var mergeArray = flatten(dataArray);
    var field2 = scale2.field;
    var min2 = scale2.min;
    var max2 = scale2.max;
    for (var index2 = 0; index2 < mergeArray.length; index2++) {
      var obj = mergeArray[index2];
      var tmpMin = Math.min.apply(null, obj[field2]);
      var tmpMax = Math.max.apply(null, obj[field2]);
      if (tmpMin < min2) {
        min2 = tmpMin;
      }
      if (tmpMax > max2) {
        max2 = tmpMax;
      }
    }
    var scaleDefs = this.scaleDefs;
    var cfg = {};
    if (min2 < scale2.min && !get(scaleDefs, [field2, "min"])) {
      cfg.min = min2;
    }
    if (max2 > scale2.max && !get(scaleDefs, [field2, "max"])) {
      cfg.max = max2;
    }
    scale2.change(cfg);
  };
  Geometry2.prototype.beforeMapping = function(beforeMappingData) {
    var source = beforeMappingData;
    if (this.sortable) {
      this.sort(source);
    }
    if (this.generatePoints) {
      for (var index2 = 0, length_5 = source.length; index2 < length_5; index2++) {
        var currentData = source[index2];
        this.generateShapePoints(currentData);
        var nextData = source[index2 + 1];
        if (nextData) {
          this.generateShapePoints(nextData);
          currentData[0].nextPoints = nextData[0].points;
        }
      }
    }
    return source;
  };
  Geometry2.prototype.generateShapePoints = function(data2) {
    var shapeFactory = this.getShapeFactory();
    var shapeAttr = this.getAttribute("shape");
    for (var index2 = 0; index2 < data2.length; index2++) {
      var obj = data2[index2];
      var cfg = this.createShapePointsCfg(obj);
      var shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;
      var points = shapeFactory.getShapePoints(shape, cfg);
      obj.points = points;
    }
  };
  Geometry2.prototype.normalizeValues = function(values2, scale2) {
    var rst = [];
    if (isArray$1(values2)) {
      for (var index2 = 0; index2 < values2.length; index2++) {
        var value2 = values2[index2];
        rst.push(scale2.scale(value2));
      }
    } else {
      rst = scale2.scale(values2);
    }
    return rst;
  };
  Geometry2.prototype.mapping = function(data2) {
    var attributes = this.attributes;
    var mappingData = [];
    for (var index2 = 0; index2 < data2.length; index2++) {
      var record = data2[index2];
      var newRecord = {
        _origin: record[FIELD_ORIGIN],
        points: record.points,
        nextPoints: record.nextPoints
      };
      for (var k in attributes) {
        if (attributes.hasOwnProperty(k)) {
          var attr = attributes[k];
          var names = attr.names;
          var values2 = this.getAttributeValues(attr, record);
          if (names.length > 1) {
            for (var j = 0; j < values2.length; j += 1) {
              var val = values2[j];
              var name_1 = names[j];
              newRecord[name_1] = isArray$1(val) && val.length === 1 ? val[0] : val;
            }
          } else {
            newRecord[names[0]] = values2.length === 1 ? values2[0] : values2;
          }
        }
      }
      this.convertPoint(newRecord);
      mappingData.push(newRecord);
    }
    return mappingData;
  };
  Geometry2.prototype.convertPoint = function(mappingRecord) {
    var x = mappingRecord.x, y = mappingRecord.y;
    var rstX;
    var rstY;
    var obj;
    var coordinate2 = this.coordinate;
    if (isArray$1(x) && isArray$1(y)) {
      rstX = [];
      rstY = [];
      for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {
        obj = coordinate2.convert({
          x: x[i],
          y: y[j]
        });
        rstX.push(obj.x);
        rstY.push(obj.y);
      }
    } else if (isArray$1(y)) {
      rstY = [];
      for (var index2 = 0; index2 < y.length; index2++) {
        var yVal = y[index2];
        obj = coordinate2.convert({
          x,
          y: yVal
        });
        if (rstX && rstX !== obj.x) {
          if (!isArray$1(rstX)) {
            rstX = [rstX];
          }
          rstX.push(obj.x);
        } else {
          rstX = obj.x;
        }
        rstY.push(obj.y);
      }
    } else if (isArray$1(x)) {
      rstX = [];
      for (var index2 = 0; index2 < x.length; index2++) {
        var xVal = x[index2];
        obj = coordinate2.convert({
          x: xVal,
          y
        });
        if (rstY && rstY !== obj.y) {
          if (!isArray$1(rstY)) {
            rstY = [rstY];
          }
          rstY.push(obj.y);
        } else {
          rstY = obj.y;
        }
        rstX.push(obj.x);
      }
    } else {
      var point2 = coordinate2.convert({
        x,
        y
      });
      rstX = point2.x;
      rstY = point2.y;
    }
    mappingRecord.x = rstX;
    mappingRecord.y = rstY;
  };
  Geometry2.prototype.getStyleCfg = function(styleOption, originData) {
    var _a2 = styleOption.fields, fields = _a2 === void 0 ? [] : _a2, callback = styleOption.callback, cfg = styleOption.cfg;
    if (cfg) {
      return cfg;
    }
    var params = fields.map(function(field2) {
      return originData[field2];
    });
    return callback.apply(void 0, params);
  };
  Geometry2.prototype.setCfg = function(cfg) {
    var _this = this;
    var coordinate2 = cfg.coordinate, data2 = cfg.data, theme2 = cfg.theme, scaleDefs = cfg.scaleDefs;
    if (coordinate2) {
      this.coordinate = coordinate2;
    }
    if (data2) {
      this.data = data2;
    }
    if (scaleDefs) {
      this.scaleDefs = scaleDefs;
      this.idFields = [];
      each$1(scaleDefs, function(scaleDef, field2) {
        if (scaleDef && scaleDef.key) {
          _this.idFields.push(field2);
        }
      });
    }
    if (theme2) {
      this.theme = this.userTheme ? deepMix({}, theme2, this.userTheme) : theme2;
    }
  };
  Geometry2.prototype.renderLabels = function(mappingArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var geometryLabel = this.geometryLabel;
    if (!geometryLabel) {
      var labelType = this.getLabelType();
      var GeometryLabelsCtor = getGeometryLabel(labelType);
      geometryLabel = new GeometryLabelsCtor(this);
      this.geometryLabel = geometryLabel;
    }
    geometryLabel.render(mappingArray, isUpdate);
    var labelsMap = geometryLabel.labelsRenderer.shapesMap;
    each$1(this.elementsMap, function(element, id) {
      var labels = filterLabelsById(id, labelsMap);
      if (labels.length) {
        element.labelShape = labels;
        for (var i = 0; i < labels.length; i++) {
          var label2 = labels[i];
          var labelChildren = label2.getChildren();
          for (var j = 0; j < labelChildren.length; j++) {
            var child = labelChildren[j];
            child.cfg.name = ["element", "label"];
            child.cfg.element = element;
          }
        }
      }
    });
  };
  Geometry2.prototype.canDoGroupAnimation = function(isUpdate) {
    return !isUpdate && this.animateOption && (get(this.animateOption, "appear") === void 0 || get(this.animateOption, "appear") && get(this.animateOption, ["appear", "animation"]) === void 0);
  };
  return Geometry2;
}(Base$2);
var transform$4 = transform$7;
function translate(element, x, y) {
  var matrix = transform$4(element.getMatrix(), [["t", x, y]]);
  element.setMatrix(matrix);
}
function getRotateMatrix(element, rotateRadian) {
  var _a2 = element.attr(), x = _a2.x, y = _a2.y;
  var matrix = transform$4(element.getMatrix(), [
    ["t", -x, -y],
    ["r", rotateRadian],
    ["t", x, y]
  ]);
  return matrix;
}
function rotate(element, rotateRadian) {
  var matrix = getRotateMatrix(element, rotateRadian);
  element.setMatrix(matrix);
}
function zoom(element, ratio) {
  var bbox = element.getBBox();
  var x = (bbox.minX + bbox.maxX) / 2;
  var y = (bbox.minY + bbox.maxY) / 2;
  element.applyToMatrix([x, y, 1]);
  var matrix = transform$4(element.getMatrix(), [
    ["t", -x, -y],
    ["s", ratio, ratio],
    ["t", x, y]
  ]);
  element.setMatrix(matrix);
}
function findLabelTextShape(label2) {
  return label2.find(function(el) {
    return el.get("type") === "text";
  });
}
function getlLabelBackgroundInfo(labelGroup, labelItem, padding2) {
  if (padding2 === void 0) {
    padding2 = [0, 0, 0, 0];
  }
  var content = labelGroup.getChildren()[0];
  if (content) {
    var labelShape = content.clone();
    if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) {
      rotate(labelShape, -labelItem.rotate);
    }
    var _a2 = labelShape.getCanvasBBox(), x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
    labelShape.destroy();
    var boxPadding = padding2;
    if (isNil(boxPadding)) {
      boxPadding = [2, 2, 2, 2];
    } else if (isNumber$1(boxPadding)) {
      boxPadding = new Array(4).fill(boxPadding);
    }
    return {
      x: x - boxPadding[3],
      y: y - boxPadding[0],
      width: width + boxPadding[1] + boxPadding[3],
      height: height + boxPadding[0] + boxPadding[2],
      rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0
    };
  }
}
function getOverlapArea$2(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}
function checkShapeOverlap$2(cur, dones) {
  var box2 = cur.getBBox();
  return some(dones, function(done) {
    var target = done.getBBox();
    return getOverlapArea$2(box2, target, 2) > 0;
  });
}
function updateLabel(fromShape, toShape, cfg) {
  var data2 = cfg.data, origin = cfg.origin, animateCfg = cfg.animateCfg, coordinate2 = cfg.coordinate;
  var updateAnimateCfg = get(animateCfg, "update");
  fromShape.set("data", data2);
  fromShape.set("origin", origin);
  fromShape.set("animateCfg", animateCfg);
  fromShape.set("coordinate", coordinate2);
  fromShape.set("visible", toShape.get("visible"));
  fromShape.getChildren().forEach(function(fromChild, idx) {
    var toChild = toShape.getChildByIndex(idx);
    if (!toChild) {
      fromShape.removeChild(fromChild);
      fromChild.remove(true);
    } else {
      fromChild.set("data", data2);
      fromChild.set("origin", origin);
      fromChild.set("animateCfg", animateCfg);
      fromChild.set("coordinate", coordinate2);
      var newAttrs = getReplaceAttrs(fromChild, toChild);
      if (updateAnimateCfg) {
        doAnimate(fromChild, updateAnimateCfg, {
          toAttrs: newAttrs,
          coordinate: coordinate2
        });
      } else {
        fromChild.attr(newAttrs);
      }
      if (toChild.isGroup()) {
        updateLabel(fromChild, toChild, cfg);
      }
    }
  });
  each$1(toShape.getChildren(), function(child, idx) {
    if (idx >= fromShape.getCount()) {
      if (!child.destroyed) {
        fromShape.add(child);
      }
    }
  });
}
var Labels = function() {
  function Labels2(cfg) {
    this.shapesMap = {};
    this.lastShapesMap = {};
    var layout = cfg.layout, container = cfg.container;
    this.layout = layout;
    this.container = container;
  }
  Labels2.prototype.render = function(items, shapes, isUpdate) {
    var _this = this;
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    this.shapesMap = {};
    var container = this.container;
    var offscreenGroup = this.createOffscreenGroup();
    if (items.length) {
      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
        var item = items_1[_i];
        if (item) {
          this.renderLabel(item, offscreenGroup);
        }
      }
      this.doLayout(items, shapes);
      this.renderLabelLine(items);
      this.renderLabelBackground(items);
      this.adjustLabel(items);
    }
    var lastShapesMap = this.lastShapesMap;
    var shapesMap = this.shapesMap;
    each$1(shapesMap, function(shape, id) {
      if (shape.destroyed) {
        delete shapesMap[id];
      } else {
        if (lastShapesMap[id]) {
          var data2 = shape.get("data");
          var origin_1 = shape.get("origin");
          var coordinate2 = shape.get("coordinate");
          var currentAnimateCfg = shape.get("animateCfg");
          var currentShape = lastShapesMap[id];
          updateLabel(currentShape, shapesMap[id], {
            data: data2,
            origin: origin_1,
            animateCfg: currentAnimateCfg,
            coordinate: coordinate2
          });
          _this.shapesMap[id] = currentShape;
        } else {
          container.add(shape);
          var animateCfg = get(shape.get("animateCfg"), isUpdate ? "enter" : "appear");
          if (animateCfg) {
            doAnimate(shape, animateCfg, {
              toAttrs: __assign$1({}, shape.attr()),
              coordinate: shape.get("coordinate")
            });
          }
        }
        delete lastShapesMap[id];
      }
    });
    each$1(lastShapesMap, function(deleteShape) {
      var animateCfg = get(deleteShape.get("animateCfg"), "leave");
      if (animateCfg) {
        doAnimate(deleteShape, animateCfg, {
          toAttrs: null,
          coordinate: deleteShape.get("coordinate")
        });
      } else {
        deleteShape.remove(true);
      }
    });
    this.lastShapesMap = shapesMap;
    offscreenGroup.destroy();
  };
  Labels2.prototype.clear = function() {
    this.container.clear();
    this.shapesMap = {};
    this.lastShapesMap = {};
  };
  Labels2.prototype.destroy = function() {
    this.container.destroy();
    this.shapesMap = null;
    this.lastShapesMap = null;
  };
  Labels2.prototype.renderLabel = function(cfg, container) {
    var id = cfg.id, elementId = cfg.elementId, data2 = cfg.data, mappingData = cfg.mappingData, coordinate2 = cfg.coordinate, animate = cfg.animate, content = cfg.content;
    var shapeAppendCfg = {
      id,
      elementId,
      data: data2,
      origin: __assign$1(__assign$1({}, mappingData), { data: mappingData[FIELD_ORIGIN] }),
      coordinate: coordinate2
    };
    var labelGroup = container.addGroup(__assign$1({
      name: "label",
      animateCfg: this.animate === false || animate === null || animate === false ? false : deepMix({}, this.animate, animate)
    }, shapeAppendCfg));
    var labelShape;
    if (content.isGroup && content.isGroup() || content.isShape && content.isShape()) {
      var _a2 = content.getCanvasBBox(), width = _a2.width, height = _a2.height;
      var textAlign = get(cfg, "textAlign", "left");
      var x = cfg.x;
      var y = cfg.y - height / 2;
      if (textAlign === "center") {
        x = x - width / 2;
      } else if (textAlign === "right" || textAlign === "end") {
        x = x - width;
      }
      translate(content, x, y);
      labelShape = content;
      labelGroup.add(content);
    } else {
      var fill = get(cfg, ["style", "fill"]);
      labelShape = labelGroup.addShape("text", __assign$1({ attrs: __assign$1(__assign$1({ x: cfg.x, y: cfg.y, textAlign: cfg.textAlign, textBaseline: get(cfg, "textBaseline", "middle"), text: cfg.content }, cfg.style), { fill: isNull(fill) ? cfg.color : fill }) }, shapeAppendCfg));
    }
    if (cfg.rotate) {
      rotate(labelShape, cfg.rotate);
    }
    this.shapesMap[id] = labelGroup;
  };
  Labels2.prototype.doLayout = function(items, shapes) {
    var _this = this;
    if (this.layout) {
      var layouts = isArray$1(this.layout) ? this.layout : [this.layout];
      each$1(layouts, function(layout) {
        var layoutFn = getGeometryLabelLayout(get(layout, "type", ""));
        if (layoutFn) {
          var labelShapes_1 = [];
          var geometryShapes_1 = [];
          each$1(_this.shapesMap, function(labelShape, id) {
            labelShapes_1.push(labelShape);
            geometryShapes_1.push(shapes[labelShape.get("elementId")]);
          });
          layoutFn(items, labelShapes_1, geometryShapes_1, _this.region, layout.cfg);
        }
      });
    }
  };
  Labels2.prototype.renderLabelLine = function(labelItems) {
    var _this = this;
    each$1(labelItems, function(labelItem) {
      var coordinate2 = get(labelItem, "coordinate");
      if (!labelItem || !coordinate2) {
        return;
      }
      var center2 = coordinate2.getCenter();
      var radius = coordinate2.getRadius();
      if (!labelItem.labelLine) {
        return;
      }
      var labelLineCfg = get(labelItem, "labelLine", {});
      var id = labelItem.id;
      var path2 = labelLineCfg.path;
      if (!path2) {
        var start = polarToCartesian(center2.x, center2.y, radius, labelItem.angle);
        path2 = [
          ["M", start.x, start.y],
          ["L", labelItem.x, labelItem.y]
        ];
      }
      var labelGroup = _this.shapesMap[id];
      if (!labelGroup.destroyed) {
        labelGroup.addShape("path", {
          capture: false,
          attrs: __assign$1({ path: path2, stroke: labelItem.color ? labelItem.color : get(labelItem, ["style", "fill"], "#000"), fill: null }, labelLineCfg.style),
          id,
          origin: labelItem.mappingData,
          data: labelItem.data,
          coordinate: labelItem.coordinate
        });
      }
    });
  };
  Labels2.prototype.renderLabelBackground = function(labelItems) {
    var _this = this;
    each$1(labelItems, function(labelItem) {
      var coordinate2 = get(labelItem, "coordinate");
      var background = get(labelItem, "background");
      if (!background || !coordinate2) {
        return;
      }
      var id = labelItem.id;
      var labelGroup = _this.shapesMap[id];
      if (!labelGroup.destroyed) {
        var labelContentShape = labelGroup.getChildren()[0];
        if (labelContentShape) {
          var _a2 = getlLabelBackgroundInfo(labelGroup, labelItem, background.padding), rotation = _a2.rotation, box2 = __rest(_a2, ["rotation"]);
          var backgroundShape = labelGroup.addShape("rect", {
            attrs: __assign$1(__assign$1({}, box2), background.style || {}),
            id,
            origin: labelItem.mappingData,
            data: labelItem.data,
            coordinate: labelItem.coordinate
          });
          backgroundShape.setZIndex(-1);
          if (rotation) {
            var matrix = labelContentShape.getMatrix();
            backgroundShape.setMatrix(matrix);
          }
        }
      }
    });
  };
  Labels2.prototype.createOffscreenGroup = function() {
    var container = this.container;
    var GroupClass = container.getGroupBase();
    var newGroup = new GroupClass({});
    return newGroup;
  };
  Labels2.prototype.adjustLabel = function(items) {
    var _this = this;
    each$1(items, function(item) {
      if (item) {
        var id = item.id;
        var labelGroup = _this.shapesMap[id];
        if (!labelGroup.destroyed) {
          var labelShapes = labelGroup.findAll(function(ele) {
            return ele.get("type") !== "path";
          });
          each$1(labelShapes, function(labelShape) {
            if (labelShape) {
              if (item.offsetX) {
                labelShape.attr("x", labelShape.attr("x") + item.offsetX);
              }
              if (item.offsetY) {
                labelShape.attr("y", labelShape.attr("y") + item.offsetY);
              }
            }
          });
        }
      }
    });
  };
  return Labels2;
}();
function avg(arr) {
  var sum = 0;
  each$1(arr, function(value2) {
    sum += value2;
  });
  return sum / arr.length;
}
var GeometryLabel = function() {
  function GeometryLabel2(geometry2) {
    this.geometry = geometry2;
  }
  GeometryLabel2.prototype.getLabelItems = function(mapppingArray) {
    var _this = this;
    var items = [];
    var labelCfgs = this.getLabelCfgs(mapppingArray);
    each$1(mapppingArray, function(mappingData, index2) {
      var labelCfg = labelCfgs[index2];
      if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {
        items.push(null);
        return;
      }
      var labelContent = !isArray$1(labelCfg.content) ? [labelCfg.content] : labelCfg.content;
      labelCfg.content = labelContent;
      var total = labelContent.length;
      each$1(labelContent, function(content, subIndex) {
        if (isNil(content) || content === "") {
          items.push(null);
          return;
        }
        var item = __assign$1(__assign$1({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));
        if (!item.textAlign) {
          item.textAlign = _this.getLabelAlign(item, subIndex, total);
        }
        if (item.offset <= 0) {
          item.labelLine = null;
        }
        items.push(item);
      });
    });
    return items;
  };
  GeometryLabel2.prototype.render = function(mapppingArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var labelItems = this.getLabelItems(mapppingArray);
    var labelsRenderer = this.getLabelsRenderer();
    var shapes = this.getGeometryShapes();
    labelsRenderer.render(labelItems, shapes, isUpdate);
  };
  GeometryLabel2.prototype.clear = function() {
    var labelsRenderer = this.labelsRenderer;
    if (labelsRenderer) {
      labelsRenderer.clear();
    }
  };
  GeometryLabel2.prototype.destroy = function() {
    var labelsRenderer = this.labelsRenderer;
    if (labelsRenderer) {
      labelsRenderer.destroy();
    }
    this.labelsRenderer = null;
  };
  GeometryLabel2.prototype.getCoordinate = function() {
    return this.geometry.coordinate;
  };
  GeometryLabel2.prototype.getDefaultLabelCfg = function(offset, position) {
    var geometry2 = this.geometry;
    var type = geometry2.type, theme2 = geometry2.theme;
    if (type === "polygon" || type === "interval" && position === "middle" || offset < 0 && !["line", "point", "path"].includes(type)) {
      return get(theme2, "innerLabels", {});
    }
    return get(theme2, "labels", {});
  };
  GeometryLabel2.prototype.getThemedLabelCfg = function(labelCfg) {
    var geometry2 = this.geometry;
    var defaultLabelCfg = this.getDefaultLabelCfg();
    var type = geometry2.type, theme2 = geometry2.theme;
    var themedLabelCfg;
    if (type === "polygon" || labelCfg.offset < 0 && !["line", "point", "path"].includes(type)) {
      themedLabelCfg = deepMix({}, defaultLabelCfg, theme2.innerLabels, labelCfg);
    } else {
      themedLabelCfg = deepMix({}, defaultLabelCfg, theme2.labels, labelCfg);
    }
    return themedLabelCfg;
  };
  GeometryLabel2.prototype.setLabelPosition = function(labelPointCfg, mappingData, index2, position) {
  };
  GeometryLabel2.prototype.getLabelOffset = function(offset) {
    var coordinate2 = this.getCoordinate();
    var vector = this.getOffsetVector(offset);
    return coordinate2.isTransposed ? vector[0] : vector[1];
  };
  GeometryLabel2.prototype.getLabelOffsetPoint = function(labelCfg, index2, total) {
    var offset = labelCfg.offset;
    var coordinate2 = this.getCoordinate();
    var transposed = coordinate2.isTransposed;
    var dim = transposed ? "x" : "y";
    var factor = transposed ? 1 : -1;
    var offsetPoint = {
      x: 0,
      y: 0
    };
    if (index2 > 0 || total === 1) {
      offsetPoint[dim] = offset * factor;
    } else {
      offsetPoint[dim] = offset * factor * -1;
    }
    return offsetPoint;
  };
  GeometryLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index2) {
    var coordinate2 = this.getCoordinate();
    var total = labelCfg.content.length;
    function getDimValue(value2, idx, isAvg) {
      if (isAvg === void 0) {
        isAvg = false;
      }
      var v = value2;
      if (isArray$1(v)) {
        if (labelCfg.content.length === 1) {
          if (isAvg) {
            v = avg(v);
          } else {
            if (v.length <= 2) {
              v = v[value2.length - 1];
            } else {
              v = avg(v);
            }
          }
        } else {
          v = v[idx];
        }
      }
      return v;
    }
    var label2 = {
      content: labelCfg.content[index2],
      x: 0,
      y: 0,
      start: { x: 0, y: 0 },
      color: "#fff"
    };
    var shape = isArray$1(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
    var isFunnel = shape === "funnel" || shape === "pyramid";
    if (this.geometry.type === "polygon") {
      var centroid = getPolygonCentroid(mappingData.x, mappingData.y);
      label2.x = centroid[0];
      label2.y = centroid[1];
    } else if (this.geometry.type === "interval" && !isFunnel) {
      label2.x = getDimValue(mappingData.x, index2, true);
      label2.y = getDimValue(mappingData.y, index2);
    } else {
      label2.x = getDimValue(mappingData.x, index2);
      label2.y = getDimValue(mappingData.y, index2);
    }
    if (isFunnel) {
      var nextPoints = get(mappingData, "nextPoints");
      var points = get(mappingData, "points");
      if (nextPoints) {
        var point1 = coordinate2.convert(points[1]);
        var point2 = coordinate2.convert(nextPoints[1]);
        label2.x = (point1.x + point2.x) / 2;
        label2.y = (point1.y + point2.y) / 2;
      } else if (shape === "pyramid") {
        var point1 = coordinate2.convert(points[1]);
        var point2 = coordinate2.convert(points[2]);
        label2.x = (point1.x + point2.x) / 2;
        label2.y = (point1.y + point2.y) / 2;
      }
    }
    if (labelCfg.position) {
      this.setLabelPosition(label2, mappingData, index2, labelCfg.position);
    }
    var offsetPoint = this.getLabelOffsetPoint(labelCfg, index2, total);
    label2.start = { x: label2.x, y: label2.y };
    label2.x += offsetPoint.x;
    label2.y += offsetPoint.y;
    label2.color = mappingData.color;
    return label2;
  };
  GeometryLabel2.prototype.getLabelAlign = function(item, index2, total) {
    var align = "center";
    var coordinate2 = this.getCoordinate();
    if (coordinate2.isTransposed) {
      var offset = item.offset;
      if (offset < 0) {
        align = "right";
      } else if (offset === 0) {
        align = "center";
      } else {
        align = "left";
      }
      if (total > 1 && index2 === 0) {
        if (align === "right") {
          align = "left";
        } else if (align === "left") {
          align = "right";
        }
      }
    }
    return align;
  };
  GeometryLabel2.prototype.getLabelId = function(mappingData) {
    var geometry2 = this.geometry;
    var type = geometry2.type;
    var xScale = geometry2.getXScale();
    var yScale = geometry2.getYScale();
    var origin = mappingData[FIELD_ORIGIN];
    var labelId = geometry2.getElementId(mappingData);
    if (type === "line" || type === "area") {
      labelId += " " + origin[xScale.field];
    } else if (type === "path") {
      labelId += " " + origin[xScale.field] + "-" + origin[yScale.field];
    }
    return labelId;
  };
  GeometryLabel2.prototype.getLabelsRenderer = function() {
    var _a2 = this.geometry, labelsContainer = _a2.labelsContainer, labelOption = _a2.labelOption, canvasRegion = _a2.canvasRegion, animateOption = _a2.animateOption;
    var coordinate2 = this.geometry.coordinate;
    var labelsRenderer = this.labelsRenderer;
    if (!labelsRenderer) {
      labelsRenderer = new Labels({
        container: labelsContainer,
        layout: get(labelOption, ["cfg", "layout"], {
          type: this.defaultLayout
        })
      });
      this.labelsRenderer = labelsRenderer;
    }
    labelsRenderer.region = canvasRegion;
    labelsRenderer.animate = animateOption ? getDefaultAnimateCfg("label", coordinate2) : false;
    return labelsRenderer;
  };
  GeometryLabel2.prototype.getLabelCfgs = function(mapppingArray) {
    var _this = this;
    var geometry2 = this.geometry;
    var labelOption = geometry2.labelOption, scales = geometry2.scales, coordinate2 = geometry2.coordinate;
    var _a2 = labelOption, fields = _a2.fields, callback = _a2.callback, cfg = _a2.cfg;
    var labelScales = fields.map(function(field2) {
      return scales[field2];
    });
    var labelCfgs = [];
    each$1(mapppingArray, function(mappingData, index2) {
      var origin = mappingData[FIELD_ORIGIN];
      var originText = _this.getLabelText(origin, labelScales);
      var callbackCfg;
      if (callback) {
        var originValues = fields.map(function(field2) {
          return origin[field2];
        });
        callbackCfg = callback.apply(void 0, originValues);
        if (isNil(callbackCfg)) {
          labelCfgs.push(null);
          return;
        }
      }
      var labelCfg = __assign$1(__assign$1({
        id: _this.getLabelId(mappingData),
        elementId: _this.geometry.getElementId(mappingData),
        data: origin,
        mappingData,
        coordinate: coordinate2
      }, cfg), callbackCfg);
      if (isFunction(labelCfg.position)) {
        labelCfg.position = labelCfg.position(origin, mappingData, index2);
      }
      var offset = _this.getLabelOffset(labelCfg.offset || 0);
      var defaultLabelCfg = _this.getDefaultLabelCfg(offset, labelCfg.position);
      labelCfg = deepMix({}, defaultLabelCfg, labelCfg);
      labelCfg.offset = _this.getLabelOffset(labelCfg.offset || 0);
      var content = labelCfg.content;
      if (isFunction(content)) {
        labelCfg.content = content(origin, mappingData, index2);
      } else if (isUndefined(content)) {
        labelCfg.content = originText[0];
      }
      labelCfgs.push(labelCfg);
    });
    return labelCfgs;
  };
  GeometryLabel2.prototype.getLabelText = function(origin, scales) {
    var labelTexts = [];
    each$1(scales, function(scale2) {
      var value2 = origin[scale2.field];
      if (isArray$1(value2)) {
        value2 = value2.map(function(subVal) {
          return scale2.getText(subVal);
        });
      } else {
        value2 = scale2.getText(value2);
      }
      if (isNil(value2) || value2 === "") {
        labelTexts.push(null);
      } else {
        labelTexts.push(value2);
      }
    });
    return labelTexts;
  };
  GeometryLabel2.prototype.getOffsetVector = function(offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var coordinate2 = this.getCoordinate();
    var actualOffset = 0;
    if (isNumber$1(offset)) {
      actualOffset = offset;
    }
    return coordinate2.isTransposed ? coordinate2.applyMatrix(actualOffset, 0) : coordinate2.applyMatrix(0, actualOffset);
  };
  GeometryLabel2.prototype.getGeometryShapes = function() {
    var geometry2 = this.geometry;
    var shapes = {};
    each$1(geometry2.elementsMap, function(element, id) {
      shapes[id] = element.shape;
    });
    each$1(geometry2.getOffscreenGroup().getChildren(), function(child) {
      var id = geometry2.getElementId(child.get("origin").mappingData);
      shapes[id] = child;
    });
    return shapes;
  };
  return GeometryLabel2;
}();
function getMappingValue(attr, value2, def) {
  if (!attr) {
    return def;
  }
  var r;
  if (attr.callback && attr.callback.length > 1) {
    var restArgs = Array(attr.callback.length - 1).fill("");
    r = attr.mapping.apply(attr, __spreadArray([value2], restArgs, false)).join("");
  } else {
    r = attr.mapping(value2).join("");
  }
  return r || def;
}
var MarkerSymbols = {
  hexagon: function(x, y, r) {
    var diffX = r / 2 * Math.sqrt(3);
    return [
      ["M", x, y - r],
      ["L", x + diffX, y - r / 2],
      ["L", x + diffX, y + r / 2],
      ["L", x, y + r],
      ["L", x - diffX, y + r / 2],
      ["L", x - diffX, y - r / 2],
      ["Z"]
    ];
  },
  bowtie: function(x, y, r) {
    var diffY = r - 1.5;
    return [["M", x - r, y - diffY], ["L", x + r, y + diffY], ["L", x + r, y - diffY], ["L", x - r, y + diffY], ["Z"]];
  },
  cross: function(x, y, r) {
    return [
      ["M", x - r, y - r],
      ["L", x + r, y + r],
      ["M", x + r, y - r],
      ["L", x - r, y + r]
    ];
  },
  tick: function(x, y, r) {
    return [
      ["M", x - r / 2, y - r],
      ["L", x + r / 2, y - r],
      ["M", x, y - r],
      ["L", x, y + r],
      ["M", x - r / 2, y + r],
      ["L", x + r / 2, y + r]
    ];
  },
  plus: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y],
      ["M", x, y - r],
      ["L", x, y + r]
    ];
  },
  hyphen: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  line: function(x, y, r) {
    return [
      ["M", x, y - r],
      ["L", x, y + r]
    ];
  }
};
var STROKES_SYMBOLS = ["line", "cross", "tick", "plus", "hyphen"];
function handleUserMarkerStyle(markerStyle, style) {
  if (isFunction(style)) {
    return style(markerStyle);
  }
  return deepMix({}, markerStyle, style);
}
function adpatorMarkerStyle(marker, color2) {
  var symbol = marker.symbol;
  if (isString(symbol) && STROKES_SYMBOLS.indexOf(symbol) !== -1) {
    var markerStyle = get(marker, "style", {});
    var lineWidth = get(markerStyle, "lineWidth", 1);
    var stroke = markerStyle.stroke || markerStyle.fill || color2;
    marker.style = deepMix({}, marker.style, { lineWidth, stroke, fill: null });
  }
}
function setMarkerSymbol(marker) {
  var symbol = marker.symbol;
  if (isString(symbol) && MarkerSymbols[symbol]) {
    marker.symbol = MarkerSymbols[symbol];
  }
}
function getLegendLayout(direction2) {
  return direction2.startsWith(DIRECTION.LEFT) || direction2.startsWith(DIRECTION.RIGHT) ? "vertical" : "horizontal";
}
function getLegendItems(view, geometry2, attr, themeMarker, userMarker) {
  var scale2 = attr.getScale(attr.type);
  if (scale2.isCategory) {
    var field_1 = scale2.field;
    var colorAttr_1 = geometry2.getAttribute("color");
    var shapeAttr_1 = geometry2.getAttribute("shape");
    var defaultColor_1 = view.getTheme().defaultColor;
    var isInPolar_1 = geometry2.coordinate.isPolar;
    return scale2.getTicks().map(function(tick, index2) {
      var _a2;
      var text2 = tick.text, scaleValue = tick.value;
      var name = text2;
      var value2 = scale2.invert(scaleValue);
      var unchecked = view.filterFieldData(field_1, [(_a2 = {}, _a2[field_1] = value2, _a2)]).length === 0;
      each$1(view.views, function(subView) {
        var _a3;
        if (!subView.filterFieldData(field_1, [(_a3 = {}, _a3[field_1] = value2, _a3)]).length) {
          unchecked = true;
        }
      });
      var color2 = getMappingValue(colorAttr_1, value2, defaultColor_1);
      var shape = getMappingValue(shapeAttr_1, value2, "point");
      var marker = geometry2.getShapeMarker(shape, {
        color: color2,
        isInPolar: isInPolar_1
      });
      var markerCfg = userMarker;
      if (isFunction(markerCfg)) {
        markerCfg = markerCfg(name, index2, __assign$1({ name, value: value2 }, deepMix({}, themeMarker, marker)));
      }
      marker = deepMix({}, themeMarker, marker, omit(__assign$1({}, markerCfg), ["style"]));
      adpatorMarkerStyle(marker, color2);
      if (markerCfg && markerCfg.style) {
        marker.style = handleUserMarkerStyle(marker.style, markerCfg.style);
      }
      setMarkerSymbol(marker);
      return { id: value2, name, value: value2, marker, unchecked };
    });
  }
  return [];
}
function getCustomLegendItems(themeMarker, userMarker, customItems) {
  return customItems.map(function(item, index2) {
    var markerCfg = userMarker;
    if (isFunction(markerCfg)) {
      markerCfg = markerCfg(item.name, index2, deepMix({}, themeMarker, item));
    }
    var itemMarker = isFunction(item.marker) ? item.marker(item.name, index2, deepMix({}, themeMarker, item)) : item.marker;
    var marker = deepMix({}, themeMarker, markerCfg, itemMarker);
    setMarkerSymbol(marker);
    item.marker = marker;
    return item;
  });
}
function getLegendThemeCfg(theme2, direction2) {
  var legendTheme = get(theme2, ["components", "legend"], {});
  return deepMix({}, get(legendTheme, ["common"], {}), deepMix({}, get(legendTheme, [direction2], {})));
}
var Util = {
  getLegendItems,
  translate,
  rotate,
  zoom,
  transform: transform$4,
  getAngle: getAngle$1,
  getSectorPath,
  polarToCartesian,
  getDelegationObject,
  getTooltipItems,
  getMappingValue
};
var WHITE_COLORS = {
  100: "#000",
  95: "#0D0D0D",
  85: "#262626",
  65: "#595959",
  45: "#8C8C8C",
  25: "#BFBFBF",
  15: "#D9D9D9",
  6: "#F0F0F0"
};
var BLACK_COLORS = {
  100: "#FFFFFF",
  95: "#F2F2F2",
  85: "#D9D9D9",
  65: "#A6A6A6",
  45: "#737373",
  25: "#404040",
  15: "#262626",
  6: "#0F0F0F"
};
var QUALITATIVE_10 = [
  "#5B8FF9",
  "#5AD8A6",
  "#5D7092",
  "#F6BD16",
  "#E86452",
  "#6DC8EC",
  "#945FB9",
  "#FF9845",
  "#1E9493",
  "#FF99C3"
];
var QUALITATIVE_20 = [
  "#5B8FF9",
  "#CDDDFD",
  "#5AD8A6",
  "#CDF3E4",
  "#5D7092",
  "#CED4DE",
  "#F6BD16",
  "#FCEBB9",
  "#E86452",
  "#F8D0CB",
  "#6DC8EC",
  "#D3EEF9",
  "#945FB9",
  "#DECFEA",
  "#FF9845",
  "#FFE0C7",
  "#1E9493",
  "#BBDEDE",
  "#FF99C3",
  "#FFE0ED"
];
var SINGLE_SEQUENCE = [
  "#B8E1FF",
  "#9AC5FF",
  "#7DAAFF",
  "#5B8FF9",
  "#3D76DD",
  "#085EC0",
  "#0047A5",
  "#00318A",
  "#001D70"
];
var createDarkStyleSheet = function(cfg) {
  if (cfg === void 0) {
    cfg = {};
  }
  var _a2 = cfg.backgroundColor, backgroundColor = _a2 === void 0 ? "#141414" : _a2, _b = cfg.subColor, subColor = _b === void 0 ? "rgba(255,255,255,0.05)" : _b, _c = cfg.paletteQualitative10, paletteQualitative10 = _c === void 0 ? QUALITATIVE_10 : _c, _d = cfg.paletteQualitative20, paletteQualitative20 = _d === void 0 ? QUALITATIVE_20 : _d, _e = cfg.paletteSemanticRed, paletteSemanticRed = _e === void 0 ? "#F4664A" : _e, _f = cfg.paletteSemanticGreen, paletteSemanticGreen = _f === void 0 ? "#30BF78" : _f, _g = cfg.paletteSemanticYellow, paletteSemanticYellow = _g === void 0 ? "#FAAD14" : _g, _h = cfg.paletteSequence, paletteSequence = _h === void 0 ? SINGLE_SEQUENCE : _h, _j = cfg.fontFamily, fontFamily = _j === void 0 ? '"Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"' : _j;
  var _k = cfg.brandColor, brandColor = _k === void 0 ? paletteQualitative10[0] : _k;
  return {
    backgroundColor,
    brandColor,
    subColor,
    paletteQualitative10,
    paletteQualitative20,
    paletteSemanticRed,
    paletteSemanticGreen,
    paletteSemanticYellow,
    paletteSequence,
    fontFamily,
    axisLineBorderColor: BLACK_COLORS[25],
    axisLineBorder: 1,
    axisLineDash: null,
    axisTitleTextFillColor: BLACK_COLORS[65],
    axisTitleTextFontSize: 12,
    axisTitleTextLineHeight: 12,
    axisTitleTextFontWeight: "normal",
    axisTitleSpacing: 12,
    axisTickLineBorderColor: BLACK_COLORS[25],
    axisTickLineLength: 4,
    axisTickLineBorder: 1,
    axisSubTickLineBorderColor: BLACK_COLORS[15],
    axisSubTickLineLength: 2,
    axisSubTickLineBorder: 1,
    axisLabelFillColor: BLACK_COLORS[45],
    axisLabelFontSize: 12,
    axisLabelLineHeight: 12,
    axisLabelFontWeight: "normal",
    axisLabelOffset: 8,
    axisGridBorderColor: BLACK_COLORS[15],
    axisGridBorder: 1,
    axisGridLineDash: null,
    legendTitleTextFillColor: BLACK_COLORS[45],
    legendTitleTextFontSize: 12,
    legendTitleTextLineHeight: 21,
    legendTitleTextFontWeight: "normal",
    legendMarkerColor: QUALITATIVE_10[0],
    legendMarkerSpacing: 8,
    legendMarkerSize: 4,
    legendCircleMarkerSize: 4,
    legendSquareMarkerSize: 4,
    legendLineMarkerSize: 5,
    legendItemNameFillColor: BLACK_COLORS[65],
    legendItemNameFontSize: 12,
    legendItemNameLineHeight: 12,
    legendItemNameFontWeight: "normal",
    legendItemSpacing: 24,
    legendItemMarginBottom: 12,
    legendSpacing: 16,
    legendPadding: [8, 8, 8, 8],
    legendHorizontalPadding: [8, 0, 8, 0],
    legendVerticalPadding: [0, 8, 0, 8],
    legendPageNavigatorMarkerSize: 12,
    legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS[45],
    legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
    legendPageNavigatorMarkerFillColor: BLACK_COLORS[45],
    legendPageNavigatorMarkerFillOpacity: 1,
    legendPageNavigatorTextFillColor: BLACK_COLORS[65],
    legendPageNavigatorTextFontSize: 12,
    sliderRailFillColor: BLACK_COLORS[15],
    sliderRailBorder: 0,
    sliderRailBorderColor: null,
    sliderRailWidth: 100,
    sliderRailHeight: 12,
    sliderLabelTextFillColor: BLACK_COLORS[45],
    sliderLabelTextFontSize: 12,
    sliderLabelTextLineHeight: 12,
    sliderLabelTextFontWeight: "normal",
    sliderHandlerFillColor: WHITE_COLORS[6],
    sliderHandlerWidth: 10,
    sliderHandlerHeight: 14,
    sliderHandlerBorder: 1,
    sliderHandlerBorderColor: WHITE_COLORS[25],
    annotationArcBorderColor: BLACK_COLORS[15],
    annotationArcBorder: 1,
    annotationLineBorderColor: BLACK_COLORS[25],
    annotationLineBorder: 1,
    annotationLineDash: null,
    annotationTextFillColor: BLACK_COLORS[65],
    annotationTextFontSize: 12,
    annotationTextLineHeight: 12,
    annotationTextFontWeight: "normal",
    annotationTextBorderColor: null,
    annotationTextBorder: 0,
    annotationRegionFillColor: BLACK_COLORS[100],
    annotationRegionFillOpacity: 0.06,
    annotationRegionBorder: 0,
    annotationRegionBorderColor: null,
    annotationDataMarkerLineLength: 16,
    tooltipCrosshairsBorderColor: BLACK_COLORS[25],
    tooltipCrosshairsBorder: 1,
    tooltipCrosshairsLineDash: null,
    tooltipContainerFillColor: "#1f1f1f",
    tooltipContainerFillOpacity: 0.95,
    tooltipContainerShadow: "0px 2px 4px rgba(0,0,0,.5)",
    tooltipContainerBorderRadius: 3,
    tooltipTextFillColor: BLACK_COLORS[65],
    tooltipTextFontSize: 12,
    tooltipTextLineHeight: 12,
    tooltipTextFontWeight: "bold",
    labelFillColor: BLACK_COLORS[65],
    labelFillColorDark: "#2c3542",
    labelFillColorLight: "#ffffff",
    labelFontSize: 12,
    labelLineHeight: 12,
    labelFontWeight: "normal",
    labelBorderColor: null,
    labelBorder: 0,
    innerLabelFillColor: WHITE_COLORS[100],
    innerLabelFontSize: 12,
    innerLabelLineHeight: 12,
    innerLabelFontWeight: "normal",
    innerLabelBorderColor: null,
    innerLabelBorder: 0,
    overflowLabelFillColor: BLACK_COLORS[65],
    overflowLabelFillColorDark: "#2c3542",
    overflowLabelFillColorLight: "#ffffff",
    overflowLabelFontSize: 12,
    overflowLabelLineHeight: 12,
    overflowLabelFontWeight: "normal",
    overflowLabelBorderColor: WHITE_COLORS[100],
    overflowLabelBorder: 1,
    labelLineBorder: 1,
    labelLineBorderColor: BLACK_COLORS[25],
    cSliderRailHieght: 16,
    cSliderBackgroundFillColor: "#416180",
    cSliderBackgroundFillOpacity: 0.05,
    cSliderForegroundFillColor: "#5B8FF9",
    cSliderForegroundFillOpacity: 0.15,
    cSliderHandlerHeight: 24,
    cSliderHandlerWidth: 10,
    cSliderHandlerFillColor: "#F7F7F7",
    cSliderHandlerFillOpacity: 1,
    cSliderHandlerHighlightFillColor: "#FFF",
    cSliderHandlerBorderColor: "#BFBFBF",
    cSliderHandlerBorder: 1,
    cSliderHandlerBorderRadius: 2,
    cSliderTextFillColor: "#fff",
    cSliderTextFillOpacity: 0.45,
    cSliderTextFontSize: 12,
    cSliderTextLineHeight: 12,
    cSliderTextFontWeight: "normal",
    cSliderTextBorderColor: null,
    cSliderTextBorder: 0,
    scrollbarTrackFillColor: "rgba(255,255,255,0.65)",
    scrollbarThumbFillColor: "rgba(0,0,0,0.35)",
    scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.45)",
    pointFillColor: QUALITATIVE_10[0],
    pointFillOpacity: 0.95,
    pointSize: 4,
    pointBorder: 1,
    pointBorderColor: WHITE_COLORS[100],
    pointBorderOpacity: 1,
    pointActiveBorderColor: BLACK_COLORS[100],
    pointSelectedBorder: 2,
    pointSelectedBorderColor: BLACK_COLORS[100],
    pointInactiveFillOpacity: 0.3,
    pointInactiveBorderOpacity: 0.3,
    hollowPointSize: 4,
    hollowPointBorder: 1,
    hollowPointBorderColor: QUALITATIVE_10[0],
    hollowPointBorderOpacity: 0.95,
    hollowPointFillColor: WHITE_COLORS[100],
    hollowPointActiveBorder: 1,
    hollowPointActiveBorderColor: BLACK_COLORS[100],
    hollowPointActiveBorderOpacity: 1,
    hollowPointSelectedBorder: 2,
    hollowPointSelectedBorderColor: BLACK_COLORS[100],
    hollowPointSelectedBorderOpacity: 1,
    hollowPointInactiveBorderOpacity: 0.3,
    lineBorder: 2,
    lineBorderColor: QUALITATIVE_10[0],
    lineBorderOpacity: 1,
    lineActiveBorder: 3,
    lineSelectedBorder: 3,
    lineInactiveBorderOpacity: 0.3,
    areaFillColor: QUALITATIVE_10[0],
    areaFillOpacity: 0.25,
    areaActiveFillColor: QUALITATIVE_10[0],
    areaActiveFillOpacity: 0.5,
    areaSelectedFillColor: QUALITATIVE_10[0],
    areaSelectedFillOpacity: 0.5,
    areaInactiveFillOpacity: 0.3,
    hollowAreaBorderColor: QUALITATIVE_10[0],
    hollowAreaBorder: 2,
    hollowAreaBorderOpacity: 1,
    hollowAreaActiveBorder: 3,
    hollowAreaActiveBorderColor: BLACK_COLORS[100],
    hollowAreaSelectedBorder: 3,
    hollowAreaSelectedBorderColor: BLACK_COLORS[100],
    hollowAreaInactiveBorderOpacity: 0.3,
    intervalFillColor: QUALITATIVE_10[0],
    intervalFillOpacity: 0.95,
    intervalActiveBorder: 1,
    intervalActiveBorderColor: BLACK_COLORS[100],
    intervalActiveBorderOpacity: 1,
    intervalSelectedBorder: 2,
    intervalSelectedBorderColor: BLACK_COLORS[100],
    intervalSelectedBorderOpacity: 1,
    intervalInactiveBorderOpacity: 0.3,
    intervalInactiveFillOpacity: 0.3,
    hollowIntervalBorder: 2,
    hollowIntervalBorderColor: QUALITATIVE_10[0],
    hollowIntervalBorderOpacity: 1,
    hollowIntervalFillColor: WHITE_COLORS[100],
    hollowIntervalActiveBorder: 2,
    hollowIntervalActiveBorderColor: BLACK_COLORS[100],
    hollowIntervalSelectedBorder: 3,
    hollowIntervalSelectedBorderColor: BLACK_COLORS[100],
    hollowIntervalSelectedBorderOpacity: 1,
    hollowIntervalInactiveBorderOpacity: 0.3
  };
};
var antvDark = createDarkStyleSheet();
function getPixelRatio$1() {
  return window ? window.devicePixelRatio : 1;
}
function distance$1(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function inBox(minX, minY, width, height, x, y) {
  return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
}
function intersectRect(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function mergeRegion(region1, region2) {
  if (!region1 || !region2) {
    return region1 || region2;
  }
  return {
    minX: Math.min(region1.minX, region2.minX),
    minY: Math.min(region1.minY, region2.minY),
    maxX: Math.max(region1.maxX, region2.maxX),
    maxY: Math.max(region1.maxY, region2.maxY)
  };
}
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
var regexLG$1 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG$1 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR$1 = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop$1 = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function addStop$1(steps, gradient2) {
  var arr = steps.match(regexColorStop$1);
  each$1(arr, function(item) {
    var itemArr = item.split(":");
    gradient2.addColorStop(itemArr[0], itemArr[1]);
  });
}
function parseLineGradient$1(context, element, gradientStr) {
  var arr = regexLG$1.exec(gradientStr);
  var angle2 = parseFloat(arr[1]) % 360 * (Math.PI / 180);
  var steps = arr[2];
  var box2 = element.getBBox();
  var start;
  var end;
  if (angle2 >= 0 && angle2 < 1 / 2 * Math.PI) {
    start = {
      x: box2.minX,
      y: box2.minY
    };
    end = {
      x: box2.maxX,
      y: box2.maxY
    };
  } else if (1 / 2 * Math.PI <= angle2 && angle2 < Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.minY
    };
    end = {
      x: box2.minX,
      y: box2.maxY
    };
  } else if (Math.PI <= angle2 && angle2 < 3 / 2 * Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.maxY
    };
    end = {
      x: box2.minX,
      y: box2.minY
    };
  } else {
    start = {
      x: box2.minX,
      y: box2.maxY
    };
    end = {
      x: box2.maxX,
      y: box2.minY
    };
  }
  var tanTheta = Math.tan(angle2);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  var gradient2 = context.createLinearGradient(start.x, start.y, x, y);
  addStop$1(steps, gradient2);
  return gradient2;
}
function parseRadialGradient$1(context, element, gradientStr) {
  var arr = regexRG$1.exec(gradientStr);
  var fx = parseFloat(arr[1]);
  var fy = parseFloat(arr[2]);
  var fr = parseFloat(arr[3]);
  var steps = arr[4];
  if (fr === 0) {
    var colors = steps.match(regexColorStop$1);
    return colors[colors.length - 1].split(":")[1];
  }
  var box2 = element.getBBox();
  var width = box2.maxX - box2.minX;
  var height = box2.maxY - box2.minY;
  var r = Math.sqrt(width * width + height * height) / 2;
  var gradient2 = context.createRadialGradient(box2.minX + width * fx, box2.minY + height * fy, 0, box2.minX + width / 2, box2.minY + height / 2, fr * r);
  addStop$1(steps, gradient2);
  return gradient2;
}
function parsePattern(context, element, patternStr) {
  if (element.get("patternSource") && element.get("patternSource") === patternStr) {
    return element.get("pattern");
  }
  var pattern2;
  var img;
  var arr = regexPR$1.exec(patternStr);
  var repeat = arr[1];
  var source = arr[2];
  function onload() {
    pattern2 = context.createPattern(img, repeat);
    element.set("pattern", pattern2);
    element.set("patternSource", patternStr);
  }
  switch (repeat) {
    case "a":
      repeat = "repeat";
      break;
    case "x":
      repeat = "repeat-x";
      break;
    case "y":
      repeat = "repeat-y";
      break;
    case "n":
      repeat = "no-repeat";
      break;
    default:
      repeat = "no-repeat";
  }
  img = new Image();
  if (!source.match(/^data:/i)) {
    img.crossOrigin = "Anonymous";
  }
  img.src = source;
  if (img.complete) {
    onload();
  } else {
    img.onload = onload;
    img.src = img.src;
  }
  return pattern2;
}
function parseStyle(context, element, color2) {
  var bbox = element.getBBox();
  if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {
    return color2;
  }
  if (isString(color2)) {
    if (color2[1] === "(" || color2[2] === "(") {
      if (color2[0] === "l") {
        return parseLineGradient$1(context, element, color2);
      }
      if (color2[0] === "r") {
        return parseRadialGradient$1(context, element, color2);
      }
      if (color2[0] === "p") {
        return parsePattern(context, element, color2);
      }
    }
    return color2;
  }
  if (color2 instanceof CanvasPattern) {
    return color2;
  }
}
function parseRadius$2(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (isArray$1(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return [r1, r2, r3, r4];
}
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod$1(toRadian(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff2 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff2 ? Math.sqrt((rx * rx * (ry * ry) - diff2) / diff2) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u);
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}
var sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, PI = Math.PI;
function _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  var arrowShape = new Path$4({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: {
      path: "M" + 10 * cos(PI / 6) + "," + 10 * sin(PI / 6) + " L0,0 L" + 10 * cos(PI / 6) + ",-" + 10 * sin(PI / 6),
      stroke,
      lineWidth
    }
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var startArrow = attrs.startArrow, endArrow = attrs.endArrow, stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var arrowAttrs = isStart ? startArrow : endArrow;
  var d = arrowAttrs.d, arrowFill = arrowAttrs.fill, arrowStroke = arrowAttrs.stroke, arrowLineWidth = arrowAttrs.lineWidth, restAttrs = __rest(arrowAttrs, ["d", "fill", "stroke", "lineWidth"]);
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  if (d) {
    x2 = x2 - cos(rad) * d;
    y2 = y2 - sin(rad) * d;
  }
  var arrowShape = new Path$4({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: __assign$1(__assign$1({}, restAttrs), {
      stroke: arrowStroke || stroke,
      lineWidth: arrowLineWidth || lineWidth,
      fill: arrowFill
    })
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function getShortenOffset(x1, y1, x2, y2, d) {
  var rad = atan2(y2 - y1, x2 - x1);
  return {
    dx: cos(rad) * d,
    dy: sin(rad) * d
  };
}
function addStartArrow(shape, attrs, x1, y1, x2, y2) {
  if (typeof attrs.startArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);
  } else if (attrs.startArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);
  } else {
    shape.set("startArrowShape", null);
  }
}
function addEndArrow(shape, attrs, x1, y1, x2, y2) {
  if (typeof attrs.endArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);
  } else if (attrs.endArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);
  } else {
    shape.set("startArrowShape", null);
  }
}
var SHAPE_ATTRS_MAP = {
  fill: "fillStyle",
  stroke: "strokeStyle",
  opacity: "globalAlpha"
};
function applyAttrsToContext(context, element) {
  var attrs = element.attr();
  for (var k in attrs) {
    var v = attrs[k];
    var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;
    if (name_1 === "matrix" && v) {
      context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);
    } else if (name_1 === "lineDash" && context.setLineDash) {
      isArray$1(v) && context.setLineDash(v);
    } else {
      if (name_1 === "strokeStyle" || name_1 === "fillStyle") {
        v = parseStyle(context, element, v);
      } else if (name_1 === "globalAlpha") {
        v = v * context.globalAlpha;
      }
      context[name_1] = v;
    }
  }
}
function drawChildren$1(context, children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.cfg.visible) {
      child.draw(context, region);
    } else {
      child.skipDraw();
    }
  }
}
function checkRefresh(canvas, children, region) {
  var refreshElements = canvas.get("refreshElements");
  each$1(refreshElements, function(el) {
    if (el !== canvas) {
      var parent_1 = el.cfg.parent;
      while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
        parent_1.cfg.refresh = true;
        parent_1 = parent_1.cfg.parent;
      }
    }
  });
  if (refreshElements[0] === canvas) {
    setChildrenRefresh(children);
  } else {
    checkChildrenRefresh(children, region);
  }
}
function checkChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.cfg.visible) {
      if (child.cfg.hasChanged) {
        child.cfg.refresh = true;
        if (child.isGroup()) {
          setChildrenRefresh(child.cfg.children);
        }
      } else if (child.cfg.refresh) {
        if (child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      } else {
        var refresh = checkElementRefresh(child, region);
        child.cfg.refresh = refresh;
        if (refresh && child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      }
    }
  }
}
function clearChanged(elements) {
  for (var i = 0; i < elements.length; i++) {
    var el = elements[i];
    el.cfg.hasChanged = false;
    if (el.isGroup() && !el.destroyed) {
      clearChanged(el.cfg.children);
    }
  }
}
function setChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    child.cfg.refresh = true;
    if (child.isGroup()) {
      setChildrenRefresh(child.get("children"));
    }
  }
}
function checkElementRefresh(shape, region) {
  var bbox = shape.cfg.cacheCanvasBBox;
  var isAllow = shape.cfg.isInView && bbox && intersectRect(bbox, region);
  return isAllow;
}
function drawPath(shape, context, attrs, arcParamsCache) {
  var path2 = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
  if (!path2) {
    return;
  }
  var currentPoint = [0, 0];
  var startMovePoint = [0, 0];
  var distance2 = {
    dx: 0,
    dy: 0
  };
  context.beginPath();
  for (var i = 0; i < path2.length; i++) {
    var params = path2[i];
    var command = params[0];
    if (i === 0 && startArrow && startArrow.d) {
      var tangent = shape.getStartTangent();
      distance2 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
    } else if (i === path2.length - 2 && path2[i + 1][0] === "Z" && endArrow && endArrow.d) {
      var lastPath = path2[i + 1];
      if (lastPath[0] === "Z") {
        var tangent = shape.getEndTangent();
        distance2 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    } else if (i === path2.length - 1 && endArrow && endArrow.d) {
      if (path2[0] !== "Z") {
        var tangent = shape.getEndTangent();
        distance2 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    }
    var dx = distance2.dx, dy = distance2.dy;
    switch (command) {
      case "M":
        context.moveTo(params[1] - dx, params[2] - dy);
        startMovePoint = [params[1], params[2]];
        break;
      case "L":
        context.lineTo(params[1] - dx, params[2] - dy);
        break;
      case "Q":
        context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
        break;
      case "C":
        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
        break;
      case "A": {
        var arcParams = void 0;
        if (arcParamsCache) {
          arcParams = arcParamsCache[i];
          if (!arcParams) {
            arcParams = getArcParams(currentPoint, params);
            arcParamsCache[i] = arcParams;
          }
        } else {
          arcParams = getArcParams(currentPoint, params);
        }
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
        if (context.ellipse) {
          context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
        } else {
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          context.translate(cx, cy);
          context.rotate(xRotation);
          context.scale(scaleX, scaleY);
          context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);
          context.scale(1 / scaleX, 1 / scaleY);
          context.rotate(-xRotation);
          context.translate(-cx, -cy);
        }
        break;
      }
      case "Z":
        context.closePath();
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
    } else {
      var len = params.length;
      currentPoint = [params[len - 2], params[len - 1]];
    }
  }
}
function refreshElement$1(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas) {
    if (changeType === "remove") {
      element._cacheCanvasBBox = element.get("cacheCanvasBBox");
    }
    if (!element.get("hasChanged")) {
      element.set("hasChanged", true);
      if (!(element.cfg.parent && element.cfg.parent.get("hasChanged"))) {
        canvas.refreshElement(element, changeType, canvas);
        if (canvas.get("autoDraw")) {
          canvas.draw();
        }
      }
    }
  }
}
function getRefreshRegion(element) {
  var region;
  if (!element.destroyed) {
    var cacheBox = element.get("cacheCanvasBBox");
    var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
    var bbox = element.getCanvasBBox();
    var validBBox = bbox && !!(bbox.width && bbox.height);
    if (validCache && validBBox) {
      region = mergeRegion(cacheBox, bbox);
    } else if (validCache) {
      region = cacheBox;
    } else if (validBBox) {
      region = bbox;
    }
  } else {
    region = element["_cacheCanvasBBox"];
  }
  return region;
}
function getMergedRegion(elements) {
  if (!elements.length) {
    return null;
  }
  var minXArr = [];
  var minYArr = [];
  var maxXArr = [];
  var maxYArr = [];
  each$1(elements, function(el) {
    var region = getRefreshRegion(el);
    if (region) {
      minXArr.push(region.minX);
      minYArr.push(region.minY);
      maxXArr.push(region.maxX);
      maxYArr.push(region.maxY);
    }
  });
  return {
    minX: min$1(minXArr),
    minY: min$1(minYArr),
    maxX: max$1(maxXArr),
    maxY: max$1(maxYArr)
  };
}
function mergeView(region, viewRegion) {
  if (!region || !viewRegion) {
    return null;
  }
  if (!intersectRect(region, viewRegion)) {
    return null;
  }
  return {
    minX: Math.max(region.minX, viewRegion.minX),
    minY: Math.max(region.minY, viewRegion.minY),
    maxX: Math.min(region.maxX, viewRegion.maxX),
    maxY: Math.min(region.maxY, viewRegion.maxY)
  };
}
var Group$1 = function(_super) {
  __extends$2(Group2, _super);
  function Group2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Group2.prototype.onCanvasChange = function(changeType) {
    refreshElement$1(this, changeType);
  };
  Group2.prototype.getShapeBase = function() {
    return Shape$1;
  };
  Group2.prototype.getGroupBase = function() {
    return Group2;
  };
  Group2.prototype._applyClip = function(context, clip) {
    if (clip) {
      context.save();
      applyAttrsToContext(context, clip);
      clip.createPath(context);
      context.restore();
      context.clip();
      clip._afterDraw();
    }
  };
  Group2.prototype.cacheCanvasBBox = function() {
    var children = this.cfg.children;
    var xArr = [];
    var yArr = [];
    each$1(children, function(child) {
      var bbox2 = child.cfg.cacheCanvasBBox;
      if (bbox2 && child.cfg.isInView) {
        xArr.push(bbox2.minX, bbox2.maxX);
        yArr.push(bbox2.minY, bbox2.maxY);
      }
    });
    var bbox = null;
    if (xArr.length) {
      var minX = min$1(xArr);
      var maxX = max$1(xArr);
      var minY = min$1(yArr);
      var maxY = max$1(yArr);
      bbox = {
        minX,
        minY,
        x: minX,
        y: minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      var canvas = this.cfg.canvas;
      if (canvas) {
        var viewRange = canvas.getViewRange();
        this.set("isInView", intersectRect(bbox, viewRange));
      }
    } else {
      this.set("isInView", false);
    }
    this.set("cacheCanvasBBox", bbox);
  };
  Group2.prototype.draw = function(context, region) {
    var children = this.cfg.children;
    var allowDraw = region ? this.cfg.refresh : true;
    if (children.length && allowDraw) {
      context.save();
      applyAttrsToContext(context, this);
      this._applyClip(context, this.getClip());
      drawChildren$1(context, children, region);
      context.restore();
      this.cacheCanvasBBox();
    }
    this.cfg.refresh = null;
    this.set("hasChanged", false);
  };
  Group2.prototype.skipDraw = function() {
    this.set("cacheCanvasBBox", null);
    this.set("hasChanged", false);
  };
  return Group2;
}(AbstractGroup);
var ShapeBase$2 = function(_super) {
  __extends$2(ShapeBase2, _super);
  function ShapeBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShapeBase2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
  };
  ShapeBase2.prototype.getShapeBase = function() {
    return Shape$1;
  };
  ShapeBase2.prototype.getGroupBase = function() {
    return Group$1;
  };
  ShapeBase2.prototype.onCanvasChange = function(changeType) {
    refreshElement$1(this, changeType);
  };
  ShapeBase2.prototype.calculateBBox = function() {
    var type = this.get("type");
    var lineWidth = this.getHitLineWidth();
    var bboxMethod = getMethod(type);
    var box2 = bboxMethod(this);
    var halfLineWidth = lineWidth / 2;
    var minX = box2.x - halfLineWidth;
    var minY = box2.y - halfLineWidth;
    var maxX = box2.x + box2.width + halfLineWidth;
    var maxY = box2.y + box2.height + halfLineWidth;
    return {
      x: minX,
      minX,
      y: minY,
      minY,
      width: box2.width + lineWidth,
      height: box2.height + lineWidth,
      maxX,
      maxY
    };
  };
  ShapeBase2.prototype.isFill = function() {
    return !!this.attrs["fill"] || this.isClipShape();
  };
  ShapeBase2.prototype.isStroke = function() {
    return !!this.attrs["stroke"];
  };
  ShapeBase2.prototype._applyClip = function(context, clip) {
    if (clip) {
      context.save();
      applyAttrsToContext(context, clip);
      clip.createPath(context);
      context.restore();
      context.clip();
      clip._afterDraw();
    }
  };
  ShapeBase2.prototype.draw = function(context, region) {
    var clip = this.cfg.clipShape;
    if (region) {
      if (this.cfg.refresh === false) {
        this.set("hasChanged", false);
        return;
      }
      var bbox = this.getCanvasBBox();
      if (!intersectRect(region, bbox)) {
        this.set("hasChanged", false);
        if (this.cfg.isInView) {
          this._afterDraw();
        }
        return;
      }
    }
    context.save();
    applyAttrsToContext(context, this);
    this._applyClip(context, clip);
    this.drawPath(context);
    context.restore();
    this._afterDraw();
  };
  ShapeBase2.prototype.getCanvasViewBox = function() {
    var canvas = this.cfg.canvas;
    if (canvas) {
      return canvas.getViewRange();
    }
    return null;
  };
  ShapeBase2.prototype.cacheCanvasBBox = function() {
    var canvasBBox = this.getCanvasViewBox();
    if (canvasBBox) {
      var bbox = this.getCanvasBBox();
      var isInView = intersectRect(bbox, canvasBBox);
      this.set("isInView", isInView);
      if (isInView) {
        this.set("cacheCanvasBBox", bbox);
      } else {
        this.set("cacheCanvasBBox", null);
      }
    }
  };
  ShapeBase2.prototype._afterDraw = function() {
    this.cacheCanvasBBox();
    this.set("hasChanged", false);
    this.set("refresh", null);
  };
  ShapeBase2.prototype.skipDraw = function() {
    this.set("cacheCanvasBBox", null);
    this.set("isInView", null);
    this.set("hasChanged", false);
  };
  ShapeBase2.prototype.drawPath = function(context) {
    this.createPath(context);
    this.strokeAndFill(context);
    this.afterDrawPath(context);
  };
  ShapeBase2.prototype.fill = function(context) {
    context.fill();
  };
  ShapeBase2.prototype.stroke = function(context) {
    context.stroke();
  };
  ShapeBase2.prototype.strokeAndFill = function(context) {
    var _a2 = this.attrs, lineWidth = _a2.lineWidth, opacity = _a2.opacity, strokeOpacity = _a2.strokeOpacity, fillOpacity = _a2.fillOpacity;
    if (this.isFill()) {
      if (!isNil(fillOpacity) && fillOpacity !== 1) {
        context.globalAlpha = fillOpacity;
        this.fill(context);
        context.globalAlpha = opacity;
      } else {
        this.fill(context);
      }
    }
    if (this.isStroke()) {
      if (lineWidth > 0) {
        if (!isNil(strokeOpacity) && strokeOpacity !== 1) {
          context.globalAlpha = strokeOpacity;
        }
        this.stroke(context);
      }
    }
    this.afterDrawPath(context);
  };
  ShapeBase2.prototype.createPath = function(context) {
  };
  ShapeBase2.prototype.afterDrawPath = function(context) {
  };
  ShapeBase2.prototype.isInShape = function(refX, refY) {
    var isStroke = this.isStroke();
    var isFill = this.isFill();
    var lineWidth = this.getHitLineWidth();
    return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
  };
  ShapeBase2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    return false;
  };
  ShapeBase2.prototype.getHitLineWidth = function() {
    if (!this.isStroke()) {
      return 0;
    }
    var attrs = this.attrs;
    return attrs["lineWidth"] + attrs["lineAppendWidth"];
  };
  return ShapeBase2;
}(AbstractShape);
var ShapeBase$3 = ShapeBase$2;
var Circle$3 = function(_super) {
  __extends$2(Circle2, _super);
  function Circle2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Circle2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, r: 0 });
  };
  Circle2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var r = attrs.r;
    var halfLineWidth = lineWidth / 2;
    var absDistance = distance$1(cx, cy, x, y);
    if (isFill && isStroke) {
      return absDistance <= r + halfLineWidth;
    }
    if (isFill) {
      return absDistance <= r;
    }
    if (isStroke) {
      return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
    }
    return false;
  };
  Circle2.prototype.createPath = function(context) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var r = attrs.r;
    context.beginPath();
    context.arc(cx, cy, r, 0, Math.PI * 2, false);
    context.closePath();
  };
  return Circle2;
}(ShapeBase$3);
var Circle$4 = Circle$3;
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}
var Ellipse$2 = function(_super) {
  __extends$2(Ellipse2, _super);
  function Ellipse2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Ellipse2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
  };
  Ellipse2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var halfLineWith = lineWidth / 2;
    var cx = attrs.x;
    var cy = attrs.y;
    var rx = attrs.rx, ry = attrs.ry;
    var squareX = (x - cx) * (x - cx);
    var squareY = (y - cy) * (y - cy);
    if (isFill && isStroke) {
      return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    if (isFill) {
      return ellipseDistance(squareX, squareY, rx, ry) <= 1;
    }
    if (isStroke) {
      return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    return false;
  };
  Ellipse2.prototype.createPath = function(context) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var rx = attrs.rx;
    var ry = attrs.ry;
    context.beginPath();
    if (context.ellipse) {
      context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
    } else {
      var r = rx > ry ? rx : ry;
      var scaleX = rx > ry ? 1 : rx / ry;
      var scaleY = rx > ry ? ry / rx : 1;
      context.save();
      context.translate(cx, cy);
      context.scale(scaleX, scaleY);
      context.arc(0, 0, r, 0, Math.PI * 2);
      context.restore();
      context.closePath();
    }
  };
  return Ellipse2;
}(ShapeBase$3);
var Ellipse$3 = Ellipse$2;
function isCanvas(dom) {
  return dom instanceof HTMLElement && isString(dom.nodeName) && dom.nodeName.toUpperCase() === "CANVAS";
}
var ImageShape = function(_super) {
  __extends$2(ImageShape2, _super);
  function ImageShape2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ImageShape2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
  };
  ImageShape2.prototype.initAttrs = function(attrs) {
    this._setImage(attrs.img);
  };
  ImageShape2.prototype.isStroke = function() {
    return false;
  };
  ImageShape2.prototype.isOnlyHitBox = function() {
    return true;
  };
  ImageShape2.prototype._afterLoading = function() {
    if (this.get("toDraw") === true) {
      var canvas = this.get("canvas");
      if (canvas) {
        canvas.draw();
      } else {
        this.createPath(this.get("context"));
      }
    }
  };
  ImageShape2.prototype._setImage = function(img) {
    var _this = this;
    var attrs = this.attrs;
    if (isString(img)) {
      var image_1 = new Image();
      image_1.onload = function() {
        if (_this.destroyed) {
          return false;
        }
        _this.attr("img", image_1);
        _this.set("loading", false);
        _this._afterLoading();
        var callback = _this.get("callback");
        if (callback) {
          callback.call(_this);
        }
      };
      image_1.crossOrigin = "Anonymous";
      image_1.src = img;
      this.set("loading", true);
    } else if (img instanceof Image) {
      if (!attrs.width) {
        attrs.width = img.width;
      }
      if (!attrs.height) {
        attrs.height = img.height;
      }
    } else if (isCanvas(img)) {
      if (!attrs.width) {
        attrs.width = Number(img.getAttribute("width"));
      }
      if (!attrs.height) {
        attrs.height, Number(img.getAttribute("height"));
      }
    }
  };
  ImageShape2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    if (name === "img") {
      this._setImage(value2);
    }
  };
  ImageShape2.prototype.createPath = function(context) {
    if (this.get("loading")) {
      this.set("toDraw", true);
      this.set("context", context);
      return;
    }
    var attrs = this.attr();
    var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height, sx = attrs.sx, sy = attrs.sy, swidth = attrs.swidth, sheight = attrs.sheight;
    var img = attrs.img;
    if (img instanceof Image || isCanvas(img)) {
      if (!isNil(sx) && !isNil(sy) && !isNil(swidth) && !isNil(sheight)) {
        context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);
      } else {
        context.drawImage(img, x, y, width, height);
      }
    }
  };
  return ImageShape2;
}(ShapeBase$3);
var ImageShape$1 = ImageShape;
function inLine(x1, y1, x2, y2, lineWidth, x, y) {
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var halfWidth = lineWidth / 2;
  if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {
    return false;
  }
  return LineUtil.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
}
var Line$4 = function(_super) {
  __extends$2(Line2, _super);
  function Line2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Line2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
  };
  Line2.prototype.initAttrs = function(attrs) {
    this.setArrow();
  };
  Line2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    this.setArrow();
  };
  Line2.prototype.setArrow = function() {
    var attrs = this.attr();
    var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
    if (startArrow) {
      addStartArrow(this, attrs, x2, y2, x1, y1);
    }
    if (endArrow) {
      addEndArrow(this, attrs, x1, y1, x2, y2);
    }
  };
  Line2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    if (!isStroke || !lineWidth) {
      return false;
    }
    var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
    return inLine(x1, y1, x2, y2, lineWidth, x, y);
  };
  Line2.prototype.createPath = function(context) {
    var attrs = this.attr();
    var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
    var startArrowDistance = {
      dx: 0,
      dy: 0
    };
    var endArrowDistance = {
      dx: 0,
      dy: 0
    };
    if (startArrow && startArrow.d) {
      startArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);
    }
    if (endArrow && endArrow.d) {
      endArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);
    }
    context.beginPath();
    context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);
    context.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);
  };
  Line2.prototype.afterDrawPath = function(context) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    if (startArrowShape) {
      startArrowShape.draw(context);
    }
    if (endArrowShape) {
      endArrowShape.draw(context);
    }
  };
  Line2.prototype.getTotalLength = function() {
    var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
    return LineUtil.length(x1, y1, x2, y2);
  };
  Line2.prototype.getPoint = function(ratio) {
    var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
    return LineUtil.pointAt(x1, y1, x2, y2, ratio);
  };
  return Line2;
}(ShapeBase$3);
var Line$5 = Line$4;
var Symbols$1 = {
  circle: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["A", r, r, 0, 1, 0, x + r, y],
      ["A", r, r, 0, 1, 0, x - r, y]
    ];
  },
  square: function(x, y, r) {
    return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
  },
  diamond: function(x, y, r) {
    return [["M", x - r, y], ["L", x, y - r], ["L", x + r, y], ["L", x, y + r], ["Z"]];
  },
  triangle: function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y + diffY], ["L", x, y - diffY], ["L", x + r, y + diffY], ["Z"]];
  },
  "triangle-down": function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y - diffY], ["L", x + r, y - diffY], ["L", x, y + diffY], ["Z"]];
  }
};
var Marker$2 = function(_super) {
  __extends$2(Marker2, _super);
  function Marker2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Marker2.prototype.initAttrs = function(attrs) {
    this._resetParamsCache();
  };
  Marker2.prototype._resetParamsCache = function() {
    this.set("paramsCache", {});
  };
  Marker2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    if (["symbol", "x", "y", "r", "radius"].indexOf(name) !== -1) {
      this._resetParamsCache();
    }
  };
  Marker2.prototype.isOnlyHitBox = function() {
    return true;
  };
  Marker2.prototype._getR = function(attrs) {
    return isNil(attrs.r) ? attrs.radius : attrs.r;
  };
  Marker2.prototype._getPath = function() {
    var attrs = this.attr();
    var x = attrs.x, y = attrs.y;
    var symbol = attrs.symbol || "circle";
    var r = this._getR(attrs);
    var method;
    var path2;
    if (isFunction(symbol)) {
      method = symbol;
      path2 = method(x, y, r);
      path2 = pathToAbsolute(path2);
    } else {
      method = Marker2.Symbols[symbol];
      if (!method) {
        console.warn(symbol + " marker is not supported.");
        return null;
      }
      path2 = method(x, y, r);
    }
    return path2;
  };
  Marker2.prototype.createPath = function(context) {
    var path2 = this._getPath();
    var paramsCache = this.get("paramsCache");
    drawPath(this, context, { path: path2 }, paramsCache);
  };
  Marker2.Symbols = Symbols$1;
  return Marker2;
}(ShapeBase$3);
var Marker$3 = Marker$2;
function isPointInPath(shape, x, y) {
  var ctx2 = getOffScreenContext$1();
  shape.createPath(ctx2);
  return ctx2.isPointInPath(x, y);
}
var tolerance = 1e-6;
function dcmp(x) {
  if (Math.abs(x) < tolerance) {
    return 0;
  }
  return x < 0 ? -1 : 1;
}
function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isInPolygon(points, x, y) {
  var isHit = false;
  var n = points.length;
  if (n <= 2) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];
    if (onSegment(p1, p2, [x, y])) {
      return true;
    }
    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
function arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
  var angle2 = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2);
  if (angle2 < startAngle || angle2 > endAngle) {
    return false;
  }
  var point2 = {
    x: cx + r * Math.cos(angle2),
    y: cy + r * Math.sin(angle2)
  };
  return distance$1(point2.x, point2.y, x, y) <= lineWidth / 2;
}
var transform$3 = transform$7;
function hasArc(path2) {
  var hasArc2 = false;
  var count = path2.length;
  for (var i = 0; i < count; i++) {
    var params = path2[i];
    var cmd = params[0];
    if (cmd === "C" || cmd === "A" || cmd === "Q") {
      hasArc2 = true;
      break;
    }
  }
  return hasArc2;
}
function isPointInStroke(segments, lineWidth, x, y, length2) {
  var isHit = false;
  var halfWidth = lineWidth / 2;
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
    if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, x, y)) {
      continue;
    }
    switch (segment.command) {
      case "L":
      case "Z":
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);
        break;
      case "Q":
        var qDistance = QuadUtil.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);
        isHit = qDistance <= lineWidth / 2;
        break;
      case "C":
        var cDistance = CubicUtil.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], x, y, length2);
        isHit = cDistance <= lineWidth / 2;
        break;
      case "A":
        var arcParams = segment.arcParams;
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;
        var p = [x, y, 1];
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        var m = transform$3(null, [
          ["t", -cx, -cy],
          ["r", -xRotation],
          ["s", 1 / scaleX, 1 / scaleY]
        ]);
        transformMat3(p, p, m);
        isHit = arc(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);
        break;
    }
    if (isHit) {
      break;
    }
  }
  return isHit;
}
function extractPolygons(path2) {
  var count = path2.length;
  var polygons = [];
  var polylines = [];
  var points = [];
  for (var i = 0; i < count; i++) {
    var params = path2[i];
    var cmd = params[0];
    if (cmd === "M") {
      if (points.length) {
        polylines.push(points);
        points = [];
      }
      points.push([params[1], params[2]]);
    } else if (cmd === "Z") {
      if (points.length) {
        polygons.push(points);
        points = [];
      }
    } else {
      points.push([params[1], params[2]]);
    }
  }
  if (points.length > 0) {
    polylines.push(points);
  }
  return {
    polygons,
    polylines
  };
}
var PathUtil = __assign$1({ hasArc, extractPolygons, isPointInStroke }, PathUtil$1);
function isInPolygons(polygons, x, y) {
  var isHit = false;
  for (var i = 0; i < polygons.length; i++) {
    var points = polygons[i];
    isHit = isInPolygon(points, x, y);
    if (isHit) {
      break;
    }
  }
  return isHit;
}
var Path$3 = function(_super) {
  __extends$2(Path2, _super);
  function Path2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Path2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { startArrow: false, endArrow: false });
  };
  Path2.prototype.initAttrs = function(attrs) {
    this._setPathArr(attrs.path);
    this.setArrow();
  };
  Path2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    if (name === "path") {
      this._setPathArr(value2);
    }
    this.setArrow();
  };
  Path2.prototype._setPathArr = function(path2) {
    this.attrs.path = pathToAbsolute(path2);
    var hasArc2 = PathUtil.hasArc(path2);
    this.set("hasArc", hasArc2);
    this.set("paramsCache", {});
    this.set("segments", null);
    this.set("curve", null);
    this.set("tCache", null);
    this.set("totalLength", null);
  };
  Path2.prototype.getSegments = function() {
    var segments = this.get("segements");
    if (!segments) {
      segments = getSegments(this.attr("path"));
      this.set("segments", segments);
    }
    return segments;
  };
  Path2.prototype.setArrow = function() {
    var attrs = this.attr();
    var startArrow = attrs.startArrow, endArrow = attrs.endArrow;
    if (startArrow) {
      var tangent = this.getStartTangent();
      addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
    }
    if (endArrow) {
      var tangent = this.getEndTangent();
      addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
    }
  };
  Path2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    var segments = this.getSegments();
    var hasArc2 = this.get("hasArc");
    var isHit = false;
    if (isStroke) {
      var length_1 = this.getTotalLength();
      isHit = PathUtil.isPointInStroke(segments, lineWidth, x, y, length_1);
    }
    if (!isHit && isFill) {
      if (hasArc2) {
        isHit = isPointInPath(this, x, y);
      } else {
        var path2 = this.attr("path");
        var extractResutl = PathUtil.extractPolygons(path2);
        isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);
      }
    }
    return isHit;
  };
  Path2.prototype.createPath = function(context) {
    var attrs = this.attr();
    var paramsCache = this.get("paramsCache");
    drawPath(this, context, attrs, paramsCache);
  };
  Path2.prototype.afterDrawPath = function(context) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    if (startArrowShape) {
      startArrowShape.draw(context);
    }
    if (endArrowShape) {
      endArrowShape.draw(context);
    }
  };
  Path2.prototype.getTotalLength = function() {
    var totalLength = this.get("totalLength");
    if (!isNil(totalLength)) {
      return totalLength;
    }
    this._calculateCurve();
    this._setTcache();
    return this.get("totalLength");
  };
  Path2.prototype.getPoint = function(ratio) {
    var tCache = this.get("tCache");
    if (!tCache) {
      this._calculateCurve();
      this._setTcache();
      tCache = this.get("tCache");
    }
    var subt;
    var index2;
    var curve = this.get("curve");
    if (!tCache || tCache.length === 0) {
      if (curve) {
        return {
          x: curve[0][1],
          y: curve[0][2]
        };
      }
      return null;
    }
    each$1(tCache, function(v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index2 = i;
      }
    });
    var seg = curve[index2];
    if (isNil(seg) || isNil(index2)) {
      return null;
    }
    var l = seg.length;
    var nextSeg = curve[index2 + 1];
    return CubicUtil.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);
  };
  Path2.prototype._calculateCurve = function() {
    var path2 = this.attr().path;
    this.set("curve", PathUtil.pathToCurve(path2));
  };
  Path2.prototype._setTcache = function() {
    var totalLength = 0;
    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    var segmentN;
    var l;
    var curve = this.get("curve");
    if (!curve) {
      return;
    }
    each$1(curve, function(segment, i) {
      segmentN = curve[i + 1];
      l = segment.length;
      if (segmentN) {
        totalLength += CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;
      }
    });
    this.set("totalLength", totalLength);
    if (totalLength === 0) {
      this.set("tCache", []);
      return;
    }
    each$1(curve, function(segment, i) {
      segmentN = curve[i + 1];
      l = segment.length;
      if (segmentN) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
        tempLength += segmentL || 0;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set("tCache", tCache);
  };
  Path2.prototype.getStartTangent = function() {
    var segments = this.getSegments();
    var result;
    if (segments.length > 1) {
      var startPoint = segments[0].currentPoint;
      var endPoint = segments[1].currentPoint;
      var tangent = segments[1].startTangent;
      result = [];
      if (tangent) {
        result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
        result.push([startPoint[0], startPoint[1]]);
      } else {
        result.push([endPoint[0], endPoint[1]]);
        result.push([startPoint[0], startPoint[1]]);
      }
    }
    return result;
  };
  Path2.prototype.getEndTangent = function() {
    var segments = this.getSegments();
    var length2 = segments.length;
    var result;
    if (length2 > 1) {
      var startPoint = segments[length2 - 2].currentPoint;
      var endPoint = segments[length2 - 1].currentPoint;
      var tangent = segments[length2 - 1].endTangent;
      result = [];
      if (tangent) {
        result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
        result.push([endPoint[0], endPoint[1]]);
      } else {
        result.push([startPoint[0], startPoint[1]]);
        result.push([endPoint[0], endPoint[1]]);
      }
    }
    return result;
  };
  return Path2;
}(ShapeBase$3);
var Path$4 = Path$3;
function inPolyline(points, lineWidth, x, y, isClose) {
  var count = points.length;
  if (count < 2) {
    return false;
  }
  for (var i = 0; i < count - 1; i++) {
    var x1 = points[i][0];
    var y1 = points[i][1];
    var x2 = points[i + 1][0];
    var y2 = points[i + 1][1];
    if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {
      return true;
    }
  }
  if (isClose) {
    var first = points[0];
    var last2 = points[count - 1];
    if (inLine(first[0], first[1], last2[0], last2[1], lineWidth, x, y)) {
      return true;
    }
  }
  return false;
}
var Polygon$3 = function(_super) {
  __extends$2(Polygon2, _super);
  function Polygon2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Polygon2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    var points = this.attr().points;
    var isHit = false;
    if (isStroke) {
      isHit = inPolyline(points, lineWidth, x, y, true);
    }
    if (!isHit && isFill) {
      isHit = isInPolygon(points, x, y);
    }
    return isHit;
  };
  Polygon2.prototype.createPath = function(context) {
    var attrs = this.attr();
    var points = attrs.points;
    if (points.length < 2) {
      return;
    }
    context.beginPath();
    for (var i = 0; i < points.length; i++) {
      var point2 = points[i];
      if (i === 0) {
        context.moveTo(point2[0], point2[1]);
      } else {
        context.lineTo(point2[0], point2[1]);
      }
    }
    context.closePath();
  };
  return Polygon2;
}(ShapeBase$3);
var Polygon$4 = Polygon$3;
var PolyLine = function(_super) {
  __extends$2(PolyLine2, _super);
  function PolyLine2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PolyLine2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { startArrow: false, endArrow: false });
  };
  PolyLine2.prototype.initAttrs = function(attrs) {
    this.setArrow();
  };
  PolyLine2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    this.setArrow();
    if (["points"].indexOf(name) !== -1) {
      this._resetCache();
    }
  };
  PolyLine2.prototype._resetCache = function() {
    this.set("totalLength", null);
    this.set("tCache", null);
  };
  PolyLine2.prototype.setArrow = function() {
    var attrs = this.attr();
    var _a2 = this.attrs, points = _a2.points, startArrow = _a2.startArrow, endArrow = _a2.endArrow;
    var length2 = points.length;
    var x1 = points[0][0];
    var y1 = points[0][1];
    var x2 = points[length2 - 1][0];
    var y2 = points[length2 - 1][1];
    if (startArrow) {
      addStartArrow(this, attrs, points[1][0], points[1][1], x1, y1);
    }
    if (endArrow) {
      addEndArrow(this, attrs, points[length2 - 2][0], points[length2 - 2][1], x2, y2);
    }
  };
  PolyLine2.prototype.isFill = function() {
    return false;
  };
  PolyLine2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    if (!isStroke || !lineWidth) {
      return false;
    }
    var points = this.attr().points;
    return inPolyline(points, lineWidth, x, y, false);
  };
  PolyLine2.prototype.isStroke = function() {
    return true;
  };
  PolyLine2.prototype.createPath = function(context) {
    var _a2 = this.attr(), points = _a2.points, startArrow = _a2.startArrow, endArrow = _a2.endArrow;
    var length2 = points.length;
    if (points.length < 2) {
      return;
    }
    var x1 = points[0][0];
    var y1 = points[0][1];
    var x2 = points[length2 - 1][0];
    var y2 = points[length2 - 1][1];
    if (startArrow && startArrow.d) {
      var distance2 = getShortenOffset(x1, y1, points[1][0], points[1][1], startArrow.d);
      x1 += distance2.dx;
      y1 += distance2.dy;
    }
    if (endArrow && endArrow.d) {
      var distance2 = getShortenOffset(points[length2 - 2][0], points[length2 - 2][1], x2, y2, endArrow.d);
      x2 -= distance2.dx;
      y2 -= distance2.dy;
    }
    context.beginPath();
    context.moveTo(x1, y1);
    for (var i = 0; i < length2 - 1; i++) {
      var point2 = points[i];
      context.lineTo(point2[0], point2[1]);
    }
    context.lineTo(x2, y2);
  };
  PolyLine2.prototype.afterDrawPath = function(context) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    if (startArrowShape) {
      startArrowShape.draw(context);
    }
    if (endArrowShape) {
      endArrowShape.draw(context);
    }
  };
  PolyLine2.prototype.getTotalLength = function() {
    var points = this.attr().points;
    var totalLength = this.get("totalLength");
    if (!isNil(totalLength)) {
      return totalLength;
    }
    this.set("totalLength", PolylineUtil.length(points));
    return this.get("totalLength");
  };
  PolyLine2.prototype.getPoint = function(ratio) {
    var points = this.attr().points;
    var tCache = this.get("tCache");
    if (!tCache) {
      this._setTcache();
      tCache = this.get("tCache");
    }
    var subt;
    var index2;
    each$1(tCache, function(v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index2 = i;
      }
    });
    return LineUtil.pointAt(points[index2][0], points[index2][1], points[index2 + 1][0], points[index2 + 1][1], subt);
  };
  PolyLine2.prototype._setTcache = function() {
    var points = this.attr().points;
    if (!points || points.length === 0) {
      return;
    }
    var totalLength = this.getTotalLength();
    if (totalLength <= 0) {
      return;
    }
    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    each$1(points, function(p, i) {
      if (points[i + 1]) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = LineUtil.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
        tempLength += segmentL;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set("tCache", tCache);
  };
  PolyLine2.prototype.getStartTangent = function() {
    var points = this.attr().points;
    var result = [];
    result.push([points[1][0], points[1][1]]);
    result.push([points[0][0], points[0][1]]);
    return result;
  };
  PolyLine2.prototype.getEndTangent = function() {
    var points = this.attr().points;
    var l = points.length - 1;
    var result = [];
    result.push([points[l - 1][0], points[l - 1][1]]);
    result.push([points[l][0], points[l][1]]);
    return result;
  };
  return PolyLine2;
}(ShapeBase$3);
var PolyLine$1 = PolyLine;
function inRect(minX, minY, width, height, lineWidth, x, y) {
  var halfWidth = lineWidth / 2;
  return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y);
}
function rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y) {
  return inLine(minX + radius, minY, minX + width - radius, minY, lineWidth, x, y) || inLine(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x, y) || inLine(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x, y) || inLine(minX, minY + height - radius, minX, minY + radius, lineWidth, x, y) || arc(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) || arc(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x, y) || arc(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x, y) || arc(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x, y);
}
var Rect$3 = function(_super) {
  __extends$2(Rect2, _super);
  function Rect2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rect2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
  };
  Rect2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var minX = attrs.x;
    var minY = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var radius = attrs.radius;
    if (!radius) {
      var halfWidth = lineWidth / 2;
      if (isFill && isStroke) {
        return inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);
      }
      if (isFill) {
        return inBox(minX, minY, width, height, x, y);
      }
      if (isStroke) {
        return inRect(minX, minY, width, height, lineWidth, x, y);
      }
    } else {
      var isHit = false;
      if (isStroke) {
        isHit = rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y);
      }
      if (!isHit && isFill) {
        isHit = isPointInPath(this, x, y);
      }
      return isHit;
    }
  };
  Rect2.prototype.createPath = function(context) {
    var attrs = this.attr();
    var x = attrs.x;
    var y = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var radius = attrs.radius;
    context.beginPath();
    if (radius === 0) {
      context.rect(x, y, width, height);
    } else {
      var _a2 = parseRadius$2(radius), r1 = _a2[0], r2 = _a2[1], r3 = _a2[2], r4 = _a2[3];
      context.moveTo(x + r1, y);
      context.lineTo(x + width - r2, y);
      r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
      context.lineTo(x + width, y + height - r3);
      r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
      context.lineTo(x + r4, y + height);
      r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
      context.lineTo(x, y + r1);
      r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
      context.closePath();
    }
  };
  return Rect2;
}(ShapeBase$3);
var Rect$4 = Rect$3;
var Text$2 = function(_super) {
  __extends$2(Text2, _super);
  function Text2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Text2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
  };
  Text2.prototype.isOnlyHitBox = function() {
    return true;
  };
  Text2.prototype.initAttrs = function(attrs) {
    this._assembleFont();
    if (attrs.text) {
      this._setText(attrs.text);
    }
  };
  Text2.prototype._assembleFont = function() {
    var attrs = this.attrs;
    attrs.font = assembleFont$1(attrs);
  };
  Text2.prototype._setText = function(text2) {
    var textArr = null;
    if (isString(text2) && text2.indexOf("\n") !== -1) {
      textArr = text2.split("\n");
    }
    this.set("textArr", textArr);
  };
  Text2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    if (name.startsWith("font")) {
      this._assembleFont();
    }
    if (name === "text") {
      this._setText(value2);
    }
  };
  Text2.prototype._getSpaceingY = function() {
    var attrs = this.attrs;
    var lineHeight = attrs.lineHeight;
    var fontSize = attrs.fontSize * 1;
    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
  };
  Text2.prototype._drawTextArr = function(context, textArr, isFill) {
    var attrs = this.attrs;
    var textBaseline = attrs.textBaseline;
    var x = attrs.x;
    var y = attrs.y;
    var fontSize = attrs.fontSize * 1;
    var spaceingY = this._getSpaceingY();
    var height = getTextHeight$1(attrs.text, attrs.fontSize, attrs.lineHeight);
    var subY;
    each$1(textArr, function(subText, index2) {
      subY = y + index2 * (spaceingY + fontSize) - height + fontSize;
      if (textBaseline === "middle")
        subY += height - fontSize - (height - fontSize) / 2;
      if (textBaseline === "top")
        subY += height - fontSize;
      if (!isNil(subText)) {
        if (isFill) {
          context.fillText(subText, x, subY);
        } else {
          context.strokeText(subText, x, subY);
        }
      }
    });
  };
  Text2.prototype._drawText = function(context, isFill) {
    var attrs = this.attr();
    var x = attrs.x;
    var y = attrs.y;
    var textArr = this.get("textArr");
    if (textArr) {
      this._drawTextArr(context, textArr, isFill);
    } else {
      var text2 = attrs.text;
      if (!isNil(text2)) {
        if (isFill) {
          context.fillText(text2, x, y);
        } else {
          context.strokeText(text2, x, y);
        }
      }
    }
  };
  Text2.prototype.strokeAndFill = function(context) {
    var _a2 = this.attrs, lineWidth = _a2.lineWidth, opacity = _a2.opacity, strokeOpacity = _a2.strokeOpacity, fillOpacity = _a2.fillOpacity;
    if (this.isStroke()) {
      if (lineWidth > 0) {
        if (!isNil(strokeOpacity) && strokeOpacity !== 1) {
          context.globalAlpha = opacity;
        }
        this.stroke(context);
      }
    }
    if (this.isFill()) {
      if (!isNil(fillOpacity) && fillOpacity !== 1) {
        context.globalAlpha = fillOpacity;
        this.fill(context);
        context.globalAlpha = opacity;
      } else {
        this.fill(context);
      }
    }
    this.afterDrawPath(context);
  };
  Text2.prototype.fill = function(context) {
    this._drawText(context, true);
  };
  Text2.prototype.stroke = function(context) {
    this._drawText(context, false);
  };
  return Text2;
}(ShapeBase$3);
var Text$3 = Text$2;
function invertFromMatrix(v, matrix) {
  if (matrix) {
    var invertMatrix = invert$1(matrix);
    return multiplyVec2$2(invertMatrix, v);
  }
  return v;
}
function getRefXY(element, x, y) {
  var totalMatrix = element.getTotalMatrix();
  if (totalMatrix) {
    var _a2 = invertFromMatrix([x, y, 1], totalMatrix), refX = _a2[0], refY = _a2[1];
    return [refX, refY];
  }
  return [x, y];
}
function preTest(element, x, y) {
  if (element.isCanvas && element.isCanvas()) {
    return true;
  }
  if (!isAllowCapture$1(element) || element.cfg.isInView === false) {
    return false;
  }
  if (element.cfg.clipShape) {
    var _a2 = getRefXY(element, x, y), refX = _a2[0], refY = _a2[1];
    if (element.isClipped(refX, refY)) {
      return false;
    }
  }
  var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();
  if (!(x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY)) {
    return false;
  }
  return true;
}
function getShape(container, x, y) {
  if (!preTest(container, x, y)) {
    return null;
  }
  var shape = null;
  var children = container.getChildren();
  var count = children.length;
  for (var i = count - 1; i >= 0; i--) {
    var child = children[i];
    if (child.isGroup()) {
      shape = getShape(child, x, y);
    } else if (preTest(child, x, y)) {
      var curShape = child;
      var _a2 = getRefXY(child, x, y), refX = _a2[0], refY = _a2[1];
      if (curShape.isInShape(refX, refY)) {
        shape = child;
      }
    }
    if (shape) {
      break;
    }
  }
  return shape;
}
var Canvas$1 = function(_super) {
  __extends$2(Canvas2, _super);
  function Canvas2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Canvas2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg["renderer"] = "canvas";
    cfg["autoDraw"] = true;
    cfg["localRefresh"] = true;
    cfg["refreshElements"] = [];
    cfg["clipView"] = true;
    cfg["quickHit"] = false;
    return cfg;
  };
  Canvas2.prototype.onCanvasChange = function(changeType) {
    if (changeType === "attr" || changeType === "sort" || changeType === "changeSize") {
      this.set("refreshElements", [this]);
      this.draw();
    }
  };
  Canvas2.prototype.getShapeBase = function() {
    return Shape$1;
  };
  Canvas2.prototype.getGroupBase = function() {
    return Group$1;
  };
  Canvas2.prototype.getPixelRatio = function() {
    var pixelRatio = this.get("pixelRatio") || getPixelRatio$1();
    return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;
  };
  Canvas2.prototype.getViewRange = function() {
    return {
      minX: 0,
      minY: 0,
      maxX: this.cfg.width,
      maxY: this.cfg.height
    };
  };
  Canvas2.prototype.createDom = function() {
    var element = document.createElement("canvas");
    var context = element.getContext("2d");
    this.set("context", context);
    return element;
  };
  Canvas2.prototype.setDOMSize = function(width, height) {
    _super.prototype.setDOMSize.call(this, width, height);
    var context = this.get("context");
    var el = this.get("el");
    var pixelRatio = this.getPixelRatio();
    el.width = pixelRatio * width;
    el.height = pixelRatio * height;
    if (pixelRatio > 1) {
      context.scale(pixelRatio, pixelRatio);
    }
  };
  Canvas2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this._clearFrame();
    var context = this.get("context");
    var element = this.get("el");
    context.clearRect(0, 0, element.width, element.height);
  };
  Canvas2.prototype.getShape = function(x, y) {
    var shape;
    if (this.get("quickHit")) {
      shape = getShape(this, x, y);
    } else {
      shape = _super.prototype.getShape.call(this, x, y, null);
    }
    return shape;
  };
  Canvas2.prototype._getRefreshRegion = function() {
    var elements = this.get("refreshElements");
    var viewRegion = this.getViewRange();
    var region;
    if (elements.length && elements[0] === this) {
      region = viewRegion;
    } else {
      region = getMergedRegion(elements);
      if (region) {
        region.minX = Math.floor(region.minX);
        region.minY = Math.floor(region.minY);
        region.maxX = Math.ceil(region.maxX);
        region.maxY = Math.ceil(region.maxY);
        region.maxY += 1;
        var clipView = this.get("clipView");
        if (clipView) {
          region = mergeView(region, viewRegion);
        }
      }
    }
    return region;
  };
  Canvas2.prototype.refreshElement = function(element) {
    var refreshElements = this.get("refreshElements");
    refreshElements.push(element);
  };
  Canvas2.prototype._clearFrame = function() {
    var drawFrame = this.get("drawFrame");
    if (drawFrame) {
      cancelAnimationFrame(drawFrame);
      this.set("drawFrame", null);
      this.set("refreshElements", []);
    }
  };
  Canvas2.prototype.draw = function() {
    var drawFrame = this.get("drawFrame");
    if (this.get("autoDraw") && drawFrame) {
      return;
    }
    this._startDraw();
  };
  Canvas2.prototype._drawAll = function() {
    var context = this.get("context");
    var element = this.get("el");
    var children = this.getChildren();
    context.clearRect(0, 0, element.width, element.height);
    applyAttrsToContext(context, this);
    drawChildren$1(context, children);
    this.set("refreshElements", []);
  };
  Canvas2.prototype._drawRegion = function() {
    var context = this.get("context");
    var refreshElements = this.get("refreshElements");
    var children = this.getChildren();
    var region = this._getRefreshRegion();
    if (region) {
      context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
      context.save();
      context.beginPath();
      context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
      context.clip();
      applyAttrsToContext(context, this);
      checkRefresh(this, children, region);
      drawChildren$1(context, children, region);
      context.restore();
    } else if (refreshElements.length) {
      clearChanged(refreshElements);
    }
    each$1(refreshElements, function(element) {
      if (element.get("hasChanged")) {
        element.set("hasChanged", false);
      }
    });
    this.set("refreshElements", []);
  };
  Canvas2.prototype._startDraw = function() {
    var _this = this;
    var drawFrame = this.get("drawFrame");
    if (!drawFrame) {
      drawFrame = requestAnimationFrame(function() {
        if (_this.get("localRefresh")) {
          _this._drawRegion();
        } else {
          _this._drawAll();
        }
        _this.set("drawFrame", null);
      });
      this.set("drawFrame", drawFrame);
    }
  };
  Canvas2.prototype.skipDraw = function() {
  };
  Canvas2.prototype.removeDom = function() {
    var el = this.get("el");
    el.width = 0;
    el.height = 0;
    el.parentNode.removeChild(el);
  };
  return Canvas2;
}(Canvas$2);
var version$1 = "0.5.12";
var CanvasEngine = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  Shape: Shape$1,
  version: version$1,
  Canvas: Canvas$1,
  Group: Group$1,
  getArcParams,
  Event: GraphEvent$1,
  Base: Base$1,
  AbstractCanvas: Canvas$2,
  AbstractGroup,
  AbstractShape,
  getBBoxMethod: getMethod,
  getTextHeight: getTextHeight$1,
  assembleFont: assembleFont$1,
  isAllowCapture: isAllowCapture$1,
  multiplyVec2: multiplyVec2$2,
  invert: invert$1,
  getOffScreenContext: getOffScreenContext$1,
  PathUtil: PathUtil$1
});
var SHAPE_TO_TAGS = {
  rect: "path",
  circle: "circle",
  line: "line",
  path: "path",
  marker: "path",
  text: "text",
  polyline: "polyline",
  polygon: "polygon",
  image: "image",
  ellipse: "ellipse",
  dom: "foreignObject"
};
var SVG_ATTR_MAP = {
  opacity: "opacity",
  fillStyle: "fill",
  fill: "fill",
  fillOpacity: "fill-opacity",
  strokeStyle: "stroke",
  strokeOpacity: "stroke-opacity",
  stroke: "stroke",
  x: "x",
  y: "y",
  r: "r",
  rx: "rx",
  ry: "ry",
  width: "width",
  height: "height",
  x1: "x1",
  x2: "x2",
  y1: "y1",
  y2: "y2",
  lineCap: "stroke-linecap",
  lineJoin: "stroke-linejoin",
  lineWidth: "stroke-width",
  lineDash: "stroke-dasharray",
  lineDashOffset: "stroke-dashoffset",
  miterLimit: "stroke-miterlimit",
  font: "font",
  fontSize: "font-size",
  fontStyle: "font-style",
  fontVariant: "font-variant",
  fontWeight: "font-weight",
  fontFamily: "font-family",
  startArrow: "marker-start",
  endArrow: "marker-end",
  path: "d",
  class: "class",
  id: "id",
  style: "style",
  preserveAspectRatio: "preserveAspectRatio"
};
function createSVGElement(type) {
  return document.createElementNS("http://www.w3.org/2000/svg", type);
}
function createDom(shape) {
  var type = SHAPE_TO_TAGS[shape.type];
  var parent = shape.getParent();
  if (!type) {
    throw new Error("the type " + shape.type + " is not supported by svg");
  }
  var element = createSVGElement(type);
  if (shape.get("id")) {
    element.id = shape.get("id");
  }
  shape.set("el", element);
  shape.set("attrs", {});
  if (parent) {
    var parentNode = parent.get("el");
    if (parentNode) {
      parentNode.appendChild(element);
    } else {
      parentNode = parent.createDom();
      parent.set("el", parentNode);
      parentNode.appendChild(element);
    }
  }
  return element;
}
function sortDom(element, sorter) {
  var el = element.get("el");
  var childList = toArray(el.children).sort(sorter);
  var fragment = document.createDocumentFragment();
  childList.forEach(function(child) {
    fragment.appendChild(child);
  });
  el.appendChild(fragment);
}
function moveTo(element, targetIndex) {
  var parentNode = element.parentNode;
  var siblings = Array.from(parentNode.childNodes).filter(function(node) {
    return node.nodeType === 1 && node.nodeName.toLowerCase() !== "defs";
  });
  var target = siblings[targetIndex];
  var currentIndex = siblings.indexOf(element);
  if (target) {
    if (currentIndex > targetIndex) {
      parentNode.insertBefore(element, target);
    } else if (currentIndex < targetIndex) {
      var targetNext = siblings[targetIndex + 1];
      if (targetNext) {
        parentNode.insertBefore(element, targetNext);
      } else {
        parentNode.appendChild(element);
      }
    }
  } else {
    parentNode.appendChild(element);
  }
}
function setShadow(model, context) {
  var el = model.cfg.el;
  var attrs = model.attr();
  var cfg = {
    dx: attrs.shadowOffsetX,
    dy: attrs.shadowOffsetY,
    blur: attrs.shadowBlur,
    color: attrs.shadowColor
  };
  if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
    el.removeAttribute("filter");
  } else {
    var id = context.find("filter", cfg);
    if (!id) {
      id = context.addShadow(cfg);
    }
    el.setAttribute("filter", "url(#" + id + ")");
  }
}
function setTransform(model) {
  var matrix = model.attr().matrix;
  if (matrix) {
    var el = model.cfg.el;
    var transform2 = [];
    for (var i = 0; i < 9; i += 3) {
      transform2.push(matrix[i] + "," + matrix[i + 1]);
    }
    transform2 = transform2.join(",");
    if (transform2.indexOf("NaN") === -1) {
      el.setAttribute("transform", "matrix(" + transform2 + ")");
    } else {
      console.warn("invalid matrix:", matrix);
    }
  }
}
function setClip(model, context) {
  var clip = model.getClip();
  var el = model.get("el");
  if (!clip) {
    el.removeAttribute("clip-path");
  } else if (clip && !el.hasAttribute("clip-path")) {
    createDom(clip);
    clip.createPath(context);
    var id = context.addClip(clip);
    el.setAttribute("clip-path", "url(#" + id + ")");
  }
}
function drawChildren(context, children) {
  children.forEach(function(child) {
    child.draw(context);
  });
}
function refreshElement(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas && canvas.get("autoDraw")) {
    var context = canvas.get("context");
    var parent_1 = element.getParent();
    var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
    var el = element.get("el");
    if (changeType === "remove") {
      var isClipShape = element.get("isClipShape");
      if (isClipShape) {
        var clipPathEl = el && el.parentNode;
        var defsEl = clipPathEl && clipPathEl.parentNode;
        if (clipPathEl && defsEl) {
          defsEl.removeChild(clipPathEl);
        }
      } else if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    } else if (changeType === "show") {
      el.setAttribute("visibility", "visible");
    } else if (changeType === "hide") {
      el.setAttribute("visibility", "hidden");
    } else if (changeType === "zIndex") {
      moveTo(el, parentChildren.indexOf(element));
    } else if (changeType === "sort") {
      var children_1 = element.get("children");
      if (children_1 && children_1.length) {
        sortDom(element, function(a, b) {
          return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
        });
      }
    } else if (changeType === "clear") {
      if (el) {
        el.innerHTML = "";
      }
    } else if (changeType === "matrix") {
      setTransform(element);
    } else if (changeType === "clip") {
      setClip(element, context);
    } else if (changeType === "attr")
      ;
    else if (changeType === "add") {
      element.draw(context);
    }
  }
}
var Group = function(_super) {
  __extends$2(Group2, _super);
  function Group2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Group2.prototype.isEntityGroup = function() {
    return true;
  };
  Group2.prototype.createDom = function() {
    var element = createSVGElement("g");
    this.set("el", element);
    var parent = this.getParent();
    if (parent) {
      var parentNode = parent.get("el");
      if (parentNode) {
        parentNode.appendChild(element);
      } else {
        parentNode = parent.createDom();
        parent.set("el", parentNode);
        parentNode.appendChild(element);
      }
    }
    return element;
  };
  Group2.prototype.afterAttrsChange = function(targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    var canvas = this.get("canvas");
    if (canvas && canvas.get("autoDraw")) {
      var context = canvas.get("context");
      this.createPath(context, targetAttrs);
    }
  };
  Group2.prototype.onCanvasChange = function(changeType) {
    refreshElement(this, changeType);
  };
  Group2.prototype.getShapeBase = function() {
    return Shape;
  };
  Group2.prototype.getGroupBase = function() {
    return Group2;
  };
  Group2.prototype.draw = function(context) {
    var children = this.getChildren();
    var el = this.get("el");
    if (this.get("destroyed")) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        this.createDom();
      }
      setClip(this, context);
      this.createPath(context);
      if (children.length) {
        drawChildren(context, children);
      }
    }
  };
  Group2.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
    setTransform(this);
  };
  return Group2;
}(AbstractGroup);
var ShapeBase = function(_super) {
  __extends$2(ShapeBase2, _super);
  function ShapeBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "svg";
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }
  ShapeBase2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
  };
  ShapeBase2.prototype.afterAttrsChange = function(targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    var canvas = this.get("canvas");
    if (canvas && canvas.get("autoDraw")) {
      var context = canvas.get("context");
      this.draw(context, targetAttrs);
    }
  };
  ShapeBase2.prototype.getShapeBase = function() {
    return Shape;
  };
  ShapeBase2.prototype.getGroupBase = function() {
    return Group;
  };
  ShapeBase2.prototype.onCanvasChange = function(changeType) {
    refreshElement(this, changeType);
  };
  ShapeBase2.prototype.calculateBBox = function() {
    var el = this.get("el");
    var bbox = null;
    if (el) {
      bbox = el.getBBox();
    } else {
      var bboxMethod = getMethod(this.get("type"));
      if (bboxMethod) {
        bbox = bboxMethod(this);
      }
    }
    if (bbox) {
      var x = bbox.x, y = bbox.y, width = bbox.width, height = bbox.height;
      var lineWidth = this.getHitLineWidth();
      var halfWidth = lineWidth / 2;
      var minX = x - halfWidth;
      var minY = y - halfWidth;
      var maxX = x + width + halfWidth;
      var maxY = y + height + halfWidth;
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: width + lineWidth,
        height: height + lineWidth
      };
    }
    return {
      x: 0,
      y: 0,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    };
  };
  ShapeBase2.prototype.isFill = function() {
    var _a2 = this.attr(), fill = _a2.fill, fillStyle = _a2.fillStyle;
    return (fill || fillStyle || this.isClipShape()) && this.canFill;
  };
  ShapeBase2.prototype.isStroke = function() {
    var _a2 = this.attr(), stroke = _a2.stroke, strokeStyle = _a2.strokeStyle;
    return (stroke || strokeStyle) && this.canStroke;
  };
  ShapeBase2.prototype.draw = function(context, targetAttrs) {
    var el = this.get("el");
    if (this.get("destroyed")) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        createDom(this);
      }
      setClip(this, context);
      this.createPath(context, targetAttrs);
      this.shadow(context, targetAttrs);
      this.strokeAndFill(context, targetAttrs);
      this.transform(targetAttrs);
    }
  };
  ShapeBase2.prototype.createPath = function(context, targetAttrs) {
  };
  ShapeBase2.prototype.strokeAndFill = function(context, targetAttrs) {
    var attrs = targetAttrs || this.attr();
    var fill = attrs.fill, fillStyle = attrs.fillStyle, stroke = attrs.stroke, strokeStyle = attrs.strokeStyle, fillOpacity = attrs.fillOpacity, strokeOpacity = attrs.strokeOpacity, lineWidth = attrs.lineWidth;
    var el = this.get("el");
    if (this.canFill) {
      if (!targetAttrs) {
        this._setColor(context, "fill", fill || fillStyle);
      } else if ("fill" in attrs) {
        this._setColor(context, "fill", fill);
      } else if ("fillStyle" in attrs) {
        this._setColor(context, "fill", fillStyle);
      }
      if (fillOpacity) {
        el.setAttribute(SVG_ATTR_MAP["fillOpacity"], fillOpacity);
      }
    }
    if (this.canStroke && lineWidth > 0) {
      if (!targetAttrs) {
        this._setColor(context, "stroke", stroke || strokeStyle);
      } else if ("stroke" in attrs) {
        this._setColor(context, "stroke", stroke);
      } else if ("strokeStyle" in attrs) {
        this._setColor(context, "stroke", strokeStyle);
      }
      if (strokeOpacity) {
        el.setAttribute(SVG_ATTR_MAP["strokeOpacity"], strokeOpacity);
      }
      if (lineWidth) {
        el.setAttribute(SVG_ATTR_MAP["lineWidth"], lineWidth);
      }
    }
  };
  ShapeBase2.prototype._setColor = function(context, attr, value2) {
    var el = this.get("el");
    if (!value2) {
      el.setAttribute(SVG_ATTR_MAP[attr], "none");
      return;
    }
    value2 = value2.trim();
    if (/^[r,R,L,l]{1}[\s]*\(/.test(value2)) {
      var id = context.find("gradient", value2);
      if (!id) {
        id = context.addGradient(value2);
      }
      el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
    } else if (/^[p,P]{1}[\s]*\(/.test(value2)) {
      var id = context.find("pattern", value2);
      if (!id) {
        id = context.addPattern(value2);
      }
      el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
    } else {
      el.setAttribute(SVG_ATTR_MAP[attr], value2);
    }
  };
  ShapeBase2.prototype.shadow = function(context, targetAttrs) {
    var attrs = this.attr();
    var _a2 = targetAttrs || attrs, shadowOffsetX = _a2.shadowOffsetX, shadowOffsetY = _a2.shadowOffsetY, shadowBlur = _a2.shadowBlur, shadowColor = _a2.shadowColor;
    if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
      setShadow(this, context);
    }
  };
  ShapeBase2.prototype.transform = function(targetAttrs) {
    var attrs = this.attr();
    var matrix = (targetAttrs || attrs).matrix;
    if (matrix) {
      setTransform(this);
    }
  };
  ShapeBase2.prototype.isInShape = function(refX, refY) {
    return this.isPointInPath(refX, refY);
  };
  ShapeBase2.prototype.isPointInPath = function(refX, refY) {
    var el = this.get("el");
    var canvas = this.get("canvas");
    var bbox = canvas.get("el").getBoundingClientRect();
    var clientX = refX + bbox.left;
    var clientY = refY + bbox.top;
    var element = document.elementFromPoint(clientX, clientY);
    if (element && element.isEqualNode(el)) {
      return true;
    }
    return false;
  };
  ShapeBase2.prototype.getHitLineWidth = function() {
    var _a2 = this.attrs, lineWidth = _a2.lineWidth, lineAppendWidth = _a2.lineAppendWidth;
    if (this.isStroke()) {
      return lineWidth + lineAppendWidth;
    }
    return 0;
  };
  return ShapeBase2;
}(AbstractShape);
var ShapeBase$1 = ShapeBase;
var Circle$1 = function(_super) {
  __extends$2(Circle2, _super);
  function Circle2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "circle";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Circle2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, r: 0 });
  };
  Circle2.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "x" || attr === "y") {
        el.setAttribute("c" + attr, value2);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  return Circle2;
}(ShapeBase$1);
var Circle$2 = Circle$1;
var Dom = function(_super) {
  __extends$2(Dom2, _super);
  function Dom2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "dom";
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }
  Dom2.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
    if (typeof attrs["html"] === "function") {
      var element = attrs["html"].call(this, attrs);
      if (element instanceof Element || element instanceof HTMLDocument) {
        var children = el.childNodes;
        for (var i = children.length - 1; i >= 0; i--) {
          el.removeChild(children[i]);
        }
        el.appendChild(element);
      } else {
        el.innerHTML = element;
      }
    } else {
      el.innerHTML = attrs["html"];
    }
  };
  return Dom2;
}(ShapeBase$1);
var Dom$1 = Dom;
var Ellipse = function(_super) {
  __extends$2(Ellipse2, _super);
  function Ellipse2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "ellipse";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Ellipse2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
  };
  Ellipse2.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "x" || attr === "y") {
        el.setAttribute("c" + attr, value2);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  return Ellipse2;
}(ShapeBase$1);
var Ellipse$1 = Ellipse;
var Image$1 = function(_super) {
  __extends$2(Image2, _super);
  function Image2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "image";
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }
  Image2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
  };
  Image2.prototype.createPath = function(context, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "img") {
        _this._setImage(attrs.img);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  Image2.prototype.setAttr = function(name, value2) {
    this.attrs[name] = value2;
    if (name === "img") {
      this._setImage(value2);
    }
  };
  Image2.prototype._setImage = function(img) {
    var attrs = this.attr();
    var el = this.get("el");
    if (isString(img)) {
      el.setAttribute("href", img);
    } else if (img instanceof window.Image) {
      if (!attrs.width) {
        el.setAttribute("width", img.width);
        this.attr("width", img.width);
      }
      if (!attrs.height) {
        el.setAttribute("height", img.height);
        this.attr("height", img.height);
      }
      el.setAttribute("href", img.src);
    } else if (img instanceof HTMLElement && isString(img.nodeName) && img.nodeName.toUpperCase() === "CANVAS") {
      el.setAttribute("href", img.toDataURL());
    } else if (img instanceof ImageData) {
      var canvas = document.createElement("canvas");
      canvas.setAttribute("width", "" + img.width);
      canvas.setAttribute("height", "" + img.height);
      canvas.getContext("2d").putImageData(img, 0, 0);
      if (!attrs.width) {
        el.setAttribute("width", "" + img.width);
        this.attr("width", img.width);
      }
      if (!attrs.height) {
        el.setAttribute("height", "" + img.height);
        this.attr("height", img.height);
      }
      el.setAttribute("href", canvas.toDataURL());
    }
  };
  return Image2;
}(ShapeBase$1);
var Image$2 = Image$1;
var Line$2 = function(_super) {
  __extends$2(Line2, _super);
  function Line2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "line";
    _this.canFill = false;
    _this.canStroke = true;
    return _this;
  }
  Line2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
  };
  Line2.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "startArrow" || attr === "endArrow") {
        if (value2) {
          var id = isObject(value2) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
          el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
        } else {
          el.removeAttribute(SVG_ATTR_MAP[attr]);
        }
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  Line2.prototype.getTotalLength = function() {
    var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
    return LineUtil.length(x1, y1, x2, y2);
  };
  Line2.prototype.getPoint = function(ratio) {
    var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
    return LineUtil.pointAt(x1, y1, x2, y2, ratio);
  };
  return Line2;
}(ShapeBase$1);
var Line$3 = Line$2;
var Symbols = {
  circle: function(x, y, r) {
    return [
      ["M", x, y],
      ["m", -r, 0],
      ["a", r, r, 0, 1, 0, r * 2, 0],
      ["a", r, r, 0, 1, 0, -r * 2, 0]
    ];
  },
  square: function(x, y, r) {
    return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
  },
  diamond: function(x, y, r) {
    return [["M", x - r, y], ["L", x, y - r], ["L", x + r, y], ["L", x, y + r], ["Z"]];
  },
  triangle: function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y + diffY], ["L", x, y - diffY], ["L", x + r, y + diffY], ["z"]];
  },
  triangleDown: function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y - diffY], ["L", x + r, y - diffY], ["L", x, y + diffY], ["Z"]];
  }
};
var symbolsFactory = {
  get: function(type) {
    return Symbols[type];
  },
  register: function(type, func) {
    Symbols[type] = func;
  },
  remove: function(type) {
    delete Symbols[type];
  },
  getAll: function() {
    return Symbols;
  }
};
var Marker = function(_super) {
  __extends$2(Marker2, _super);
  function Marker2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "marker";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Marker2.prototype.createPath = function(context) {
    var el = this.get("el");
    el.setAttribute("d", this._assembleMarker());
  };
  Marker2.prototype._assembleMarker = function() {
    var d = this._getPath();
    if (isArray$1(d)) {
      return d.map(function(path2) {
        return path2.join(" ");
      }).join("");
    }
    return d;
  };
  Marker2.prototype._getPath = function() {
    var attrs = this.attr();
    var x = attrs.x, y = attrs.y;
    var r = attrs.r || attrs.radius;
    var symbol = attrs.symbol || "circle";
    var method;
    if (isFunction(symbol)) {
      method = symbol;
    } else {
      method = symbolsFactory.get(symbol);
    }
    if (!method) {
      console.warn(method + " symbol is not exist.");
      return null;
    }
    return method(x, y, r);
  };
  Marker2.symbolsFactory = symbolsFactory;
  return Marker2;
}(ShapeBase$1);
var Marker$1 = Marker;
var Path$1 = function(_super) {
  __extends$2(Path2, _super);
  function Path2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "path";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Path2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { startArrow: false, endArrow: false });
  };
  Path2.prototype.createPath = function(context, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "path" && isArray$1(value2)) {
        el.setAttribute("d", _this._formatPath(value2));
      } else if (attr === "startArrow" || attr === "endArrow") {
        if (value2) {
          var id = isObject(value2) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
          el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
        } else {
          el.removeAttribute(SVG_ATTR_MAP[attr]);
        }
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  Path2.prototype._formatPath = function(value2) {
    var newValue = value2.map(function(path2) {
      return path2.join(" ");
    }).join("");
    if (~newValue.indexOf("NaN")) {
      return "";
    }
    return newValue;
  };
  Path2.prototype.getTotalLength = function() {
    var el = this.get("el");
    return el ? el.getTotalLength() : null;
  };
  Path2.prototype.getPoint = function(ratio) {
    var el = this.get("el");
    var totalLength = this.getTotalLength();
    if (totalLength === 0) {
      return null;
    }
    var point2 = el ? el.getPointAtLength(ratio * totalLength) : null;
    return point2 ? {
      x: point2.x,
      y: point2.y
    } : null;
  };
  return Path2;
}(ShapeBase$1);
var Path$2 = Path$1;
var Polygon$1 = function(_super) {
  __extends$2(Polygon2, _super);
  function Polygon2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "polygon";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Polygon2.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "points" && isArray$1(value2) && value2.length >= 2) {
        el.setAttribute("points", value2.map(function(point2) {
          return point2[0] + "," + point2[1];
        }).join(" "));
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  return Polygon2;
}(ShapeBase$1);
var Polygon$2 = Polygon$1;
var Polyline = function(_super) {
  __extends$2(Polyline2, _super);
  function Polyline2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "polyline";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Polyline2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { startArrow: false, endArrow: false });
  };
  Polyline2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    if (["points"].indexOf(name) !== -1) {
      this._resetCache();
    }
  };
  Polyline2.prototype._resetCache = function() {
    this.set("totalLength", null);
    this.set("tCache", null);
  };
  Polyline2.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "points" && isArray$1(value2) && value2.length >= 2) {
        el.setAttribute("points", value2.map(function(point2) {
          return point2[0] + "," + point2[1];
        }).join(" "));
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  Polyline2.prototype.getTotalLength = function() {
    var points = this.attr().points;
    var totalLength = this.get("totalLength");
    if (!isNil(totalLength)) {
      return totalLength;
    }
    this.set("totalLength", PolylineUtil.length(points));
    return this.get("totalLength");
  };
  Polyline2.prototype.getPoint = function(ratio) {
    var points = this.attr().points;
    var tCache = this.get("tCache");
    if (!tCache) {
      this._setTcache();
      tCache = this.get("tCache");
    }
    var subt;
    var index2;
    each$1(tCache, function(v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index2 = i;
      }
    });
    return LineUtil.pointAt(points[index2][0], points[index2][1], points[index2 + 1][0], points[index2 + 1][1], subt);
  };
  Polyline2.prototype._setTcache = function() {
    var points = this.attr().points;
    if (!points || points.length === 0) {
      return;
    }
    var totalLength = this.getTotalLength();
    if (totalLength <= 0) {
      return;
    }
    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    each$1(points, function(p, i) {
      if (points[i + 1]) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = LineUtil.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
        tempLength += segmentL;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set("tCache", tCache);
  };
  Polyline2.prototype.getStartTangent = function() {
    var points = this.attr().points;
    var result = [];
    result.push([points[1][0], points[1][1]]);
    result.push([points[0][0], points[0][1]]);
    return result;
  };
  Polyline2.prototype.getEndTangent = function() {
    var points = this.attr().points;
    var l = points.length - 1;
    var result = [];
    result.push([points[l - 1][0], points[l - 1][1]]);
    result.push([points[l][0], points[l][1]]);
    return result;
  };
  return Polyline2;
}(ShapeBase$1);
var Polyline$1 = Polyline;
function parseRadius$1(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (isArray$1(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return {
    r1,
    r2,
    r3,
    r4
  };
}
var Rect$1 = function(_super) {
  __extends$2(Rect2, _super);
  function Rect2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "rect";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Rect2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
  };
  Rect2.prototype.createPath = function(context, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    var completed = false;
    var pathRelatedAttrs = ["x", "y", "width", "height", "radius"];
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (pathRelatedAttrs.indexOf(attr) !== -1 && !completed) {
        el.setAttribute("d", _this._assembleRect(attrs));
        completed = true;
      } else if (pathRelatedAttrs.indexOf(attr) === -1 && SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  Rect2.prototype._assembleRect = function(attrs) {
    var x = attrs.x;
    var y = attrs.y;
    var w = attrs.width;
    var h = attrs.height;
    var radius = attrs.radius;
    if (!radius) {
      return "M " + x + "," + y + " l " + w + ",0 l 0," + h + " l" + -w + " 0 z";
    }
    var r = parseRadius$1(radius);
    if (isArray$1(radius)) {
      if (radius.length === 1) {
        r.r1 = r.r2 = r.r3 = r.r4 = radius[0];
      } else if (radius.length === 2) {
        r.r1 = r.r3 = radius[0];
        r.r2 = r.r4 = radius[1];
      } else if (radius.length === 3) {
        r.r1 = radius[0];
        r.r2 = r.r4 = radius[1];
        r.r3 = radius[2];
      } else {
        r.r1 = radius[0];
        r.r2 = radius[1];
        r.r3 = radius[2];
        r.r4 = radius[3];
      }
    } else {
      r.r1 = r.r2 = r.r3 = r.r4 = radius;
    }
    var d = [
      ["M " + (x + r.r1) + "," + y],
      ["l " + (w - r.r1 - r.r2) + ",0"],
      ["a " + r.r2 + "," + r.r2 + ",0,0,1," + r.r2 + "," + r.r2],
      ["l 0," + (h - r.r2 - r.r3)],
      ["a " + r.r3 + "," + r.r3 + ",0,0,1," + -r.r3 + "," + r.r3],
      ["l " + (r.r3 + r.r4 - w) + ",0"],
      ["a " + r.r4 + "," + r.r4 + ",0,0,1," + -r.r4 + "," + -r.r4],
      ["l 0," + (r.r4 + r.r1 - h)],
      ["a " + r.r1 + "," + r.r1 + ",0,0,1," + r.r1 + "," + -r.r1],
      ["z"]
    ];
    return d.join(" ");
  };
  return Rect2;
}(ShapeBase$1);
var Rect$2 = Rect$1;
var LETTER_SPACING = 0.3;
var BASELINE_MAP = {
  top: "before-edge",
  middle: "central",
  bottom: "after-edge",
  alphabetic: "baseline",
  hanging: "hanging"
};
var BASELINE_MAP_FOR_FIREFOX = {
  top: "text-before-edge",
  middle: "central",
  bottom: "text-after-edge",
  alphabetic: "alphabetic",
  hanging: "hanging"
};
var ANCHOR_MAP = {
  left: "left",
  start: "left",
  center: "middle",
  right: "end",
  end: "end"
};
var Text = function(_super) {
  __extends$2(Text2, _super);
  function Text2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "text";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Text2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
  };
  Text2.prototype.createPath = function(context, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    this._setFont();
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "text") {
        _this._setText("" + value2);
      } else if (attr === "matrix" && value2) {
        setTransform(_this);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
    el.setAttribute("paint-order", "stroke");
    el.setAttribute("style", "stroke-linecap:butt; stroke-linejoin:miter;");
  };
  Text2.prototype._setFont = function() {
    var el = this.get("el");
    var _a2 = this.attr(), textBaseline = _a2.textBaseline, textAlign = _a2.textAlign;
    var browser2 = detect();
    if (browser2 && browser2.name === "firefox") {
      el.setAttribute("dominant-baseline", BASELINE_MAP_FOR_FIREFOX[textBaseline] || "alphabetic");
    } else {
      el.setAttribute("alignment-baseline", BASELINE_MAP[textBaseline] || "baseline");
    }
    el.setAttribute("text-anchor", ANCHOR_MAP[textAlign] || "left");
  };
  Text2.prototype._setText = function(text2) {
    var el = this.get("el");
    var _a2 = this.attr(), x = _a2.x, _b = _a2.textBaseline, baseline = _b === void 0 ? "bottom" : _b;
    if (!text2) {
      el.innerHTML = "";
    } else if (~text2.indexOf("\n")) {
      var textArr = text2.split("\n");
      var textLen_1 = textArr.length - 1;
      var arr_1 = "";
      each$1(textArr, function(segment, i) {
        if (i === 0) {
          if (baseline === "alphabetic") {
            arr_1 += '<tspan x="' + x + '" dy="' + -textLen_1 + 'em">' + segment + "</tspan>";
          } else if (baseline === "top") {
            arr_1 += '<tspan x="' + x + '" dy="0.9em">' + segment + "</tspan>";
          } else if (baseline === "middle") {
            arr_1 += '<tspan x="' + x + '" dy="' + -(textLen_1 - 1) / 2 + 'em">' + segment + "</tspan>";
          } else if (baseline === "bottom") {
            arr_1 += '<tspan x="' + x + '" dy="-' + (textLen_1 + LETTER_SPACING) + 'em">' + segment + "</tspan>";
          } else if (baseline === "hanging") {
            arr_1 += '<tspan x="' + x + '" dy="' + (-(textLen_1 - 1) - LETTER_SPACING) + 'em">' + segment + "</tspan>";
          }
        } else {
          arr_1 += '<tspan x="' + x + '" dy="1em">' + segment + "</tspan>";
        }
      });
      el.innerHTML = arr_1;
    } else {
      el.innerHTML = text2;
    }
  };
  return Text2;
}(ShapeBase$1);
var Text$1 = Text;
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^)]+\))/gi;
function addStop(steps) {
  var arr = steps.match(regexColorStop);
  if (!arr) {
    return "";
  }
  var stops = "";
  arr.sort(function(a, b) {
    a = a.split(":");
    b = b.split(":");
    return Number(a[0]) - Number(b[0]);
  });
  each$1(arr, function(item) {
    item = item.split(":");
    stops += '<stop offset="' + item[0] + '" stop-color="' + item[1] + '"></stop>';
  });
  return stops;
}
function parseLineGradient(color2, el) {
  var arr = regexLG.exec(color2);
  var angle2 = mod$1(toRadian(parseFloat(arr[1])), Math.PI * 2);
  var steps = arr[2];
  var start;
  var end;
  if (angle2 >= 0 && angle2 < 0.5 * Math.PI) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 1
    };
  } else if (0.5 * Math.PI <= angle2 && angle2 < Math.PI) {
    start = {
      x: 1,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  } else if (Math.PI <= angle2 && angle2 < 1.5 * Math.PI) {
    start = {
      x: 1,
      y: 1
    };
    end = {
      x: 0,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 1
    };
    end = {
      x: 1,
      y: 0
    };
  }
  var tanTheta = Math.tan(angle2);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  el.setAttribute("x1", start.x);
  el.setAttribute("y1", start.y);
  el.setAttribute("x2", x);
  el.setAttribute("y2", y);
  el.innerHTML = addStop(steps);
}
function parseRadialGradient(color2, self) {
  var arr = regexRG.exec(color2);
  var cx = parseFloat(arr[1]);
  var cy = parseFloat(arr[2]);
  var r = parseFloat(arr[3]);
  var steps = arr[4];
  self.setAttribute("cx", cx);
  self.setAttribute("cy", cy);
  self.setAttribute("r", r);
  self.innerHTML = addStop(steps);
}
var Gradient = function() {
  function Gradient2(cfg) {
    this.cfg = {};
    var el = null;
    var id = uniqueId("gradient_");
    if (cfg.toLowerCase()[0] === "l") {
      el = createSVGElement("linearGradient");
      parseLineGradient(cfg, el);
    } else {
      el = createSVGElement("radialGradient");
      parseRadialGradient(cfg, el);
    }
    el.setAttribute("id", id);
    this.el = el;
    this.id = id;
    this.cfg = cfg;
    return this;
  }
  Gradient2.prototype.match = function(type, attr) {
    return this.cfg === attr;
  };
  return Gradient2;
}();
var ATTR_MAP = {
  shadowColor: "color",
  shadowOpacity: "opacity",
  shadowBlur: "blur",
  shadowOffsetX: "dx",
  shadowOffsetY: "dy"
};
var SHADOW_DIMENSION = {
  x: "-40%",
  y: "-40%",
  width: "200%",
  height: "200%"
};
var Shadow = function() {
  function Shadow2(cfg) {
    this.type = "filter";
    this.cfg = {};
    this.type = "filter";
    var el = createSVGElement("filter");
    each$1(SHADOW_DIMENSION, function(v, k) {
      el.setAttribute(k, v);
    });
    this.el = el;
    this.id = uniqueId("filter_");
    this.el.id = this.id;
    this.cfg = cfg;
    this._parseShadow(cfg, el);
    return this;
  }
  Shadow2.prototype.match = function(type, cfg) {
    if (this.type !== type) {
      return false;
    }
    var flag = true;
    var config = this.cfg;
    each$1(Object.keys(config), function(attr) {
      if (config[attr] !== cfg[attr]) {
        flag = false;
        return false;
      }
    });
    return flag;
  };
  Shadow2.prototype.update = function(name, value2) {
    var config = this.cfg;
    config[ATTR_MAP[name]] = value2;
    this._parseShadow(config, this.el);
    return this;
  };
  Shadow2.prototype._parseShadow = function(config, el) {
    var child = '<feDropShadow\n      dx="' + (config.dx || 0) + '"\n      dy="' + (config.dy || 0) + '"\n      stdDeviation="' + (config.blur ? config.blur / 10 : 0) + '"\n      flood-color="' + (config.color ? config.color : "#000") + '"\n      flood-opacity="' + (config.opacity ? config.opacity : 1) + '"\n      />';
    el.innerHTML = child;
  };
  return Shadow2;
}();
var Arrow = function() {
  function Arrow2(attrs, type) {
    this.cfg = {};
    var el = createSVGElement("marker");
    var id = uniqueId("marker_");
    el.setAttribute("id", id);
    var shape = createSVGElement("path");
    shape.setAttribute("stroke", attrs.stroke || "none");
    shape.setAttribute("fill", attrs.fill || "none");
    el.appendChild(shape);
    el.setAttribute("overflow", "visible");
    el.setAttribute("orient", "auto-start-reverse");
    this.el = el;
    this.child = shape;
    this.id = id;
    var cfg = attrs[type === "marker-start" ? "startArrow" : "endArrow"];
    this.stroke = attrs.stroke || "#000";
    if (cfg === true) {
      this._setDefaultPath(type, shape);
    } else {
      this.cfg = cfg;
      this._setMarker(attrs.lineWidth, shape);
    }
    return this;
  }
  Arrow2.prototype.match = function() {
    return false;
  };
  Arrow2.prototype._setDefaultPath = function(type, el) {
    var parent = this.el;
    el.setAttribute("d", "M0,0 L" + 10 * Math.cos(Math.PI / 6) + ",5 L0,10");
    parent.setAttribute("refX", "" + 10 * Math.cos(Math.PI / 6));
    parent.setAttribute("refY", "" + 5);
  };
  Arrow2.prototype._setMarker = function(r, el) {
    var parent = this.el;
    var path2 = this.cfg.path;
    var d = this.cfg.d;
    if (isArray$1(path2)) {
      path2 = path2.map(function(segment) {
        return segment.join(" ");
      }).join("");
    }
    el.setAttribute("d", path2);
    parent.appendChild(el);
    if (d) {
      parent.setAttribute("refX", "" + d / r);
    }
  };
  Arrow2.prototype.update = function(fill) {
    var child = this.child;
    if (child.attr) {
      child.attr("fill", fill);
    } else {
      child.setAttribute("fill", fill);
    }
  };
  return Arrow2;
}();
var Clip = function() {
  function Clip2(cfg) {
    this.type = "clip";
    this.cfg = {};
    var el = createSVGElement("clipPath");
    this.el = el;
    this.id = uniqueId("clip_");
    el.id = this.id;
    var shapeEl = cfg.cfg.el;
    el.appendChild(shapeEl);
    this.cfg = cfg;
    return this;
  }
  Clip2.prototype.match = function() {
    return false;
  };
  Clip2.prototype.remove = function() {
    var el = this.el;
    el.parentNode.removeChild(el);
  };
  return Clip2;
}();
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var Pattern = function() {
  function Pattern2(cfg) {
    this.cfg = {};
    var el = createSVGElement("pattern");
    el.setAttribute("patternUnits", "userSpaceOnUse");
    var child = createSVGElement("image");
    el.appendChild(child);
    var id = uniqueId("pattern_");
    el.id = id;
    this.el = el;
    this.id = id;
    this.cfg = cfg;
    var arr = regexPR.exec(cfg);
    var source = arr[2];
    child.setAttribute("href", source);
    var img = new Image();
    if (!source.match(/^data:/i)) {
      img.crossOrigin = "Anonymous";
    }
    img.src = source;
    function onload() {
      el.setAttribute("width", "" + img.width);
      el.setAttribute("height", "" + img.height);
    }
    if (img.complete) {
      onload();
    } else {
      img.onload = onload;
      img.src = img.src;
    }
    return this;
  }
  Pattern2.prototype.match = function(type, attr) {
    return this.cfg === attr;
  };
  return Pattern2;
}();
var Defs = function() {
  function Defs2(canvas) {
    var el = createSVGElement("defs");
    var id = uniqueId("defs_");
    el.id = id;
    canvas.appendChild(el);
    this.children = [];
    this.defaultArrow = {};
    this.el = el;
    this.canvas = canvas;
  }
  Defs2.prototype.find = function(type, attr) {
    var children = this.children;
    var result = null;
    for (var i = 0; i < children.length; i++) {
      if (children[i].match(type, attr)) {
        result = children[i].id;
        break;
      }
    }
    return result;
  };
  Defs2.prototype.findById = function(id) {
    var children = this.children;
    var flag = null;
    for (var i = 0; i < children.length; i++) {
      if (children[i].id === id) {
        flag = children[i];
        break;
      }
    }
    return flag;
  };
  Defs2.prototype.add = function(item) {
    this.children.push(item);
    item.canvas = this.canvas;
    item.parent = this;
  };
  Defs2.prototype.getDefaultArrow = function(attrs, name) {
    var stroke = attrs.stroke || attrs.strokeStyle;
    if (this.defaultArrow[stroke]) {
      return this.defaultArrow[stroke].id;
    }
    var arrow = new Arrow(attrs, name);
    this.defaultArrow[stroke] = arrow;
    this.el.appendChild(arrow.el);
    this.add(arrow);
    return arrow.id;
  };
  Defs2.prototype.addGradient = function(cfg) {
    var gradient2 = new Gradient(cfg);
    this.el.appendChild(gradient2.el);
    this.add(gradient2);
    return gradient2.id;
  };
  Defs2.prototype.addArrow = function(attrs, name) {
    var arrow = new Arrow(attrs, name);
    this.el.appendChild(arrow.el);
    this.add(arrow);
    return arrow.id;
  };
  Defs2.prototype.addShadow = function(cfg) {
    var shadow = new Shadow(cfg);
    this.el.appendChild(shadow.el);
    this.add(shadow);
    return shadow.id;
  };
  Defs2.prototype.addPattern = function(cfg) {
    var pattern2 = new Pattern(cfg);
    this.el.appendChild(pattern2.el);
    this.add(pattern2);
    return pattern2.id;
  };
  Defs2.prototype.addClip = function(cfg) {
    var clip = new Clip(cfg);
    this.el.appendChild(clip.el);
    this.add(clip);
    return clip.id;
  };
  return Defs2;
}();
var Canvas = function(_super) {
  __extends$2(Canvas2, _super);
  function Canvas2(cfg) {
    return _super.call(this, __assign$1(__assign$1({}, cfg), {
      autoDraw: true,
      renderer: "svg"
    })) || this;
  }
  Canvas2.prototype.getShapeBase = function() {
    return Shape;
  };
  Canvas2.prototype.getGroupBase = function() {
    return Group;
  };
  Canvas2.prototype.getShape = function(x, y, ev) {
    var target = ev.target || ev.srcElement;
    if (!SHAPE_TO_TAGS[target.tagName]) {
      var parent_1 = target.parentNode;
      while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {
        parent_1 = parent_1.parentNode;
      }
      target = parent_1;
    }
    return this.find(function(child) {
      return child.get("el") === target;
    });
  };
  Canvas2.prototype.createDom = function() {
    var element = createSVGElement("svg");
    var context = new Defs(element);
    element.setAttribute("width", "" + this.get("width"));
    element.setAttribute("height", "" + this.get("height"));
    this.set("context", context);
    return element;
  };
  Canvas2.prototype.onCanvasChange = function(changeType) {
    var context = this.get("context");
    var el = this.get("el");
    if (changeType === "sort") {
      var children_1 = this.get("children");
      if (children_1 && children_1.length) {
        sortDom(this, function(a, b) {
          return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
        });
      }
    } else if (changeType === "clear") {
      if (el) {
        el.innerHTML = "";
        var defsEl = context.el;
        defsEl.innerHTML = "";
        el.appendChild(defsEl);
      }
    } else if (changeType === "matrix") {
      setTransform(this);
    } else if (changeType === "clip") {
      setClip(this, context);
    } else if (changeType === "changeSize") {
      el.setAttribute("width", "" + this.get("width"));
      el.setAttribute("height", "" + this.get("height"));
    }
  };
  Canvas2.prototype.draw = function() {
    var context = this.get("context");
    var children = this.getChildren();
    setClip(this, context);
    if (children.length) {
      drawChildren(context, children);
    }
  };
  return Canvas2;
}(Canvas$2);
var version = "0.5.6";
var SVGEngine = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  Shape,
  version,
  Canvas,
  Group,
  Event: GraphEvent$1,
  Base: Base$1,
  AbstractCanvas: Canvas$2,
  AbstractGroup,
  AbstractShape,
  getBBoxMethod: getMethod,
  getTextHeight: getTextHeight$1,
  assembleFont: assembleFont$1,
  isAllowCapture: isAllowCapture$1,
  multiplyVec2: multiplyVec2$2,
  invert: invert$1,
  getOffScreenContext: getOffScreenContext$1,
  PathUtil: PathUtil$1
});
function isValueEmpty(value2) {
  if (value2) {
    return false;
  }
  return value2 === null || value2 === void 0 || isNaN(value2);
}
function isYNil(point2) {
  if (isArray$1(point2)) {
    return isValueEmpty(point2[1].y);
  }
  var value2 = point2.y;
  return isArray$1(value2) ? isValueEmpty(value2[0]) : isValueEmpty(value2);
}
function getPathPoints(points, connectNulls, showSinglePoint) {
  if (connectNulls === void 0) {
    connectNulls = false;
  }
  if (showSinglePoint === void 0) {
    showSinglePoint = true;
  }
  if (!points.length || points.length === 1 && !showSinglePoint) {
    return [];
  }
  if (connectNulls) {
    var filtered = [];
    for (var i = 0, len = points.length; i < len; i++) {
      var point2 = points[i];
      if (!isYNil(point2)) {
        filtered.push(point2);
      }
    }
    return [filtered];
  }
  var result = [];
  var tmp = [];
  for (var i = 0, len = points.length; i < len; i++) {
    var point2 = points[i];
    if (isYNil(point2)) {
      if (tmp.length) {
        if (!(tmp.length === 1 && !showSinglePoint)) {
          result.push(tmp);
        }
        tmp = [];
      }
    } else {
      tmp.push(point2);
    }
  }
  if (tmp.length) {
    result.push(tmp);
  }
  return result;
}
function getViolinPath(points) {
  var path2 = [];
  for (var i = 0; i < points.length; i++) {
    var point2 = points[i];
    if (point2) {
      var action = i === 0 ? "M" : "L";
      path2.push([action, point2.x, point2.y]);
    }
  }
  var first = points[0];
  if (first) {
    path2.push(["L", first.x, first.y]);
    path2.push(["z"]);
  }
  return path2;
}
function getSmoothViolinPath(points) {
  var half = points.length / 2;
  var leftPoints = [];
  var rightPoints = [];
  for (var i = 0; i < points.length; i++) {
    if (i < half) {
      leftPoints.push(points[i]);
    } else {
      rightPoints.push(points[i]);
    }
  }
  var leftPath = getSplinePath$1(leftPoints, false);
  var rightPath = getSplinePath$1(rightPoints, false);
  if (rightPoints.length) {
    leftPath.push(["L", rightPoints[0].x, rightPoints[0].y]);
  }
  rightPath.shift();
  var path2 = leftPath.concat(rightPath);
  if (leftPoints.length) {
    path2.push(["L", leftPoints[0].x, leftPoints[0].y]);
  }
  path2.push(["z"]);
  return path2;
}
function getStyle(cfg, isStroke, isFill, sizeName) {
  if (sizeName === void 0) {
    sizeName = "";
  }
  var _a2 = cfg.style, style = _a2 === void 0 ? {} : _a2, defaultStyle = cfg.defaultStyle, color2 = cfg.color, size2 = cfg.size;
  var attrs = __assign$1(__assign$1({}, defaultStyle), style);
  if (color2) {
    if (isStroke) {
      if (!style.stroke) {
        attrs.stroke = color2;
      }
    }
    if (isFill) {
      if (!style.fill) {
        attrs.fill = color2;
      }
    }
  }
  if (sizeName && isNil(style[sizeName]) && !isNil(size2)) {
    attrs[sizeName] = size2;
  }
  return attrs;
}
function getBackgroundRectStyle(cfg) {
  return deepMix({}, {
    fill: "#CCD6EC",
    fillOpacity: 0.3
  }, get(cfg, ["background", "style"]));
}
function splitPoints(obj) {
  var x = obj.x;
  var y = isArray$1(obj.y) ? obj.y : [obj.y];
  return y.map(function(eachY, index2) {
    return {
      x: isArray$1(x) ? x[index2] : x,
      y: eachY
    };
  });
}
var LineSymbols = {
  line: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  dot: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  dash: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  smooth: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["A", r / 2, r / 2, 0, 1, 1, x, y],
      ["A", r / 2, r / 2, 0, 1, 0, x + r, y]
    ];
  },
  hv: function(x, y, r) {
    return [
      ["M", x - r - 1, y - 2.5],
      ["L", x, y - 2.5],
      ["L", x, y + 2.5],
      ["L", x + r + 1, y + 2.5]
    ];
  },
  vh: function(x, y, r) {
    return [
      ["M", x - r - 1, y + 2.5],
      ["L", x, y + 2.5],
      ["L", x, y - 2.5],
      ["L", x + r + 1, y - 2.5]
    ];
  },
  hvh: function(x, y, r) {
    return [
      ["M", x - (r + 1), y + 2.5],
      ["L", x - r / 2, y + 2.5],
      ["L", x - r / 2, y - 2.5],
      ["L", x + r / 2, y - 2.5],
      ["L", x + r / 2, y + 2.5],
      ["L", x + r + 1, y + 2.5]
    ];
  },
  vhv: function(x, y) {
    return [
      ["M", x - 5, y + 2.5],
      ["L", x - 5, y],
      ["L", x, y],
      ["L", x, y - 3],
      ["L", x, y + 3],
      ["L", x + 6.5, y + 3]
    ];
  }
};
function getLineMarker(markerCfg, shapeType) {
  var color2 = markerCfg.color;
  return {
    symbol: LineSymbols[shapeType],
    style: {
      lineWidth: 2,
      r: 6,
      stroke: color2
    }
  };
}
function getShapeAttrs$1(cfg, smooth, constraint) {
  var isStack = cfg.isStack, connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, showSinglePoint = cfg.showSinglePoint;
  var shapeAttrs = getStyle(cfg, true, false, "lineWidth");
  var points = getPathPoints(cfg.points, connectNulls, showSinglePoint);
  var path2 = [];
  for (var i = 0, len = points.length; i < len; i++) {
    var eachLinePoints = points[i];
    path2 = path2.concat(getPath$3(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));
  }
  shapeAttrs.path = path2;
  return shapeAttrs;
}
function getSinglePath(points, isInCircle, smooth, constraint, style) {
  if (points.length === 1) {
    return [
      ["M", points[0].x, points[0].y - style.lineWidth / 2],
      ["L", points[0].x, points[0].y],
      ["L", points[0].x, points[0].y + style.lineWidth / 2]
    ];
  }
  var path2;
  if (!smooth) {
    path2 = getLinePath(points, false);
    if (isInCircle) {
      path2.push(["Z"]);
    }
  } else {
    if (isInCircle && points.length) {
      points.push({ x: points[0].x, y: points[0].y });
    }
    path2 = getSplinePath$1(points, false, constraint);
  }
  return path2;
}
function getRangePath(points, isInCircle, isStack, smooth, constraint, style) {
  var topPoints = [];
  var bottomPoints = [];
  each$1(points, function(point2) {
    var result = splitPoints(point2);
    topPoints.push(result[1]);
    bottomPoints.push(result[0]);
  });
  var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);
  var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);
  if (isStack) {
    return topPath;
  }
  return topPath.concat(bottomPath);
}
function getPath$3(points, isInCircle, isStack, smooth, constraint, style) {
  if (points.length) {
    var first = points[0];
    return isArray$1(first.y) ? getRangePath(points, isInCircle, isStack, smooth, constraint, style) : getSinglePath(points, isInCircle, smooth, constraint, style);
  }
  return [];
}
registerShapeFactory("line", {
  defaultShapeType: "line"
});
each$1(["line", "dot", "dash", "smooth"], function(shapeType) {
  registerShape("line", shapeType, {
    draw: function(cfg, container) {
      var smooth = shapeType === "smooth";
      var constraint;
      if (smooth) {
        var _a2 = this.coordinate, start = _a2.start, end = _a2.end;
        constraint = [
          [start.x, end.y],
          [end.x, start.y]
        ];
      }
      var attrs = getShapeAttrs$1(cfg, smooth, constraint);
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "line",
        capture: !smooth
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      return getLineMarker(markerCfg, shapeType);
    }
  });
});
var Path = function(_super) {
  __extends$2(Path2, _super);
  function Path2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "path";
    _this.shapeType = "line";
    var _a2 = cfg.connectNulls, connectNulls = _a2 === void 0 ? false : _a2, _b = cfg.showSinglePoint, showSinglePoint = _b === void 0 ? true : _b;
    _this.connectNulls = connectNulls;
    _this.showSinglePoint = showSinglePoint;
    return _this;
  }
  Path2.prototype.updateElements = function(mappingDataArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var keyData = new Map();
    var keyIndex = new Map();
    var keys2 = [];
    var index2 = 0;
    for (var i = 0; i < mappingDataArray.length; i++) {
      var mappingData = mappingDataArray[i];
      var key = this.getElementId(mappingData);
      keys2.push(key);
      keyData.set(key, mappingData);
      keyIndex.set(key, index2);
      index2++;
    }
    this.elements = new Array(index2);
    var _a2 = diff(this.lastElementsMap, keys2), added = _a2.added, updated = _a2.updated, removed = _a2.removed;
    for (var _i = 0, added_1 = added; _i < added_1.length; _i++) {
      var key = added_1[_i];
      var mappingData = keyData.get(key);
      var shapeFactory = this.getShapeFactory();
      var shapeCfg = this.getShapeInfo(mappingData);
      var i = keyIndex.get(key);
      var element = new Element$1({
        shapeFactory,
        container: this.container,
        offscreenGroup: this.getOffscreenGroup(),
        elementIndex: i
      });
      element.geometry = this;
      element.animate = this.animateOption;
      element.draw(shapeCfg, isUpdate);
      this.elementsMap[key] = element;
      this.elements[i] = element;
    }
    for (var _b = 0, updated_1 = updated; _b < updated_1.length; _b++) {
      var key = updated_1[_b];
      var mappingData = keyData.get(key);
      var element = this.lastElementsMap[key];
      var i = keyIndex.get(key);
      var shapeCfg = this.getShapeInfo(mappingData);
      var preShapeCfg = element.getModel();
      if (this.isCoordinateChanged || isModelChange(preShapeCfg, shapeCfg)) {
        element.animate = this.animateOption;
        element.update(shapeCfg);
      }
      this.elementsMap[key] = element;
      this.elements[i] = element;
    }
    for (var _c = 0, removed_1 = removed; _c < removed_1.length; _c++) {
      var key = removed_1[_c];
      var element = this.lastElementsMap[key];
      element.animate = this.animateOption;
      element.destroy();
    }
  };
  Path2.prototype.getPointsAndData = function(mappingData) {
    var points = [];
    var data2 = [];
    for (var i = 0, len = mappingData.length; i < len; i++) {
      var obj = mappingData[i];
      points.push({
        x: obj.x,
        y: obj.y
      });
      data2.push(obj[FIELD_ORIGIN]);
    }
    return {
      points,
      data: data2
    };
  };
  Path2.prototype.getShapeInfo = function(mappingData) {
    var shapeCfg = this.getDrawCfg(mappingData[0]);
    var _a2 = this.getPointsAndData(mappingData), points = _a2.points, data2 = _a2.data;
    shapeCfg.mappingData = mappingData;
    shapeCfg.data = data2;
    shapeCfg.isStack = !!this.getAdjust("stack");
    shapeCfg.points = points;
    shapeCfg.connectNulls = this.connectNulls;
    shapeCfg.showSinglePoint = this.showSinglePoint;
    return shapeCfg;
  };
  return Path2;
}(Geometry);
function getPath$2(points, isInCircle, smooth, registeredShape, constraint) {
  var path2 = [];
  if (points.length) {
    var topLinePoints_1 = [];
    var bottomLinePoints_1 = [];
    for (var i = 0, len = points.length; i < len; i++) {
      var point2 = points[i];
      topLinePoints_1.push(point2[1]);
      bottomLinePoints_1.push(point2[0]);
    }
    bottomLinePoints_1 = bottomLinePoints_1.reverse();
    each$1([topLinePoints_1, bottomLinePoints_1], function(pointsData, index2) {
      var subPath = [];
      var parsedPoints = registeredShape.parsePoints(pointsData);
      var p1 = parsedPoints[0];
      if (topLinePoints_1.length === 1 && bottomLinePoints_1.length === 1) {
        subPath = index2 === 0 ? [
          ["M", p1.x - 0.5, p1.y],
          ["L", p1.x + 0.5, p1.y]
        ] : [
          ["L", p1.x + 0.5, p1.y],
          ["L", p1.x - 0.5, p1.y]
        ];
      } else {
        if (isInCircle) {
          parsedPoints.push({ x: p1.x, y: p1.y });
        }
        if (smooth) {
          subPath = getSplinePath$1(parsedPoints, false, constraint);
        } else {
          subPath = getLinePath(parsedPoints, false);
        }
        if (index2 > 0) {
          subPath[0][0] = "L";
        }
      }
      path2 = path2.concat(subPath);
    });
    path2.push(["Z"]);
  }
  return path2;
}
function getShapeAttrs(cfg, isStroke, smooth, registeredShape, constraint) {
  var attrs = getStyle(cfg, isStroke, !isStroke, "lineWidth");
  var connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, points = cfg.points, showSinglePoint = cfg.showSinglePoint;
  var pathPoints = getPathPoints(points, connectNulls, showSinglePoint);
  var path2 = [];
  for (var i = 0, len = pathPoints.length; i < len; i++) {
    var eachPoints = pathPoints[i];
    path2 = path2.concat(getPath$2(eachPoints, isInCircle, smooth, registeredShape, constraint));
  }
  attrs.path = path2;
  return attrs;
}
function getConstraint(coordinate2) {
  var start = coordinate2.start, end = coordinate2.end;
  return [
    [start.x, end.y],
    [end.x, start.y]
  ];
}
registerShapeFactory("area", {
  defaultShapeType: "area",
  getDefaultPoints: function(pointInfo) {
    var x = pointInfo.x, y0 = pointInfo.y0;
    var y = isArray$1(pointInfo.y) ? pointInfo.y : [y0, pointInfo.y];
    return y.map(function(yItem) {
      return {
        x,
        y: yItem
      };
    });
  }
});
registerShape("area", "area", {
  draw: function(cfg, container) {
    var attrs = getShapeAttrs(cfg, false, false, this);
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        fill: color2
      }
    };
  }
});
var Area$1 = function(_super) {
  __extends$2(Area2, _super);
  function Area2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "area";
    _this.shapeType = "area";
    _this.generatePoints = true;
    _this.startOnZero = true;
    var _a2 = cfg.startOnZero, startOnZero = _a2 === void 0 ? true : _a2, _b = cfg.sortable, sortable = _b === void 0 ? false : _b, _c = cfg.showSinglePoint, showSinglePoint = _c === void 0 ? false : _c;
    _this.startOnZero = startOnZero;
    _this.sortable = sortable;
    _this.showSinglePoint = showSinglePoint;
    return _this;
  }
  Area2.prototype.getPointsAndData = function(mappingData) {
    var points = [];
    var data2 = [];
    for (var i = 0, len = mappingData.length; i < len; i++) {
      var obj = mappingData[i];
      points.push(obj.points);
      data2.push(obj[FIELD_ORIGIN]);
    }
    return {
      points,
      data: data2
    };
  };
  Area2.prototype.getYMinValue = function() {
    if (this.startOnZero) {
      return _super.prototype.getYMinValue.call(this);
    }
    var yScale = this.getYScale();
    return yScale.min;
  };
  return Area2;
}(Path);
registerShapeFactory("edge", {
  defaultShapeType: "line",
  getDefaultPoints: function(pointInfo) {
    return splitPoints(pointInfo);
  }
});
registerShape("edge", "line", {
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false, "lineWidth");
    var path2 = getLinePath(this.parsePoints(cfg.points), this.coordinate.isPolar);
    return container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});
var Edge = function(_super) {
  __extends$2(Edge2, _super);
  function Edge2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "edge";
    _this.shapeType = "edge";
    _this.generatePoints = true;
    return _this;
  }
  return Edge2;
}(Geometry);
var Heatmap = function(_super) {
  __extends$2(Heatmap2, _super);
  function Heatmap2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "heatmap";
    _this.paletteCache = {};
    return _this;
  }
  Heatmap2.prototype.updateElements = function(mappingDataArray, isUpdate) {
    for (var i = 0; i < mappingDataArray.length; i++) {
      var mappingData = mappingDataArray[i];
      var range = this.prepareRange(mappingData);
      var radius = this.prepareSize();
      var blur_1 = get(this.styleOption, ["cfg", "shadowBlur"]);
      if (!isNumber$1(blur_1)) {
        blur_1 = radius / 2;
      }
      this.prepareGreyScaleBlurredCircle(radius, blur_1);
      this.drawWithRange(mappingData, range, radius, blur_1);
    }
  };
  Heatmap2.prototype.color = function(field2, cfg) {
    this.createAttrOption("color", field2, typeof cfg !== "function" ? cfg : "");
    return this;
  };
  Heatmap2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this.clearShadowCanvasCtx();
    this.paletteCache = {};
  };
  Heatmap2.prototype.prepareRange = function(data2) {
    var colorAttr = this.getAttribute("color");
    var colorField = colorAttr.getFields()[0];
    var min2 = Infinity;
    var max2 = -Infinity;
    data2.forEach(function(row) {
      var value2 = row[FIELD_ORIGIN][colorField];
      if (value2 > max2) {
        max2 = value2;
      }
      if (value2 < min2) {
        min2 = value2;
      }
    });
    if (min2 === max2) {
      min2 = max2 - 1;
    }
    return [min2, max2];
  };
  Heatmap2.prototype.prepareSize = function() {
    var radius = this.getDefaultValue("size");
    if (!isNumber$1(radius)) {
      radius = this.getDefaultSize();
    }
    return radius;
  };
  Heatmap2.prototype.prepareGreyScaleBlurredCircle = function(radius, blur) {
    var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
    var r2 = radius + blur;
    var ctx2 = grayScaleBlurredCanvas.getContext("2d");
    grayScaleBlurredCanvas.width = grayScaleBlurredCanvas.height = r2 * 2;
    ctx2.clearRect(0, 0, grayScaleBlurredCanvas.width, grayScaleBlurredCanvas.height);
    ctx2.shadowOffsetX = ctx2.shadowOffsetY = r2 * 2;
    ctx2.shadowBlur = blur;
    ctx2.shadowColor = "black";
    ctx2.beginPath();
    ctx2.arc(-r2, -r2, radius, 0, Math.PI * 2, true);
    ctx2.closePath();
    ctx2.fill();
  };
  Heatmap2.prototype.drawWithRange = function(data2, range, radius, blur) {
    var _a2 = this.coordinate, start = _a2.start, end = _a2.end;
    var width = this.coordinate.getWidth();
    var height = this.coordinate.getHeight();
    var colorAttr = this.getAttribute("color");
    var valueField = colorAttr.getFields()[0];
    this.clearShadowCanvasCtx();
    var ctx2 = this.getShadowCanvasCtx();
    if (range) {
      data2 = data2.filter(function(row) {
        return row[FIELD_ORIGIN][valueField] <= range[1] && row[FIELD_ORIGIN][valueField] >= range[0];
      });
    }
    var scale2 = this.scales[valueField];
    for (var _i = 0, data_1 = data2; _i < data_1.length; _i++) {
      var obj = data_1[_i];
      var _b = this.getDrawCfg(obj), x = _b.x, y = _b.y;
      var alpha = scale2.scale(obj[FIELD_ORIGIN][valueField]);
      this.drawGrayScaleBlurredCircle(x - start.x, y - end.y, radius + blur, alpha, ctx2);
    }
    var colored = ctx2.getImageData(0, 0, width, height);
    this.clearShadowCanvasCtx();
    this.colorize(colored);
    ctx2.putImageData(colored, 0, 0);
    var imageShape = this.getImageShape();
    imageShape.attr("x", start.x);
    imageShape.attr("y", end.y);
    imageShape.attr("width", width);
    imageShape.attr("height", height);
    imageShape.attr("img", ctx2.canvas);
    imageShape.set("origin", this.getShapeInfo(data2));
  };
  Heatmap2.prototype.getDefaultSize = function() {
    var position = this.getAttribute("position");
    var coordinate2 = this.coordinate;
    return Math.min(coordinate2.getWidth() / (position.scales[0].ticks.length * 4), coordinate2.getHeight() / (position.scales[1].ticks.length * 4));
  };
  Heatmap2.prototype.clearShadowCanvasCtx = function() {
    var ctx2 = this.getShadowCanvasCtx();
    ctx2.clearRect(0, 0, ctx2.canvas.width, ctx2.canvas.height);
  };
  Heatmap2.prototype.getShadowCanvasCtx = function() {
    var canvas = this.shadowCanvas;
    if (!canvas) {
      canvas = document.createElement("canvas");
      this.shadowCanvas = canvas;
    }
    canvas.width = this.coordinate.getWidth();
    canvas.height = this.coordinate.getHeight();
    return canvas.getContext("2d");
  };
  Heatmap2.prototype.getGrayScaleBlurredCanvas = function() {
    if (!this.grayScaleBlurredCanvas) {
      this.grayScaleBlurredCanvas = document.createElement("canvas");
    }
    return this.grayScaleBlurredCanvas;
  };
  Heatmap2.prototype.drawGrayScaleBlurredCircle = function(x, y, r, alpha, ctx2) {
    var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
    ctx2.globalAlpha = alpha;
    ctx2.drawImage(grayScaleBlurredCanvas, x - r, y - r);
  };
  Heatmap2.prototype.colorize = function(img) {
    var colorAttr = this.getAttribute("color");
    var pixels = img.data;
    var paletteCache = this.paletteCache;
    for (var i = 3; i < pixels.length; i += 4) {
      var alpha = pixels[i];
      if (isNumber$1(alpha)) {
        var palette = paletteCache[alpha] ? paletteCache[alpha] : colorUtil.rgb2arr(colorAttr.gradient(alpha / 256));
        pixels[i - 3] = palette[0];
        pixels[i - 2] = palette[1];
        pixels[i - 1] = palette[2];
        pixels[i] = alpha;
      }
    }
  };
  Heatmap2.prototype.getImageShape = function() {
    var imageShape = this.imageShape;
    if (imageShape) {
      return imageShape;
    }
    var container = this.container;
    imageShape = container.addShape({
      type: "image",
      attrs: {}
    });
    this.imageShape = imageShape;
    return imageShape;
  };
  Heatmap2.prototype.getShapeInfo = function(mappingData) {
    var shapeCfg = this.getDrawCfg(mappingData[0]);
    var data2 = mappingData.map(function(obj) {
      return obj[FIELD_ORIGIN];
    });
    return __assign$1(__assign$1({}, shapeCfg), { mappingData, data: data2 });
  };
  return Heatmap2;
}(Geometry);
function getRectPoints$1(pointInfo) {
  var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size2 = pointInfo.size;
  var yMin;
  var yMax;
  if (isArray$1(y)) {
    yMin = y[0], yMax = y[1];
  } else {
    yMin = y0;
    yMax = y;
  }
  var xMin;
  var xMax;
  if (isArray$1(x)) {
    xMin = x[0], xMax = x[1];
  } else {
    xMin = x - size2 / 2;
    xMax = x + size2 / 2;
  }
  var points = [
    { x: xMin, y: yMin },
    { x: xMin, y: yMax }
  ];
  points.push({ x: xMax, y: yMax }, { x: xMax, y: yMin });
  return points;
}
function getRectPath$1(points, isClosed) {
  if (isClosed === void 0) {
    isClosed = true;
  }
  var path2 = [];
  var firstPoint = points[0];
  path2.push(["M", firstPoint.x, firstPoint.y]);
  for (var i = 1, len = points.length; i < len; i++) {
    path2.push(["L", points[i].x, points[i].y]);
  }
  if (isClosed) {
    path2.push(["L", firstPoint.x, firstPoint.y]);
    path2.push(["z"]);
  }
  return path2;
}
function parseRadius(radius, minLength) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (isArray$1(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  if (r1 + r2 > minLength) {
    r1 = r1 ? minLength / (1 + r2 / r1) : 0;
    r2 = minLength - r1;
  }
  if (r3 + r4 > minLength) {
    r3 = r3 ? minLength / (1 + r4 / r3) : 0;
    r4 = minLength - r3;
  }
  return [r1 || 0, r2 || 0, r3 || 0, r4 || 0];
}
function getBackgroundRectPath(cfg, points, coordinate2) {
  var path2 = [];
  if (coordinate2.isRect) {
    var p0 = coordinate2.isTransposed ? { x: coordinate2.start.x, y: points[0].y } : { x: points[0].x, y: coordinate2.start.y };
    var p1 = coordinate2.isTransposed ? { x: coordinate2.end.x, y: points[2].y } : { x: points[3].x, y: coordinate2.end.y };
    var radius = get(cfg, ["background", "style", "radius"]);
    if (radius) {
      var width = coordinate2.isTransposed ? Math.abs(points[0].y - points[2].y) : points[2].x - points[1].x;
      var height = coordinate2.isTransposed ? coordinate2.getWidth() : coordinate2.getHeight();
      var _a2 = parseRadius(radius, Math.min(width, height)), r1 = _a2[0], r2 = _a2[1], r3 = _a2[2], r4 = _a2[3];
      path2.push(["M", p0.x, p1.y + r1]);
      r1 !== 0 && path2.push(["A", r1, r1, 0, 0, 1, p0.x + r1, p1.y]);
      path2.push(["L", p1.x - r2, p1.y]);
      r2 !== 0 && path2.push(["A", r2, r2, 0, 0, 1, p1.x, p1.y + r2]);
      path2.push(["L", p1.x, p0.y - r3]);
      r3 !== 0 && path2.push(["A", r3, r3, 0, 0, 1, p1.x - r3, p0.y]);
      path2.push(["L", p0.x + r4, p0.y]);
      r4 !== 0 && path2.push(["A", r4, r4, 0, 0, 1, p0.x, p0.y - r4]);
    } else {
      path2.push(["M", p0.x, p0.y]);
      path2.push(["L", p1.x, p0.y]);
      path2.push(["L", p1.x, p1.y]);
      path2.push(["L", p0.x, p1.y]);
      path2.push(["L", p0.x, p0.y]);
    }
    path2.push(["z"]);
  }
  if (coordinate2.isPolar) {
    var center2 = coordinate2.getCenter();
    var _b = getAngle$1(cfg, coordinate2), startAngle = _b.startAngle, endAngle = _b.endAngle;
    if (coordinate2.type !== "theta" && !coordinate2.isTransposed) {
      path2 = getSectorPath(center2.x, center2.y, coordinate2.getRadius(), startAngle, endAngle);
    } else {
      var pow = function(v) {
        return Math.pow(v, 2);
      };
      var r1 = Math.sqrt(pow(center2.x - points[0].x) + pow(center2.y - points[0].y));
      var r2 = Math.sqrt(pow(center2.x - points[2].x) + pow(center2.y - points[2].y));
      path2 = getSectorPath(center2.x, center2.y, r1, coordinate2.startAngle, coordinate2.endAngle, r2);
    }
  }
  return path2;
}
function getIntervalRectPath(points, lineCap, coor) {
  var width = coor.getWidth();
  var height = coor.getHeight();
  var isRect = coor.type === "rect";
  var path2 = [];
  var r = (points[2].x - points[1].x) / 2;
  var ry = coor.isTransposed ? r * height / width : r * width / height;
  if (lineCap === "round") {
    if (isRect) {
      path2.push(["M", points[0].x, points[0].y + ry]);
      path2.push(["L", points[1].x, points[1].y - ry]);
      path2.push(["A", r, r, 0, 0, 1, points[2].x, points[2].y - ry]);
      path2.push(["L", points[3].x, points[3].y + ry]);
      path2.push(["A", r, r, 0, 0, 1, points[0].x, points[0].y + ry]);
    } else {
      path2.push(["M", points[0].x, points[0].y]);
      path2.push(["L", points[1].x, points[1].y]);
      path2.push(["A", r, r, 0, 0, 1, points[2].x, points[2].y]);
      path2.push(["L", points[3].x, points[3].y]);
      path2.push(["A", r, r, 0, 0, 1, points[0].x, points[0].y]);
    }
    path2.push(["z"]);
  } else {
    path2 = getRectPath$1(points);
  }
  return path2;
}
function getFunnelPath(points, nextPoints, isPyramid) {
  var path2 = [];
  if (!isNil(nextPoints)) {
    path2.push(["M", points[0].x, points[0].y], ["L", points[1].x, points[1].y], ["L", nextPoints[1].x, nextPoints[1].y], ["L", nextPoints[0].x, nextPoints[0].y], ["Z"]);
  } else if (isPyramid) {
    path2.push(["M", points[0].x, points[0].y], ["L", points[1].x, points[1].y], ["L", (points[2].x + points[3].x) / 2, (points[2].y + points[3].y) / 2], ["Z"]);
  } else {
    path2.push(["M", points[0].x, points[0].y], ["L", points[1].x, points[1].y], ["L", points[2].x, points[2].y], ["L", points[3].x, points[3].y], ["Z"]);
  }
  return path2;
}
function getRectWithCornerRadius(points, coordinate2, radius) {
  var _a2, _b, _c, _d;
  var p0 = points[0], p1 = points[1], p2 = points[2], p3 = points[3];
  var _e = [0, 0, 0, 0], r1 = _e[0], r2 = _e[1], r3 = _e[2], r4 = _e[3];
  if (p0.y < p1.y) {
    p1 = points[0], p0 = points[1], p3 = points[2], p2 = points[3];
    _a2 = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r4 = _a2[0], r3 = _a2[1], r2 = _a2[2], r1 = _a2[3];
  } else {
    _b = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r1 = _b[0], r2 = _b[1], r3 = _b[2], r4 = _b[3];
  }
  if (coordinate2.isTransposed) {
    p0 = points[0], p3 = points[1], p2 = points[2], p1 = points[3];
    if (points[0].x > points[1].x) {
      p3 = points[0], p0 = points[1], p1 = points[2], p2 = points[3];
      _c = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r1 = _c[0], r4 = _c[1], r3 = _c[2], r2 = _c[3];
    } else {
      _d = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r2 = _d[0], r3 = _d[1], r4 = _d[2], r1 = _d[3];
    }
  }
  var path2 = [];
  path2.push(["M", p1.x, p1.y + r1]);
  r1 !== 0 && path2.push(["A", r1, r1, 0, 0, 1, p1.x + r1, p1.y]);
  path2.push(["L", p2.x - r2, p2.y]);
  r2 !== 0 && path2.push(["A", r2, r2, 0, 0, 1, p2.x, p2.y + r2]);
  path2.push(["L", p3.x, p3.y - r3]);
  r3 !== 0 && path2.push(["A", r3, r3, 0, 0, 1, p3.x - r3, p3.y]);
  path2.push(["L", p0.x + r4, p0.y]);
  r4 !== 0 && path2.push(["A", r4, r4, 0, 0, 1, p0.x, p0.y - r4]);
  path2.push(["L", p1.x, p1.y + r1]);
  path2.push(["z"]);
  return path2;
}
registerShapeFactory("interval", {
  defaultShapeType: "rect",
  getDefaultPoints: function(pointInfo) {
    return getRectPoints$1(pointInfo);
  }
});
registerShape("interval", "rect", {
  draw: function(cfg, container) {
    var style = getStyle(cfg, false, true);
    var group2 = container;
    var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
    if (backgroundCfg) {
      group2 = container.addGroup();
      var backgroundStyle = getBackgroundRectStyle(cfg);
      var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
      group2.addShape("path", {
        attrs: __assign$1(__assign$1({}, backgroundStyle), { path: backgroundPath }),
        zIndex: -1,
        name: BACKGROUND_SHAPE
      });
    }
    var path2;
    if (style.radius && this.coordinate.isRect) {
      path2 = getRectWithCornerRadius(this.parsePoints(cfg.points), this.coordinate, style.radius);
    } else {
      path2 = this.parsePath(getIntervalRectPath(cfg.points, style.lineCap, this.coordinate));
    }
    var shape = group2.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 }),
      name: "interval"
    });
    return backgroundCfg ? group2 : shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color, isInPolar = markerCfg.isInPolar;
    if (isInPolar) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          fill: color2
        }
      };
    }
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
function findMinDistance(arr, scale2) {
  var count = arr.length;
  var sourceArr = arr;
  if (isString(sourceArr[0])) {
    sourceArr = arr.map(function(v) {
      return scale2.translate(v);
    });
  }
  var distance2 = sourceArr[1] - sourceArr[0];
  for (var i = 2; i < count; i++) {
    var tmp = sourceArr[i] - sourceArr[i - 1];
    if (distance2 > tmp) {
      distance2 = tmp;
    }
  }
  return distance2;
}
function getDodgeCount(dataArray, dodgeBy) {
  if (dodgeBy) {
    var mergeData = flatten(dataArray);
    var values2 = valuesOfKey(mergeData, dodgeBy);
    return values2.length;
  }
  return dataArray.length;
}
function getDefaultSize(geometry2) {
  var theme2 = geometry2.theme;
  var coordinate2 = geometry2.coordinate;
  var xScale = geometry2.getXScale();
  var xValues = xScale.values;
  var dataArray = geometry2.beforeMappingData;
  var count = xValues.length;
  var xDimensionLength = getXDimensionLength(geometry2.coordinate);
  var intervalPadding = geometry2.intervalPadding, dodgePadding = geometry2.dodgePadding;
  var maxColumnWidth = geometry2.maxColumnWidth || theme2.maxColumnWidth;
  var minColumnWidth = geometry2.minColumnWidth || theme2.minColumnWidth;
  var columnWidthRatio = geometry2.columnWidthRatio || theme2.columnWidthRatio;
  var multiplePieWidthRatio = geometry2.multiplePieWidthRatio || theme2.multiplePieWidthRatio;
  var roseWidthRatio = geometry2.roseWidthRatio || theme2.roseWidthRatio;
  if (xScale.isLinear && xValues.length > 1) {
    xValues.sort();
    var interval2 = findMinDistance(xValues, xScale);
    count = (xScale.max - xScale.min) / interval2;
    if (xValues.length > count) {
      count = xValues.length;
    }
  }
  var range = xScale.range;
  var normalizedSize = 1 / count;
  var wr = 1;
  if (coordinate2.isPolar) {
    if (coordinate2.isTransposed && count > 1) {
      wr = multiplePieWidthRatio;
    } else {
      wr = roseWidthRatio;
    }
  } else {
    if (xScale.isLinear) {
      normalizedSize *= range[1] - range[0];
    }
    wr = columnWidthRatio;
  }
  if (!isNil(intervalPadding) && intervalPadding >= 0) {
    var normalizedIntervalPadding = intervalPadding / xDimensionLength;
    normalizedSize = (1 - (count - 1) * normalizedIntervalPadding) / count;
  } else {
    normalizedSize *= wr;
  }
  if (geometry2.getAdjust("dodge")) {
    var dodgeAdjust = geometry2.getAdjust("dodge");
    var dodgeBy = dodgeAdjust.dodgeBy;
    var dodgeCount = getDodgeCount(dataArray, dodgeBy);
    if (!isNil(dodgePadding) && dodgePadding >= 0) {
      var normalizedDodgePadding = dodgePadding / xDimensionLength;
      normalizedSize = (normalizedSize - normalizedDodgePadding * (dodgeCount - 1)) / dodgeCount;
    } else if (!isNil(intervalPadding) && intervalPadding >= 0) {
      normalizedSize *= wr;
      normalizedSize = normalizedSize / dodgeCount;
    } else {
      normalizedSize = normalizedSize / dodgeCount;
    }
    normalizedSize = normalizedSize >= 0 ? normalizedSize : 0;
  }
  if (!isNil(maxColumnWidth) && maxColumnWidth >= 0) {
    var normalizedMaxColumnWidth = maxColumnWidth / xDimensionLength;
    if (normalizedSize > normalizedMaxColumnWidth) {
      normalizedSize = normalizedMaxColumnWidth;
    }
  }
  if (!isNil(minColumnWidth) && minColumnWidth >= 0) {
    var normalizedMinColumnWidth = minColumnWidth / xDimensionLength;
    if (normalizedSize < normalizedMinColumnWidth) {
      normalizedSize = normalizedMinColumnWidth;
    }
  }
  return normalizedSize;
}
var Interval = function(_super) {
  __extends$2(Interval2, _super);
  function Interval2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "interval";
    _this.shapeType = "interval";
    _this.generatePoints = true;
    var background = cfg.background;
    _this.background = background;
    return _this;
  }
  Interval2.prototype.createShapePointsCfg = function(obj) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
    var size2;
    var sizeAttr = this.getAttribute("size");
    if (sizeAttr) {
      size2 = this.getAttributeValues(sizeAttr, obj)[0];
      var coordinate2 = this.coordinate;
      var coordinateWidth = getXDimensionLength(coordinate2);
      size2 = size2 / coordinateWidth;
    } else {
      if (!this.defaultSize) {
        this.defaultSize = getDefaultSize(this);
      }
      size2 = this.defaultSize;
    }
    cfg.size = size2;
    return cfg;
  };
  Interval2.prototype.adjustScale = function() {
    _super.prototype.adjustScale.call(this);
    var yScale = this.getYScale();
    if (this.coordinate.type === "theta") {
      yScale.change({
        nice: false,
        min: 0,
        max: getMaxScale(yScale)
      });
    } else {
      var scaleDefs = this.scaleDefs;
      var field2 = yScale.field, min2 = yScale.min, max2 = yScale.max, type = yScale.type;
      if (type !== "time") {
        if (min2 > 0 && !get(scaleDefs, [field2, "min"])) {
          yScale.change({
            min: 0
          });
        }
        if (max2 <= 0 && !get(scaleDefs, [field2, "max"])) {
          yScale.change({
            max: 0
          });
        }
      }
    }
  };
  Interval2.prototype.getDrawCfg = function(mappingData) {
    var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingData);
    shapeCfg.background = this.background;
    return shapeCfg;
  };
  return Interval2;
}(Geometry);
var Line$1 = function(_super) {
  __extends$2(Line2, _super);
  function Line2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "line";
    var _a2 = cfg.sortable, sortable = _a2 === void 0 ? false : _a2;
    _this.sortable = sortable;
    return _this;
  }
  return Line2;
}(Path);
var SHAPES = ["circle", "square", "bowtie", "diamond", "hexagon", "triangle", "triangle-down"];
var HOLLOW_SHAPES = ["cross", "tick", "plus", "hyphen", "line"];
function drawPoints(shape, cfg, container, shapeName, isStroke) {
  var style = getStyle(cfg, isStroke, !isStroke, "r");
  var points = shape.parsePoints(cfg.points);
  var pointPosition = points[0];
  if (cfg.isStack) {
    pointPosition = points[1];
  } else if (points.length > 1) {
    var group2 = container.addGroup();
    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
      var point2 = points_1[_i];
      group2.addShape({
        type: "marker",
        attrs: __assign$1(__assign$1(__assign$1({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), point2)
      });
    }
    return group2;
  }
  return container.addShape({
    type: "marker",
    attrs: __assign$1(__assign$1(__assign$1({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), pointPosition)
  });
}
registerShapeFactory("point", {
  defaultShapeType: "hollow-circle",
  getDefaultPoints: function(pointInfo) {
    return splitPoints(pointInfo);
  }
});
each$1(SHAPES, function(shapeName) {
  registerShape("point", "hollow-" + shapeName, {
    draw: function(cfg, container) {
      return drawPoints(this, cfg, container, shapeName, true);
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: MarkerSymbols[shapeName] || shapeName,
        style: {
          r: 4.5,
          stroke: color2,
          fill: null
        }
      };
    }
  });
});
var Point = function(_super) {
  __extends$2(Point2, _super);
  function Point2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "point";
    _this.shapeType = "point";
    _this.generatePoints = true;
    return _this;
  }
  Point2.prototype.getDrawCfg = function(mappingDatum) {
    var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingDatum);
    return __assign$1(__assign$1({}, shapeCfg), { isStack: !!this.getAdjust("stack") });
  };
  return Point2;
}(Geometry);
function getPath$1(points) {
  var flag = points[0];
  var i = 1;
  var path2 = [["M", flag.x, flag.y]];
  while (i < points.length) {
    var c = points[i];
    if (c.x !== points[i - 1].x || c.y !== points[i - 1].y) {
      path2.push(["L", c.x, c.y]);
      if (c.x === flag.x && c.y === flag.y && i < points.length - 1) {
        flag = points[i + 1];
        path2.push(["Z"]);
        path2.push(["M", flag.x, flag.y]);
        i++;
      }
    }
    i++;
  }
  if (!isEqual$2(last(path2), flag)) {
    path2.push(["L", flag.x, flag.y]);
  }
  path2.push(["Z"]);
  return path2;
}
registerShapeFactory("polygon", {
  defaultShapeType: "polygon",
  getDefaultPoints: function(pointInfo) {
    var points = [];
    each$1(pointInfo.x, function(subX, index2) {
      var subY = pointInfo.y[index2];
      points.push({
        x: subX,
        y: subY
      });
    });
    return points;
  }
});
registerShape("polygon", "polygon", {
  draw: function(cfg, container) {
    if (!isEmpty(cfg.points)) {
      var shapeAttrs = getStyle(cfg, true, true);
      var path2 = this.parsePath(getPath$1(cfg.points));
      return container.addShape("path", {
        attrs: __assign$1(__assign$1({}, shapeAttrs), { path: path2 }),
        name: "polygon"
      });
    }
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
var Polygon = function(_super) {
  __extends$2(Polygon2, _super);
  function Polygon2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "polygon";
    _this.shapeType = "polygon";
    _this.generatePoints = true;
    return _this;
  }
  Polygon2.prototype.createShapePointsCfg = function(obj) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
    var x = cfg.x;
    var y = cfg.y;
    var temp;
    if (!(isArray$1(x) && isArray$1(y))) {
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var xCount = xScale.values.length;
      var yCount = yScale.values.length;
      var xOffset = 0.5 * 1 / xCount;
      var yOffset = 0.5 * 1 / yCount;
      if (xScale.isCategory && yScale.isCategory) {
        x = [x - xOffset, x - xOffset, x + xOffset, x + xOffset];
        y = [y - yOffset, y + yOffset, y + yOffset, y - yOffset];
      } else if (isArray$1(x)) {
        temp = x;
        x = [temp[0], temp[0], temp[1], temp[1]];
        y = [y - yOffset / 2, y + yOffset / 2, y + yOffset / 2, y - yOffset / 2];
      } else if (isArray$1(y)) {
        temp = y;
        y = [temp[0], temp[1], temp[1], temp[0]];
        x = [x - xOffset / 2, x - xOffset / 2, x + xOffset / 2, x + xOffset / 2];
      }
      cfg.x = x;
      cfg.y = y;
    }
    return cfg;
  };
  return Polygon2;
}(Geometry);
registerShapeFactory("schema", {
  defaultShapeType: ""
});
var Schema = function(_super) {
  __extends$2(Schema2, _super);
  function Schema2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "schema";
    _this.shapeType = "schema";
    _this.generatePoints = true;
    return _this;
  }
  Schema2.prototype.createShapePointsCfg = function(record) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, record);
    var size2;
    var sizeAttr = this.getAttribute("size");
    if (sizeAttr) {
      size2 = this.getAttributeValues(sizeAttr, record)[0];
      var coordinate2 = this.coordinate;
      var coordinateWidth = getXDimensionLength(coordinate2);
      size2 = size2 / coordinateWidth;
    } else {
      if (!this.defaultSize) {
        this.defaultSize = getDefaultSize(this);
      }
      size2 = this.defaultSize;
    }
    cfg.size = size2;
    return cfg;
  };
  return Schema2;
}(Geometry);
function normalizeSize(arr) {
  if (!isArray$1(arr)) {
    return [];
  }
  var maxValue = max$1(arr);
  return map$2(arr, function(num) {
    return num / maxValue;
  });
}
registerShapeFactory("violin", {
  defaultShapeType: "violin",
  getDefaultPoints: function(pointInfo) {
    var radius = pointInfo.size / 2;
    var points = [];
    var sizeArr = normalizeSize(pointInfo._size);
    each$1(pointInfo.y, function(y, index2) {
      var offset = sizeArr[index2] * radius;
      var isMin = index2 === 0;
      var isMax = index2 === pointInfo.y.length - 1;
      points.push({
        isMin,
        isMax,
        x: pointInfo.x - offset,
        y
      });
      points.unshift({
        isMin,
        isMax,
        x: pointInfo.x + offset,
        y
      });
    });
    return points;
  }
});
registerShape("violin", "violin", {
  draw: function(cfg, container) {
    var shapeAttrs = getStyle(cfg, true, true);
    var path2 = this.parsePath(getViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign$1(__assign$1({}, shapeAttrs), { path: path2 }),
      name: "violin"
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
var Violin = function(_super) {
  __extends$2(Violin2, _super);
  function Violin2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "violin";
    _this.shapeType = "violin";
    _this.generatePoints = true;
    return _this;
  }
  Violin2.prototype.createShapePointsCfg = function(record) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, record);
    var size2;
    var sizeAttr = this.getAttribute("size");
    if (sizeAttr) {
      size2 = this.getAttributeValues(sizeAttr, record)[0];
      var coordinate2 = this.coordinate;
      var coordinateWidth = getXDimensionLength(coordinate2);
      size2 = size2 / coordinateWidth;
    } else {
      if (!this.defaultSize) {
        this.defaultSize = getDefaultSize(this);
      }
      size2 = this.defaultSize;
    }
    cfg.size = size2;
    cfg._size = get(record[FIELD_ORIGIN], [this._sizeField]);
    return cfg;
  };
  Violin2.prototype.initAttributes = function() {
    var attributeOption = this.attributeOption;
    var sizeField = attributeOption.size ? attributeOption.size.fields[0] : this._sizeField ? this._sizeField : "size";
    this._sizeField = sizeField;
    delete attributeOption.size;
    _super.prototype.initAttributes.call(this);
  };
  return Violin2;
}(Geometry);
registerShape("area", "line", {
  draw: function(cfg, container) {
    var attrs = getShapeAttrs(cfg, true, false, this);
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        stroke: color2,
        fill: null
      }
    };
  }
});
registerShape("area", "smooth", {
  draw: function(cfg, container) {
    var coordinate2 = this.coordinate;
    var attrs = getShapeAttrs(cfg, false, true, this, getConstraint(coordinate2));
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        fill: color2
      }
    };
  }
});
registerShape("area", "smooth-line", {
  draw: function(cfg, container) {
    var coordinate2 = this.coordinate;
    var attrs = getShapeAttrs(cfg, true, true, this, getConstraint(coordinate2));
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        stroke: color2,
        fill: null
      }
    };
  }
});
function getCPath(from, to) {
  return [
    "C",
    from.x * 1 / 2 + to.x * 1 / 2,
    from.y,
    from.x * 1 / 2 + to.x * 1 / 2,
    to.y,
    to.x,
    to.y
  ];
}
function getQPath(to, center2) {
  var points = [];
  points.push({
    x: center2.x,
    y: center2.y
  });
  points.push(to);
  var sub2 = ["Q"];
  each$1(points, function(point2) {
    sub2.push(point2.x, point2.y);
  });
  return sub2;
}
function getArcShapePath(from, to, center2) {
  var sub2 = getQPath(to, center2);
  var path2 = [["M", from.x, from.y]];
  path2.push(sub2);
  return path2;
}
function getArcShapeWeightPath(points, center2) {
  var arc1 = getQPath(points[1], center2);
  var arc2 = getQPath(points[3], center2);
  var path2 = [["M", points[0].x, points[0].y]];
  path2.push(arc2);
  path2.push(["L", points[3].x, points[3].y]);
  path2.push(["L", points[2].x, points[2].y]);
  path2.push(arc1);
  path2.push(["L", points[1].x, points[1].y]);
  path2.push(["L", points[0].x, points[0].y]);
  path2.push(["Z"]);
  return path2;
}
registerShape("edge", "arc", {
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false, "lineWidth");
    var points = cfg.points;
    var type = points.length > 2 ? "weight" : "normal";
    var path2;
    if (cfg.isInCircle) {
      var center2 = { x: 0, y: 1 };
      if (type === "normal") {
        path2 = getArcShapePath(points[0], points[1], center2);
      } else {
        style.fill = style.stroke;
        path2 = getArcShapeWeightPath(points, center2);
      }
      path2 = this.parsePath(path2);
      return container.addShape("path", {
        attrs: __assign$1(__assign$1({}, style), { path: path2 })
      });
    } else {
      if (type === "normal") {
        points = this.parsePoints(points);
        path2 = getArcPath((points[1].x + points[0].x) / 2, points[0].y, Math.abs(points[1].x - points[0].x) / 2, Math.PI, Math.PI * 2);
        return container.addShape("path", {
          attrs: __assign$1(__assign$1({}, style), { path: path2 })
        });
      } else {
        var c1 = getCPath(points[1], points[3]);
        var c2 = getCPath(points[2], points[0]);
        path2 = [
          ["M", points[0].x, points[0].y],
          ["L", points[1].x, points[1].y],
          c1,
          ["L", points[3].x, points[3].y],
          ["L", points[2].x, points[2].y],
          c2,
          ["Z"]
        ];
        path2 = this.parsePath(path2);
        style.fill = style.stroke;
        return container.addShape("path", {
          attrs: __assign$1(__assign$1({}, style), { path: path2 })
        });
      }
    }
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});
function getSmoothPath(from, to) {
  var sub2 = getCPath(from, to);
  var path2 = [["M", from.x, from.y]];
  path2.push(sub2);
  return path2;
}
registerShape("edge", "smooth", {
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false, "lineWidth");
    var points = cfg.points;
    var path2 = this.parsePath(getSmoothPath(points[0], points[1]));
    return container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});
var CORNER_PERCENT = 1 / 3;
function getVHVPath(from, to) {
  var points = [];
  points.push({
    x: from.x,
    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
  });
  points.push({
    x: to.x,
    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
  });
  points.push(to);
  var path2 = [["M", from.x, from.y]];
  each$1(points, function(point2) {
    path2.push(["L", point2.x, point2.y]);
  });
  return path2;
}
registerShape("edge", "vhv", {
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false, "lineWidth");
    var points = cfg.points;
    var path2 = this.parsePath(getVHVPath(points[0], points[1]));
    return container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});
registerShape("interval", "funnel", {
  getPoints: function(shapePoint) {
    shapePoint.size = shapePoint.size * 2;
    return getRectPoints$1(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle(cfg, false, true);
    var path2 = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, false));
    var shape = container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
registerShape("interval", "hollow-rect", {
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false);
    var group2 = container;
    var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
    if (backgroundCfg) {
      group2 = container.addGroup();
      var backgroundStyle = getBackgroundRectStyle(cfg);
      var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
      group2.addShape("path", {
        attrs: __assign$1(__assign$1({}, backgroundStyle), { path: backgroundPath }),
        zIndex: -1,
        name: BACKGROUND_SHAPE
      });
    }
    var path2 = this.parsePath(getRectPath$1(cfg.points));
    var shape = group2.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 }),
      name: "interval"
    });
    return backgroundCfg ? group2 : shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color, isInPolar = markerCfg.isInPolar;
    if (isInPolar) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          stroke: color2,
          fill: null
        }
      };
    }
    return {
      symbol: "square",
      style: {
        r: 4,
        stroke: color2,
        fill: null
      }
    };
  }
});
function getLinePoints(pointInfo) {
  var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0;
  if (isArray$1(y)) {
    return y.map(function(yItem, idx) {
      return {
        x: isArray$1(x) ? x[idx] : x,
        y: yItem
      };
    });
  }
  return [
    { x, y: y0 },
    { x, y }
  ];
}
registerShape("interval", "line", {
  getPoints: function(shapePoint) {
    return getLinePoints(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false, "lineWidth");
    var newStyle = omit(__assign$1({}, style), ["fill"]);
    var path2 = this.parsePath(getRectPath$1(cfg.points, false));
    var shape = container.addShape("path", {
      attrs: __assign$1(__assign$1({}, newStyle), { path: path2 }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        return [
          ["M", x, y - r],
          ["L", x, y + r]
        ];
      },
      style: {
        r: 5,
        stroke: color2
      }
    };
  }
});
registerShape("interval", "pyramid", {
  getPoints: function(shapePoint) {
    shapePoint.size = shapePoint.size * 2;
    return getRectPoints$1(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle(cfg, false, true);
    var path2 = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, true));
    var shape = container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
function getTickPoints(pointInfo) {
  var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size2 = pointInfo.size;
  var yMin;
  var yMax;
  if (isArray$1(y)) {
    yMin = y[0], yMax = y[1];
  } else {
    yMin = y0;
    yMax = y;
  }
  var xMax = x + size2 / 2;
  var xMin = x - size2 / 2;
  return [
    { x, y: yMin },
    { x, y: yMax },
    { x: xMin, y: yMin },
    { x: xMax, y: yMin },
    { x: xMin, y: yMax },
    { x: xMax, y: yMax }
  ];
}
function getTickPath(points) {
  return [
    ["M", points[0].x, points[0].y],
    ["L", points[1].x, points[1].y],
    ["M", points[2].x, points[2].y],
    ["L", points[3].x, points[3].y],
    ["M", points[4].x, points[4].y],
    ["L", points[5].x, points[5].y]
  ];
}
registerShape("interval", "tick", {
  getPoints: function(shapePoint) {
    return getTickPoints(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false);
    var path2 = this.parsePath(getTickPath(cfg.points));
    var shape = container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        return [
          ["M", x - r / 2, y - r],
          ["L", x + r / 2, y - r],
          ["M", x, y - r],
          ["L", x, y + r],
          ["M", x - r / 2, y + r],
          ["L", x + r / 2, y + r]
        ];
      },
      style: {
        r: 5,
        stroke: color2
      }
    };
  }
});
var interpolateCallback = function(point2, nextPoint, shapeType) {
  var x = point2.x;
  var y = point2.y;
  var nextX = nextPoint.x;
  var nextY = nextPoint.y;
  var result;
  switch (shapeType) {
    case "hv":
      result = [{ x: nextX, y }];
      break;
    case "vh":
      result = [{ x, y: nextY }];
      break;
    case "hvh":
      var middleX = (nextX + x) / 2;
      result = [
        { x: middleX, y },
        { x: middleX, y: nextY }
      ];
      break;
    case "vhv":
      var middleY = (y + nextY) / 2;
      result = [
        { x, y: middleY },
        { x: nextX, y: middleY }
      ];
      break;
  }
  return result;
};
function getInterpolatePoints(points, shapeType) {
  var result = [];
  each$1(points, function(point2, index2) {
    var nextPoint = points[index2 + 1];
    result.push(point2);
    if (nextPoint) {
      var interpolatePoint = interpolateCallback(point2, nextPoint, shapeType);
      result = result.concat(interpolatePoint);
    }
  });
  return result;
}
function getInterpolatePath(points) {
  return points.map(function(point2, index2) {
    return index2 === 0 ? ["M", point2.x, point2.y] : ["L", point2.x, point2.y];
  });
}
function getInterpolateShapeAttrs(cfg, shapeType) {
  var points = getPathPoints(cfg.points, cfg.connectNulls, cfg.showSinglePoint);
  var path2 = [];
  each$1(points, function(eachLinePoints) {
    var interpolatePoints = getInterpolatePoints(eachLinePoints, shapeType);
    path2 = path2.concat(getInterpolatePath(interpolatePoints));
  });
  return __assign$1(__assign$1({}, getStyle(cfg, true, false, "lineWidth")), { path: path2 });
}
each$1(["hv", "vh", "hvh", "vhv"], function(shapeType) {
  registerShape("line", shapeType, {
    draw: function(cfg, container) {
      var attrs = getInterpolateShapeAttrs(cfg, shapeType);
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "line"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      return getLineMarker(markerCfg, shapeType);
    }
  });
});
each$1(HOLLOW_SHAPES, function(shapeName) {
  registerShape("point", shapeName, {
    draw: function(cfg, container) {
      return drawPoints(this, cfg, container, shapeName, true);
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: MarkerSymbols[shapeName],
        style: {
          r: 4.5,
          stroke: color2,
          fill: null
        }
      };
    }
  });
});
registerShape("point", "image", {
  draw: function(cfg, container) {
    var size2 = getStyle(cfg, false, false, "r").r;
    var points = this.parsePoints(cfg.points);
    var pointPosition = points[0];
    if (cfg.isStack) {
      pointPosition = points[1];
    } else if (points.length > 1) {
      var group2 = container.addGroup();
      for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
        var point2 = points_1[_i];
        group2.addShape("image", {
          attrs: {
            x: point2.x - size2 / 2,
            y: point2.y - size2,
            width: size2,
            height: size2,
            img: cfg.shape[1]
          }
        });
      }
      return group2;
    }
    return container.addShape("image", {
      attrs: {
        x: pointPosition.x - size2 / 2,
        y: pointPosition.y - size2,
        width: size2,
        height: size2,
        img: cfg.shape[1]
      }
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: color2
      }
    };
  }
});
each$1(SHAPES, function(shapeName) {
  registerShape("point", shapeName, {
    draw: function(cfg, container) {
      return drawPoints(this, cfg, container, shapeName, false);
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: MarkerSymbols[shapeName] || shapeName,
        style: {
          r: 4.5,
          fill: color2
        }
      };
    }
  });
});
function parseValue(value2) {
  var array = !isArray$1(value2) ? [value2] : value2;
  var min2 = array[0];
  var max2 = array[array.length - 1];
  var min1 = array.length > 1 ? array[1] : min2;
  var max1 = array.length > 3 ? array[3] : max2;
  var median = array.length > 2 ? array[2] : min1;
  return {
    min: min2,
    max: max2,
    min1,
    max1,
    median
  };
}
function getBoxPoints(x, y, size2) {
  var halfSize = size2 / 2;
  var pointsArray;
  if (isArray$1(y)) {
    var _a2 = parseValue(y), min2 = _a2.min, max2 = _a2.max, median = _a2.median, min1 = _a2.min1, max1 = _a2.max1;
    var minX = x - halfSize;
    var maxX = x + halfSize;
    pointsArray = [
      [minX, max2],
      [maxX, max2],
      [x, max2],
      [x, max1],
      [minX, min1],
      [minX, max1],
      [maxX, max1],
      [maxX, min1],
      [x, min1],
      [x, min2],
      [minX, min2],
      [maxX, min2],
      [minX, median],
      [maxX, median]
    ];
  } else {
    y = isNil(y) ? 0.5 : y;
    var _b = parseValue(x), min2 = _b.min, max2 = _b.max, median = _b.median, min1 = _b.min1, max1 = _b.max1;
    var minY = y - halfSize;
    var maxY = y + halfSize;
    pointsArray = [
      [min2, minY],
      [min2, maxY],
      [min2, y],
      [min1, y],
      [min1, minY],
      [min1, maxY],
      [max1, maxY],
      [max1, minY],
      [max1, y],
      [max2, y],
      [max2, minY],
      [max2, maxY],
      [median, minY],
      [median, maxY]
    ];
  }
  return pointsArray.map(function(arr) {
    return {
      x: arr[0],
      y: arr[1]
    };
  });
}
function getBoxPath(points) {
  return [
    ["M", points[0].x, points[0].y],
    ["L", points[1].x, points[1].y],
    ["M", points[2].x, points[2].y],
    ["L", points[3].x, points[3].y],
    ["M", points[4].x, points[4].y],
    ["L", points[5].x, points[5].y],
    ["L", points[6].x, points[6].y],
    ["L", points[7].x, points[7].y],
    ["L", points[4].x, points[4].y],
    ["Z"],
    ["M", points[8].x, points[8].y],
    ["L", points[9].x, points[9].y],
    ["M", points[10].x, points[10].y],
    ["L", points[11].x, points[11].y],
    ["M", points[12].x, points[12].y],
    ["L", points[13].x, points[13].y]
  ];
}
registerShape("schema", "box", {
  getPoints: function(shapePoint) {
    var x = shapePoint.x, y = shapePoint.y, size2 = shapePoint.size;
    return getBoxPoints(x, y, size2);
  },
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false);
    var path2 = this.parsePath(getBoxPath(cfg.points));
    var shape = container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2, name: "schema" })
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        var yValues = [y - 6, y - 3, y, y + 3, y + 6];
        var points = getBoxPoints(x, yValues, r);
        return [
          ["M", points[0].x + 1, points[0].y],
          ["L", points[1].x - 1, points[1].y],
          ["M", points[2].x, points[2].y],
          ["L", points[3].x, points[3].y],
          ["M", points[4].x, points[4].y],
          ["L", points[5].x, points[5].y],
          ["L", points[6].x, points[6].y],
          ["L", points[7].x, points[7].y],
          ["L", points[4].x, points[4].y],
          ["Z"],
          ["M", points[8].x, points[8].y],
          ["L", points[9].x, points[9].y],
          ["M", points[10].x + 1, points[10].y],
          ["L", points[11].x - 1, points[11].y],
          ["M", points[12].x, points[12].y],
          ["L", points[13].x, points[13].y]
        ];
      },
      style: {
        r: 6,
        lineWidth: 1,
        stroke: color2
      }
    };
  }
});
function getCandleYValues(value2) {
  var array = !isArray$1(value2) ? [value2] : value2;
  var sorted = array.sort(function(a, b) {
    return b - a;
  });
  return padEnd(sorted, 4, sorted[sorted.length - 1]);
}
function getCandlePoints(x, y, size2) {
  var yValues = getCandleYValues(y);
  return [
    { x, y: yValues[0] },
    { x, y: yValues[1] },
    { x: x - size2 / 2, y: yValues[2] },
    { x: x - size2 / 2, y: yValues[1] },
    { x: x + size2 / 2, y: yValues[1] },
    { x: x + size2 / 2, y: yValues[2] },
    { x, y: yValues[2] },
    { x, y: yValues[3] }
  ];
}
function getCandlePath(points) {
  return [
    ["M", points[0].x, points[0].y],
    ["L", points[1].x, points[1].y],
    ["M", points[2].x, points[2].y],
    ["L", points[3].x, points[3].y],
    ["L", points[4].x, points[4].y],
    ["L", points[5].x, points[5].y],
    ["Z"],
    ["M", points[6].x, points[6].y],
    ["L", points[7].x, points[7].y]
  ];
}
registerShape("schema", "candle", {
  getPoints: function(shapePoint) {
    var x = shapePoint.x, y = shapePoint.y, size2 = shapePoint.size;
    return getCandlePoints(x, y, size2);
  },
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, true);
    var path2 = this.parsePath(getCandlePath(cfg.points));
    var shape = container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2, name: "schema" })
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        var yValues = [y + 7.5, y + 3, y - 3, y - 7.5];
        var points = getCandlePoints(x, yValues, r);
        return [
          ["M", points[0].x, points[0].y],
          ["L", points[1].x, points[1].y],
          ["M", points[2].x, points[2].y],
          ["L", points[3].x, points[3].y],
          ["L", points[4].x, points[4].y],
          ["L", points[5].x, points[5].y],
          ["Z"],
          ["M", points[6].x, points[6].y],
          ["L", points[7].x, points[7].y]
        ];
      },
      style: {
        lineWidth: 1,
        stroke: color2,
        fill: color2,
        r: 6
      }
    };
  }
});
function getRectAttrs(points, size2) {
  var width = Math.abs(points[0].x - points[2].x);
  var height = Math.abs(points[0].y - points[2].y);
  var len = Math.min(width, height);
  if (size2) {
    len = clamp(size2, 0, Math.min(width, height));
  }
  len = len / 2;
  var centerX = (points[0].x + points[2].x) / 2;
  var centerY = (points[0].y + points[2].y) / 2;
  return {
    x: centerX - len,
    y: centerY - len,
    width: len * 2,
    height: len * 2
  };
}
registerShape("polygon", "square", {
  draw: function(cfg, container) {
    if (!isEmpty(cfg.points)) {
      var shapeAttrs = getStyle(cfg, true, true);
      var points = this.parsePoints(cfg.points);
      return container.addShape("rect", {
        attrs: __assign$1(__assign$1({}, shapeAttrs), getRectAttrs(points, cfg.size)),
        name: "polygon"
      });
    }
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
registerShape("violin", "smooth", {
  draw: function(cfg, container) {
    var attrs = getStyle(cfg, true, true);
    var path2 = this.parsePath(getSmoothViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign$1(__assign$1({}, attrs), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        stroke: null,
        r: 4,
        fill: color2
      }
    };
  }
});
registerShape("violin", "hollow", {
  draw: function(cfg, container) {
    var attrs = getStyle(cfg, true, false);
    var path2 = this.parsePath(getViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign$1(__assign$1({}, attrs), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4,
        fill: null,
        stroke: color2
      }
    };
  }
});
registerShape("violin", "hollow-smooth", {
  draw: function(cfg, container) {
    var attrs = getStyle(cfg, true, false);
    var path2 = this.parsePath(getSmoothViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign$1(__assign$1({}, attrs), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4,
        fill: null,
        stroke: color2
      }
    };
  }
});
var IntervalLabel = function(_super) {
  __extends$2(IntervalLabel2, _super);
  function IntervalLabel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IntervalLabel2.prototype.getLabelValueDir = function(mappingData) {
    var dim = "y";
    var points = mappingData.points;
    return points[0][dim] <= points[2][dim] ? 1 : -1;
  };
  IntervalLabel2.prototype.getLabelOffsetPoint = function(labelCfg, index2, total, position) {
    var _a2;
    var point2 = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index2, total);
    var coordinate2 = this.getCoordinate();
    var transposed = coordinate2.isTransposed;
    var dim = transposed ? "x" : "y";
    var dir = this.getLabelValueDir(labelCfg.mappingData);
    point2 = __assign$1(__assign$1({}, point2), (_a2 = {}, _a2[dim] = point2[dim] * dir, _a2));
    if (coordinate2.isReflect("x")) {
      point2 = __assign$1(__assign$1({}, point2), { x: point2.x * -1 });
    }
    if (coordinate2.isReflect("y")) {
      point2 = __assign$1(__assign$1({}, point2), { y: point2.y * -1 });
    }
    return point2;
  };
  IntervalLabel2.prototype.getThemedLabelCfg = function(labelCfg) {
    var geometry2 = this.geometry;
    var defaultLabelCfg = this.getDefaultLabelCfg();
    var theme2 = geometry2.theme;
    return deepMix({}, defaultLabelCfg, theme2.labels, labelCfg.position === "middle" ? { offset: 0 } : {}, labelCfg);
  };
  IntervalLabel2.prototype.setLabelPosition = function(labelPointCfg, mappingData, index2, position) {
    var coordinate2 = this.getCoordinate();
    var transposed = coordinate2.isTransposed;
    var shapePoints = mappingData.points;
    var point0 = coordinate2.convert(shapePoints[0]);
    var point2 = coordinate2.convert(shapePoints[2]);
    var dir = this.getLabelValueDir(mappingData);
    var top;
    var right2;
    var bottom;
    var left2;
    var shape = isArray$1(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
    if (shape === "funnel" || shape === "pyramid") {
      var nextPoints = get(mappingData, "nextPoints");
      var points = get(mappingData, "points");
      if (nextPoints) {
        var p0 = coordinate2.convert(points[0]);
        var p1 = coordinate2.convert(points[1]);
        var nextP0 = coordinate2.convert(nextPoints[0]);
        var nextP1 = coordinate2.convert(nextPoints[1]);
        if (transposed) {
          top = Math.min(nextP0.y, p0.y);
          bottom = Math.max(nextP0.y, p0.y);
          right2 = (p1.x + nextP1.x) / 2;
          left2 = (p0.x + nextP0.x) / 2;
        } else {
          top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
          bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
          right2 = nextP1.x;
          left2 = p0.x;
        }
      } else {
        top = Math.min(point2.y, point0.y);
        bottom = Math.max(point2.y, point0.y);
        right2 = point2.x;
        left2 = point0.x;
      }
    } else {
      top = Math.min(point2.y, point0.y);
      bottom = Math.max(point2.y, point0.y);
      right2 = point2.x;
      left2 = point0.x;
    }
    switch (position) {
      case "right":
        labelPointCfg.x = right2;
        labelPointCfg.y = (top + bottom) / 2;
        labelPointCfg.textAlign = get(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
        break;
      case "left":
        labelPointCfg.x = left2;
        labelPointCfg.y = (top + bottom) / 2;
        labelPointCfg.textAlign = get(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
        break;
      case "bottom":
        if (transposed) {
          labelPointCfg.x = (right2 + left2) / 2;
        }
        labelPointCfg.y = bottom;
        labelPointCfg.textAlign = get(labelPointCfg, "textAlign", "center");
        labelPointCfg.textBaseline = get(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
        break;
      case "middle":
        if (transposed) {
          labelPointCfg.x = (right2 + left2) / 2;
        }
        labelPointCfg.y = (top + bottom) / 2;
        labelPointCfg.textAlign = get(labelPointCfg, "textAlign", "center");
        labelPointCfg.textBaseline = get(labelPointCfg, "textBaseline", "middle");
        break;
      case "top":
        if (transposed) {
          labelPointCfg.x = (right2 + left2) / 2;
        }
        labelPointCfg.y = top;
        labelPointCfg.textAlign = get(labelPointCfg, "textAlign", "center");
        labelPointCfg.textBaseline = get(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
        break;
    }
  };
  return IntervalLabel2;
}(GeometryLabel);
var HALF_PI = Math.PI / 2;
var PolarLabel = function(_super) {
  __extends$2(PolarLabel2, _super);
  function PolarLabel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PolarLabel2.prototype.getLabelOffset = function(offset) {
    var coordinate2 = this.getCoordinate();
    var actualOffset = 0;
    if (isNumber$1(offset)) {
      actualOffset = offset;
    } else if (isString(offset) && offset.indexOf("%") !== -1) {
      var r = coordinate2.getRadius();
      if (coordinate2.innerRadius > 0) {
        r = r * (1 - coordinate2.innerRadius);
      }
      actualOffset = parseFloat(offset) * 0.01 * r;
    }
    return actualOffset;
  };
  PolarLabel2.prototype.getLabelItems = function(mapppingArray) {
    var items = _super.prototype.getLabelItems.call(this, mapppingArray);
    var yScale = this.geometry.getYScale();
    return map$2(items, function(item) {
      if (item && yScale) {
        var percent2 = yScale.scale(get(item.data, yScale.field));
        return __assign$1(__assign$1({}, item), { percent: percent2 });
      }
      return item;
    });
  };
  PolarLabel2.prototype.getLabelAlign = function(point2) {
    var coordinate2 = this.getCoordinate();
    var align;
    if (point2.labelEmit) {
      align = point2.angle <= Math.PI / 2 && point2.angle >= -Math.PI / 2 ? "left" : "right";
    } else if (!coordinate2.isTransposed) {
      align = "center";
    } else {
      var center2 = coordinate2.getCenter();
      var offset = point2.offset;
      if (Math.abs(point2.x - center2.x) < 1) {
        align = "center";
      } else if (point2.angle > Math.PI || point2.angle <= 0) {
        align = offset > 0 ? "left" : "right";
      } else {
        align = offset > 0 ? "right" : "left";
      }
    }
    return align;
  };
  PolarLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index2) {
    var factor = 1;
    var arcPoint;
    var content = labelCfg.content[index2];
    if (this.isToMiddle(mappingData)) {
      arcPoint = this.getMiddlePoint(mappingData.points);
    } else {
      if (labelCfg.content.length === 1 && index2 === 0) {
        index2 = 1;
      } else if (index2 === 0) {
        factor = -1;
      }
      arcPoint = this.getArcPoint(mappingData, index2);
    }
    var offset = labelCfg.offset * factor;
    var middleAngle = this.getPointAngle(arcPoint);
    var isLabelEmit = labelCfg.labelEmit;
    var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);
    if (labelPositionCfg.r === 0) {
      labelPositionCfg.content = "";
    } else {
      labelPositionCfg.content = content;
      labelPositionCfg.angle = middleAngle;
      labelPositionCfg.color = mappingData.color;
    }
    labelPositionCfg.rotate = labelCfg.autoRotate ? this.getLabelRotate(middleAngle, offset, isLabelEmit) : labelCfg.rotate;
    labelPositionCfg.start = {
      x: arcPoint.x,
      y: arcPoint.y
    };
    return labelPositionCfg;
  };
  PolarLabel2.prototype.getArcPoint = function(mappingData, index2) {
    if (index2 === void 0) {
      index2 = 0;
    }
    if (!isArray$1(mappingData.x) && !isArray$1(mappingData.y)) {
      return {
        x: mappingData.x,
        y: mappingData.y
      };
    }
    return {
      x: isArray$1(mappingData.x) ? mappingData.x[index2] : mappingData.x,
      y: isArray$1(mappingData.y) ? mappingData.y[index2] : mappingData.y
    };
  };
  PolarLabel2.prototype.getPointAngle = function(point2) {
    return getAngleByPoint(this.getCoordinate(), point2);
  };
  PolarLabel2.prototype.getCirclePoint = function(angle2, offset, point2, isLabelEmit) {
    var coordinate2 = this.getCoordinate();
    var center2 = coordinate2.getCenter();
    var r = getDistanceToCenter(coordinate2, point2);
    if (r === 0) {
      return __assign$1(__assign$1({}, center2), { r });
    }
    var labelAngle = angle2;
    if (coordinate2.isTransposed && r > offset && !isLabelEmit) {
      var appendAngle = Math.asin(offset / (2 * r));
      labelAngle = angle2 + appendAngle * 2;
    } else {
      r = r + offset;
    }
    return {
      x: center2.x + r * Math.cos(labelAngle),
      y: center2.y + r * Math.sin(labelAngle),
      r
    };
  };
  PolarLabel2.prototype.getLabelRotate = function(angle2, offset, isLabelEmit) {
    var rotate2 = angle2 + HALF_PI;
    if (isLabelEmit) {
      rotate2 -= HALF_PI;
    }
    if (rotate2) {
      if (rotate2 > HALF_PI) {
        rotate2 = rotate2 - Math.PI;
      } else if (rotate2 < -HALF_PI) {
        rotate2 = rotate2 + Math.PI;
      }
    }
    return rotate2;
  };
  PolarLabel2.prototype.getMiddlePoint = function(points) {
    var coordinate2 = this.getCoordinate();
    var count = points.length;
    var middlePoint = {
      x: 0,
      y: 0
    };
    each$1(points, function(point2) {
      middlePoint.x += point2.x;
      middlePoint.y += point2.y;
    });
    middlePoint.x /= count;
    middlePoint.y /= count;
    middlePoint = coordinate2.convert(middlePoint);
    return middlePoint;
  };
  PolarLabel2.prototype.isToMiddle = function(mappingData) {
    return mappingData.x.length > 2;
  };
  return PolarLabel2;
}(GeometryLabel);
var PieLabel = function(_super) {
  __extends$2(PieLabel2, _super);
  function PieLabel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.defaultLayout = "distribute";
    return _this;
  }
  PieLabel2.prototype.getDefaultLabelCfg = function(offset, position) {
    var cfg = _super.prototype.getDefaultLabelCfg.call(this, offset, position);
    return deepMix({}, cfg, get(this.geometry.theme, "pieLabels", {}));
  };
  PieLabel2.prototype.getLabelOffset = function(offset) {
    return _super.prototype.getLabelOffset.call(this, offset) || 0;
  };
  PieLabel2.prototype.getLabelRotate = function(angle2, offset, isLabelLimit) {
    var rotate2;
    if (offset < 0) {
      rotate2 = angle2;
      if (rotate2 > Math.PI / 2) {
        rotate2 = rotate2 - Math.PI;
      }
      if (rotate2 < -Math.PI / 2) {
        rotate2 = rotate2 + Math.PI;
      }
    }
    return rotate2;
  };
  PieLabel2.prototype.getLabelAlign = function(point2) {
    var coordinate2 = this.getCoordinate();
    var center2 = coordinate2.getCenter();
    var align;
    if (point2.angle <= Math.PI / 2 && point2.x >= center2.x) {
      align = "left";
    } else {
      align = "right";
    }
    if (point2.offset <= 0) {
      if (align === "right") {
        align = "left";
      } else {
        align = "right";
      }
    }
    return align;
  };
  PieLabel2.prototype.getArcPoint = function(point2) {
    return point2;
  };
  PieLabel2.prototype.getPointAngle = function(point2) {
    var coordinate2 = this.getCoordinate();
    var startPoint = {
      x: isArray$1(point2.x) ? point2.x[0] : point2.x,
      y: point2.y[0]
    };
    var endPoint = {
      x: isArray$1(point2.x) ? point2.x[1] : point2.x,
      y: point2.y[1]
    };
    var angle2;
    var startAngle = getAngleByPoint(coordinate2, startPoint);
    if (point2.points && point2.points[0].y === point2.points[1].y) {
      angle2 = startAngle;
    } else {
      var endAngle = getAngleByPoint(coordinate2, endPoint);
      if (startAngle >= endAngle) {
        endAngle = endAngle + Math.PI * 2;
      }
      angle2 = startAngle + (endAngle - startAngle) / 2;
    }
    return angle2;
  };
  PieLabel2.prototype.getCirclePoint = function(angle2, offset) {
    var coordinate2 = this.getCoordinate();
    var center2 = coordinate2.getCenter();
    var r = coordinate2.getRadius() + offset;
    return __assign$1(__assign$1({}, polarToCartesian(center2.x, center2.y, r, angle2)), { angle: angle2, r });
  };
  return PieLabel2;
}(PolarLabel);
var MARGIN$1 = 4;
function antiCollision$1(labelShapes, labels, lineHeight, plotRange, center2, isRight) {
  var overlapping = true;
  var start = plotRange.start;
  var end = plotRange.end;
  var startY = Math.min(start.y, end.y);
  var totalHeight = Math.abs(start.y - end.y);
  var i;
  var maxY = 0;
  var minY = Number.MIN_VALUE;
  var boxes = labels.map(function(label2) {
    if (label2.y > maxY) {
      maxY = label2.y;
    }
    if (label2.y < minY) {
      minY = label2.y;
    }
    return {
      size: lineHeight,
      targets: [label2.y - startY]
    };
  });
  minY -= startY;
  if (maxY - startY > totalHeight) {
    totalHeight = maxY - startY;
  }
  while (overlapping) {
    boxes.forEach(function(box3) {
      var target = (Math.min.apply(minY, box3.targets) + Math.max.apply(minY, box3.targets)) / 2;
      box3.pos = Math.min(Math.max(minY, target - box3.size / 2), totalHeight - box3.size);
    });
    overlapping = false;
    i = boxes.length;
    while (i--) {
      if (i > 0) {
        var previousBox = boxes[i - 1];
        var box2 = boxes[i];
        if (previousBox.pos + previousBox.size > box2.pos) {
          previousBox.size += box2.size;
          previousBox.targets = previousBox.targets.concat(box2.targets);
          if (previousBox.pos + previousBox.size > totalHeight) {
            previousBox.pos = totalHeight - previousBox.size;
          }
          boxes.splice(i, 1);
          overlapping = true;
        }
      }
    }
  }
  i = 0;
  boxes.forEach(function(b) {
    var posInCompositeBox = startY + lineHeight / 2;
    b.targets.forEach(function() {
      labels[i].y = b.pos + posInCompositeBox;
      posInCompositeBox += lineHeight;
      i++;
    });
  });
  var labelsMap = {};
  for (var _i = 0, labelShapes_1 = labelShapes; _i < labelShapes_1.length; _i++) {
    var labelShape = labelShapes_1[_i];
    labelsMap[labelShape.get("id")] = labelShape;
  }
  labels.forEach(function(label2) {
    var rPow2 = label2.r * label2.r;
    var dyPow2 = Math.pow(Math.abs(label2.y - center2.y), 2);
    if (rPow2 < dyPow2) {
      label2.x = center2.x;
    } else {
      var dx = Math.sqrt(rPow2 - dyPow2);
      if (!isRight) {
        label2.x = center2.x - dx;
      } else {
        label2.x = center2.x + dx;
      }
    }
    var labelShape2 = labelsMap[label2.id];
    labelShape2.attr("x", label2.x);
    labelShape2.attr("y", label2.y);
    var textShape = find$1(labelShape2.getChildren(), function(ele) {
      return ele.get("type") === "text";
    });
    if (textShape) {
      textShape.attr("y", label2.y);
      textShape.attr("x", label2.x);
    }
  });
}
function distribute(items, labels, shapes, region) {
  if (!items.length || !labels.length) {
    return;
  }
  var offset = items[0] ? items[0].offset : 0;
  var coordinate2 = labels[0].get("coordinate");
  var radius = coordinate2.getRadius();
  var center2 = coordinate2.getCenter();
  if (offset > 0) {
    var lineHeight_1 = 14;
    var totalR = radius + offset;
    var totalHeight_1 = totalR * 2 + lineHeight_1 * 2;
    var plotRange_1 = {
      start: coordinate2.start,
      end: coordinate2.end
    };
    var halves_1 = [
      [],
      []
    ];
    items.forEach(function(labelItem) {
      if (!labelItem) {
        return;
      }
      if (labelItem.textAlign === "right") {
        halves_1[0].push(labelItem);
      } else {
        halves_1[1].push(labelItem);
      }
    });
    halves_1.forEach(function(half, index2) {
      var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;
      if (half.length > maxLabelsCountForOneSide) {
        half.sort(function(a, b) {
          return b["..percent"] - a["..percent"];
        });
        half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);
      }
      half.sort(function(a, b) {
        return a.y - b.y;
      });
      antiCollision$1(labels, half, lineHeight_1, plotRange_1, center2, index2);
    });
  }
  each$1(items, function(item) {
    if (item && item.labelLine) {
      var distance2 = item.offset;
      var angle2 = item.angle;
      var startPoint = polarToCartesian(center2.x, center2.y, radius, angle2);
      var innerPoint = polarToCartesian(center2.x, center2.y, radius + distance2 / 2, angle2);
      var itemX = item.x + get(item, "offsetX", 0);
      var itemY = item.y + get(item, "offsetY", 0);
      var endPoint = {
        x: itemX - Math.cos(angle2) * MARGIN$1,
        y: itemY - Math.sin(angle2) * MARGIN$1
      };
      if (!isObject(item.labelLine)) {
        item.labelLine = {};
      }
      item.labelLine.path = [
        "M " + startPoint.x,
        startPoint.y + " Q" + innerPoint.x,
        innerPoint.y + " " + endPoint.x,
        endPoint.y
      ].join(",");
    }
  });
}
function antiCollision(items, labelHeight, plotRange) {
  var labels = items.filter(function(item) {
    return !item.invisible;
  });
  labels.sort(function(a, b) {
    return a.y - b.y;
  });
  var overlapping = true;
  var startY = plotRange.minY;
  var endY = plotRange.maxY;
  var totalHeight = Math.abs(startY - endY);
  var i;
  var maxY = 0;
  var minY = Number.MIN_VALUE;
  var boxes = labels.map(function(label2) {
    if (label2.y > maxY) {
      maxY = label2.y;
    }
    if (label2.y < minY) {
      minY = label2.y;
    }
    return {
      content: label2.content,
      size: labelHeight,
      targets: [label2.y - startY],
      pos: null
    };
  });
  minY -= startY;
  if (maxY - startY > totalHeight) {
    totalHeight = maxY - startY;
  }
  while (overlapping) {
    boxes.forEach(function(box3) {
      var target = (Math.min.apply(minY, box3.targets) + Math.max.apply(minY, box3.targets)) / 2;
      box3.pos = Math.min(Math.max(minY, target - box3.size / 2), totalHeight - box3.size);
      box3.pos = Math.max(0, box3.pos);
    });
    overlapping = false;
    i = boxes.length;
    while (i--) {
      if (i > 0) {
        var previousBox = boxes[i - 1];
        var box2 = boxes[i];
        if (previousBox.pos + previousBox.size > box2.pos) {
          previousBox.size += box2.size;
          previousBox.targets = previousBox.targets.concat(box2.targets);
          if (previousBox.pos + previousBox.size > totalHeight) {
            previousBox.pos = totalHeight - previousBox.size;
          }
          boxes.splice(i, 1);
          overlapping = true;
        }
      }
    }
  }
  i = 0;
  boxes.forEach(function(b) {
    var posInCompositeBox = startY + labelHeight / 2;
    b.targets.forEach(function() {
      labels[i].y = b.pos + posInCompositeBox;
      posInCompositeBox += labelHeight;
      i++;
    });
  });
}
var MARGIN = 4;
function drawLabelline$1(item, coordinate2) {
  var center2 = coordinate2.getCenter();
  var radius = coordinate2.getRadius();
  if (item && item.labelLine) {
    var angle2 = item.angle, labelOffset = item.offset;
    var startPoint = polarToCartesian(center2.x, center2.y, radius, angle2);
    var itemX = item.x + get(item, "offsetX", 0) * (Math.cos(angle2) > 0 ? 1 : -1);
    var itemY = item.y + get(item, "offsetY", 0) * (Math.sin(angle2) > 0 ? 1 : -1);
    var endPoint = {
      x: itemX - Math.cos(angle2) * MARGIN,
      y: itemY - Math.sin(angle2) * MARGIN
    };
    var smoothConnector = item.labelLine.smooth;
    var path2 = [];
    var dx = endPoint.x - center2.x;
    var dy = endPoint.y - center2.y;
    var endAngle = Math.atan(dy / dx);
    if (dx < 0) {
      endAngle += Math.PI;
    }
    if (smoothConnector === false) {
      if (!isObject(item.labelLine)) {
        item.labelLine = {};
      }
      var sweepFlag = 0;
      if (angle2 < 0 && angle2 > -Math.PI / 2 || angle2 > Math.PI * 1.5) {
        if (endPoint.y > startPoint.y) {
          sweepFlag = 1;
        }
      }
      if (angle2 >= 0 && angle2 < Math.PI / 2) {
        if (endPoint.y > startPoint.y) {
          sweepFlag = 1;
        }
      }
      if (angle2 >= Math.PI / 2 && angle2 < Math.PI) {
        if (startPoint.y > endPoint.y) {
          sweepFlag = 1;
        }
      }
      if (angle2 < -Math.PI / 2 || angle2 >= Math.PI && angle2 < Math.PI * 1.5) {
        if (startPoint.y > endPoint.y) {
          sweepFlag = 1;
        }
      }
      var distance2 = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);
      var breakPoint = polarToCartesian(center2.x, center2.y, radius + distance2, angle2);
      var breakPoint3 = polarToCartesian(center2.x, center2.y, radius + labelOffset / 2, endAngle);
      var largeArcFlag = 0;
      path2.push("M " + startPoint.x + " " + startPoint.y);
      path2.push("L " + breakPoint.x + " " + breakPoint.y);
      path2.push("A " + center2.x + " " + center2.y + " 0 " + largeArcFlag + " " + sweepFlag + " " + breakPoint3.x + " " + breakPoint3.y);
      path2.push("L " + endPoint.x + " " + endPoint.y);
    } else {
      var breakPoint = polarToCartesian(center2.x, center2.y, radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)), angle2);
      var xSign = startPoint.x < center2.x ? 1 : -1;
      path2.push("M " + endPoint.x + " " + endPoint.y);
      var slope1 = (startPoint.y - center2.y) / (startPoint.x - center2.x);
      var slope2 = (endPoint.y - center2.y) / (endPoint.x - center2.x);
      if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {
        path2.push.apply(path2, [
          "C",
          endPoint.x + xSign * 4,
          endPoint.y,
          2 * breakPoint.x - startPoint.x,
          2 * breakPoint.y - startPoint.y,
          startPoint.x,
          startPoint.y
        ]);
      }
      path2.push("L " + startPoint.x + " " + startPoint.y);
    }
    item.labelLine.path = path2.join(" ");
  }
}
function pieOuterLabelLayout(originalItems, labels, shapes, region) {
  var items = filter(originalItems, function(item) {
    return !isNil(item);
  });
  var coordinate2 = labels[0] && labels[0].get("coordinate");
  if (!coordinate2) {
    return;
  }
  var center2 = coordinate2.getCenter();
  var radius = coordinate2.getRadius();
  var labelsMap = {};
  for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
    var labelShape = labels_1[_i];
    labelsMap[labelShape.get("id")] = labelShape;
  }
  var labelHeight = get(items[0], "labelHeight", 14);
  var labelOffset = get(items[0], "offset", 0);
  if (labelOffset <= 0) {
    return;
  }
  var LEFT_HALF_KEY = "left";
  var RIGHT_HALF_KEY = "right";
  var separateLabels = groupBy(items, function(item) {
    return item.x < center2.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
  });
  var start = coordinate2.start, end = coordinate2.end;
  var totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate2.getHeight());
  var totalR = totalHeight / 2;
  var labelsContainerRange = {
    minX: start.x,
    maxX: end.x,
    minY: center2.y - totalR,
    maxY: center2.y + totalR
  };
  each$1(separateLabels, function(half, key) {
    var maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);
    if (half.length > maxLabelsCountForOneSide) {
      half.sort(function(a, b) {
        return b.percent - a.percent;
      });
      each$1(half, function(labelItem, idx) {
        if (idx + 1 > maxLabelsCountForOneSide) {
          labelsMap[labelItem.id].set("visible", false);
          labelItem.invisible = true;
        }
      });
    }
    antiCollision(half, labelHeight, labelsContainerRange);
  });
  each$1(separateLabels, function(half, key) {
    each$1(half, function(item) {
      var isRight = key === RIGHT_HALF_KEY;
      var labelShape2 = labelsMap[item.id];
      var content = labelShape2.getChildByIndex(0);
      if (content) {
        var r = radius + labelOffset;
        var dy = item.y - center2.y;
        var rPow2 = Math.pow(r, 2);
        var dyPow2 = Math.pow(dy, 2);
        var dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;
        var dx = Math.sqrt(dxPow2);
        var dx_offset = Math.abs(Math.cos(item.angle) * r);
        if (!isRight) {
          item.x = center2.x - Math.max(dx, dx_offset);
        } else {
          item.x = center2.x + Math.max(dx, dx_offset);
        }
      }
      if (content) {
        content.attr("y", item.y);
        content.attr("x", item.x);
      }
      drawLabelline$1(item, coordinate2);
    });
  });
}
var INFLECTION_OFFSET = 4;
var LABEL_OFFSET_X = 4;
var LABEL_TEXT_LINE_OFFSET = 4;
function drawLabelline(item, coordinate2, inRight) {
  var center2 = coordinate2.getCenter();
  var radius = coordinate2.getRadius();
  var startPoint = {
    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),
    y: item.y
  };
  var inflectionPoint = polarToCartesian(center2.x, center2.y, radius + INFLECTION_OFFSET, item.angle);
  var p1 = { x: startPoint.x, y: startPoint.y };
  var p2 = { x: inflectionPoint.x, y: inflectionPoint.y };
  var endPoint = polarToCartesian(center2.x, center2.y, radius, item.angle);
  var path2 = "";
  if (startPoint.y !== inflectionPoint.y) {
    var offset = inRight ? 4 : -4;
    p1.y = startPoint.y;
    if (item.angle < 0 && item.angle >= -Math.PI / 2) {
      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y < inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.max(p2.x, p1.x - offset);
      }
    }
    if (item.angle > 0 && item.angle < Math.PI / 2) {
      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y > inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.max(p2.x, p1.x - offset);
      }
    }
    if (item.angle > Math.PI / 2) {
      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y > inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.min(p2.x, p1.x - offset);
      }
    }
    if (item.angle < -Math.PI / 2) {
      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y < inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.min(p2.x, p1.x - offset);
      }
    }
  }
  path2 = [
    "M " + startPoint.x + "," + startPoint.y,
    "L " + p1.x + "," + p1.y,
    "L " + p2.x + "," + p2.y,
    "L " + inflectionPoint.x + "," + inflectionPoint.y,
    "L " + endPoint.x + "," + endPoint.y
  ].join(" ");
  item.labelLine = deepMix({}, item.labelLine, { path: path2 });
}
function pieSpiderLabelLayout(items, labels, shapes, region) {
  var coordinate2 = labels[0] && labels[0].get("coordinate");
  if (!coordinate2) {
    return;
  }
  var center2 = coordinate2.getCenter();
  var radius = coordinate2.getRadius();
  var labelsMap = {};
  for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
    var labelShape = labels_1[_i];
    labelsMap[labelShape.get("id")] = labelShape;
  }
  var labelHeight = get(items[0], "labelHeight", 14);
  var labelOffset = Math.max(get(items[0], "offset", 0), INFLECTION_OFFSET);
  each$1(items, function(item) {
    var label2 = get(labelsMap, [item.id]);
    if (!label2) {
      return;
    }
    var inRight = item.x > center2.x || item.x === center2.x && item.y > center2.y;
    var offsetX = !isNil(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;
    var inflectionPoint = polarToCartesian(center2.x, center2.y, radius + INFLECTION_OFFSET, item.angle);
    var totalOffset = labelOffset + offsetX;
    item.x = center2.x + (inRight ? 1 : -1) * (radius + totalOffset);
    item.y = inflectionPoint.y;
  });
  var start = coordinate2.start, end = coordinate2.end;
  var LEFT_HALF_KEY = "left";
  var RIGHT_HALF_KEY = "right";
  var seperateLabels = groupBy(items, function(item) {
    return item.x < center2.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
  });
  var totalHeight = (radius + labelOffset) * 2 + labelHeight;
  each$1(seperateLabels, function(half) {
    var halfHeight = half.length * labelHeight;
    if (halfHeight > totalHeight) {
      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));
    }
  });
  var labelsContainerRange = {
    minX: start.x,
    maxX: end.x,
    minY: center2.y - totalHeight / 2,
    maxY: center2.y + totalHeight / 2
  };
  each$1(seperateLabels, function(half, key) {
    var maxLabelsCountForOneSide = totalHeight / labelHeight;
    if (half.length > maxLabelsCountForOneSide) {
      half.sort(function(a, b) {
        return b.percent - a.percent;
      });
      each$1(half, function(labelItem, idx) {
        if (idx > maxLabelsCountForOneSide) {
          labelsMap[labelItem.id].set("visible", false);
          labelItem.invisible = true;
        }
      });
    }
    antiCollision(half, labelHeight, labelsContainerRange);
  });
  var startY = labelsContainerRange.minY;
  var endY = labelsContainerRange.maxY;
  each$1(seperateLabels, function(half, key) {
    var inRight = key === RIGHT_HALF_KEY;
    each$1(half, function(item) {
      var label2 = get(labelsMap, item && [item.id]);
      if (!label2) {
        return;
      }
      if (item.y < startY || item.y > endY) {
        label2.set("visible", false);
        return;
      }
      var labelContent = label2.getChildByIndex(0);
      var box2 = labelContent.getCanvasBBox();
      var originalPos = { x: inRight ? box2.x : box2.maxX, y: box2.y + box2.height / 2 };
      translate(labelContent, item.x - originalPos.x, item.y - originalPos.y);
      if (item.labelLine) {
        drawLabelline(item, coordinate2, inRight);
      }
    });
  });
}
function limitInCanvas(items, labels, shapes, region) {
  each$1(labels, function(label2) {
    var regionMinX = region.minX, regionMinY = region.minY, regionMaxX = region.maxX, regionMaxY = region.maxY;
    var _a2 = label2.getCanvasBBox(), minX = _a2.minX, minY = _a2.minY, maxX = _a2.maxX, maxY = _a2.maxY, x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
    var finalX = x;
    var finalY = y;
    if (minX < regionMinX || maxX < regionMinX) {
      finalX = regionMinX;
    }
    if (minY < regionMinY || maxY < regionMinY) {
      finalY = regionMinY;
    }
    if (minX > regionMaxX) {
      finalX = regionMaxX - width;
    } else if (maxX > regionMaxX) {
      finalX = finalX - (maxX - regionMaxX);
    }
    if (minY > regionMaxY) {
      finalY = regionMaxY - height;
    } else if (maxY > regionMaxY) {
      finalY = finalY - (maxY - regionMaxY);
    }
    if (finalX !== x || finalY !== y) {
      translate(label2, finalX - x, finalY - y);
    }
  });
}
function limitInShape(items, labels, shapes, region) {
  each$1(labels, function(label2, index2) {
    var labelBBox = label2.getCanvasBBox();
    var shapeBBox = shapes[index2].getBBox();
    if (labelBBox.minX < shapeBBox.minX || labelBBox.minY < shapeBBox.minY || labelBBox.maxX > shapeBBox.maxX || labelBBox.maxY > shapeBBox.maxY) {
      label2.remove(true);
    }
  });
}
var MAX_TIMES = 100;
var Greedy = function() {
  function Greedy2(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    this.bitmap = {};
    var _a2 = cfg.xGap, xGap = _a2 === void 0 ? 1 : _a2, _b = cfg.yGap, yGap = _b === void 0 ? 8 : _b;
    this.xGap = xGap;
    this.yGap = yGap;
  }
  Greedy2.prototype.hasGap = function(bbox) {
    var hasGap = true;
    var bitmap = this.bitmap;
    var minX = Math.round(bbox.minX);
    var maxX = Math.round(bbox.maxX);
    var minY = Math.round(bbox.minY);
    var maxY = Math.round(bbox.maxY);
    for (var i = minX; i <= maxX; i += 1) {
      if (!bitmap[i]) {
        bitmap[i] = {};
        continue;
      }
      if (i === minX || i === maxX) {
        for (var j = minY; j <= maxY; j++) {
          if (bitmap[i][j]) {
            hasGap = false;
            break;
          }
        }
      } else {
        if (bitmap[i][minY] || bitmap[i][maxY]) {
          hasGap = false;
          break;
        }
      }
    }
    return hasGap;
  };
  Greedy2.prototype.fillGap = function(bbox) {
    var bitmap = this.bitmap;
    var minX = Math.round(bbox.minX);
    var maxX = Math.round(bbox.maxX);
    var minY = Math.round(bbox.minY);
    var maxY = Math.round(bbox.maxY);
    for (var i = minX; i <= maxX; i += 1) {
      if (!bitmap[i]) {
        bitmap[i] = {};
      }
    }
    for (var i = minX; i <= maxX; i += this.xGap) {
      for (var j = minY; j <= maxY; j += this.yGap) {
        bitmap[i][j] = true;
      }
      bitmap[i][maxY] = true;
    }
    if (this.yGap !== 1) {
      for (var i = minY; i <= maxY; i += 1) {
        bitmap[minX][i] = true;
        bitmap[maxX][i] = true;
      }
    }
    if (this.xGap !== 1) {
      for (var i = minX; i <= maxX; i += 1) {
        bitmap[i][minY] = true;
        bitmap[i][maxY] = true;
      }
    }
  };
  Greedy2.prototype.destroy = function() {
    this.bitmap = {};
  };
  return Greedy2;
}();
function spiralFill(label2, greedy, maxTimes) {
  if (maxTimes === void 0) {
    maxTimes = MAX_TIMES;
  }
  var dt = -1;
  var _a2 = label2.attr(), x = _a2.x, y = _a2.y;
  var bbox = label2.getCanvasBBox();
  var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);
  var dxdy;
  var t = -dt;
  var dx = 0;
  var dy = 0;
  var f = function(param) {
    var nt = param * 0.1;
    return [nt * Math.cos(nt), nt * Math.sin(nt)];
  };
  if (greedy.hasGap(bbox)) {
    greedy.fillGap(bbox);
    return true;
  }
  var canFill = false;
  var times = 0;
  var accessedCache = {};
  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {
    dxdy = f(t += dt);
    dx = ~~dxdy[0];
    dy = ~~dxdy[1];
    if (!dx && !dy || accessedCache[dx + "-" + dy]) {
      continue;
    }
    label2.attr({ x: x + dx, y: y + dy });
    if (dx + dy < 0) {
      label2.attr("textAlign", "right");
    }
    times++;
    if (greedy.hasGap(label2.getCanvasBBox())) {
      greedy.fillGap(label2.getCanvasBBox());
      canFill = true;
      accessedCache[dx + "-" + dy] = true;
      break;
    }
  }
  return canFill;
}
function adjustLabelPosition(label2, x, y, index2) {
  var _a2 = label2.getCanvasBBox(), width = _a2.width, height = _a2.height;
  var attrs = {
    x,
    y,
    textAlign: "center"
  };
  switch (index2) {
    case 0:
      attrs.y -= height + 1;
      attrs.x += 1;
      attrs.textAlign = "left";
      break;
    case 1:
      attrs.y -= height + 1;
      attrs.x -= 1;
      attrs.textAlign = "right";
      break;
    case 2:
      attrs.y += height + 1;
      attrs.x -= 1;
      attrs.textAlign = "right";
      break;
    case 3:
      attrs.y += height + 1;
      attrs.x += 1;
      attrs.textAlign = "left";
      break;
    case 5:
      attrs.y -= height * 2 + 2;
      break;
    case 6:
      attrs.y += height * 2 + 2;
      break;
    case 7:
      attrs.x += width + 1;
      attrs.textAlign = "left";
      break;
    case 8:
      attrs.x -= width + 1;
      attrs.textAlign = "right";
      break;
  }
  label2.attr(attrs);
  return label2.getCanvasBBox();
}
function fixedOverlap(items, labels, shapes, region) {
  var greedy = new Greedy();
  each$1(labels, function(label2) {
    var labelShape = label2.find(function(shape) {
      return shape.get("type") === "text";
    });
    if (!spiralFill(labelShape, greedy)) {
      label2.remove(true);
    }
  });
  greedy.destroy();
}
function overlap(items, labels, shapes, region) {
  var greedy = new Greedy();
  each$1(labels, function(label2) {
    var labelShape = label2.find(function(shape) {
      return shape.get("type") === "text";
    });
    var _a2 = labelShape.attr(), x = _a2.x, y = _a2.y;
    var canFill = false;
    for (var i = 0; i <= 8; i++) {
      var bbox = adjustLabelPosition(labelShape, x, y, i);
      if (greedy.hasGap(bbox)) {
        greedy.fillGap(bbox);
        canFill = true;
        break;
      }
    }
    if (!canFill) {
      label2.remove(true);
    }
  });
  greedy.destroy();
}
var dot = dot$1;
function getAxes(points) {
  if (points.length > 4) {
    return [];
  }
  var vector = function(start, end) {
    return [end.x - start.x, end.y - start.y];
  };
  var AB = vector(points[0], points[1]);
  var BC = vector(points[1], points[2]);
  return [AB, BC];
}
function rotateAtPoint(point2, deg, origin) {
  if (deg === void 0) {
    deg = 0;
  }
  if (origin === void 0) {
    origin = { x: 0, y: 0 };
  }
  var x = point2.x, y = point2.y;
  return {
    x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,
    y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y
  };
}
function getRectPoints(box2) {
  var points = [
    { x: box2.x, y: box2.y },
    { x: box2.x + box2.width, y: box2.y },
    { x: box2.x + box2.width, y: box2.y + box2.height },
    { x: box2.x, y: box2.y + box2.height }
  ];
  var rotation = box2.rotation;
  if (rotation) {
    return [
      rotateAtPoint(points[0], rotation, points[0]),
      rotateAtPoint(points[1], rotation, points[0]),
      rotateAtPoint(points[2], rotation, points[0]),
      rotateAtPoint(points[3], rotation, points[0])
    ];
  }
  return points;
}
function getProjection(points, axis2) {
  if (points.length > 4) {
    return { min: 0, max: 0 };
  }
  var scalars = [];
  points.forEach(function(point2) {
    scalars.push(dot([point2.x, point2.y], axis2));
  });
  return { min: Math.min.apply(Math, scalars), max: Math.max.apply(Math, scalars) };
}
function isProjectionOverlap(projection1, projection2) {
  return projection1.max > projection2.min && projection1.min < projection2.max;
}
function isValidNumber(d) {
  return isNumber$1(d) && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;
}
function isValidBox(box2) {
  return Object.values(box2).every(isValidNumber);
}
function isIntersectRect(box1, box2, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);
}
function isIntersect(box1, box2) {
  if (!isValidBox(box1) || !isValidBox(box2))
    return false;
  if (!box1.rotation && !box2.rotation) {
    return isIntersectRect(box1, box2);
  }
  var rect1Points = getRectPoints(box1);
  var rect2Points = getRectPoints(box2);
  var axes = __spreadArray(__spreadArray([], getAxes(rect1Points), true), getAxes(rect2Points), true);
  for (var i = 0; i < axes.length; i++) {
    var axis2 = axes[i];
    var projection1 = getProjection(rect1Points, axis2);
    var projection2 = getProjection(rect2Points, axis2);
    if (!isProjectionOverlap(projection1, projection2))
      return false;
  }
  return true;
}
function hideOverlap(items, labels, shapes, region) {
  for (var i = 0; i < labels.length; i++) {
    var label1 = labels[i];
    if (labels[i].get("visible")) {
      for (var j = i + 1; j < labels.length; j++) {
        var label2 = labels[j];
        if (label1 && label2 && label1 !== label2 && label2.get("visible")) {
          var box1 = getlLabelBackgroundInfo(label1, items[i], get(items[i], "background.padding"));
          var box2 = getlLabelBackgroundInfo(label2, items[j], get(items[j], "background.padding"));
          if (isIntersect(box1, box2)) {
            labels[j].set("visible", false);
          }
        }
      }
    }
  }
}
var preset = {
  "#5B8FF9": true
};
var isContrastColorWhite = function(color2) {
  var rgb = colorUtil.toRGB(color2).toUpperCase();
  if (preset[rgb]) {
    return preset[rgb];
  }
  var _a2 = colorUtil.rgb2arr(rgb), r = _a2[0], g = _a2[1], b = _a2[2];
  var isDark = (r * 299 + g * 587 + b * 114) / 1e3 < 128;
  return isDark;
};
function adjustColor(items, labels, shapes) {
  if (shapes.length === 0) {
    return;
  }
  var element = shapes[0].get("element");
  var theme2 = element.geometry.theme;
  var _a2 = theme2.labels || {}, fillColorLight = _a2.fillColorLight, fillColorDark = _a2.fillColorDark;
  shapes.forEach(function(shape, index2) {
    var label2 = labels[index2];
    var textShape = label2.find(function(el) {
      return el.get("type") === "text";
    });
    var shapeBBox = BBox.fromObject(shape.getBBox());
    var textBBox = BBox.fromObject(textShape.getCanvasBBox());
    var overflow = !shapeBBox.contains(textBBox);
    var bgColor = shape.attr("fill");
    var fillWhite = isContrastColorWhite(bgColor);
    if (!overflow) {
      if (fillWhite) {
        if (fillColorLight) {
          textShape.attr("fill", fillColorLight);
        }
      } else {
        if (fillColorDark) {
          textShape.attr("fill", fillColorDark);
        }
      }
    } else {
      textShape.attr(theme2.overflowLabels.style);
    }
  });
}
function shouldInShapeSingle(geometry2, label2, shape) {
  var coordinate2 = geometry2.coordinate;
  var textShape = findLabelTextShape(label2);
  var textBBox = BBox.fromObject(textShape.getCanvasBBox());
  var shapeBBox = BBox.fromObject(shape.getBBox());
  return coordinate2.isTransposed ? shapeBBox.height >= textBBox.height : shapeBBox.width >= textBBox.width;
}
function shouldInShape(geometry2, labels, shapes) {
  var isStack = !!geometry2.getAdjust("stack");
  return isStack || labels.every(function(label2, index2) {
    var shape = shapes[index2];
    return shouldInShapeSingle(geometry2, label2, shape);
  });
}
function moveInShape(geometry2, label2, shape) {
  var coordinate2 = geometry2.coordinate;
  var shapeBBox = BBox.fromObject(shape.getBBox());
  var textShape = findLabelTextShape(label2);
  if (coordinate2.isTransposed) {
    textShape.attr({
      x: shapeBBox.minX + shapeBBox.width / 2,
      textAlign: "center"
    });
  } else {
    textShape.attr({
      y: shapeBBox.minY + shapeBBox.height / 2,
      textBaseline: "middle"
    });
  }
}
function intervalAdjustPosition(items, labels, shapes) {
  var _a2;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a2 = shapes[0]) === null || _a2 === void 0 ? void 0 : _a2.get("element");
  var geometry2 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry2 || geometry2.type !== "interval") {
    return;
  }
  var inShape = shouldInShape(geometry2, labels, shapes);
  if (inShape) {
    shapes.forEach(function(shape, index2) {
      var label2 = labels[index2];
      moveInShape(geometry2, label2, shape);
    });
  }
}
function filterLabel(labels) {
  var MAX_CNT = 500;
  var filteredLabels = [];
  var pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);
  each$1(labels, function(label2, idx) {
    if (idx % pages === 0) {
      filteredLabels.push(label2);
    } else {
      label2.set("visible", false);
    }
  });
  return filteredLabels;
}
function intervalHideOverlap(items, labels, shapes) {
  var _a2;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a2 = shapes[0]) === null || _a2 === void 0 ? void 0 : _a2.get("element");
  var geometry2 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry2 || geometry2.type !== "interval") {
    return;
  }
  var filteredLabels = filterLabel(labels);
  var xField = geometry2.getXYFields()[0];
  var dones = [];
  var todo = [];
  var groupedLabels = groupBy(filteredLabels, function(label2) {
    return label2.get("data")[xField];
  });
  var xValues = uniq$2(map$2(filteredLabels, function(label2) {
    return label2.get("data")[xField];
  }));
  var xValue;
  filteredLabels.forEach(function(label2) {
    label2.set("visible", true);
  });
  var addCurrentGroup = function(curItems) {
    if (curItems) {
      if (curItems.length) {
        todo.push(curItems.pop());
      }
      todo.push.apply(todo, curItems);
    }
  };
  if (size(xValues) > 0) {
    xValue = xValues.shift();
    addCurrentGroup(groupedLabels[xValue]);
  }
  if (size(xValues) > 0) {
    xValue = xValues.pop();
    addCurrentGroup(groupedLabels[xValue]);
  }
  each$1(xValues.reverse(), function(val) {
    addCurrentGroup(groupedLabels[val]);
  });
  while (todo.length > 0) {
    var cur = todo.shift();
    if (cur.get("visible")) {
      if (checkShapeOverlap$2(cur, dones)) {
        cur.set("visible", false);
      } else {
        dones.push(cur);
      }
    }
  }
}
function sortLabels$1(geometry2, labels) {
  var yField = geometry2.getXYFields()[1];
  var result = [];
  var sortedLabels = labels.sort(function(left2, right2) {
    return left2.get("data")[yField] - left2.get("data")[yField];
  });
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.shift());
  }
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.pop());
  }
  result.push.apply(result, sortedLabels);
  return result;
}
function hasSome$1(dones, current, compare2) {
  return dones.some(function(done) {
    return compare2(done, current);
  });
}
function getOverlapArea$1(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}
function checkShapeOverlap$1(dones, current) {
  return hasSome$1(dones, current, function(left2, right2) {
    var leftText = findLabelTextShape(left2);
    var rightText = findLabelTextShape(right2);
    return getOverlapArea$1(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
  });
}
function pointAdjustPosition(items, labels, shapes, region, cfg) {
  var _a2, _b;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a2 = shapes[0]) === null || _a2 === void 0 ? void 0 : _a2.get("element");
  var geometry2 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry2 || geometry2.type !== "point") {
    return;
  }
  var _c = geometry2.getXYFields(), xField = _c[0], yField = _c[1];
  var groupedLabels = groupBy(labels, function(label2) {
    return label2.get("data")[xField];
  });
  var dones = [];
  var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
  map$2(keys(groupedLabels).reverse(), function(xValue) {
    var sortedCollections = sortLabels$1(geometry2, groupedLabels[xValue]);
    while (sortedCollections.length) {
      var current = sortedCollections.shift();
      var textShape = findLabelTextShape(current);
      if (hasSome$1(dones, current, function(left2, right2) {
        return left2.get("data")[xField] === right2.get("data")[xField] && left2.get("data")[yField] === right2.get("data")[yField];
      })) {
        textShape.set("visible", false);
        continue;
      }
      var upFail = checkShapeOverlap$1(dones, current);
      var downFail = false;
      if (upFail) {
        textShape.attr("y", textShape.attr("y") + 2 * offset);
        downFail = checkShapeOverlap$1(dones, current);
      }
      if (downFail) {
        textShape.set("visible", false);
        continue;
      }
      dones.push(current);
    }
  });
}
function sortLabels(geometry2, labels) {
  var yField = geometry2.getXYFields()[1];
  var result = [];
  var sortedLabels = labels.sort(function(left2, right2) {
    return left2.get("data")[yField] - left2.get("data")[yField];
  });
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.shift());
  }
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.pop());
  }
  result.push.apply(result, sortedLabels);
  return result;
}
function hasSome(dones, current, compare2) {
  return dones.some(function(done) {
    return compare2(done, current);
  });
}
function getOverlapArea(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}
function checkShapeOverlap(dones, current) {
  return hasSome(dones, current, function(left2, right2) {
    var leftText = findLabelTextShape(left2);
    var rightText = findLabelTextShape(right2);
    return getOverlapArea(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
  });
}
function pathAdjustPosition(items, labels, shapes, region, cfg) {
  var _a2, _b;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a2 = shapes[0]) === null || _a2 === void 0 ? void 0 : _a2.get("element");
  var geometry2 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry2 || ["path", "line", "area"].indexOf(geometry2.type) < 0) {
    return;
  }
  var _c = geometry2.getXYFields(), xField = _c[0], yField = _c[1];
  var groupedLabels = groupBy(labels, function(label2) {
    return label2.get("data")[xField];
  });
  var dones = [];
  var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
  map$2(keys(groupedLabels).reverse(), function(xValue) {
    var sortedCollections = sortLabels(geometry2, groupedLabels[xValue]);
    while (sortedCollections.length) {
      var current = sortedCollections.shift();
      var textShape = findLabelTextShape(current);
      if (hasSome(dones, current, function(left2, right2) {
        return left2.get("data")[xField] === right2.get("data")[xField] && left2.get("data")[yField] === right2.get("data")[yField];
      })) {
        textShape.set("visible", false);
        continue;
      }
      var upFail = checkShapeOverlap(dones, current);
      var downFail = false;
      if (upFail) {
        textShape.attr("y", textShape.attr("y") + 2 * offset);
        downFail = checkShapeOverlap(dones, current);
      }
      if (downFail) {
        textShape.set("visible", false);
        continue;
      }
      dones.push(current);
    }
  });
}
var ctx$1;
function getCanvasContext$1() {
  if (!ctx$1) {
    ctx$1 = document.createElement("canvas").getContext("2d");
  }
  return ctx$1;
}
var measureTextWidth$1 = memoize(function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  var ctx2 = getCanvasContext$1();
  ctx2.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
  return ctx2.measureText(isString(text2) ? text2 : "").width;
}, function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArray([text2], values(font), true).join("");
});
var getEllipsisText = function(text2, maxWidth, font) {
  var STEP = 16;
  var DOT_WIDTH = measureTextWidth$1("...", font);
  var leftText;
  if (!isString(text2)) {
    leftText = toString$2(text2);
  } else {
    leftText = text2;
  }
  var leftWidth = maxWidth;
  var r = [];
  var currentText;
  var currentWidth;
  if (measureTextWidth$1(text2, font) <= maxWidth) {
    return text2;
  }
  while (true) {
    currentText = leftText.substr(0, STEP);
    currentWidth = measureTextWidth$1(currentText, font);
    if (currentWidth + DOT_WIDTH > leftWidth) {
      if (currentWidth > leftWidth) {
        break;
      }
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(STEP);
    if (!leftText) {
      return r.join("");
    }
  }
  while (true) {
    currentText = leftText.substr(0, 1);
    currentWidth = measureTextWidth$1(currentText, font);
    if (currentWidth + DOT_WIDTH > leftWidth) {
      break;
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(1);
    if (!leftText) {
      return r.join("");
    }
  }
  return r.join("") + "...";
};
function limitInPlot$3(items, labels, shapes, region, cfg) {
  if (labels.length <= 0) {
    return;
  }
  var direction2 = (cfg === null || cfg === void 0 ? void 0 : cfg.direction) || ["top", "right", "bottom", "left"];
  var action = (cfg === null || cfg === void 0 ? void 0 : cfg.action) || "translate";
  var margin = (cfg === null || cfg === void 0 ? void 0 : cfg.margin) || 0;
  var coordinate2 = labels[0].get("coordinate");
  if (!coordinate2) {
    return;
  }
  var _a2 = getCoordinateBBox(coordinate2, margin), regionMinX = _a2.minX, regionMinY = _a2.minY, regionMaxX = _a2.maxX, regionMaxY = _a2.maxY;
  each$1(labels, function(label2) {
    var _a3 = label2.getCanvasBBox(), minX = _a3.minX, minY = _a3.minY, maxX = _a3.maxX, maxY = _a3.maxY, x = _a3.x, y = _a3.y, width = _a3.width, height = _a3.height;
    var finalX = x;
    var finalY = y;
    if (direction2.indexOf("left") >= 0 && (minX < regionMinX || maxX < regionMinX)) {
      finalX = regionMinX;
    }
    if (direction2.indexOf("top") >= 0 && (minY < regionMinY || maxY < regionMinY)) {
      finalY = regionMinY;
    }
    if (direction2.indexOf("right") >= 0) {
      if (minX > regionMaxX) {
        finalX = regionMaxX - width;
      } else if (maxX > regionMaxX) {
        finalX = finalX - (maxX - regionMaxX);
      }
    }
    if (direction2.indexOf("bottom") >= 0) {
      if (minY > regionMaxY) {
        finalY = regionMaxY - height;
      } else if (maxY > regionMaxY) {
        finalY = finalY - (maxY - regionMaxY);
      }
    }
    if (finalX !== x || finalY !== y) {
      var translateX_1 = finalX - x;
      if (action === "translate") {
        translate(label2, translateX_1, finalY - y);
      } else if (action === "ellipsis") {
        var textShapes = label2.findAll(function(shape) {
          return shape.get("type") === "text";
        });
        textShapes.forEach(function(textShape) {
          var style = pick$1(textShape.attr(), ["fontSize", "fontFamily", "fontWeight", "fontStyle", "fontVariant"]);
          var textBox = textShape.getCanvasBBox();
          var text2 = getEllipsisText(textShape.attr("text"), textBox.width - Math.abs(translateX_1), style);
          textShape.attr("text", text2);
        });
      } else {
        label2.hide();
      }
    }
  });
}
function fadeIn(shape, animateCfg, cfg) {
  var endState = {
    fillOpacity: isNil(shape.attr("fillOpacity")) ? 1 : shape.attr("fillOpacity"),
    strokeOpacity: isNil(shape.attr("strokeOpacity")) ? 1 : shape.attr("strokeOpacity"),
    opacity: isNil(shape.attr("opacity")) ? 1 : shape.attr("opacity")
  };
  shape.attr({
    fillOpacity: 0,
    strokeOpacity: 0,
    opacity: 0
  });
  shape.animate(endState, animateCfg);
}
function fadeOut(shape, animateCfg, cfg) {
  var endState = {
    fillOpacity: 0,
    strokeOpacity: 0,
    opacity: 0
  };
  var easing = animateCfg.easing, duration = animateCfg.duration, delay = animateCfg.delay;
  shape.animate(endState, duration, easing, function() {
    shape.remove(true);
  }, delay);
}
function transformShape(shape, vector, direct) {
  var scaledMatrix;
  var x = vector[0], y = vector[1];
  shape.applyToMatrix([x, y, 1]);
  if (direct === "x") {
    shape.setMatrix(transform$7(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 0.01, 1],
      ["t", x, y]
    ]));
    scaledMatrix = transform$7(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 100, 1],
      ["t", x, y]
    ]);
  } else if (direct === "y") {
    shape.setMatrix(transform$7(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 1, 0.01],
      ["t", x, y]
    ]));
    scaledMatrix = transform$7(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 1, 100],
      ["t", x, y]
    ]);
  } else if (direct === "xy") {
    shape.setMatrix(transform$7(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 0.01, 0.01],
      ["t", x, y]
    ]));
    scaledMatrix = transform$7(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 100, 100],
      ["t", x, y]
    ]);
  }
  return scaledMatrix;
}
function doScaleAnimate(element, animateCfg, coordinate2, yMinPoint, type) {
  var start = coordinate2.start, end = coordinate2.end;
  var width = coordinate2.getWidth();
  var height = coordinate2.getHeight();
  var x;
  var y;
  if (type === "y") {
    x = start.x + width / 2;
    y = yMinPoint.y < start.y ? yMinPoint.y : start.y;
  } else if (type === "x") {
    x = yMinPoint.x > start.x ? yMinPoint.x : start.x;
    y = start.y + height / 2;
  } else if (type === "xy") {
    if (coordinate2.isPolar) {
      x = coordinate2.getCenter().x;
      y = coordinate2.getCenter().y;
    } else {
      x = (start.x + end.x) / 2;
      y = (start.y + end.y) / 2;
    }
  }
  var endMatrix = transformShape(element, [x, y], type);
  element.animate({
    matrix: endMatrix
  }, animateCfg);
}
function growInX(element, animateCfg, cfg) {
  var coordinate2 = cfg.coordinate, minYPoint = cfg.minYPoint;
  doScaleAnimate(element, animateCfg, coordinate2, minYPoint, "x");
}
function growInY(element, animateCfg, cfg) {
  var coordinate2 = cfg.coordinate, minYPoint = cfg.minYPoint;
  doScaleAnimate(element, animateCfg, coordinate2, minYPoint, "y");
}
function growInXY(element, animateCfg, cfg) {
  var coordinate2 = cfg.coordinate, minYPoint = cfg.minYPoint;
  doScaleAnimate(element, animateCfg, coordinate2, minYPoint, "xy");
}
function pathIn(element, animateCfg, cfg) {
  var length2 = element.getTotalLength();
  element.attr("lineDash", [length2]);
  element.animate(function(ratio) {
    return {
      lineDashOffset: (1 - ratio) * length2
    };
  }, animateCfg);
}
function positionUpdate(shape, animateCfg, cfg) {
  var toAttrs = cfg.toAttrs;
  var x = toAttrs.x;
  var y = toAttrs.y;
  delete toAttrs.x;
  delete toAttrs.y;
  shape.attr(toAttrs);
  shape.animate({
    x,
    y
  }, animateCfg);
}
function scaleInX(shape, animateCfg, cfg) {
  var box2 = shape.getBBox();
  var mappingData = shape.get("origin").mappingData;
  var points = mappingData.points;
  var x = points[0].y - points[1].y > 0 ? box2.maxX : box2.minX;
  var y = (box2.minY + box2.maxY) / 2;
  shape.applyToMatrix([x, y, 1]);
  var matrix = transform$7(shape.getMatrix(), [
    ["t", -x, -y],
    ["s", 0.01, 1],
    ["t", x, y]
  ]);
  shape.setMatrix(matrix);
  shape.animate({
    matrix: transform$7(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 100, 1],
      ["t", x, y]
    ])
  }, animateCfg);
}
function scaleInY(shape, animateCfg, cfg) {
  var box2 = shape.getBBox();
  var mappingData = shape.get("origin").mappingData;
  var x = (box2.minX + box2.maxX) / 2;
  var points = mappingData.points;
  var y = points[0].y - points[1].y <= 0 ? box2.maxY : box2.minY;
  shape.applyToMatrix([x, y, 1]);
  var matrix = transform$7(shape.getMatrix(), [
    ["t", -x, -y],
    ["s", 1, 0.01],
    ["t", x, y]
  ]);
  shape.setMatrix(matrix);
  shape.animate({
    matrix: transform$7(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 1, 100],
      ["t", x, y]
    ])
  }, animateCfg);
}
function getAngle(startPoint, arcPath) {
  var _a2;
  var _b = getArcParams(startPoint, arcPath), startAngle = _b.startAngle, endAngle = _b.endAngle;
  if (!isNumberEqual$1(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {
    startAngle += Math.PI * 2;
  }
  if (!isNumberEqual$1(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {
    endAngle += Math.PI * 2;
  }
  if (arcPath[5] === 0) {
    _a2 = [endAngle, startAngle], startAngle = _a2[0], endAngle = _a2[1];
  }
  if (isNumberEqual$1(startAngle, Math.PI * 1.5)) {
    startAngle = Math.PI * -0.5;
  }
  if (isNumberEqual$1(endAngle, Math.PI * -0.5)) {
    endAngle = Math.PI * 1.5;
  }
  return {
    startAngle,
    endAngle
  };
}
function getArcStartPoint(path2) {
  var startPoint;
  if (path2[0] === "M" || path2[0] === "L") {
    startPoint = [path2[1], path2[2]];
  } else if (path2[0] === "a" || path2[0] === "A" || path2[0] === "C") {
    startPoint = [path2[path2.length - 2], path2[path2.length - 1]];
  }
  return startPoint;
}
function getArcInfo(path2) {
  var _a2;
  var startAngle;
  var endAngle;
  var arcPaths = path2.filter(function(command) {
    return command[0] === "A" || command[0] === "a";
  });
  if (arcPaths.length === 0) {
    return {
      startAngle: 0,
      endAngle: 0,
      radius: 0,
      innerRadius: 0
    };
  }
  var firstArcPathCommand = arcPaths[0];
  var lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];
  var firstIndex = path2.indexOf(firstArcPathCommand);
  var lastIndex = path2.indexOf(lastArcPathCommand);
  var firstStartPoint = getArcStartPoint(path2[firstIndex - 1]);
  var lastStartPoint = getArcStartPoint(path2[lastIndex - 1]);
  var _b = getAngle(firstStartPoint, firstArcPathCommand), firstStartAngle = _b.startAngle, firstEndAngle = _b.endAngle;
  var _c = getAngle(lastStartPoint, lastArcPathCommand), lastStartAngle = _c.startAngle, lastEndAngle = _c.endAngle;
  if (isNumberEqual$1(firstStartAngle, lastStartAngle) && isNumberEqual$1(firstEndAngle, lastEndAngle)) {
    startAngle = firstStartAngle;
    endAngle = firstEndAngle;
  } else {
    startAngle = Math.min(firstStartAngle, lastStartAngle);
    endAngle = Math.max(firstEndAngle, lastEndAngle);
  }
  var radius = firstArcPathCommand[1];
  var innerRadius = arcPaths[arcPaths.length - 1][1];
  if (radius < innerRadius) {
    _a2 = [innerRadius, radius], radius = _a2[0], innerRadius = _a2[1];
  } else if (radius === innerRadius) {
    innerRadius = 0;
  }
  return {
    startAngle,
    endAngle,
    radius,
    innerRadius
  };
}
function sectorPathUpdate(shape, animateCfg, cfg) {
  var toAttrs = cfg.toAttrs, coordinate2 = cfg.coordinate;
  var path2 = toAttrs.path || [];
  var pathCommands = path2.map(function(command) {
    return command[0];
  });
  if (path2.length < 1)
    return;
  var _a2 = getArcInfo(path2), curStartAngle = _a2.startAngle, curEndAngle = _a2.endAngle, radius = _a2.radius, innerRadius = _a2.innerRadius;
  var _b = getArcInfo(shape.attr("path")), preStartAngle = _b.startAngle, preEndAngle = _b.endAngle;
  var center2 = coordinate2.getCenter();
  var diffStartAngle = curStartAngle - preStartAngle;
  var diffEndAngle = curEndAngle - preEndAngle;
  if (diffStartAngle === 0 && diffEndAngle === 0) {
    shape.attr("path", path2);
    return;
  }
  shape.animate(function(ratio) {
    var onFrameStartAngle = preStartAngle + ratio * diffStartAngle;
    var onFrameEndAngle = preEndAngle + ratio * diffEndAngle;
    return __assign$1(__assign$1({}, toAttrs), { path: isEqual$2(pathCommands, ["M", "A", "A", "Z"]) ? getArcPath(center2.x, center2.y, radius, onFrameStartAngle, onFrameEndAngle) : getSectorPath(center2.x, center2.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius) });
  }, __assign$1(__assign$1({}, animateCfg), { callback: function() {
    shape.attr("path", path2);
  } }));
}
function waveIn(element, animateCfg, cfg) {
  var _a2 = getCoordinateClipCfg(cfg.coordinate, 20), type = _a2.type, startState = _a2.startState, endState = _a2.endState;
  var clipShape = element.setClip({
    type,
    attrs: startState
  });
  clipShape.animate(endState, __assign$1(__assign$1({}, animateCfg), { callback: function() {
    if (element && !element.get("destroyed")) {
      element.set("clipShape", null);
    }
    clipShape.remove(true);
  } }));
}
function doShapeZoom(shape, animateCfg, type) {
  if (shape.isGroup()) {
    each$1(shape.getChildren(), function(child) {
      doShapeZoom(child, animateCfg, type);
    });
  } else {
    var bbox = shape.getBBox();
    var x = (bbox.minX + bbox.maxX) / 2;
    var y = (bbox.minY + bbox.maxY) / 2;
    shape.applyToMatrix([x, y, 1]);
    if (type === "zoomIn") {
      var matrix = transform$7(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 0.01, 0.01],
        ["t", x, y]
      ]);
      shape.setMatrix(matrix);
      shape.animate({
        matrix: transform$7(shape.getMatrix(), [
          ["t", -x, -y],
          ["s", 100, 100],
          ["t", x, y]
        ])
      }, animateCfg);
    } else {
      shape.animate({
        matrix: transform$7(shape.getMatrix(), [
          ["t", -x, -y],
          ["s", 0.01, 0.01],
          ["t", x, y]
        ])
      }, __assign$1(__assign$1({}, animateCfg), { callback: function() {
        shape.remove(true);
      } }));
    }
  }
}
function zoomIn(shape, animateCfg, cfg) {
  doShapeZoom(shape, animateCfg, "zoomIn");
}
function zoomOut(shape, animateCfg, cfg) {
  doShapeZoom(shape, animateCfg, "zoomOut");
}
function getFactTitleConfig(direction2) {
  if ([DIRECTION.TOP, DIRECTION.BOTTOM].includes(direction2)) {
    return {
      offsetX: 0,
      offsetY: direction2 === DIRECTION.TOP ? -8 : 8,
      style: {
        textAlign: "center",
        textBaseline: direction2 === DIRECTION.TOP ? "bottom" : "top"
      }
    };
  }
  if ([DIRECTION.LEFT, DIRECTION.RIGHT].includes(direction2)) {
    return {
      offsetX: direction2 === DIRECTION.LEFT ? -8 : 8,
      offsetY: 0,
      style: {
        textAlign: direction2 === DIRECTION.LEFT ? "right" : "left",
        textBaseline: "middle",
        rotate: Math.PI / 2
      }
    };
  }
  return {};
}
function getAnglePoint(center2, r, angle2) {
  return {
    x: center2.x + r * Math.cos(angle2),
    y: center2.y + r * Math.sin(angle2)
  };
}
var Circle = function(_super) {
  __extends$2(Circle2, _super);
  function Circle2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Circle2.prototype.getDefaultCfg = function() {
    return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: "circle",
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this)
    });
  };
  Circle2.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Circle2.prototype.getRegion = function(count, index2) {
    var r = 1 / 2;
    var center2 = { x: 0.5, y: 0.5 };
    var avgAngle = Math.PI * 2 / count;
    var angle2 = -1 * Math.PI / 2 + avgAngle * index2;
    var facetR = r / (1 + 1 / Math.sin(avgAngle / 2));
    var middle = getAnglePoint(center2, r - facetR, angle2);
    var startAngle = Math.PI * 5 / 4;
    var endAngle = Math.PI * 1 / 4;
    return {
      start: getAnglePoint(middle, facetR, startAngle),
      end: getAnglePoint(middle, facetR, endAngle)
    };
  };
  Circle2.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  Circle2.prototype.beforeEachView = function(view, facet) {
  };
  Circle2.prototype.generateFacets = function(data2) {
    var _this = this;
    var _a2 = this.cfg, fields = _a2.fields, type = _a2.type;
    var field2 = fields[0];
    if (!field2) {
      throw new Error("No `fields` specified!");
    }
    var values2 = this.getFieldValues(data2, field2);
    var count = values2.length;
    var rst = [];
    values2.forEach(function(value2, index2) {
      var conditions = [{ field: field2, value: value2, values: values2 }];
      var facetData = filter(data2, _this.getFacetDataFilter(conditions));
      var facet = {
        type,
        data: facetData,
        region: _this.getRegion(count, index2),
        columnValue: value2,
        columnField: field2,
        columnIndex: index2,
        columnValuesLength: count,
        rowValue: null,
        rowField: null,
        rowIndex: 0,
        rowValuesLength: 1
      };
      rst.push(facet);
    });
    return rst;
  };
  Circle2.prototype.getXAxisOption = function(x, axes, option, facet) {
    return option;
  };
  Circle2.prototype.getYAxisOption = function(y, axes, option, facet) {
    return option;
  };
  Circle2.prototype.renderTitle = function() {
    var _this = this;
    each$1(this.facets, function(facet) {
      var columnValue = facet.columnValue, view = facet.view;
      var formatter = get(_this.cfg.title, "formatter");
      var config = deepMix({
        position: ["50%", "0%"],
        content: formatter ? formatter(columnValue) : columnValue
      }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
      view.annotation().text(config);
    });
  };
  return Circle2;
}(Facet);
var List = function(_super) {
  __extends$2(List2, _super);
  function List2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  List2.prototype.getDefaultCfg = function() {
    return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: "list",
      cols: null,
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this)
    });
  };
  List2.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  List2.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  List2.prototype.beforeEachView = function(view, facet) {
  };
  List2.prototype.generateFacets = function(data2) {
    var _this = this;
    var fields = this.cfg.fields;
    var cols = this.cfg.cols;
    var columnField = fields[0];
    if (!columnField) {
      throw new Error("No `fields` specified!");
    }
    var colValues = this.getFieldValues(data2, columnField);
    var count = colValues.length;
    cols = cols || count;
    var rows = this.getPageCount(count, cols);
    var rst = [];
    colValues.forEach(function(val, index2) {
      var _a2 = _this.getRowCol(index2, cols), row = _a2.row, col = _a2.col;
      var conditions = [{ field: columnField, value: val, values: colValues }];
      var facetData = filter(data2, _this.getFacetDataFilter(conditions));
      var facet = {
        type: _this.cfg.type,
        data: facetData,
        region: _this.getRegion(rows, cols, col, row),
        columnValue: val,
        rowValue: val,
        columnField,
        rowField: null,
        columnIndex: col,
        rowIndex: row,
        columnValuesLength: cols,
        rowValuesLength: rows,
        total: count
      };
      rst.push(facet);
    });
    return rst;
  };
  List2.prototype.getXAxisOption = function(x, axes, option, facet) {
    if (facet.rowIndex !== facet.rowValuesLength - 1 && facet.columnValuesLength * facet.rowIndex + facet.columnIndex + 1 + facet.columnValuesLength <= facet.total) {
      return __assign$1(__assign$1({}, option), { label: null, title: null });
    }
    return option;
  };
  List2.prototype.getYAxisOption = function(y, axes, option, facet) {
    if (facet.columnIndex !== 0) {
      return __assign$1(__assign$1({}, option), { title: null, label: null });
    }
    return option;
  };
  List2.prototype.renderTitle = function() {
    var _this = this;
    each$1(this.facets, function(facet) {
      var columnValue = facet.columnValue, view = facet.view;
      var formatter = get(_this.cfg.title, "formatter");
      var config = deepMix({
        position: ["50%", "0%"],
        content: formatter ? formatter(columnValue) : columnValue
      }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
      view.annotation().text(config);
    });
  };
  List2.prototype.getPageCount = function(total, pageSize) {
    return Math.floor((total + pageSize - 1) / pageSize);
  };
  List2.prototype.getRowCol = function(index2, pageSize) {
    var row = Math.floor(index2 / pageSize);
    var col = index2 % pageSize;
    return { row, col };
  };
  return List2;
}(Facet);
var Matrix = function(_super) {
  __extends$2(Matrix2, _super);
  function Matrix2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Matrix2.prototype.getDefaultCfg = function() {
    return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: "matrix",
      showTitle: false,
      columnTitle: __assign$1({}, _super.prototype.getDefaultTitleCfg.call(this)),
      rowTitle: __assign$1({}, _super.prototype.getDefaultTitleCfg.call(this))
    });
  };
  Matrix2.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Matrix2.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  Matrix2.prototype.beforeEachView = function(view, facet) {
  };
  Matrix2.prototype.generateFacets = function(data2) {
    var _a2 = this.cfg, fields = _a2.fields, type = _a2.type;
    var rowValuesLength = fields.length;
    var columnValuesLength = rowValuesLength;
    var rst = [];
    for (var i = 0; i < columnValuesLength; i++) {
      var columnField = fields[i];
      for (var j = 0; j < rowValuesLength; j++) {
        var rowField = fields[j];
        var facet = {
          type,
          data: data2,
          region: this.getRegion(rowValuesLength, columnValuesLength, i, j),
          columnValue: columnField,
          rowValue: rowField,
          columnField,
          rowField,
          columnIndex: i,
          rowIndex: j,
          columnValuesLength,
          rowValuesLength
        };
        rst.push(facet);
      }
    }
    return rst;
  };
  Matrix2.prototype.getXAxisOption = function(x, axes, option, facet) {
    if (facet.rowIndex !== facet.rowValuesLength - 1) {
      return __assign$1(__assign$1({}, option), { label: null, title: null });
    }
    return option;
  };
  Matrix2.prototype.getYAxisOption = function(y, axes, option, facet) {
    if (facet.columnIndex !== 0) {
      return __assign$1(__assign$1({}, option), { title: null, label: null });
    }
    return option;
  };
  Matrix2.prototype.renderTitle = function() {
    var _this = this;
    each$1(this.facets, function(facet, facetIndex) {
      var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength;
      facet.rowValuesLength;
      var columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
      if (rowIndex === 0) {
        var formatter = get(_this.cfg.columnTitle, "formatter");
        var config = deepMix({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
        view.annotation().text(config);
      }
      if (columnIndex === columnValuesLength - 1) {
        var formatter = get(_this.cfg.rowTitle, "formatter");
        var config = deepMix({
          position: ["100%", "50%"],
          content: formatter ? formatter(rowValue) : rowValue
        }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
        view.annotation().text(config);
      }
    });
  };
  return Matrix2;
}(Facet);
var Mirror = function(_super) {
  __extends$2(Mirror2, _super);
  function Mirror2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Mirror2.prototype.getDefaultCfg = function() {
    return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: "mirror",
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this),
      transpose: false
    });
  };
  Mirror2.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Mirror2.prototype.beforeEachView = function(view, facet) {
    if (this.cfg.transpose) {
      if (facet.columnIndex % 2 === 0) {
        view.coordinate().transpose().reflect("x");
      } else {
        view.coordinate().transpose();
      }
    } else {
      if (facet.rowIndex % 2 !== 0) {
        view.coordinate().reflect("y");
      }
    }
  };
  Mirror2.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  Mirror2.prototype.generateFacets = function(data2) {
    var _this = this;
    var f = this.cfg.fields[0];
    var rst = [];
    var columnValuesLength = 1;
    var rowValuesLength = 1;
    var columnValues = [""];
    var rowValues = [""];
    var columnField;
    var rowField;
    if (this.cfg.transpose) {
      columnField = f;
      columnValues = this.getFieldValues(data2, columnField).slice(0, 2);
      columnValuesLength = columnValues.length;
    } else {
      rowField = f;
      rowValues = this.getFieldValues(data2, rowField).slice(0, 2);
      rowValuesLength = rowValues.length;
    }
    columnValues.forEach(function(xVal, xIndex) {
      rowValues.forEach(function(yVal, yIndex) {
        var conditions = [
          { field: columnField, value: xVal, values: columnValues },
          { field: rowField, value: yVal, values: rowValues }
        ];
        var facetData = filter(data2, _this.getFacetDataFilter(conditions));
        var facet = {
          type: _this.cfg.type,
          data: facetData,
          region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
          columnValue: xVal,
          rowValue: yVal,
          columnField,
          rowField,
          columnIndex: xIndex,
          rowIndex: yIndex,
          columnValuesLength,
          rowValuesLength
        };
        rst.push(facet);
      });
    });
    return rst;
  };
  Mirror2.prototype.getXAxisOption = function(x, axes, option, facet) {
    if (facet.columnIndex === 1 || facet.rowIndex === 1) {
      return __assign$1(__assign$1({}, option), { label: null, title: null });
    }
    return option;
  };
  Mirror2.prototype.getYAxisOption = function(y, axes, option, facet) {
    return option;
  };
  Mirror2.prototype.renderTitle = function() {
    var _this = this;
    each$1(this.facets, function(facet, facetIndex) {
      var columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
      var formatter = get(_this.cfg.title, "formatter");
      if (_this.cfg.transpose) {
        var config = deepMix({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      } else {
        var config = deepMix({
          position: ["100%", "50%"],
          content: formatter ? formatter(rowValue) : rowValue
        }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.title);
        view.annotation().text(config);
      }
    });
  };
  return Mirror2;
}(Facet);
var Rect = function(_super) {
  __extends$2(Rect2, _super);
  function Rect2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rect2.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  Rect2.prototype.beforeEachView = function(view, facet) {
  };
  Rect2.prototype.getDefaultCfg = function() {
    return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: "rect",
      columnTitle: __assign$1({}, _super.prototype.getDefaultTitleCfg.call(this)),
      rowTitle: __assign$1({}, _super.prototype.getDefaultTitleCfg.call(this))
    });
  };
  Rect2.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Rect2.prototype.generateFacets = function(data2) {
    var _this = this;
    var _a2 = this.cfg.fields, columnField = _a2[0], rowField = _a2[1];
    var rst = [];
    var columnValuesLength = 1;
    var rowValuesLength = 1;
    var columnValues = [""];
    var rowValues = [""];
    if (columnField) {
      columnValues = this.getFieldValues(data2, columnField);
      columnValuesLength = columnValues.length;
    }
    if (rowField) {
      rowValues = this.getFieldValues(data2, rowField);
      rowValuesLength = rowValues.length;
    }
    columnValues.forEach(function(xVal, xIndex) {
      rowValues.forEach(function(yVal, yIndex) {
        var conditions = [
          { field: columnField, value: xVal, values: columnValues },
          { field: rowField, value: yVal, values: rowValues }
        ];
        var facetData = filter(data2, _this.getFacetDataFilter(conditions));
        var facet = {
          type: _this.cfg.type,
          data: facetData,
          region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
          columnValue: xVal,
          rowValue: yVal,
          columnField,
          rowField,
          columnIndex: xIndex,
          rowIndex: yIndex,
          columnValuesLength,
          rowValuesLength
        };
        rst.push(facet);
      });
    });
    return rst;
  };
  Rect2.prototype.renderTitle = function() {
    var _this = this;
    each$1(this.facets, function(facet, facetIndex) {
      var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength, columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
      if (rowIndex === 0) {
        var formatter = get(_this.cfg.columnTitle, "formatter");
        var config = deepMix({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
        view.annotation().text(config);
      }
      if (columnIndex === columnValuesLength - 1) {
        var formatter = get(_this.cfg.rowTitle, "formatter");
        var config = deepMix({
          position: ["100%", "50%"],
          content: formatter ? formatter(rowValue) : rowValue
        }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
        view.annotation().text(config);
      }
    });
  };
  Rect2.prototype.getXAxisOption = function(x, axes, option, facet) {
    if (facet.rowIndex !== facet.rowValuesLength - 1) {
      return __assign$1(__assign$1({}, option), { title: null, label: null });
    } else if (facet.columnIndex !== Math.floor((facet.columnValuesLength - 1) / 2)) {
      return __assign$1(__assign$1({}, option), { title: null });
    }
    return option;
  };
  Rect2.prototype.getYAxisOption = function(y, axes, option, facet) {
    if (facet.columnIndex !== 0) {
      return __assign$1(__assign$1({}, option), { title: null, label: null });
    } else if (facet.rowIndex !== Math.floor((facet.rowValuesLength - 1) / 2)) {
      return __assign$1(__assign$1({}, option), { title: null });
    }
    return option;
  };
  return Rect2;
}(Facet);
var Tree = function(_super) {
  __extends$2(Tree2, _super);
  function Tree2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.afterChartRender = function() {
      if (_this.facets && _this.cfg.line) {
        _this.container.clear();
        _this.drawLines(_this.facets);
      }
    };
    return _this;
  }
  Tree2.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  Tree2.prototype.beforeEachView = function(view, facet) {
  };
  Tree2.prototype.init = function() {
    _super.prototype.init.call(this);
    this.view.on(VIEW_LIFE_CIRCLE.AFTER_RENDER, this.afterChartRender);
  };
  Tree2.prototype.getDefaultCfg = function() {
    return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: "tree",
      line: {
        style: {
          lineWidth: 1,
          stroke: "#ddd"
        },
        smooth: false
      },
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this)
    });
  };
  Tree2.prototype.generateFacets = function(data2) {
    var fields = this.cfg.fields;
    if (!fields.length) {
      throw new Error("Please specify for the fields for rootFacet!");
    }
    var rst = [];
    var rootFacet = {
      type: this.cfg.type,
      data: data2,
      region: null,
      rowValuesLength: this.getRows(),
      columnValuesLength: 1,
      rowIndex: 0,
      columnIndex: 0,
      rowField: "",
      columnField: "",
      rowValue: "",
      columnValue: ""
    };
    rst.push(rootFacet);
    rootFacet.children = this.getChildFacets(data2, 1, rst);
    this.setRegion(rst);
    return rst;
  };
  Tree2.prototype.setRegion = function(facets) {
    var _this = this;
    this.forceColIndex(facets);
    facets.forEach(function(facet) {
      facet.region = _this.getRegion(facet.rowValuesLength, facet.columnValuesLength, facet.columnIndex, facet.rowIndex);
    });
  };
  Tree2.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
    var xWidth = 1 / cols;
    var yWidth = 1 / rows;
    var start = {
      x: xWidth * xIndex,
      y: yWidth * yIndex
    };
    var end = {
      x: start.x + xWidth,
      y: start.y + yWidth * 2 / 3
    };
    return {
      start,
      end
    };
  };
  Tree2.prototype.forceColIndex = function(facets) {
    var _this = this;
    var leafs = [];
    var index2 = 0;
    facets.forEach(function(facet2) {
      if (_this.isLeaf(facet2)) {
        leafs.push(facet2);
        facet2.columnIndex = index2;
        index2++;
      }
    });
    leafs.forEach(function(facet2) {
      facet2.columnValuesLength = leafs.length;
    });
    var maxLevel = this.cfg.fields.length;
    for (var i = maxLevel - 1; i >= 0; i--) {
      var levelFacets = this.getFacetsByLevel(facets, i);
      for (var _i = 0, levelFacets_1 = levelFacets; _i < levelFacets_1.length; _i++) {
        var facet = levelFacets_1[_i];
        if (!this.isLeaf(facet)) {
          facet.originColIndex = facet.columnIndex;
          facet.columnIndex = this.getRegionIndex(facet.children);
          facet.columnValuesLength = leafs.length;
        }
      }
    }
  };
  Tree2.prototype.getFacetsByLevel = function(facets, level) {
    var rst = [];
    facets.forEach(function(facet) {
      if (facet.rowIndex === level) {
        rst.push(facet);
      }
    });
    return rst;
  };
  Tree2.prototype.getRegionIndex = function(children) {
    var first = children[0];
    var last2 = children[children.length - 1];
    return (last2.columnIndex - first.columnIndex) / 2 + first.columnIndex;
  };
  Tree2.prototype.isLeaf = function(facet) {
    return !facet.children || !facet.children.length;
  };
  Tree2.prototype.getRows = function() {
    return this.cfg.fields.length + 1;
  };
  Tree2.prototype.getChildFacets = function(data2, level, arr) {
    var _this = this;
    var fields = this.cfg.fields;
    var length2 = fields.length;
    if (length2 < level) {
      return;
    }
    var rst = [];
    var field2 = fields[level - 1];
    var values2 = this.getFieldValues(data2, field2);
    values2.forEach(function(value2, index2) {
      var conditions = [{ field: field2, value: value2, values: values2 }];
      var subData = data2.filter(_this.getFacetDataFilter(conditions));
      if (subData.length) {
        var facet = {
          type: _this.cfg.type,
          data: subData,
          region: null,
          columnValue: value2,
          rowValue: "",
          columnField: field2,
          rowField: "",
          columnIndex: index2,
          rowValuesLength: _this.getRows(),
          columnValuesLength: 1,
          rowIndex: level,
          children: _this.getChildFacets(subData, level + 1, arr)
        };
        rst.push(facet);
        arr.push(facet);
      }
    });
    return rst;
  };
  Tree2.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Tree2.prototype.renderTitle = function() {
    var _this = this;
    each$1(this.facets, function(facet) {
      var columnValue = facet.columnValue, view = facet.view;
      var formatter = get(_this.cfg.title, "formatter");
      var config = deepMix({
        position: ["50%", "0%"],
        content: formatter ? formatter(columnValue) : columnValue
      }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
      view.annotation().text(config);
    });
  };
  Tree2.prototype.drawLines = function(facets) {
    var _this = this;
    facets.forEach(function(facet) {
      if (!_this.isLeaf(facet)) {
        var children = facet.children;
        _this.addFacetLines(facet, children);
      }
    });
  };
  Tree2.prototype.addFacetLines = function(facet, children) {
    var _this = this;
    var view = facet.view;
    var region = view.coordinateBBox;
    var start = {
      x: region.x + region.width / 2,
      y: region.y + region.height
    };
    children.forEach(function(subFacet) {
      var subRegion = subFacet.view.coordinateBBox;
      var end = {
        x: subRegion.bl.x + (subRegion.tr.x - subRegion.bl.x) / 2,
        y: subRegion.tr.y
      };
      var middle1 = {
        x: start.x,
        y: start.y + (end.y - start.y) / 2
      };
      var middle2 = {
        x: end.x,
        y: middle1.y
      };
      _this.drawLine([start, middle1, middle2, end]);
    });
  };
  Tree2.prototype.getPath = function(points) {
    var path2 = [];
    var smooth = this.cfg.line.smooth;
    if (smooth) {
      path2.push(["M", points[0].x, points[0].y]);
      path2.push(["C", points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);
    } else {
      points.forEach(function(point2, index2) {
        if (index2 === 0) {
          path2.push(["M", point2.x, point2.y]);
        } else {
          path2.push(["L", point2.x, point2.y]);
        }
      });
    }
    return path2;
  };
  Tree2.prototype.drawLine = function(points) {
    var path2 = this.getPath(points);
    var line2 = this.cfg.line.style;
    this.container.addShape("path", {
      attrs: mix({
        path: path2
      }, line2)
    });
  };
  Tree2.prototype.getXAxisOption = function(x, axes, option, facet) {
    if (facet.rowIndex !== facet.rowValuesLength - 1) {
      return __assign$1(__assign$1({}, option), { title: null, label: null });
    }
    return option;
  };
  Tree2.prototype.getYAxisOption = function(y, axes, option, facet) {
    if (facet.originColIndex !== 0 && facet.columnIndex !== 0) {
      return __assign$1(__assign$1({}, option), { title: null, label: null });
    }
    return option;
  };
  return Tree2;
}(Facet);
function getMedian(array) {
  var arr = __spreadArray([], array, true);
  arr.sort(function(a, b) {
    return a - b;
  });
  var len = arr.length;
  if (len === 0) {
    return 0;
  }
  if (len % 2 === 1) {
    return arr[(len - 1) / 2];
  }
  return (arr[len / 2] + arr[len / 2 - 1]) / 2;
}
function getMean(array) {
  var sum = reduce(array, function(r, num) {
    return r += isNaN(num) || !isNumber$1(num) ? 0 : num;
  }, 0);
  return array.length === 0 ? 0 : sum / array.length;
}
function getNormalizedValue(val, scale2) {
  if (!scale2) {
    return null;
  }
  var scaled;
  switch (val) {
    case "start":
      return 0;
    case "center":
      return 0.5;
    case "end":
      return 1;
    case "median": {
      scaled = scale2.isCategory ? getMedian(scale2.values.map(function(_, idx) {
        return idx;
      })) : getMedian(scale2.values);
      break;
    }
    case "mean": {
      scaled = scale2.isCategory ? (scale2.values.length - 1) / 2 : getMean(scale2.values);
      break;
    }
    case "min":
      scaled = scale2.isCategory ? 0 : scale2[val];
      break;
    case "max":
      scaled = scale2.isCategory ? scale2.values.length - 1 : scale2[val];
      break;
    default:
      scaled = val;
      break;
  }
  return scale2.scale(scaled);
}
var ANNOTATIONS_AFTER_RENDER = ["regionFilter", "shape"];
var Annotation = function(_super) {
  __extends$2(Annotation2, _super);
  function Annotation2(view) {
    var _this = _super.call(this, view) || this;
    _this.cache = new Map();
    _this.foregroundContainer = _this.view.getLayer(LAYER.FORE).addGroup();
    _this.backgroundContainer = _this.view.getLayer(LAYER.BG).addGroup();
    _this.option = [];
    return _this;
  }
  Object.defineProperty(Annotation2.prototype, "name", {
    get: function() {
      return "annotation";
    },
    enumerable: false,
    configurable: true
  });
  Annotation2.prototype.init = function() {
  };
  Annotation2.prototype.layout = function() {
    this.update();
  };
  Annotation2.prototype.render = function() {
  };
  Annotation2.prototype.update = function() {
    var _this = this;
    this.onAfterRender(function() {
      var updated = new Map();
      each$1(_this.option, function(option) {
        if (contains(ANNOTATIONS_AFTER_RENDER, option.type)) {
          var co = _this.updateOrCreate(option);
          if (co) {
            updated.set(_this.getCacheKey(option), co);
          }
        }
      });
      _this.cache = _this.syncCache(updated);
    });
    var updateCache = new Map();
    each$1(this.option, function(option) {
      if (!contains(ANNOTATIONS_AFTER_RENDER, option.type)) {
        var co = _this.updateOrCreate(option);
        if (co) {
          updateCache.set(_this.getCacheKey(option), co);
        }
      }
    });
    this.cache = this.syncCache(updateCache);
  };
  Annotation2.prototype.clear = function(includeOption) {
    if (includeOption === void 0) {
      includeOption = false;
    }
    _super.prototype.clear.call(this);
    this.clearComponents();
    this.foregroundContainer.clear();
    this.backgroundContainer.clear();
    if (includeOption) {
      this.option = [];
    }
  };
  Annotation2.prototype.destroy = function() {
    this.clear(true);
    this.foregroundContainer.remove(true);
    this.backgroundContainer.remove(true);
  };
  Annotation2.prototype.getComponents = function() {
    var co = [];
    this.cache.forEach(function(value2) {
      co.push(value2);
    });
    return co;
  };
  Annotation2.prototype.clearComponents = function() {
    this.getComponents().forEach(function(co) {
      co.component.destroy();
    });
    this.cache.clear();
  };
  Annotation2.prototype.onAfterRender = function(doWhat) {
    if (this.view.getOptions().animate) {
      this.view.geometries.forEach(function(g) {
        if (g.animateOption) {
          g.once(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE, function() {
            doWhat();
          });
        }
      });
    } else {
      this.view.getRootView().once(VIEW_LIFE_CIRCLE.AFTER_RENDER, function() {
        doWhat();
      });
    }
  };
  Annotation2.prototype.createAnnotation = function(option) {
    var type = option.type;
    var Ctor = AnnotationComponent[upperFirst(type)];
    if (Ctor) {
      var theme2 = this.getAnnotationTheme(type);
      var cfg = this.getAnnotationCfg(type, option, theme2);
      var annotation2 = new Ctor(cfg);
      return {
        component: annotation2,
        layer: this.isTop(cfg) ? LAYER.FORE : LAYER.BG,
        direction: DIRECTION.NONE,
        type: COMPONENT_TYPE.ANNOTATION,
        extra: option
      };
    }
  };
  Annotation2.prototype.annotation = function(option) {
    this.option.push(option);
  };
  Annotation2.prototype.arc = function(option) {
    this.annotation(__assign$1({ type: "arc" }, option));
    return this;
  };
  Annotation2.prototype.image = function(option) {
    this.annotation(__assign$1({ type: "image" }, option));
    return this;
  };
  Annotation2.prototype.line = function(option) {
    this.annotation(__assign$1({ type: "line" }, option));
    return this;
  };
  Annotation2.prototype.region = function(option) {
    this.annotation(__assign$1({ type: "region" }, option));
    return this;
  };
  Annotation2.prototype.text = function(option) {
    this.annotation(__assign$1({ type: "text" }, option));
    return this;
  };
  Annotation2.prototype.dataMarker = function(option) {
    this.annotation(__assign$1({ type: "dataMarker" }, option));
    return this;
  };
  Annotation2.prototype.dataRegion = function(option) {
    this.annotation(__assign$1({ type: "dataRegion" }, option));
  };
  Annotation2.prototype.regionFilter = function(option) {
    this.annotation(__assign$1({ type: "regionFilter" }, option));
  };
  Annotation2.prototype.shape = function(option) {
    this.annotation(__assign$1({ type: "shape" }, option));
  };
  Annotation2.prototype.html = function(option) {
    this.annotation(__assign$1({ type: "html" }, option));
  };
  Annotation2.prototype.parsePosition = function(p) {
    var xScale = this.view.getXScale();
    var yScales = this.view.getScalesByDim("y");
    var position = isFunction(p) ? p.call(null, xScale, yScales) : p;
    var x = 0;
    var y = 0;
    if (isArray$1(position)) {
      var xPos = position[0], yPos = position[1];
      if (isString(xPos) && xPos.indexOf("%") !== -1 && !isNaN(xPos.slice(0, -1))) {
        return this.parsePercentPosition(position);
      }
      x = getNormalizedValue(xPos, xScale);
      y = getNormalizedValue(yPos, Object.values(yScales)[0]);
    } else if (!isNil(position)) {
      for (var _i = 0, _a2 = keys(position); _i < _a2.length; _i++) {
        var key = _a2[_i];
        var value2 = position[key];
        if (key === xScale.field) {
          x = getNormalizedValue(value2, xScale);
        }
        if (yScales[key]) {
          y = getNormalizedValue(value2, yScales[key]);
        }
      }
    }
    return this.view.getCoordinate().convert({ x, y });
  };
  Annotation2.prototype.getRegionPoints = function(start, end) {
    var _this = this;
    var xScale = this.view.getXScale();
    var yScales = this.view.getScalesByDim("y");
    var yScale = Object.values(yScales)[0];
    var xField = xScale.field;
    var viewData = this.view.getData();
    var startXValue = isArray$1(start) ? start[0] : start[xField];
    var endXValue = isArray$1(end) ? end[0] : end[xField];
    var arr = [];
    var startIndex;
    each$1(viewData, function(item, idx) {
      if (item[xField] === startXValue) {
        startIndex = idx;
      }
      if (idx >= startIndex) {
        var point2 = _this.parsePosition([item[xField], item[yScale.field]]);
        if (point2) {
          arr.push(point2);
        }
      }
      if (item[xField] === endXValue) {
        return false;
      }
    });
    return arr;
  };
  Annotation2.prototype.parsePercentPosition = function(position) {
    var xPercent = parseFloat(position[0]) / 100;
    var yPercent = parseFloat(position[1]) / 100;
    var coordinate2 = this.view.getCoordinate();
    var start = coordinate2.start, end = coordinate2.end;
    var topLeft = {
      x: Math.min(start.x, end.x),
      y: Math.min(start.y, end.y)
    };
    var x = coordinate2.getWidth() * xPercent + topLeft.x;
    var y = coordinate2.getHeight() * yPercent + topLeft.y;
    return { x, y };
  };
  Annotation2.prototype.getCoordinateBBox = function() {
    var coordinate2 = this.view.getCoordinate();
    var start = coordinate2.start, end = coordinate2.end;
    var width = coordinate2.getWidth();
    var height = coordinate2.getHeight();
    var topLeft = {
      x: Math.min(start.x, end.x),
      y: Math.min(start.y, end.y)
    };
    return {
      x: topLeft.x,
      y: topLeft.y,
      minX: topLeft.x,
      minY: topLeft.y,
      maxX: topLeft.x + width,
      maxY: topLeft.y + height,
      width,
      height
    };
  };
  Annotation2.prototype.getAnnotationCfg = function(type, option, theme2) {
    var _this = this;
    var coordinate2 = this.view.getCoordinate();
    var canvas = this.view.getCanvas();
    var o = {};
    if (isNil(option)) {
      return null;
    }
    if (type === "arc") {
      var _a2 = option, start = _a2.start, end = _a2.end, rest = __rest(_a2, ["start", "end"]);
      var sp = this.parsePosition(start);
      var ep = this.parsePosition(end);
      var startAngle = getAngleByPoint(coordinate2, sp);
      var endAngle = getAngleByPoint(coordinate2, ep);
      if (startAngle > endAngle) {
        endAngle = Math.PI * 2 + endAngle;
      }
      o = __assign$1(__assign$1({}, rest), { center: coordinate2.getCenter(), radius: getDistanceToCenter(coordinate2, sp), startAngle, endAngle });
    } else if (type === "image") {
      var _b = option, start = _b.start, end = _b.end, rest = __rest(_b, ["start", "end"]);
      o = __assign$1(__assign$1({}, rest), { start: this.parsePosition(start), end: this.parsePosition(end), src: option.src });
    } else if (type === "line") {
      var _c = option, start = _c.start, end = _c.end, rest = __rest(_c, ["start", "end"]);
      o = __assign$1(__assign$1({}, rest), { start: this.parsePosition(start), end: this.parsePosition(end), text: get(option, "text", null) });
    } else if (type === "region") {
      var _d = option, start = _d.start, end = _d.end, rest = __rest(_d, ["start", "end"]);
      o = __assign$1(__assign$1({}, rest), { start: this.parsePosition(start), end: this.parsePosition(end) });
    } else if (type === "text") {
      var filteredData = this.view.getData();
      var _e = option, position = _e.position, content = _e.content, rest = __rest(_e, ["position", "content"]);
      var textContent = content;
      if (isFunction(content)) {
        textContent = content(filteredData);
      }
      o = __assign$1(__assign$1(__assign$1({}, this.parsePosition(position)), rest), { content: textContent });
    } else if (type === "dataMarker") {
      var _f = option, position = _f.position, point2 = _f.point, line2 = _f.line, text2 = _f.text, autoAdjust = _f.autoAdjust, direction2 = _f.direction, rest = __rest(_f, ["position", "point", "line", "text", "autoAdjust", "direction"]);
      o = __assign$1(__assign$1(__assign$1({}, rest), this.parsePosition(position)), { coordinateBBox: this.getCoordinateBBox(), point: point2, line: line2, text: text2, autoAdjust, direction: direction2 });
    } else if (type === "dataRegion") {
      var _g = option, start = _g.start, end = _g.end, region = _g.region, text2 = _g.text, lineLength = _g.lineLength, rest = __rest(_g, ["start", "end", "region", "text", "lineLength"]);
      o = __assign$1(__assign$1({}, rest), { points: this.getRegionPoints(start, end), region, text: text2, lineLength });
    } else if (type === "regionFilter") {
      var _h = option, start = _h.start, end = _h.end, apply_1 = _h.apply, color2 = _h.color, rest = __rest(_h, ["start", "end", "apply", "color"]);
      var geometries = this.view.geometries;
      var shapes_1 = [];
      var addShapes_1 = function(item) {
        if (!item) {
          return;
        }
        if (item.isGroup()) {
          item.getChildren().forEach(function(child) {
            return addShapes_1(child);
          });
        } else {
          shapes_1.push(item);
        }
      };
      each$1(geometries, function(geom) {
        if (apply_1) {
          if (contains(apply_1, geom.type)) {
            each$1(geom.elements, function(elem) {
              addShapes_1(elem.shape);
            });
          }
        } else {
          each$1(geom.elements, function(elem) {
            addShapes_1(elem.shape);
          });
        }
      });
      o = __assign$1(__assign$1({}, rest), { color: color2, shapes: shapes_1, start: this.parsePosition(start), end: this.parsePosition(end) });
    } else if (type === "shape") {
      var _j = option, render_1 = _j.render, restOptions = __rest(_j, ["render"]);
      var wrappedRender = function(container) {
        if (isFunction(option.render)) {
          return render_1(container, _this.view, { parsePosition: _this.parsePosition.bind(_this) });
        }
      };
      o = __assign$1(__assign$1({}, restOptions), { render: wrappedRender });
    } else if (type === "html") {
      var _k = option, html_1 = _k.html, position = _k.position, restOptions = __rest(_k, ["html", "position"]);
      var wrappedHtml = function(container) {
        if (isFunction(html_1)) {
          return html_1(container, _this.view);
        }
        return html_1;
      };
      o = __assign$1(__assign$1(__assign$1({}, restOptions), this.parsePosition(position)), {
        parent: canvas.get("el").parentNode,
        html: wrappedHtml
      });
    }
    var cfg = deepMix({}, theme2, __assign$1(__assign$1({}, o), { top: option.top, style: option.style, offsetX: option.offsetX, offsetY: option.offsetY }));
    if (type !== "html") {
      cfg.container = this.getComponentContainer(cfg);
    }
    cfg.animate = this.view.getOptions().animate && cfg.animate && get(option, "animate", cfg.animate);
    cfg.animateOption = deepMix({}, DEFAULT_ANIMATE_CFG, cfg.animateOption, option.animateOption);
    return cfg;
  };
  Annotation2.prototype.isTop = function(option) {
    return get(option, "top", true);
  };
  Annotation2.prototype.getComponentContainer = function(option) {
    return this.isTop(option) ? this.foregroundContainer : this.backgroundContainer;
  };
  Annotation2.prototype.getAnnotationTheme = function(type) {
    return get(this.view.getTheme(), ["components", "annotation", type], {});
  };
  Annotation2.prototype.updateOrCreate = function(option) {
    var co = this.cache.get(this.getCacheKey(option));
    if (co) {
      var type = option.type;
      var theme2 = this.getAnnotationTheme(type);
      var cfg = this.getAnnotationCfg(type, option, theme2);
      omit(cfg, ["container"]);
      co.component.update(cfg);
      if (contains(ANNOTATIONS_AFTER_RENDER, option.type)) {
        co.component.render();
      }
    } else {
      co = this.createAnnotation(option);
      if (co) {
        co.component.init();
        if (contains(ANNOTATIONS_AFTER_RENDER, option.type)) {
          co.component.render();
        }
      }
    }
    return co;
  };
  Annotation2.prototype.syncCache = function(updated) {
    var _this = this;
    var newCache = new Map(this.cache);
    updated.forEach(function(co, key) {
      newCache.set(key, co);
    });
    newCache.forEach(function(co, key) {
      if (!find$1(_this.option, function(option) {
        return key === _this.getCacheKey(option);
      })) {
        co.component.destroy();
        newCache.delete(key);
      }
    });
    return newCache;
  };
  Annotation2.prototype.getCacheKey = function(option) {
    return option;
  };
  return Annotation2;
}(Controller);
function getGridThemeCfg(theme2, direction2) {
  var axisTheme = deepMix({}, get(theme2, ["components", "axis", "common"]), get(theme2, ["components", "axis", direction2]));
  return get(axisTheme, ["grid"], {});
}
function getLineGridItems(coordinate2, scale2, dim, alignTick) {
  var items = [];
  var ticks = scale2.getTicks();
  if (coordinate2.isPolar) {
    ticks.push({
      value: 1,
      text: "",
      tickValue: ""
    });
  }
  ticks.reduce(function(preTick, currentTick, currentIndex) {
    var currentValue = currentTick.value;
    if (alignTick) {
      items.push({
        points: [
          coordinate2.convert(dim === "y" ? { x: 0, y: currentValue } : { x: currentValue, y: 0 }),
          coordinate2.convert(dim === "y" ? { x: 1, y: currentValue } : { x: currentValue, y: 1 })
        ]
      });
    } else {
      if (currentIndex) {
        var preValue = preTick.value;
        var middleValue = (preValue + currentValue) / 2;
        items.push({
          points: [
            coordinate2.convert(dim === "y" ? { x: 0, y: middleValue } : { x: middleValue, y: 0 }),
            coordinate2.convert(dim === "y" ? { x: 1, y: middleValue } : { x: middleValue, y: 1 })
          ]
        });
      }
    }
    return currentTick;
  }, ticks[0]);
  return items;
}
function getCircleGridItems(coordinate2, xScale, yScale, alignTick, dim) {
  var count = xScale.values.length;
  var items = [];
  var ticks = yScale.getTicks();
  ticks.reduce(function(preTick, currentTick) {
    var preValue = preTick ? preTick.value : currentTick.value;
    var currentValue = currentTick.value;
    var middleValue = (preValue + currentValue) / 2;
    if (dim === "x") {
      items.push({
        points: [
          coordinate2.convert({
            x: alignTick ? currentValue : middleValue,
            y: 0
          }),
          coordinate2.convert({
            x: alignTick ? currentValue : middleValue,
            y: 1
          })
        ]
      });
    } else {
      items.push({
        points: map$2(Array(count + 1), function(__, idx) {
          return coordinate2.convert({
            x: idx / count,
            y: alignTick ? currentValue : middleValue
          });
        })
      });
    }
    return currentTick;
  }, ticks[0]);
  return items;
}
function showGrid(axisTheme, axisOption) {
  var userGrid = get(axisOption, "grid");
  if (userGrid === null) {
    return false;
  }
  var themeGrid = get(axisTheme, "grid");
  return !(userGrid === void 0 && themeGrid === null);
}
var OMIT_CFG = ["container"];
var AXIS_DEFAULT_ANIMATE_CFG = __assign$1(__assign$1({}, DEFAULT_ANIMATE_CFG), { appear: null });
var Axis = function(_super) {
  __extends$2(Axis2, _super);
  function Axis2(view) {
    var _this = _super.call(this, view) || this;
    _this.cache = new Map();
    _this.gridContainer = _this.view.getLayer(LAYER.BG).addGroup();
    _this.gridForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
    _this.axisContainer = _this.view.getLayer(LAYER.BG).addGroup();
    _this.axisForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
    return _this;
  }
  Object.defineProperty(Axis2.prototype, "name", {
    get: function() {
      return "axis";
    },
    enumerable: false,
    configurable: true
  });
  Axis2.prototype.init = function() {
  };
  Axis2.prototype.render = function() {
    this.update();
  };
  Axis2.prototype.layout = function() {
    var _this = this;
    var coordinate2 = this.view.getCoordinate();
    each$1(this.getComponents(), function(co) {
      var component2 = co.component, direction2 = co.direction, type = co.type, extra = co.extra;
      var dim = extra.dim, scale2 = extra.scale, alignTick = extra.alignTick;
      var updated;
      if (type === COMPONENT_TYPE.AXIS) {
        if (coordinate2.isPolar) {
          if (dim === "x") {
            updated = coordinate2.isTransposed ? getAxisRegion(coordinate2, direction2) : getCircleAxisCenterRadius(coordinate2);
          } else if (dim === "y") {
            updated = coordinate2.isTransposed ? getCircleAxisCenterRadius(coordinate2) : getAxisRegion(coordinate2, direction2);
          }
        } else {
          updated = getAxisRegion(coordinate2, direction2);
        }
      } else if (type === COMPONENT_TYPE.GRID) {
        if (coordinate2.isPolar) {
          var items = void 0;
          if (coordinate2.isTransposed) {
            items = dim === "x" ? getCircleGridItems(coordinate2, _this.view.getYScales()[0], scale2, alignTick, dim) : getLineGridItems(coordinate2, scale2, dim, alignTick);
          } else {
            items = dim === "x" ? getLineGridItems(coordinate2, scale2, dim, alignTick) : getCircleGridItems(coordinate2, _this.view.getXScale(), scale2, alignTick, dim);
          }
          updated = {
            items,
            center: _this.view.getCoordinate().getCenter()
          };
        } else {
          updated = { items: getLineGridItems(coordinate2, scale2, dim, alignTick) };
        }
      }
      component2.update(updated);
    });
  };
  Axis2.prototype.update = function() {
    this.option = this.view.getOptions().axes;
    var updatedCache = new Map();
    this.updateXAxes(updatedCache);
    this.updateYAxes(updatedCache);
    var newCache = new Map();
    this.cache.forEach(function(co, key) {
      if (updatedCache.has(key)) {
        newCache.set(key, co);
      } else {
        co.component.destroy();
      }
    });
    this.cache = newCache;
  };
  Axis2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this.cache.clear();
    this.gridContainer.clear();
    this.gridForeContainer.clear();
    this.axisContainer.clear();
    this.axisForeContainer.clear();
  };
  Axis2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.gridContainer.remove(true);
    this.gridForeContainer.remove(true);
    this.axisContainer.remove(true);
    this.axisForeContainer.remove(true);
  };
  Axis2.prototype.getComponents = function() {
    var co = [];
    this.cache.forEach(function(value2) {
      co.push(value2);
    });
    return co;
  };
  Axis2.prototype.updateXAxes = function(updatedCache) {
    var scale2 = this.view.getXScale();
    if (!scale2 || scale2.isIdentity) {
      return;
    }
    var xAxisOption = getAxisOption(this.option, scale2.field);
    if (xAxisOption === false) {
      return;
    }
    var direction2 = getAxisDirection(xAxisOption, DIRECTION.BOTTOM);
    var layer = LAYER.BG;
    var dim = "x";
    var coordinate2 = this.view.getCoordinate();
    var axisId = this.getId("axis", scale2.field);
    var gridId = this.getId("grid", scale2.field);
    if (coordinate2.isRect) {
      var axis2 = this.cache.get(axisId);
      if (axis2) {
        var cfg = this.getLineAxisCfg(scale2, xAxisOption, direction2);
        omit(cfg, OMIT_CFG);
        axis2.component.update(cfg);
        updatedCache.set(axisId, axis2);
      } else {
        axis2 = this.createLineAxis(scale2, xAxisOption, layer, direction2, dim);
        this.cache.set(axisId, axis2);
        updatedCache.set(axisId, axis2);
      }
      var grid = this.cache.get(gridId);
      if (grid) {
        var cfg = this.getLineGridCfg(scale2, xAxisOption, direction2, dim);
        omit(cfg, OMIT_CFG);
        grid.component.update(cfg);
        updatedCache.set(gridId, grid);
      } else {
        grid = this.createLineGrid(scale2, xAxisOption, layer, direction2, dim);
        if (grid) {
          this.cache.set(gridId, grid);
          updatedCache.set(gridId, grid);
        }
      }
    } else if (coordinate2.isPolar) {
      var axis2 = this.cache.get(axisId);
      if (axis2) {
        var cfg = coordinate2.isTransposed ? this.getLineAxisCfg(scale2, xAxisOption, DIRECTION.RADIUS) : this.getCircleAxisCfg(scale2, xAxisOption, direction2);
        omit(cfg, OMIT_CFG);
        axis2.component.update(cfg);
        updatedCache.set(axisId, axis2);
      } else {
        if (coordinate2.isTransposed) {
          if (isUndefined(xAxisOption)) {
            return;
          } else {
            axis2 = this.createLineAxis(scale2, xAxisOption, layer, DIRECTION.RADIUS, dim);
          }
        } else {
          axis2 = this.createCircleAxis(scale2, xAxisOption, layer, direction2, dim);
        }
        this.cache.set(axisId, axis2);
        updatedCache.set(axisId, axis2);
      }
      var grid = this.cache.get(gridId);
      if (grid) {
        var cfg = coordinate2.isTransposed ? this.getCircleGridCfg(scale2, xAxisOption, DIRECTION.RADIUS, dim) : this.getLineGridCfg(scale2, xAxisOption, DIRECTION.CIRCLE, dim);
        omit(cfg, OMIT_CFG);
        grid.component.update(cfg);
        updatedCache.set(gridId, grid);
      } else {
        if (coordinate2.isTransposed) {
          if (isUndefined(xAxisOption)) {
            return;
          } else {
            grid = this.createCircleGrid(scale2, xAxisOption, layer, DIRECTION.RADIUS, dim);
          }
        } else {
          grid = this.createLineGrid(scale2, xAxisOption, layer, DIRECTION.CIRCLE, dim);
        }
        if (grid) {
          this.cache.set(gridId, grid);
          updatedCache.set(gridId, grid);
        }
      }
    } else
      ;
  };
  Axis2.prototype.updateYAxes = function(updatedCache) {
    var _this = this;
    var yScales = this.view.getYScales();
    each$1(yScales, function(scale2, idx) {
      if (!scale2 || scale2.isIdentity) {
        return;
      }
      var field2 = scale2.field;
      var yAxisOption = getAxisOption(_this.option, field2);
      if (yAxisOption !== false) {
        var layer = LAYER.BG;
        var dim = "y";
        var axisId = _this.getId("axis", field2);
        var gridId = _this.getId("grid", field2);
        var coordinate2 = _this.view.getCoordinate();
        if (coordinate2.isRect) {
          var direction2 = getAxisDirection(yAxisOption, idx === 0 ? DIRECTION.LEFT : DIRECTION.RIGHT);
          var axis2 = _this.cache.get(axisId);
          if (axis2) {
            var cfg = _this.getLineAxisCfg(scale2, yAxisOption, direction2);
            omit(cfg, OMIT_CFG);
            axis2.component.update(cfg);
            updatedCache.set(axisId, axis2);
          } else {
            axis2 = _this.createLineAxis(scale2, yAxisOption, layer, direction2, dim);
            _this.cache.set(axisId, axis2);
            updatedCache.set(axisId, axis2);
          }
          var grid = _this.cache.get(gridId);
          if (grid) {
            var cfg = _this.getLineGridCfg(scale2, yAxisOption, direction2, dim);
            omit(cfg, OMIT_CFG);
            grid.component.update(cfg);
            updatedCache.set(gridId, grid);
          } else {
            grid = _this.createLineGrid(scale2, yAxisOption, layer, direction2, dim);
            if (grid) {
              _this.cache.set(gridId, grid);
              updatedCache.set(gridId, grid);
            }
          }
        } else if (coordinate2.isPolar) {
          var axis2 = _this.cache.get(axisId);
          if (axis2) {
            var cfg = coordinate2.isTransposed ? _this.getCircleAxisCfg(scale2, yAxisOption, DIRECTION.CIRCLE) : _this.getLineAxisCfg(scale2, yAxisOption, DIRECTION.RADIUS);
            omit(cfg, OMIT_CFG);
            axis2.component.update(cfg);
            updatedCache.set(axisId, axis2);
          } else {
            if (coordinate2.isTransposed) {
              if (isUndefined(yAxisOption)) {
                return;
              } else {
                axis2 = _this.createCircleAxis(scale2, yAxisOption, layer, DIRECTION.CIRCLE, dim);
              }
            } else {
              axis2 = _this.createLineAxis(scale2, yAxisOption, layer, DIRECTION.RADIUS, dim);
            }
            _this.cache.set(axisId, axis2);
            updatedCache.set(axisId, axis2);
          }
          var grid = _this.cache.get(gridId);
          if (grid) {
            var cfg = coordinate2.isTransposed ? _this.getLineGridCfg(scale2, yAxisOption, DIRECTION.CIRCLE, dim) : _this.getCircleGridCfg(scale2, yAxisOption, DIRECTION.RADIUS, dim);
            omit(cfg, OMIT_CFG);
            grid.component.update(cfg);
            updatedCache.set(gridId, grid);
          } else {
            if (coordinate2.isTransposed) {
              if (isUndefined(yAxisOption)) {
                return;
              } else {
                grid = _this.createLineGrid(scale2, yAxisOption, layer, DIRECTION.CIRCLE, dim);
              }
            } else {
              grid = _this.createCircleGrid(scale2, yAxisOption, layer, DIRECTION.RADIUS, dim);
            }
            if (grid) {
              _this.cache.set(gridId, grid);
              updatedCache.set(gridId, grid);
            }
          }
        } else
          ;
      }
    });
  };
  Axis2.prototype.createLineAxis = function(scale2, option, layer, direction2, dim) {
    var axis2 = {
      component: new LineAxis(this.getLineAxisCfg(scale2, option, direction2)),
      layer,
      direction: direction2 === DIRECTION.RADIUS ? DIRECTION.NONE : direction2,
      type: COMPONENT_TYPE.AXIS,
      extra: { dim, scale: scale2 }
    };
    axis2.component.set("field", scale2.field);
    axis2.component.init();
    return axis2;
  };
  Axis2.prototype.createLineGrid = function(scale2, option, layer, direction2, dim) {
    var cfg = this.getLineGridCfg(scale2, option, direction2, dim);
    if (cfg) {
      var grid = {
        component: new LineGrid(cfg),
        layer,
        direction: DIRECTION.NONE,
        type: COMPONENT_TYPE.GRID,
        extra: {
          dim,
          scale: scale2,
          alignTick: get(cfg, "alignTick", true)
        }
      };
      grid.component.init();
      return grid;
    }
  };
  Axis2.prototype.createCircleAxis = function(scale2, option, layer, direction2, dim) {
    var axis2 = {
      component: new CircleAxis(this.getCircleAxisCfg(scale2, option, direction2)),
      layer,
      direction: direction2,
      type: COMPONENT_TYPE.AXIS,
      extra: { dim, scale: scale2 }
    };
    axis2.component.set("field", scale2.field);
    axis2.component.init();
    return axis2;
  };
  Axis2.prototype.createCircleGrid = function(scale2, option, layer, direction2, dim) {
    var cfg = this.getCircleGridCfg(scale2, option, direction2, dim);
    if (cfg) {
      var grid = {
        component: new CircleGrid(cfg),
        layer,
        direction: DIRECTION.NONE,
        type: COMPONENT_TYPE.GRID,
        extra: {
          dim,
          scale: scale2,
          alignTick: get(cfg, "alignTick", true)
        }
      };
      grid.component.init();
      return grid;
    }
  };
  Axis2.prototype.getLineAxisCfg = function(scale2, axisOption, direction2) {
    var container = get(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
    var coordinate2 = this.view.getCoordinate();
    var region = getAxisRegion(coordinate2, direction2);
    var titleText = getAxisTitleText(scale2, axisOption);
    var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), direction2);
    var optionWithTitle = get(axisOption, ["title"]) ? deepMix({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction2, axisOption.title) }, axisOption) : axisOption;
    var cfg = deepMix(__assign$1(__assign$1({ container }, region), { ticks: scale2.getTicks().map(function(tick) {
      return { id: "" + tick.tickValue, name: tick.text, value: tick.value };
    }), verticalFactor: coordinate2.isPolar ? getAxisFactorByRegion(region, coordinate2.getCenter()) * -1 : getAxisFactorByRegion(region, coordinate2.getCenter()), theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
    var _a2 = this.getAnimateCfg(cfg), animate = _a2.animate, animateOption = _a2.animateOption;
    cfg.animateOption = animateOption;
    cfg.animate = animate;
    var isAxisVertical = isVertical(region);
    var verticalLimitLength = get(cfg, "verticalLimitLength", isAxisVertical ? 1 / 3 : 1 / 2);
    if (verticalLimitLength <= 1) {
      var canvasWidth = this.view.getCanvas().get("width");
      var canvasHeight = this.view.getCanvas().get("height");
      cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);
    }
    return cfg;
  };
  Axis2.prototype.getLineGridCfg = function(scale2, axisOption, direction2, dim) {
    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction2), axisOption)) {
      return void 0;
    }
    var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), direction2);
    var gridCfg = deepMix({
      container: get(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer
    }, gridThemeCfg, get(axisOption, "grid"), this.getAnimateCfg(axisOption));
    gridCfg.items = getLineGridItems(this.view.getCoordinate(), scale2, dim, get(gridCfg, "alignTick", true));
    return gridCfg;
  };
  Axis2.prototype.getCircleAxisCfg = function(scale2, axisOption, direction2) {
    var container = get(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
    var coordinate2 = this.view.getCoordinate();
    var ticks = scale2.getTicks().map(function(tick) {
      return { id: "" + tick.tickValue, name: tick.text, value: tick.value };
    });
    if (!scale2.isCategory && Math.abs(coordinate2.endAngle - coordinate2.startAngle) === Math.PI * 2) {
      ticks.pop();
    }
    var titleText = getAxisTitleText(scale2, axisOption);
    var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), DIRECTION.CIRCLE);
    var optionWithTitle = get(axisOption, ["title"]) ? deepMix({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction2, axisOption.title) }, axisOption) : axisOption;
    var cfg = deepMix(__assign$1(__assign$1({ container }, getCircleAxisCenterRadius(this.view.getCoordinate())), { ticks, verticalFactor: 1, theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
    var _a2 = this.getAnimateCfg(cfg), animate = _a2.animate, animateOption = _a2.animateOption;
    cfg.animate = animate;
    cfg.animateOption = animateOption;
    return cfg;
  };
  Axis2.prototype.getCircleGridCfg = function(scale2, axisOption, direction2, dim) {
    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction2), axisOption)) {
      return void 0;
    }
    var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), DIRECTION.RADIUS);
    var gridCfg = deepMix({
      container: get(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer,
      center: this.view.getCoordinate().getCenter()
    }, gridThemeCfg, get(axisOption, "grid"), this.getAnimateCfg(axisOption));
    var alignTick = get(gridCfg, "alignTick", true);
    var verticalScale = dim === "x" ? this.view.getYScales()[0] : this.view.getXScale();
    gridCfg.items = getCircleGridItems(this.view.getCoordinate(), verticalScale, scale2, alignTick, dim);
    return gridCfg;
  };
  Axis2.prototype.getId = function(name, key) {
    var coordinate2 = this.view.getCoordinate();
    return name + "-" + key + "-" + coordinate2.type;
  };
  Axis2.prototype.getAnimateCfg = function(cfg) {
    return {
      animate: this.view.getOptions().animate && get(cfg, "animate"),
      animateOption: cfg && cfg.animateOption ? deepMix({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG
    };
  };
  return Axis2;
}(Controller);
function directionToPosition(parentBBox, bbox, direction2) {
  if (direction2 === DIRECTION.TOP) {
    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.minY];
  }
  if (direction2 === DIRECTION.BOTTOM) {
    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.maxY - bbox.height];
  }
  if (direction2 === DIRECTION.LEFT) {
    return [parentBBox.minX, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
  }
  if (direction2 === DIRECTION.RIGHT) {
    return [parentBBox.maxX - bbox.width, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
  }
  if (direction2 === DIRECTION.TOP_LEFT || direction2 === DIRECTION.LEFT_TOP) {
    return [parentBBox.tl.x, parentBBox.tl.y];
  }
  if (direction2 === DIRECTION.TOP_RIGHT || direction2 === DIRECTION.RIGHT_TOP) {
    return [parentBBox.tr.x - bbox.width, parentBBox.tr.y];
  }
  if (direction2 === DIRECTION.BOTTOM_LEFT || direction2 === DIRECTION.LEFT_BOTTOM) {
    return [parentBBox.bl.x, parentBBox.bl.y - bbox.height];
  }
  if (direction2 === DIRECTION.BOTTOM_RIGHT || direction2 === DIRECTION.RIGHT_BOTTOM) {
    return [parentBBox.br.x - bbox.width, parentBBox.br.y - bbox.height];
  }
  return [0, 0];
}
function getLegendOption(legends, field2) {
  if (isBoolean(legends)) {
    return legends === false ? false : {};
  }
  return get(legends, [field2], legends);
}
function getDirection(legendOption) {
  return get(legendOption, "position", DIRECTION.BOTTOM);
}
var Legend = function(_super) {
  __extends$2(Legend2, _super);
  function Legend2(view) {
    var _this = _super.call(this, view) || this;
    _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
    return _this;
  }
  Object.defineProperty(Legend2.prototype, "name", {
    get: function() {
      return "legend";
    },
    enumerable: false,
    configurable: true
  });
  Legend2.prototype.init = function() {
  };
  Legend2.prototype.render = function() {
    this.update();
  };
  Legend2.prototype.layout = function() {
    var _this = this;
    this.layoutBBox = this.view.viewBBox;
    each$1(this.components, function(co) {
      var component2 = co.component, direction2 = co.direction;
      var layout = getLegendLayout(direction2);
      var maxWidthRatio = component2.get("maxWidthRatio");
      var maxHeightRatio = component2.get("maxHeightRatio");
      var maxSize = _this.getCategoryLegendSizeCfg(layout, maxWidthRatio, maxHeightRatio);
      var maxWidth = component2.get("maxWidth");
      var maxHeight = component2.get("maxHeight");
      component2.update({
        maxWidth: Math.min(maxSize.maxWidth, maxWidth || 0),
        maxHeight: Math.min(maxSize.maxHeight, maxHeight || 0)
      });
      var padding2 = component2.get("padding");
      var bboxObject = component2.getLayoutBBox();
      var bbox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(padding2);
      var _a2 = directionToPosition(_this.view.viewBBox, bbox, direction2), x1 = _a2[0], y1 = _a2[1];
      var _b = directionToPosition(_this.layoutBBox, bbox, direction2), x2 = _b[0], y2 = _b[1];
      var x = 0;
      var y = 0;
      if (direction2.startsWith("top") || direction2.startsWith("bottom")) {
        x = x1;
        y = y2;
      } else {
        x = x2;
        y = y1;
      }
      component2.setLocation({ x: x + padding2[3], y: y + padding2[0] });
      _this.layoutBBox = _this.layoutBBox.cut(bbox, direction2);
    });
  };
  Legend2.prototype.update = function() {
    var _this = this;
    this.option = this.view.getOptions().legends;
    var updated = {};
    var eachLegend = function(geometry2, attr, scale2) {
      var id2 = _this.getId(scale2.field);
      var existCo2 = _this.getComponentById(id2);
      if (existCo2) {
        var cfg = void 0;
        var legendOption = getLegendOption(_this.option, scale2.field);
        if (legendOption !== false) {
          if (get(legendOption, "custom")) {
            cfg = _this.getCategoryCfg(geometry2, attr, scale2, legendOption, true);
          } else {
            if (scale2.isLinear) {
              cfg = _this.getContinuousCfg(geometry2, attr, scale2, legendOption);
            } else if (scale2.isCategory) {
              cfg = _this.getCategoryCfg(geometry2, attr, scale2, legendOption);
            }
          }
        }
        if (cfg) {
          omit(cfg, ["container"]);
          existCo2.direction = getDirection(legendOption);
          existCo2.component.update(cfg);
          updated[id2] = true;
        }
      } else {
        var legend2 = _this.createFieldLegend(geometry2, attr, scale2);
        if (legend2) {
          legend2.component.init();
          _this.components.push(legend2);
          updated[id2] = true;
        }
      }
    };
    if (get(this.option, "custom")) {
      var id = "global-custom";
      var existCo = this.getComponentById(id);
      if (existCo) {
        var customCfg = this.getCategoryCfg(void 0, void 0, void 0, this.option, true);
        omit(customCfg, ["container"]);
        existCo.component.update(customCfg);
        updated[id] = true;
      } else {
        var component2 = this.createCustomLegend(void 0, void 0, void 0, this.option);
        if (component2) {
          component2.init();
          var layer = LAYER.FORE;
          var direction2 = getDirection(this.option);
          this.components.push({
            id,
            component: component2,
            layer,
            direction: direction2,
            type: COMPONENT_TYPE.LEGEND,
            extra: void 0
          });
          updated[id] = true;
        }
      }
    } else {
      this.loopLegends(eachLegend);
    }
    var components = [];
    each$1(this.getComponents(), function(co) {
      if (updated[co.id]) {
        components.push(co);
      } else {
        co.component.destroy();
      }
    });
    this.components = components;
  };
  Legend2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this.container.clear();
  };
  Legend2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.container.remove(true);
  };
  Legend2.prototype.getGeometries = function(view) {
    var _this = this;
    var geometries = view.geometries;
    each$1(view.views, function(v) {
      geometries = geometries.concat(_this.getGeometries(v));
    });
    return geometries;
  };
  Legend2.prototype.loopLegends = function(doEach) {
    var isRootView = this.view.getRootView() === this.view;
    if (!isRootView) {
      return;
    }
    var geometries = this.getGeometries(this.view);
    var looped = {};
    each$1(geometries, function(geometry2) {
      var attributes = geometry2.getGroupAttributes();
      each$1(attributes, function(attr) {
        var scale2 = attr.getScale(attr.type);
        if (!scale2 || scale2.type === "identity" || looped[scale2.field]) {
          return;
        }
        doEach(geometry2, attr, scale2);
        looped[scale2.field] = true;
      });
    });
  };
  Legend2.prototype.createFieldLegend = function(geometry2, attr, scale2) {
    var component2;
    var legendOption = getLegendOption(this.option, scale2.field);
    var layer = LAYER.FORE;
    var direction2 = getDirection(legendOption);
    if (legendOption !== false) {
      if (get(legendOption, "custom")) {
        component2 = this.createCustomLegend(geometry2, attr, scale2, legendOption);
      } else {
        if (scale2.isLinear) {
          component2 = this.createContinuousLegend(geometry2, attr, scale2, legendOption);
        } else if (scale2.isCategory) {
          component2 = this.createCategoryLegend(geometry2, attr, scale2, legendOption);
        }
      }
    }
    if (component2) {
      component2.set("field", scale2.field);
      return {
        id: this.getId(scale2.field),
        component: component2,
        layer,
        direction: direction2,
        type: COMPONENT_TYPE.LEGEND,
        extra: { scale: scale2 }
      };
    }
  };
  Legend2.prototype.createCustomLegend = function(geometry2, attr, scale2, legendOption) {
    var cfg = this.getCategoryCfg(geometry2, attr, scale2, legendOption, true);
    return new CategoryLegend(cfg);
  };
  Legend2.prototype.createContinuousLegend = function(geometry2, attr, scale2, legendOption) {
    var cfg = this.getContinuousCfg(geometry2, attr, scale2, omit(legendOption, ["value"]));
    return new ContinuousLegend(cfg);
  };
  Legend2.prototype.createCategoryLegend = function(geometry2, attr, scale2, legendOption) {
    var cfg = this.getCategoryCfg(geometry2, attr, scale2, legendOption);
    return new CategoryLegend(cfg);
  };
  Legend2.prototype.getContinuousCfg = function(geometry2, attr, scale2, legendOption) {
    var ticks = scale2.getTicks();
    var containMin = find$1(ticks, function(tick) {
      return tick.value === 0;
    });
    var containMax = find$1(ticks, function(tick) {
      return tick.value === 1;
    });
    var items = ticks.map(function(tick) {
      var value2 = tick.value, tickValue = tick.tickValue;
      var attrValue = attr.mapping(scale2.invert(value2)).join("");
      return {
        value: tickValue,
        attrValue,
        color: attrValue,
        scaleValue: value2
      };
    });
    if (!containMin) {
      items.push({
        value: scale2.min,
        attrValue: attr.mapping(scale2.invert(0)).join(""),
        color: attr.mapping(scale2.invert(0)).join(""),
        scaleValue: 0
      });
    }
    if (!containMax) {
      items.push({
        value: scale2.max,
        attrValue: attr.mapping(scale2.invert(1)).join(""),
        color: attr.mapping(scale2.invert(1)).join(""),
        scaleValue: 1
      });
    }
    items.sort(function(a, b) {
      return a.value - b.value;
    });
    var attrLegendCfg = {
      min: head(items).value,
      max: last(items).value,
      colors: [],
      rail: {
        type: attr.type
      },
      track: {}
    };
    if (attr.type === "size") {
      attrLegendCfg.track = {
        style: {
          fill: attr.type === "size" ? this.view.getTheme().defaultColor : void 0
        }
      };
    }
    if (attr.type === "color") {
      attrLegendCfg.colors = items.map(function(item) {
        return item.attrValue;
      });
    }
    var container = this.container;
    var direction2 = getDirection(legendOption);
    var layout = getLegendLayout(direction2);
    var title = get(legendOption, "title");
    if (title) {
      title = deepMix({
        text: getName(scale2)
      }, title);
    }
    attrLegendCfg.container = container;
    attrLegendCfg.layout = layout;
    attrLegendCfg.title = title;
    attrLegendCfg.animateOption = DEFAULT_ANIMATE_CFG;
    return this.mergeLegendCfg(attrLegendCfg, legendOption, "continuous");
  };
  Legend2.prototype.getCategoryCfg = function(geometry2, attr, scale2, legendOption, custom) {
    var container = this.container;
    var direction2 = get(legendOption, "position", DIRECTION.BOTTOM);
    var legendTheme = getLegendThemeCfg(this.view.getTheme(), direction2);
    var themeMarker = get(legendTheme, ["marker"]);
    var userMarker = get(legendOption, "marker");
    var layout = getLegendLayout(direction2);
    var themePageNavigator = get(legendTheme, ["pageNavigator"]);
    var userPageNavigator = get(legendOption, "pageNavigator");
    var items = custom ? getCustomLegendItems(themeMarker, userMarker, legendOption.items) : getLegendItems(this.view, geometry2, attr, themeMarker, userMarker);
    var title = get(legendOption, "title");
    if (title) {
      title = deepMix({
        text: scale2 ? getName(scale2) : ""
      }, title);
    }
    var maxWidthRatio = get(legendOption, "maxWidthRatio");
    var maxHeightRatio = get(legendOption, "maxHeightRatio");
    var baseCfg = this.getCategoryLegendSizeCfg(layout, maxWidthRatio, maxHeightRatio);
    baseCfg.container = container;
    baseCfg.layout = layout;
    baseCfg.items = items;
    baseCfg.title = title;
    baseCfg.animateOption = DEFAULT_ANIMATE_CFG;
    baseCfg.pageNavigator = deepMix({}, themePageNavigator, userPageNavigator);
    var categoryCfg = this.mergeLegendCfg(baseCfg, legendOption, direction2);
    if (categoryCfg.reversed) {
      categoryCfg.items.reverse();
    }
    var maxItemWidth = get(categoryCfg, "maxItemWidth");
    if (maxItemWidth && maxItemWidth <= 1) {
      categoryCfg.maxItemWidth = this.view.viewBBox.width * maxItemWidth;
    }
    return categoryCfg;
  };
  Legend2.prototype.mergeLegendCfg = function(baseCfg, legendOption, direction2) {
    var position = direction2.split("-")[0];
    var themeObject = getLegendThemeCfg(this.view.getTheme(), position);
    return deepMix({}, themeObject, baseCfg, legendOption);
  };
  Legend2.prototype.getId = function(key) {
    return this.name + "-" + key;
  };
  Legend2.prototype.getComponentById = function(id) {
    return find$1(this.components, function(co) {
      return co.id === id;
    });
  };
  Legend2.prototype.getCategoryLegendSizeCfg = function(layout, maxWidthRatio, maxHeightRatio) {
    if (maxWidthRatio === void 0) {
      maxWidthRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
    }
    if (maxHeightRatio === void 0) {
      maxHeightRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
    }
    var _a2 = this.view.viewBBox, vw = _a2.width, vh = _a2.height;
    return layout === "vertical" ? {
      maxWidth: vw * maxWidthRatio,
      maxHeight: vh
    } : {
      maxWidth: vw,
      maxHeight: vh * maxHeightRatio
    };
  };
  return Legend2;
}(Controller);
var Slider = function(_super) {
  __extends$2(Slider2, _super);
  function Slider2(view) {
    var _this = _super.call(this, view) || this;
    _this.onChangeFn = noop;
    _this.resetMeasure = function() {
      _this.clear();
    };
    _this.onValueChange = function(v) {
      var min2 = v[0], max2 = v[1];
      _this.start = min2;
      _this.end = max2;
      _this.changeViewData(min2, max2);
    };
    _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
    _this.onChangeFn = throttle(_this.onValueChange, 20, {
      leading: true
    });
    _this.width = 0;
    _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
    _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
    return _this;
  }
  Object.defineProperty(Slider2.prototype, "name", {
    get: function() {
      return "slider";
    },
    enumerable: false,
    configurable: true
  });
  Slider2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
    this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
  };
  Slider2.prototype.init = function() {
  };
  Slider2.prototype.render = function() {
    this.option = this.view.getOptions().slider;
    var _a2 = this.getSliderCfg(), start = _a2.start, end = _a2.end;
    if (isNil(this.start)) {
      this.start = start;
      this.end = end;
    }
    var viewData = this.view.getOptions().data;
    if (this.option && !isEmpty(viewData)) {
      if (this.slider) {
        this.slider = this.updateSlider();
      } else {
        this.slider = this.createSlider();
        this.slider.component.on("sliderchange", this.onChangeFn);
      }
    } else {
      if (this.slider) {
        this.slider.component.destroy();
        this.slider = void 0;
      }
    }
  };
  Slider2.prototype.layout = function() {
    var _this = this;
    if (this.option && !this.width) {
      this.measureSlider();
      setTimeout(function() {
        if (!_this.view.destroyed) {
          _this.changeViewData(_this.start, _this.end);
        }
      }, 0);
    }
    if (this.slider) {
      var width = this.view.coordinateBBox.width;
      var padding2 = this.slider.component.get("padding");
      var paddingTop = padding2[0];
      padding2[1];
      padding2[2];
      var paddingLeft = padding2[3];
      var bboxObject = this.slider.component.getLayoutBBox();
      var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding2);
      var _a2 = this.getMinMaxText(this.start, this.end), minText = _a2.minText, maxText = _a2.maxText;
      var _b = directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM);
      _b[0];
      var y1 = _b[1];
      var _c = directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), x2 = _c[0];
      _c[1];
      this.slider.component.update(__assign$1(__assign$1({}, this.getSliderCfg()), { x: x2 + paddingLeft, y: y1 + paddingTop, width: this.width, start: this.start, end: this.end, minText, maxText }));
      this.view.viewBBox = this.view.viewBBox.cut(bbox, DIRECTION.BOTTOM);
    }
  };
  Slider2.prototype.update = function() {
    this.render();
  };
  Slider2.prototype.createSlider = function() {
    var cfg = this.getSliderCfg();
    var component2 = new Slider$1(__assign$1({ container: this.container }, cfg));
    component2.init();
    return {
      component: component2,
      layer: LAYER.FORE,
      direction: DIRECTION.BOTTOM,
      type: COMPONENT_TYPE.SLIDER
    };
  };
  Slider2.prototype.updateSlider = function() {
    var cfg = this.getSliderCfg();
    if (this.width) {
      var _a2 = this.getMinMaxText(this.start, this.end), minText = _a2.minText, maxText = _a2.maxText;
      cfg = __assign$1(__assign$1({}, cfg), { width: this.width, start: this.start, end: this.end, minText, maxText });
    }
    this.slider.component.update(cfg);
    return this.slider;
  };
  Slider2.prototype.measureSlider = function() {
    var width = this.getSliderCfg().width;
    this.width = width;
  };
  Slider2.prototype.getSliderCfg = function() {
    var cfg = {
      height: 16,
      start: 0,
      end: 1,
      minText: "",
      maxText: "",
      x: 0,
      y: 0,
      width: this.view.coordinateBBox.width
    };
    if (isObject(this.option)) {
      var trendCfg = __assign$1({ data: this.getData() }, get(this.option, "trendCfg", {}));
      cfg = deepMix({}, cfg, this.getThemeOptions(), this.option);
      cfg = __assign$1(__assign$1({}, cfg), { trendCfg });
    }
    cfg.start = clamp(Math.min(isNil(cfg.start) ? 0 : cfg.start, isNil(cfg.end) ? 1 : cfg.end), 0, 1);
    cfg.end = clamp(Math.max(isNil(cfg.start) ? 0 : cfg.start, isNil(cfg.end) ? 1 : cfg.end), 0, 1);
    return cfg;
  };
  Slider2.prototype.getData = function() {
    var data2 = this.view.getOptions().data;
    var yScale = this.view.getYScales()[0];
    var groupScales = this.view.getGroupScales();
    if (groupScales.length) {
      var _a2 = groupScales[0], field_1 = _a2.field, ticks_1 = _a2.ticks;
      return data2.reduce(function(pre, cur) {
        if (cur[field_1] === ticks_1[0]) {
          pre.push(cur[yScale.field]);
        }
        return pre;
      }, []);
    }
    return data2.map(function(datum) {
      return datum[yScale.field] || 0;
    });
  };
  Slider2.prototype.getThemeOptions = function() {
    var theme2 = this.view.getTheme();
    return get(theme2, ["components", "slider", "common"], {});
  };
  Slider2.prototype.getMinMaxText = function(min2, max2) {
    var data2 = this.view.getOptions().data;
    var xScale = this.view.getXScale();
    var values2 = valuesOfKey(data2, xScale.field);
    var xValues = values2;
    var dataSize = size(data2);
    if (!xScale || !dataSize) {
      return {};
    }
    var xTickCount = size(xValues);
    var minIndex = Math.floor(min2 * (xTickCount - 1));
    var maxIndex = Math.floor(max2 * (xTickCount - 1));
    var minText = get(xValues, [minIndex]);
    var maxText = get(xValues, [maxIndex]);
    var formatter = this.getSliderCfg().formatter;
    if (formatter) {
      minText = formatter(minText, data2[minIndex], minIndex);
      maxText = formatter(maxText, data2[maxIndex], maxIndex);
    }
    return {
      minText,
      maxText
    };
  };
  Slider2.prototype.changeViewData = function(min2, max2) {
    var data2 = this.view.getOptions().data;
    var xScale = this.view.getXScale();
    var dataSize = size(data2);
    if (!xScale || !dataSize) {
      return;
    }
    var values2 = valuesOfKey(data2, xScale.field);
    var xValues = values2;
    var xTickCount = size(xValues);
    var minIndex = Math.floor(min2 * (xTickCount - 1));
    var maxIndex = Math.floor(max2 * (xTickCount - 1));
    this.view.filter(xScale.field, function(value2, datum) {
      var idx = xValues.indexOf(value2);
      return idx > -1 ? isBetween$1(idx, minIndex, maxIndex) : true;
    });
    this.view.render(true);
  };
  Slider2.prototype.getComponents = function() {
    return this.slider ? [this.slider] : [];
  };
  Slider2.prototype.clear = function() {
    if (this.slider) {
      this.slider.component.destroy();
      this.slider = void 0;
    }
    this.width = 0;
    this.start = void 0;
    this.end = void 0;
  };
  return Slider2;
}(Controller);
var DEFAULT_PADDING = 0;
var DEFAULT_SIZE = 8;
var DEFAULT_CATEGORY_SIZE = 32;
var MIN_THUMB_LENGTH = 20;
var Scrollbar = function(_super) {
  __extends$2(Scrollbar2, _super);
  function Scrollbar2(view) {
    var _this = _super.call(this, view) || this;
    _this.onChangeFn = noop;
    _this.resetMeasure = function() {
      _this.clear();
    };
    _this.onValueChange = function(_a2) {
      var ratio = _a2.ratio;
      var animate = _this.getValidScrollbarCfg().animate;
      _this.ratio = clamp(ratio, 0, 1);
      var originalAnimate = _this.view.getOptions().animate;
      if (!animate) {
        _this.view.animate(false);
      }
      _this.changeViewData(_this.getScrollRange(), true);
      _this.view.animate(originalAnimate);
    };
    _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
    _this.onChangeFn = throttle(_this.onValueChange, 20, {
      leading: true
    });
    _this.trackLen = 0;
    _this.thumbLen = 0;
    _this.ratio = 0;
    _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
    _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
    return _this;
  }
  Object.defineProperty(Scrollbar2.prototype, "name", {
    get: function() {
      return "scrollbar";
    },
    enumerable: false,
    configurable: true
  });
  Scrollbar2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
    this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
  };
  Scrollbar2.prototype.init = function() {
  };
  Scrollbar2.prototype.render = function() {
    this.option = this.view.getOptions().scrollbar;
    if (this.option) {
      if (this.scrollbar) {
        this.scrollbar = this.updateScrollbar();
      } else {
        this.scrollbar = this.createScrollbar();
        this.scrollbar.component.on("scrollchange", this.onChangeFn);
      }
    } else {
      if (this.scrollbar) {
        this.scrollbar.component.destroy();
        this.scrollbar = void 0;
      }
    }
  };
  Scrollbar2.prototype.layout = function() {
    var _this = this;
    if (this.option && !this.trackLen) {
      this.measureScrollbar();
      setTimeout(function() {
        if (!_this.view.destroyed) {
          _this.changeViewData(_this.getScrollRange(), true);
        }
      });
    }
    if (this.scrollbar) {
      var width = this.view.coordinateBBox.width;
      var padding2 = this.scrollbar.component.get("padding");
      var bboxObject = this.scrollbar.component.getLayoutBBox();
      var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding2);
      var cfg = this.getScrollbarComponentCfg();
      var x = void 0;
      var y = void 0;
      if (cfg.isHorizontal) {
        var _a2 = directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM);
        _a2[0];
        var y1 = _a2[1];
        var _b = directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), x2 = _b[0];
        _b[1];
        x = x2;
        y = y1;
      } else {
        var _c = directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT);
        _c[0];
        var y1 = _c[1];
        var _d = directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT), x2 = _d[0];
        _d[1];
        x = x2;
        y = y1;
      }
      x += padding2[3];
      y += padding2[0];
      if (this.trackLen) {
        this.scrollbar.component.update(__assign$1(__assign$1({}, cfg), { x, y, trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }));
      } else {
        this.scrollbar.component.update(__assign$1(__assign$1({}, cfg), { x, y }));
      }
      this.view.viewBBox = this.view.viewBBox.cut(bbox, cfg.isHorizontal ? DIRECTION.BOTTOM : DIRECTION.RIGHT);
    }
  };
  Scrollbar2.prototype.update = function() {
    this.render();
  };
  Scrollbar2.prototype.getComponents = function() {
    return this.scrollbar ? [this.scrollbar] : [];
  };
  Scrollbar2.prototype.clear = function() {
    if (this.scrollbar) {
      this.scrollbar.component.destroy();
      this.scrollbar = void 0;
    }
    this.trackLen = 0;
    this.thumbLen = 0;
    this.ratio = 0;
    this.cnt = 0;
    this.step = 0;
    this.data = void 0;
    this.xScaleCfg = void 0;
    this.yScalesCfg = [];
  };
  Scrollbar2.prototype.setValue = function(ratio) {
    this.onValueChange({ ratio });
  };
  Scrollbar2.prototype.getValue = function() {
    return this.ratio;
  };
  Scrollbar2.prototype.getThemeOptions = function() {
    var theme2 = this.view.getTheme();
    return get(theme2, ["components", "scrollbar", "common"], {});
  };
  Scrollbar2.prototype.getScrollbarTheme = function(style) {
    var theme2 = get(this.view.getTheme(), ["components", "scrollbar"]);
    var _a2 = style || {}, thumbHighlightColor = _a2.thumbHighlightColor, restStyles = __rest(_a2, ["thumbHighlightColor"]);
    return {
      default: deepMix({}, get(theme2, ["default", "style"], {}), restStyles),
      hover: deepMix({}, get(theme2, ["hover", "style"], {}), { thumbColor: thumbHighlightColor })
    };
  };
  Scrollbar2.prototype.measureScrollbar = function() {
    var xScale = this.view.getXScale();
    var yScales = this.view.getYScales().slice();
    this.data = this.getScrollbarData();
    this.step = this.getStep();
    this.cnt = this.getCnt();
    var _a2 = this.getScrollbarComponentCfg(), trackLen = _a2.trackLen, thumbLen = _a2.thumbLen;
    this.trackLen = trackLen;
    this.thumbLen = thumbLen;
    this.xScaleCfg = {
      field: xScale.field,
      values: xScale.values || []
    };
    this.yScalesCfg = yScales;
  };
  Scrollbar2.prototype.getScrollRange = function() {
    var startIdx = Math.floor((this.cnt - this.step) * clamp(this.ratio, 0, 1));
    var endIdx = Math.min(startIdx + this.step - 1, this.cnt - 1);
    return [startIdx, endIdx];
  };
  Scrollbar2.prototype.changeViewData = function(_a2, render) {
    var _this = this;
    var startIdx = _a2[0], endIdx = _a2[1];
    var type = this.getValidScrollbarCfg().type;
    var isHorizontal2 = type !== "vertical";
    var values2 = valuesOfKey(this.data, this.xScaleCfg.field);
    var xValues = isHorizontal2 ? values2 : values2.reverse();
    this.yScalesCfg.forEach(function(cfg) {
      _this.view.scale(cfg.field, {
        formatter: cfg.formatter,
        type: cfg.type,
        min: cfg.min,
        max: cfg.max
      });
    });
    this.view.filter(this.xScaleCfg.field, function(val) {
      var idx = xValues.indexOf(val);
      return idx > -1 ? isBetween$1(idx, startIdx, endIdx) : true;
    });
    this.view.render(true);
  };
  Scrollbar2.prototype.createScrollbar = function() {
    var type = this.getValidScrollbarCfg().type;
    var isHorizontal2 = type !== "vertical";
    var component2 = new Scrollbar$1(__assign$1(__assign$1({ container: this.container }, this.getScrollbarComponentCfg()), { x: 0, y: 0 }));
    component2.init();
    return {
      component: component2,
      layer: LAYER.FORE,
      direction: isHorizontal2 ? DIRECTION.BOTTOM : DIRECTION.RIGHT,
      type: COMPONENT_TYPE.SCROLLBAR
    };
  };
  Scrollbar2.prototype.updateScrollbar = function() {
    var config = this.getScrollbarComponentCfg();
    var realConfig = this.trackLen ? __assign$1(__assign$1({}, config), { trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }) : __assign$1({}, config);
    this.scrollbar.component.update(realConfig);
    return this.scrollbar;
  };
  Scrollbar2.prototype.getStep = function() {
    if (this.step) {
      return this.step;
    }
    var coordinateBBox = this.view.coordinateBBox;
    var _a2 = this.getValidScrollbarCfg(), type = _a2.type, categorySize = _a2.categorySize;
    var isHorizontal2 = type !== "vertical";
    return Math.floor((isHorizontal2 ? coordinateBBox.width : coordinateBBox.height) / categorySize);
  };
  Scrollbar2.prototype.getCnt = function() {
    if (this.cnt) {
      return this.cnt;
    }
    var xScale = this.view.getXScale();
    var data2 = this.getScrollbarData();
    var values2 = valuesOfKey(data2, xScale.field);
    return size(values2);
  };
  Scrollbar2.prototype.getScrollbarComponentCfg = function() {
    var _a2 = this.view, coordinateBBox = _a2.coordinateBBox, viewBBox = _a2.viewBBox;
    var _b = this.getValidScrollbarCfg(), type = _b.type, padding2 = _b.padding, width = _b.width, height = _b.height, style = _b.style;
    var isHorizontal2 = type !== "vertical";
    var paddingTop = padding2[0], paddingRight = padding2[1], paddingBottom = padding2[2], paddingLeft = padding2[3];
    var position = isHorizontal2 ? {
      x: coordinateBBox.minX + paddingLeft,
      y: viewBBox.maxY - height - paddingBottom
    } : {
      x: viewBBox.maxX - width - paddingRight,
      y: coordinateBBox.minY + paddingTop
    };
    var step = this.getStep();
    var cnt = this.getCnt();
    var trackLen = isHorizontal2 ? coordinateBBox.width - paddingLeft - paddingRight : coordinateBBox.height - paddingTop - paddingBottom;
    var thumbLen = Math.max(trackLen * clamp(step / cnt, 0, 1), MIN_THUMB_LENGTH);
    return __assign$1(__assign$1({}, this.getThemeOptions()), { x: position.x, y: position.y, size: isHorizontal2 ? height : width, isHorizontal: isHorizontal2, trackLen, thumbLen, thumbOffset: 0, theme: this.getScrollbarTheme(style) });
  };
  Scrollbar2.prototype.getValidScrollbarCfg = function() {
    var cfg = {
      type: "horizontal",
      categorySize: DEFAULT_CATEGORY_SIZE,
      width: DEFAULT_SIZE,
      height: DEFAULT_SIZE,
      padding: [0, 0, 0, 0],
      animate: true,
      style: {}
    };
    if (isObject(this.option)) {
      cfg = __assign$1(__assign$1({}, cfg), this.option);
    }
    if (!isObject(this.option) || !this.option.padding) {
      cfg.padding = cfg.type === "horizontal" ? [DEFAULT_PADDING, 0, DEFAULT_PADDING, 0] : [0, DEFAULT_PADDING, 0, DEFAULT_PADDING];
    }
    return cfg;
  };
  Scrollbar2.prototype.getScrollbarData = function() {
    var coordinate2 = this.view.getCoordinate();
    var cfg = this.getValidScrollbarCfg();
    var data2 = this.view.getOptions().data || [];
    if (coordinate2.isReflect("y") && cfg.type === "vertical") {
      data2 = __spreadArray([], data2, true).reverse();
    }
    return data2;
  };
  return Scrollbar2;
}(Controller);
var DEFAULT_REGION_PATH_STYLE = {
  fill: "#CCD6EC",
  opacity: 0.3
};
function getItemsOfView(view, point2, tooltipCfg) {
  var items = findItemsFromViewRecurisive(view, point2, tooltipCfg);
  if (items.length) {
    items = flatten(items);
    for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
      var itemArr = items_1[_i];
      for (var _a2 = 0, itemArr_1 = itemArr; _a2 < itemArr_1.length; _a2++) {
        var item = itemArr_1[_a2];
        var _b = item.mappingData, x = _b.x, y = _b.y;
        item.x = isArray$1(x) ? x[x.length - 1] : x;
        item.y = isArray$1(y) ? y[y.length - 1] : y;
      }
    }
    var shared = tooltipCfg.shared;
    if (shared === false && items.length > 1) {
      var snapItem = items[0];
      var min2 = Math.abs(point2.y - snapItem[0].y);
      for (var _c = 0, items_2 = items; _c < items_2.length; _c++) {
        var aItem = items_2[_c];
        var yDistance = Math.abs(point2.y - aItem[0].y);
        if (yDistance <= min2) {
          snapItem = aItem;
          min2 = yDistance;
        }
      }
      items = [snapItem];
    }
    return uniq$2(flatten(items));
  }
  return [];
}
var ActiveRegion = function(_super) {
  __extends$2(ActiveRegion2, _super);
  function ActiveRegion2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ActiveRegion2.prototype.show = function(args) {
    var view = this.context.view;
    var ev = this.context.event;
    var tooltipCfg = view.getController("tooltip").getTooltipCfg();
    var tooltipItems = getItemsOfView(view, {
      x: ev.x,
      y: ev.y
    }, tooltipCfg);
    if (isEqual$2(tooltipItems, this.items)) {
      return;
    }
    this.items = tooltipItems;
    if (tooltipItems.length) {
      var xField_1 = view.getXScale().field;
      var xValue_1 = tooltipItems[0].data[xField_1];
      var elements_1 = [];
      var geometries = view.geometries;
      each$1(geometries, function(geometry2) {
        if (geometry2.type === "interval" || geometry2.type === "schema") {
          var result = geometry2.getElementsBy(function(ele) {
            var eleData = ele.getData();
            return eleData[xField_1] === xValue_1;
          });
          elements_1 = elements_1.concat(result);
        }
      });
      if (elements_1.length) {
        var coordinate_1 = view.getCoordinate();
        var firstBBox_1 = elements_1[0].shape.getCanvasBBox();
        var lastBBox_1 = elements_1[0].shape.getCanvasBBox();
        var groupBBox_1 = firstBBox_1;
        each$1(elements_1, function(ele) {
          var bbox = ele.shape.getCanvasBBox();
          if (coordinate_1.isTransposed) {
            if (bbox.minY < firstBBox_1.minY) {
              firstBBox_1 = bbox;
            }
            if (bbox.maxY > lastBBox_1.maxY) {
              lastBBox_1 = bbox;
            }
          } else {
            if (bbox.minX < firstBBox_1.minX) {
              firstBBox_1 = bbox;
            }
            if (bbox.maxX > lastBBox_1.maxX) {
              lastBBox_1 = bbox;
            }
          }
          groupBBox_1.x = Math.min(bbox.minX, groupBBox_1.minX);
          groupBBox_1.y = Math.min(bbox.minY, groupBBox_1.minY);
          groupBBox_1.width = Math.max(bbox.maxX, groupBBox_1.maxX) - groupBBox_1.x;
          groupBBox_1.height = Math.max(bbox.maxY, groupBBox_1.maxY) - groupBBox_1.y;
        });
        var backgroundGroup = view.backgroundGroup, coordinateBBox = view.coordinateBBox;
        var path2 = void 0;
        if (coordinate_1.isRect) {
          var xScale = view.getXScale();
          var _a2 = args || {}, appendRatio = _a2.appendRatio, appendWidth = _a2.appendWidth;
          if (isNil(appendWidth)) {
            appendRatio = isNil(appendRatio) ? xScale.isLinear ? 0 : 0.25 : appendRatio;
            appendWidth = coordinate_1.isTransposed ? appendRatio * lastBBox_1.height : appendRatio * firstBBox_1.width;
          }
          var minX = void 0;
          var minY = void 0;
          var width = void 0;
          var height = void 0;
          if (coordinate_1.isTransposed) {
            minX = coordinateBBox.minX;
            minY = Math.min(lastBBox_1.minY, firstBBox_1.minY) - appendWidth;
            width = coordinateBBox.width;
            height = groupBBox_1.height + appendWidth * 2;
          } else {
            minX = Math.min(firstBBox_1.minX, lastBBox_1.minX) - appendWidth;
            minY = coordinateBBox.minY;
            width = groupBBox_1.width + appendWidth * 2;
            height = coordinateBBox.height;
          }
          path2 = [
            ["M", minX, minY],
            ["L", minX + width, minY],
            ["L", minX + width, minY + height],
            ["L", minX, minY + height],
            ["Z"]
          ];
        } else {
          var firstElement = head(elements_1);
          var lastElement = last(elements_1);
          var startAngle = getAngle$1(firstElement.getModel(), coordinate_1).startAngle;
          var endAngle = getAngle$1(lastElement.getModel(), coordinate_1).endAngle;
          var center2 = coordinate_1.getCenter();
          var radius = coordinate_1.getRadius();
          var innterRadius = coordinate_1.innerRadius * radius;
          path2 = getSectorPath(center2.x, center2.y, radius, startAngle, endAngle, innterRadius);
        }
        if (this.regionPath) {
          this.regionPath.attr("path", path2);
          this.regionPath.show();
        } else {
          var style = get(args, "style", DEFAULT_REGION_PATH_STYLE);
          this.regionPath = backgroundGroup.addShape({
            type: "path",
            name: "active-region",
            capture: false,
            attrs: __assign$1(__assign$1({}, style), { path: path2 })
          });
        }
      }
    }
  };
  ActiveRegion2.prototype.hide = function() {
    if (this.regionPath) {
      this.regionPath.hide();
    }
    this.items = null;
  };
  ActiveRegion2.prototype.destroy = function() {
    this.hide();
    if (this.regionPath) {
      this.regionPath.remove(true);
    }
    _super.prototype.destroy.call(this);
  };
  return ActiveRegion2;
}(Action);
var TooltipAction = function(_super) {
  __extends$2(TooltipAction2, _super);
  function TooltipAction2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.timeStamp = 0;
    return _this;
  }
  TooltipAction2.prototype.show = function() {
    var context = this.context;
    var ev = context.event;
    var view = context.view;
    var isTooltipLocked = view.isTooltipLocked();
    if (isTooltipLocked) {
      return;
    }
    var lastTimeStamp = this.timeStamp;
    var timeStamp = +new Date();
    var showDelay = get(context.view.getOptions(), "tooltip.showDelay", 16);
    if (timeStamp - lastTimeStamp > showDelay) {
      var preLoc = this.location;
      var curLoc = { x: ev.x, y: ev.y };
      if (!preLoc || !isEqual$2(preLoc, curLoc)) {
        this.showTooltip(view, curLoc);
      }
      this.timeStamp = timeStamp;
      this.location = curLoc;
    }
  };
  TooltipAction2.prototype.hide = function() {
    var view = this.context.view;
    var tooltip2 = view.getController("tooltip");
    var _a2 = this.context.event, clientX = _a2.clientX, clientY = _a2.clientY;
    if (tooltip2.isCursorEntered({ x: clientX, y: clientY })) {
      return;
    }
    if (view.isTooltipLocked()) {
      return;
    }
    this.hideTooltip(view);
    this.location = null;
  };
  TooltipAction2.prototype.showTooltip = function(view, point2) {
    view.showTooltip(point2);
  };
  TooltipAction2.prototype.hideTooltip = function(view) {
    view.hideTooltip();
  };
  return TooltipAction2;
}(Action);
var SiblingTooltip = function(_super) {
  __extends$2(SiblingTooltip2, _super);
  function SiblingTooltip2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SiblingTooltip2.prototype.showTooltip = function(view, point2) {
    var siblings = getSilbings(view);
    each$1(siblings, function(sibling) {
      var siblingPoint = getSiblingPoint(view, sibling, point2);
      sibling.showTooltip(siblingPoint);
    });
  };
  SiblingTooltip2.prototype.hideTooltip = function(view) {
    var siblings = getSilbings(view);
    each$1(siblings, function(sibling) {
      sibling.hideTooltip();
    });
  };
  return SiblingTooltip2;
}(TooltipAction);
var EllipsisText = function(_super) {
  __extends$2(EllipsisText2, _super);
  function EllipsisText2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.timeStamp = 0;
    return _this;
  }
  EllipsisText2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.tooltip && this.tooltip.destroy();
  };
  EllipsisText2.prototype.show = function() {
    var context = this.context;
    var ev = context.event;
    var lastTimeStamp = this.timeStamp;
    var timeStamp = +new Date();
    if (timeStamp - lastTimeStamp > 16) {
      var preLoc = this.location;
      var curLoc = { x: ev.x, y: ev.y };
      if (!preLoc || !isEqual$2(preLoc, curLoc)) {
        this.showTooltip(curLoc);
      }
      this.timeStamp = timeStamp;
      this.location = curLoc;
    }
  };
  EllipsisText2.prototype.hide = function() {
    this.hideTooltip();
    this.location = null;
  };
  EllipsisText2.prototype.showTooltip = function(curLoc) {
    var context = this.context;
    var ev = context.event;
    var target = ev.target;
    if (target && target.get("tip")) {
      if (!this.tooltip) {
        this.renderTooltip();
      }
      var tipContent = target.get("tip");
      this.tooltip.update(__assign$1({ title: tipContent }, curLoc));
      this.tooltip.show();
    }
  };
  EllipsisText2.prototype.hideTooltip = function() {
    this.tooltip && this.tooltip.hide();
  };
  EllipsisText2.prototype.renderTooltip = function() {
    var _a2;
    var view = this.context.view;
    var canvas = view.canvas;
    var region = {
      start: { x: 0, y: 0 },
      end: { x: canvas.get("width"), y: canvas.get("height") }
    };
    var theme2 = view.getTheme();
    var tooltipStyles = get(theme2, ["components", "tooltip", "domStyles"], {});
    var tooltip2 = new HtmlTooltip({
      parent: canvas.get("el").parentNode,
      region,
      visible: false,
      crosshairs: null,
      domStyles: __assign$1({}, deepMix({}, tooltipStyles, (_a2 = {}, _a2[CONTAINER_CLASS] = { "max-width": "50%" }, _a2[TITLE_CLASS] = { "word-break": "break-all" }, _a2)))
    });
    tooltip2.init();
    tooltip2.setCapture(false);
    this.tooltip = tooltip2;
  };
  return EllipsisText2;
}(Action);
var StateBase = function(_super) {
  __extends$2(StateBase2, _super);
  function StateBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "";
    return _this;
  }
  StateBase2.prototype.hasState = function(element) {
    return element.hasState(this.stateName);
  };
  StateBase2.prototype.setElementState = function(element, enable) {
    element.setState(this.stateName, enable);
  };
  StateBase2.prototype.setState = function() {
    this.setStateEnable(true);
  };
  StateBase2.prototype.clear = function() {
    var view = this.context.view;
    this.clearViewState(view);
  };
  StateBase2.prototype.clearViewState = function(view) {
    var _this = this;
    var elements = getElementsByState(view, this.stateName);
    each$1(elements, function(el) {
      _this.setElementState(el, false);
    });
  };
  return StateBase2;
}(Action);
function getItem(shape) {
  return get(shape.get("delegateObject"), "item");
}
var ElementState = function(_super) {
  __extends$2(ElementState2, _super);
  function ElementState2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.ignoreListItemStates = ["unchecked"];
    return _this;
  }
  ElementState2.prototype.isItemIgnore = function(item, list) {
    var states = this.ignoreListItemStates;
    var filtered = states.filter(function(state2) {
      return list.hasState(item, state2);
    });
    return !!filtered.length;
  };
  ElementState2.prototype.setStateByComponent = function(component2, item, enable) {
    var view = this.context.view;
    var field2 = component2.get("field");
    var elements = getElements(view);
    this.setElementsStateByItem(elements, field2, item, enable);
  };
  ElementState2.prototype.setStateByElement = function(element, enable) {
    this.setElementState(element, enable);
  };
  ElementState2.prototype.isMathItem = function(element, field2, item) {
    var view = this.context.view;
    var scale2 = getScaleByField(view, field2);
    var value2 = getElementValue$1(element, field2);
    return !isNil(value2) && item.name === scale2.getText(value2);
  };
  ElementState2.prototype.setElementsStateByItem = function(elements, field2, item, enable) {
    var _this = this;
    each$1(elements, function(el) {
      if (_this.isMathItem(el, field2, item)) {
        el.setState(_this.stateName, enable);
      }
    });
  };
  ElementState2.prototype.setStateEnable = function(enable) {
    var element = getCurrentElement$1(this.context);
    if (element) {
      if (isElementChange(this.context)) {
        this.setStateByElement(element, enable);
      }
    } else {
      var delegateObject = getDelegationObject(this.context);
      if (isList(delegateObject)) {
        var item = delegateObject.item, component2 = delegateObject.component;
        if (item && component2 && !this.isItemIgnore(item, component2)) {
          var event_1 = this.context.event.gEvent;
          if (event_1 && event_1.fromShape && event_1.toShape && getItem(event_1.fromShape) === getItem(event_1.toShape)) {
            return;
          }
          this.setStateByComponent(component2, item, enable);
        }
      }
    }
  };
  ElementState2.prototype.toggle = function() {
    var element = getCurrentElement$1(this.context);
    if (element) {
      var hasState = element.hasState(this.stateName);
      this.setElementState(element, !hasState);
    }
  };
  ElementState2.prototype.reset = function() {
    this.setStateEnable(false);
  };
  return ElementState2;
}(StateBase);
var ElementActive = function(_super) {
  __extends$2(ElementActive2, _super);
  function ElementActive2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ElementActive2.prototype.active = function() {
    this.setState();
  };
  return ElementActive2;
}(ElementState);
var LinkByColor = function(_super) {
  __extends$2(LinkByColor2, _super);
  function LinkByColor2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.cache = {};
    return _this;
  }
  LinkByColor2.prototype.getColorScale = function(view, element) {
    var colorAttr = element.geometry.getAttribute("color");
    if (!colorAttr) {
      return null;
    }
    var scale2 = view.getScaleByField(colorAttr.getFields()[0]);
    return scale2;
  };
  LinkByColor2.prototype.getLinkPath = function(element, nextElement) {
    var view = this.context.view;
    var isTransposed = view.getCoordinate().isTransposed;
    var bbox = element.shape.getCanvasBBox();
    var nextBBox = nextElement.shape.getCanvasBBox();
    var path2 = isTransposed ? [
      ["M", bbox.minX, bbox.minY],
      ["L", nextBBox.minX, nextBBox.maxY],
      ["L", nextBBox.maxX, nextBBox.maxY],
      ["L", bbox.maxX, bbox.minY],
      ["Z"]
    ] : [
      ["M", bbox.maxX, bbox.minY],
      ["L", nextBBox.minX, nextBBox.minY],
      ["L", nextBBox.minX, nextBBox.maxY],
      ["L", bbox.maxX, bbox.maxY],
      ["Z"]
    ];
    return path2;
  };
  LinkByColor2.prototype.addLinkShape = function(group2, element, nextElement, activeStyle) {
    var style = {
      opacity: 0.4,
      fill: element.shape.attr("fill")
    };
    group2.addShape({
      type: "path",
      attrs: __assign$1(__assign$1({}, deepMix({}, style, isFunction(activeStyle) ? activeStyle(style, element) : activeStyle)), { path: this.getLinkPath(element, nextElement) })
    });
  };
  LinkByColor2.prototype.linkByElement = function(element, activeStyle) {
    var _this = this;
    var view = this.context.view;
    var scale2 = this.getColorScale(view, element);
    if (!scale2) {
      return;
    }
    var value2 = getElementValue$1(element, scale2.field);
    if (!this.cache[value2]) {
      var elements_1 = getElementsByField(view, scale2.field, value2);
      var linkGroup = this.linkGroup;
      var group_1 = linkGroup.addGroup();
      this.cache[value2] = group_1;
      var count_1 = elements_1.length;
      each$1(elements_1, function(el, index2) {
        if (index2 < count_1 - 1) {
          var nextEl = elements_1[index2 + 1];
          _this.addLinkShape(group_1, el, nextEl, activeStyle);
        }
      });
    }
  };
  LinkByColor2.prototype.removeLink = function(element) {
    var scale2 = this.getColorScale(this.context.view, element);
    if (!scale2) {
      return;
    }
    var value2 = getElementValue$1(element, scale2.field);
    if (this.cache[value2]) {
      this.cache[value2].remove();
      this.cache[value2] = null;
    }
  };
  LinkByColor2.prototype.link = function(args) {
    var context = this.context;
    if (!this.linkGroup) {
      this.linkGroup = context.view.foregroundGroup.addGroup({
        id: "link-by-color-group",
        capture: false
      });
    }
    var element = getCurrentElement$1(context);
    if (element) {
      this.linkByElement(element, args === null || args === void 0 ? void 0 : args.style);
    }
  };
  LinkByColor2.prototype.unlink = function() {
    var element = getCurrentElement$1(this.context);
    if (element) {
      this.removeLink(element);
    }
  };
  LinkByColor2.prototype.clear = function() {
    if (this.linkGroup) {
      this.linkGroup.clear();
    }
    this.cache = {};
  };
  LinkByColor2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    if (this.linkGroup) {
      this.linkGroup.remove();
    }
  };
  return LinkByColor2;
}(Action);
var ElementRangeState = function(_super) {
  __extends$2(ElementRangeState2, _super);
  function ElementRangeState2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.startPoint = null;
    _this.endPoint = null;
    _this.isStarted = false;
    _this.effectSiblings = false;
    _this.effectByRecord = false;
    return _this;
  }
  ElementRangeState2.prototype.getCurrentPoint = function() {
    var event = this.context.event;
    return {
      x: event.x,
      y: event.y
    };
  };
  ElementRangeState2.prototype.start = function() {
    this.clear();
    this.startPoint = this.getCurrentPoint();
    this.isStarted = true;
  };
  ElementRangeState2.prototype.getIntersectElements = function() {
    var elements = null;
    if (isMask(this.context)) {
      elements = getMaskedElements(this.context, 10);
    } else {
      var startPoint = this.startPoint;
      var endPoint = this.isStarted ? this.getCurrentPoint() : this.endPoint;
      if (!startPoint || !endPoint) {
        return;
      }
      var box2 = {
        minX: Math.min(startPoint.x, endPoint.x),
        minY: Math.min(startPoint.y, endPoint.y),
        maxX: Math.max(startPoint.x, endPoint.x),
        maxY: Math.max(startPoint.y, endPoint.y)
      };
      var view = this.context.view;
      elements = getIntersectElements(view, box2);
    }
    return elements;
  };
  ElementRangeState2.prototype.setStateEnable = function(enable) {
    if (this.effectSiblings && !this.effectByRecord) {
      this.setSiblingsState(enable);
    } else {
      var allElements = getElements(this.context.view);
      var elements = this.getIntersectElements();
      if (elements && elements.length) {
        if (this.effectByRecord) {
          this.setSiblingsStateByRecord(elements, enable);
        } else {
          this.setElementsState(elements, enable, allElements);
        }
      } else {
        this.clear();
      }
    }
  };
  ElementRangeState2.prototype.setSiblingsStateByRecord = function(elements, enable) {
    var _this = this;
    var view = this.context.view;
    var siblings = getSilbings(view);
    var records = elements.map(function(el) {
      return el.getModel().data;
    });
    var xFiled = view.getXScale().field;
    var yField = view.getYScales()[0].field;
    each$1(siblings, function(sibling) {
      var allElements = getElements(sibling);
      var effectElements = allElements.filter(function(el) {
        var record = el.getModel().data;
        return isInRecords(records, record, xFiled, yField);
      });
      _this.setElementsState(effectElements, enable, allElements);
    });
  };
  ElementRangeState2.prototype.setSiblingsState = function(enable) {
    var _this = this;
    var view = this.context.view;
    var siblings = getSilbings(view);
    if (isMask(this.context)) {
      each$1(siblings, function(sibling) {
        var allElements = getElements(sibling);
        var effectElements = getSiblingMaskElements(_this.context, sibling, 10);
        if (effectElements && effectElements.length) {
          _this.setElementsState(effectElements, enable, allElements);
        } else {
          _this.clearViewState(sibling);
        }
      });
    }
  };
  ElementRangeState2.prototype.setElementsState = function(elements, enable, allElements) {
    var _this = this;
    each$1(allElements, function(el) {
      if (!elements.includes(el)) {
        _this.setElementState(el, false);
      } else {
        _this.setElementState(el, enable);
      }
    });
  };
  ElementRangeState2.prototype.end = function() {
    this.isStarted = false;
    this.endPoint = this.getCurrentPoint();
  };
  ElementRangeState2.prototype.clear = function() {
    var _this = this;
    var view = this.context.view;
    if (this.effectSiblings) {
      var siblings = getSilbings(view);
      each$1(siblings, function(sibling) {
        _this.clearViewState(sibling);
      });
    } else {
      this.clearViewState(view);
    }
  };
  return ElementRangeState2;
}(StateBase);
var ElementRangeActive = function(_super) {
  __extends$2(ElementRangeActive2, _super);
  function ElementRangeActive2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ElementRangeActive2.prototype.active = function() {
    this.setState();
  };
  return ElementRangeActive2;
}(ElementRangeState);
var ElementSingleState = function(_super) {
  __extends$2(ElementSingleState2, _super);
  function ElementSingleState2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ElementSingleState2.prototype.setStateEnable = function(enable) {
    var element = getCurrentElement$1(this.context);
    if (element) {
      if (!isElementChange(this.context)) {
        return;
      }
      if (enable) {
        this.clear();
        this.setElementState(element, true);
      } else if (this.hasState(element)) {
        this.setElementState(element, false);
      }
    }
  };
  ElementSingleState2.prototype.toggle = function() {
    var element = getCurrentElement$1(this.context);
    if (element) {
      var hasState = this.hasState(element);
      if (!hasState) {
        this.clear();
      }
      this.setElementState(element, !hasState);
    }
  };
  ElementSingleState2.prototype.reset = function() {
    this.setStateEnable(false);
  };
  return ElementSingleState2;
}(StateBase);
var ElementSingleActive = function(_super) {
  __extends$2(ElementSingleActive2, _super);
  function ElementSingleActive2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ElementSingleActive2.prototype.active = function() {
    this.setState();
  };
  return ElementSingleActive2;
}(ElementSingleState);
var STATUS_UNACTIVE$3 = "inactive";
var STATUS_ACTIVE$3 = "active";
function clearHighlight$1(view) {
  var elements = getElements(view);
  each$1(elements, function(el) {
    if (el.hasState(STATUS_ACTIVE$3)) {
      el.setState(STATUS_ACTIVE$3, false);
    }
    if (el.hasState(STATUS_UNACTIVE$3)) {
      el.setState(STATUS_UNACTIVE$3, false);
    }
  });
}
function setHighlightBy(elements, callback, enable) {
  each$1(elements, function(el) {
    if (callback(el)) {
      if (el.hasState(STATUS_UNACTIVE$3)) {
        el.setState(STATUS_UNACTIVE$3, false);
      }
      el.setState(STATUS_ACTIVE$3, enable);
    } else {
      if (el.hasState(STATUS_ACTIVE$3)) {
        el.setState(STATUS_ACTIVE$3, false);
      }
      el.setState(STATUS_UNACTIVE$3, enable);
    }
  });
}
var STATUS_UNACTIVE$2 = ELEMENT_STATE.INACTIVE;
var STATUS_ACTIVE$2 = ELEMENT_STATE.ACTIVE;
var ElementHighlight = function(_super) {
  __extends$2(ElementHighlight2, _super);
  function ElementHighlight2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = STATUS_ACTIVE$2;
    return _this;
  }
  ElementHighlight2.prototype.setElementsStateByItem = function(elements, field2, item, enable) {
    var _this = this;
    var callback = function(el) {
      return _this.isMathItem(el, field2, item);
    };
    this.setHighlightBy(elements, callback, enable);
  };
  ElementHighlight2.prototype.setElementHighlight = function(el, callback) {
    if (callback(el)) {
      if (el.hasState(STATUS_UNACTIVE$2)) {
        el.setState(STATUS_UNACTIVE$2, false);
      }
      el.setState(STATUS_ACTIVE$2, true);
    } else if (!el.hasState(STATUS_ACTIVE$2)) {
      el.setState(STATUS_UNACTIVE$2, true);
    }
  };
  ElementHighlight2.prototype.setHighlightBy = function(elements, callback, enable) {
    var _this = this;
    if (enable) {
      each$1(elements, function(el) {
        _this.setElementHighlight(el, callback);
      });
    } else {
      var activeElements = getElementsByState(this.context.view, STATUS_ACTIVE$2);
      var allCancel_1 = true;
      each$1(activeElements, function(el) {
        if (!callback(el)) {
          allCancel_1 = false;
          return false;
        }
      });
      if (allCancel_1) {
        this.clear();
      } else {
        each$1(elements, function(el) {
          if (callback(el)) {
            if (el.hasState(STATUS_ACTIVE$2)) {
              el.setState(STATUS_ACTIVE$2, false);
            }
            el.setState(STATUS_UNACTIVE$2, true);
          }
        });
      }
    }
  };
  ElementHighlight2.prototype.setElementState = function(element, enable) {
    var view = this.context.view;
    var elements = getElements(view);
    this.setHighlightBy(elements, function(el) {
      return element === el;
    }, enable);
  };
  ElementHighlight2.prototype.highlight = function() {
    this.setState();
  };
  ElementHighlight2.prototype.clear = function() {
    var view = this.context.view;
    clearHighlight$1(view);
  };
  return ElementHighlight2;
}(ElementState);
var HighlightColor = function(_super) {
  __extends$2(HighlightColor2, _super);
  function HighlightColor2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HighlightColor2.prototype.setStateByElement = function(element, enable) {
    var view = this.context.view;
    var colorAttr = element.geometry.getAttribute("color");
    if (!colorAttr) {
      return;
    }
    var scale2 = view.getScaleByField(colorAttr.getFields()[0]);
    var value2 = getElementValue$1(element, scale2.field);
    var elements = getElements(view);
    var highlightElements = elements.filter(function(el) {
      return getElementValue$1(el, scale2.field) === value2;
    });
    this.setHighlightBy(elements, function(el) {
      return highlightElements.includes(el);
    }, enable);
  };
  return HighlightColor2;
}(ElementHighlight);
var HighlightX = function(_super) {
  __extends$2(HighlightX2, _super);
  function HighlightX2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HighlightX2.prototype.setElementHighlight = function(el, callback) {
    if (callback(el)) {
      if (el.hasState(STATUS_UNACTIVE$2)) {
        el.setState(STATUS_UNACTIVE$2, false);
      }
      el.setState(STATUS_ACTIVE$2, true);
    } else {
      el.setState(STATUS_UNACTIVE$2, true);
      if (el.hasState(STATUS_ACTIVE$2)) {
        el.setState(STATUS_ACTIVE$2, false);
      }
    }
  };
  HighlightX2.prototype.setStateByElement = function(element, enable) {
    var view = this.context.view;
    var scale2 = view.getXScale();
    var value2 = getElementValue$1(element, scale2.field);
    var elements = getElements(view);
    var highlightElements = elements.filter(function(el) {
      return getElementValue$1(el, scale2.field) === value2;
    });
    this.setHighlightBy(elements, function(el) {
      return highlightElements.includes(el);
    }, enable);
  };
  HighlightX2.prototype.toggle = function() {
    var element = getCurrentElement$1(this.context);
    if (element) {
      var hasState = element.hasState(this.stateName);
      this.setStateByElement(element, !hasState);
    }
  };
  return HighlightX2;
}(ElementHighlight);
var EVENTS$1;
(function(EVENTS2) {
  EVENTS2["BEFORE_HIGHLIGHT"] = "element-range-highlight:beforehighlight";
  EVENTS2["AFTER_HIGHLIGHT"] = "element-range-highlight:afterhighlight";
  EVENTS2["BEFORE_CLEAR"] = "element-range-highlight:beforeclear";
  EVENTS2["AFTER_CLEAR"] = "element-range-highlight:afterclear";
})(EVENTS$1 || (EVENTS$1 = {}));
var ElementRangeHighlight = function(_super) {
  __extends$2(ElementRangeHighlight2, _super);
  function ElementRangeHighlight2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ElementRangeHighlight2.prototype.clearViewState = function(view) {
    clearHighlight$1(view);
  };
  ElementRangeHighlight2.prototype.highlight = function() {
    var _a2 = this.context, view = _a2.view, event = _a2.event;
    var elements = this.getIntersectElements();
    var payload = { view, event, highlightElements: elements };
    view.emit(EVENTS$1.BEFORE_HIGHLIGHT, Event.fromData(view, EVENTS$1.BEFORE_HIGHLIGHT, payload));
    this.setState();
    view.emit(EVENTS$1.AFTER_HIGHLIGHT, Event.fromData(view, EVENTS$1.AFTER_HIGHLIGHT, payload));
  };
  ElementRangeHighlight2.prototype.clear = function() {
    var view = this.context.view;
    view.emit(EVENTS$1.BEFORE_CLEAR, Event.fromData(view, EVENTS$1.BEFORE_CLEAR, {}));
    _super.prototype.clear.call(this);
    view.emit(EVENTS$1.AFTER_CLEAR, Event.fromData(view, EVENTS$1.AFTER_CLEAR, {}));
  };
  ElementRangeHighlight2.prototype.setElementsState = function(elements, enable, allElements) {
    setHighlightBy(allElements, function(el) {
      return elements.indexOf(el) >= 0;
    }, enable);
  };
  return ElementRangeHighlight2;
}(ElementRangeState);
var ElementSingleHighlight = function(_super) {
  __extends$2(ElementSingleHighlight2, _super);
  function ElementSingleHighlight2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ElementSingleHighlight2.prototype.highlight = function() {
    this.setState();
  };
  ElementSingleHighlight2.prototype.setElementState = function(element, enable) {
    var view = this.context.view;
    var elements = getElements(view);
    setHighlightBy(elements, function(el) {
      return element === el;
    }, enable);
  };
  ElementSingleHighlight2.prototype.clear = function() {
    var view = this.context.view;
    clearHighlight$1(view);
  };
  return ElementSingleHighlight2;
}(ElementSingleState);
var ElementRangeSelected = function(_super) {
  __extends$2(ElementRangeSelected2, _super);
  function ElementRangeSelected2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "selected";
    return _this;
  }
  ElementRangeSelected2.prototype.selected = function() {
    this.setState();
  };
  return ElementRangeSelected2;
}(ElementRangeState);
var ElementMultipleSelected = function(_super) {
  __extends$2(ElementMultipleSelected2, _super);
  function ElementMultipleSelected2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "selected";
    return _this;
  }
  ElementMultipleSelected2.prototype.selected = function() {
    this.setState();
  };
  return ElementMultipleSelected2;
}(ElementState);
var ElementSingleSelected = function(_super) {
  __extends$2(ElementSingleSelected2, _super);
  function ElementSingleSelected2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "selected";
    return _this;
  }
  ElementSingleSelected2.prototype.selected = function() {
    this.setState();
  };
  return ElementSingleSelected2;
}(ElementSingleState);
var ListState = function(_super) {
  __extends$2(ListState2, _super);
  function ListState2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "";
    _this.ignoreItemStates = [];
    return _this;
  }
  ListState2.prototype.getTriggerListInfo = function() {
    var delegateObject = getDelegationObject(this.context);
    var info = null;
    if (isList(delegateObject)) {
      info = {
        item: delegateObject.item,
        list: delegateObject.component
      };
    }
    return info;
  };
  ListState2.prototype.getAllowComponents = function() {
    var _this = this;
    var view = this.context.view;
    var components = getComponents(view);
    var rst = [];
    each$1(components, function(component2) {
      if (component2.isList() && _this.allowSetStateByElement(component2)) {
        rst.push(component2);
      }
    });
    return rst;
  };
  ListState2.prototype.hasState = function(list, item) {
    return list.hasState(item, this.stateName);
  };
  ListState2.prototype.clearAllComponentsState = function() {
    var _this = this;
    var components = this.getAllowComponents();
    each$1(components, function(component2) {
      component2.clearItemsState(_this.stateName);
    });
  };
  ListState2.prototype.allowSetStateByElement = function(component2) {
    var field2 = component2.get("field");
    if (!field2) {
      return false;
    }
    if (this.cfg && this.cfg.componentNames) {
      var name_1 = component2.get("name");
      if (this.cfg.componentNames.indexOf(name_1) === -1) {
        return false;
      }
    }
    var view = this.context.view;
    var scale2 = getScaleByField(view, field2);
    return scale2 && scale2.isCategory;
  };
  ListState2.prototype.allowSetStateByItem = function(item, list) {
    var ignoreStates = this.ignoreItemStates;
    if (ignoreStates.length) {
      var filterStates = ignoreStates.filter(function(state2) {
        return list.hasState(item, state2);
      });
      return filterStates.length === 0;
    }
    return true;
  };
  ListState2.prototype.setStateByElement = function(component2, element, enable) {
    var field2 = component2.get("field");
    var view = this.context.view;
    var scale2 = getScaleByField(view, field2);
    var value2 = getElementValue$1(element, field2);
    var text2 = scale2.getText(value2);
    this.setItemsState(component2, text2, enable);
  };
  ListState2.prototype.setStateEnable = function(enable) {
    var _this = this;
    var element = getCurrentElement$1(this.context);
    if (element) {
      var components = this.getAllowComponents();
      each$1(components, function(component3) {
        _this.setStateByElement(component3, element, enable);
      });
    } else {
      var delegateObject = getDelegationObject(this.context);
      if (isList(delegateObject)) {
        var item = delegateObject.item, component2 = delegateObject.component;
        if (this.allowSetStateByElement(component2) && this.allowSetStateByItem(item, component2)) {
          this.setItemState(component2, item, enable);
        }
      }
    }
  };
  ListState2.prototype.setItemsState = function(list, name, enable) {
    var _this = this;
    var items = list.getItems();
    each$1(items, function(item) {
      if (item.name === name) {
        _this.setItemState(list, item, enable);
      }
    });
  };
  ListState2.prototype.setItemState = function(list, item, enable) {
    list.setItemState(item, this.stateName, enable);
  };
  ListState2.prototype.setState = function() {
    this.setStateEnable(true);
  };
  ListState2.prototype.reset = function() {
    this.setStateEnable(false);
  };
  ListState2.prototype.toggle = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo && triggerInfo.item) {
      var list = triggerInfo.list, item = triggerInfo.item;
      var enable = this.hasState(list, item);
      this.setItemState(list, item, !enable);
    }
  };
  ListState2.prototype.clear = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo) {
      triggerInfo.list.clearItemsState(this.stateName);
    } else {
      this.clearAllComponentsState();
    }
  };
  return ListState2;
}(Action);
var ListActive = function(_super) {
  __extends$2(ListActive2, _super);
  function ListActive2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ListActive2.prototype.active = function() {
    this.setState();
  };
  return ListActive2;
}(ListState);
var STATUS_UNACTIVE$1 = "inactive";
var STATUS_ACTIVE$1 = "active";
function clearList(list) {
  var items = list.getItems();
  each$1(items, function(item) {
    if (list.hasState(item, STATUS_ACTIVE$1)) {
      list.setItemState(item, STATUS_ACTIVE$1, false);
    }
    if (list.hasState(item, STATUS_UNACTIVE$1)) {
      list.setItemState(item, STATUS_UNACTIVE$1, false);
    }
  });
}
var STATUS_UNACTIVE = "inactive";
var STATUS_ACTIVE = "active";
var ListHighlight = function(_super) {
  __extends$2(ListHighlight2, _super);
  function ListHighlight2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = STATUS_ACTIVE;
    _this.ignoreItemStates = ["unchecked"];
    return _this;
  }
  ListHighlight2.prototype.setItemsState = function(list, name, enable) {
    this.setHighlightBy(list, function(item) {
      return item.name === name;
    }, enable);
  };
  ListHighlight2.prototype.setItemState = function(list, item, enable) {
    list.getItems();
    this.setHighlightBy(list, function(el) {
      return el === item;
    }, enable);
  };
  ListHighlight2.prototype.setHighlightBy = function(list, callback, enable) {
    var items = list.getItems();
    if (enable) {
      each$1(items, function(item) {
        if (callback(item)) {
          if (list.hasState(item, STATUS_UNACTIVE)) {
            list.setItemState(item, STATUS_UNACTIVE, false);
          }
          list.setItemState(item, STATUS_ACTIVE, true);
        } else if (!list.hasState(item, STATUS_ACTIVE)) {
          list.setItemState(item, STATUS_UNACTIVE, true);
        }
      });
    } else {
      var activeItems = list.getItemsByState(STATUS_ACTIVE);
      var allCancel_1 = true;
      each$1(activeItems, function(item) {
        if (!callback(item)) {
          allCancel_1 = false;
          return false;
        }
      });
      if (allCancel_1) {
        this.clear();
      } else {
        each$1(items, function(item) {
          if (callback(item)) {
            if (list.hasState(item, STATUS_ACTIVE)) {
              list.setItemState(item, STATUS_ACTIVE, false);
            }
            list.setItemState(item, STATUS_UNACTIVE, true);
          }
        });
      }
    }
  };
  ListHighlight2.prototype.highlight = function() {
    this.setState();
  };
  ListHighlight2.prototype.clear = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo) {
      clearList(triggerInfo.list);
    } else {
      var components = this.getAllowComponents();
      each$1(components, function(component2) {
        component2.clearItemsState(STATUS_ACTIVE);
        component2.clearItemsState(STATUS_UNACTIVE);
      });
    }
  };
  return ListHighlight2;
}(ListState);
var ListSelected = function(_super) {
  __extends$2(ListSelected2, _super);
  function ListSelected2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "selected";
    return _this;
  }
  ListSelected2.prototype.selected = function() {
    this.setState();
  };
  return ListSelected2;
}(ListState);
var ListUnchecked = function(_super) {
  __extends$2(ListUnchecked2, _super);
  function ListUnchecked2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "unchecked";
    return _this;
  }
  ListUnchecked2.prototype.unchecked = function() {
    this.setState();
  };
  return ListUnchecked2;
}(ListState);
var STATUS_UNCHECKED = "unchecked";
var STATUS_CHECKED = "checked";
var ListChecked = function(_super) {
  __extends$2(ListChecked2, _super);
  function ListChecked2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = STATUS_CHECKED;
    return _this;
  }
  ListChecked2.prototype.setItemState = function(list, item, enable) {
    this.setCheckedBy(list, function(el) {
      return el === item;
    }, enable);
  };
  ListChecked2.prototype.setCheckedBy = function(list, callback, enable) {
    var items = list.getItems();
    if (enable) {
      each$1(items, function(item) {
        if (callback(item)) {
          if (list.hasState(item, STATUS_UNCHECKED)) {
            list.setItemState(item, STATUS_UNCHECKED, false);
          }
          list.setItemState(item, STATUS_CHECKED, true);
        } else if (!list.hasState(item, STATUS_CHECKED)) {
          list.setItemState(item, STATUS_UNCHECKED, true);
        }
      });
    }
  };
  ListChecked2.prototype.toggle = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo && triggerInfo.item) {
      var list_1 = triggerInfo.list, item = triggerInfo.item;
      var allChecked = !some(list_1.getItems(), function(t) {
        return list_1.hasState(t, STATUS_UNCHECKED);
      });
      if (allChecked || list_1.hasState(item, STATUS_UNCHECKED)) {
        this.setItemState(list_1, item, true);
      } else {
        this.reset();
      }
    }
  };
  ListChecked2.prototype.checked = function() {
    this.setState();
  };
  ListChecked2.prototype.reset = function() {
    var components = this.getAllowComponents();
    each$1(components, function(component2) {
      component2.clearItemsState(STATUS_CHECKED);
      component2.clearItemsState(STATUS_UNCHECKED);
    });
  };
  return ListChecked2;
}(ListState);
var MaskBase = function(_super) {
  __extends$2(MaskBase2, _super);
  function MaskBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.maskShape = null;
    _this.points = [];
    _this.starting = false;
    _this.moving = false;
    _this.preMovePoint = null;
    _this.shapeType = "path";
    return _this;
  }
  MaskBase2.prototype.getCurrentPoint = function() {
    var event = this.context.event;
    return {
      x: event.x,
      y: event.y
    };
  };
  MaskBase2.prototype.emitEvent = function(type) {
    var eventName = "mask:" + type;
    var view = this.context.view;
    var event = this.context.event;
    view.emit(eventName, {
      target: this.maskShape,
      shape: this.maskShape,
      points: this.points,
      x: event.x,
      y: event.y
    });
  };
  MaskBase2.prototype.createMask = function() {
    var view = this.context.view;
    var maskAttrs = this.getMaskAttrs();
    var maskShape = view.foregroundGroup.addShape({
      type: this.shapeType,
      name: "mask",
      draggable: true,
      attrs: __assign$1({ fill: "#C5D4EB", opacity: 0.3 }, maskAttrs)
    });
    return maskShape;
  };
  MaskBase2.prototype.getMaskPath = function() {
    return [];
  };
  MaskBase2.prototype.show = function() {
    if (this.maskShape) {
      this.maskShape.show();
      this.emitEvent("show");
    }
  };
  MaskBase2.prototype.start = function(arg) {
    this.starting = true;
    this.moving = false;
    this.points = [this.getCurrentPoint()];
    if (!this.maskShape) {
      this.maskShape = this.createMask();
      this.maskShape.set("capture", false);
    }
    this.updateMask(arg === null || arg === void 0 ? void 0 : arg.maskStyle);
    this.emitEvent("start");
  };
  MaskBase2.prototype.moveStart = function() {
    this.moving = true;
    this.preMovePoint = this.getCurrentPoint();
  };
  MaskBase2.prototype.move = function() {
    if (!this.moving || !this.maskShape) {
      return;
    }
    var currentPoint = this.getCurrentPoint();
    var preMovePoint = this.preMovePoint;
    var dx = currentPoint.x - preMovePoint.x;
    var dy = currentPoint.y - preMovePoint.y;
    var points = this.points;
    each$1(points, function(point2) {
      point2.x += dx;
      point2.y += dy;
    });
    this.updateMask();
    this.emitEvent("change");
    this.preMovePoint = currentPoint;
  };
  MaskBase2.prototype.updateMask = function(maskStyle) {
    var attrs = deepMix({}, this.getMaskAttrs(), maskStyle);
    this.maskShape.attr(attrs);
  };
  MaskBase2.prototype.moveEnd = function() {
    this.moving = false;
    this.preMovePoint = null;
  };
  MaskBase2.prototype.end = function() {
    this.starting = false;
    this.emitEvent("end");
    if (this.maskShape) {
      this.maskShape.set("capture", true);
    }
  };
  MaskBase2.prototype.hide = function() {
    if (this.maskShape) {
      this.maskShape.hide();
      this.emitEvent("hide");
    }
  };
  MaskBase2.prototype.resize = function() {
    if (this.starting && this.maskShape) {
      this.points.push(this.getCurrentPoint());
      this.updateMask();
      this.emitEvent("change");
    }
  };
  MaskBase2.prototype.destroy = function() {
    this.points = [];
    if (this.maskShape) {
      this.maskShape.remove();
    }
    this.maskShape = null;
    this.preMovePoint = null;
    _super.prototype.destroy.call(this);
  };
  return MaskBase2;
}(Action);
var CircleMask = function(_super) {
  __extends$2(CircleMask2, _super);
  function CircleMask2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.shapeType = "circle";
    return _this;
  }
  CircleMask2.prototype.getMaskAttrs = function() {
    var points = this.points;
    var currentPoint = last(this.points);
    var r = 0;
    var x = 0;
    var y = 0;
    if (points.length) {
      var first = points[0];
      r = distance$2(first, currentPoint) / 2;
      x = (currentPoint.x + first.x) / 2;
      y = (currentPoint.y + first.y) / 2;
    }
    return {
      x,
      y,
      r
    };
  };
  return CircleMask2;
}(MaskBase);
var RectMask = function(_super) {
  __extends$2(RectMask2, _super);
  function RectMask2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.shapeType = "rect";
    return _this;
  }
  RectMask2.prototype.getRegion = function() {
    var points = this.points;
    return {
      start: head(points),
      end: last(points)
    };
  };
  RectMask2.prototype.getMaskAttrs = function() {
    var _a2 = this.getRegion(), start = _a2.start, end = _a2.end;
    var x = Math.min(start.x, end.x);
    var y = Math.min(start.y, end.y);
    var width = Math.abs(end.x - start.x);
    var height = Math.abs(end.y - start.y);
    return {
      x,
      y,
      width,
      height
    };
  };
  return RectMask2;
}(MaskBase);
function clampPoint(point2) {
  point2.x = clamp(point2.x, 0, 1);
  point2.y = clamp(point2.y, 0, 1);
}
var DimRect = function(_super) {
  __extends$2(DimRect2, _super);
  function DimRect2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.dim = "x";
    _this.inPlot = true;
    return _this;
  }
  DimRect2.prototype.getRegion = function() {
    var start = null;
    var end = null;
    var points = this.points;
    var dim = this.dim;
    var coord2 = this.context.view.getCoordinate();
    var normalStart = coord2.invert(head(points));
    var normalEnd = coord2.invert(last(points));
    if (this.inPlot) {
      clampPoint(normalStart);
      clampPoint(normalEnd);
    }
    if (dim === "x") {
      start = coord2.convert({
        x: normalStart.x,
        y: 0
      });
      end = coord2.convert({
        x: normalEnd.x,
        y: 1
      });
    } else {
      start = coord2.convert({
        x: 0,
        y: normalStart.y
      });
      end = coord2.convert({
        x: 1,
        y: normalEnd.y
      });
    }
    return {
      start,
      end
    };
  };
  return DimRect2;
}(RectMask);
var PathMask = function(_super) {
  __extends$2(PathMask2, _super);
  function PathMask2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PathMask2.prototype.getMaskPath = function() {
    var points = this.points;
    var path2 = [];
    if (points.length) {
      each$1(points, function(point2, index2) {
        if (index2 === 0) {
          path2.push(["M", point2.x, point2.y]);
        } else {
          path2.push(["L", point2.x, point2.y]);
        }
      });
      path2.push(["L", points[0].x, points[0].y]);
    }
    return path2;
  };
  PathMask2.prototype.getMaskAttrs = function() {
    return {
      path: this.getMaskPath()
    };
  };
  PathMask2.prototype.addPoint = function() {
    this.resize();
  };
  return PathMask2;
}(MaskBase);
var SmoothPathMask = function(_super) {
  __extends$2(SmoothPathMask2, _super);
  function SmoothPathMask2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SmoothPathMask2.prototype.getMaskPath = function() {
    var points = this.points;
    return getSpline(points, true);
  };
  return SmoothPathMask2;
}(PathMask);
var CursorAction = function(_super) {
  __extends$2(CursorAction2, _super);
  function CursorAction2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CursorAction2.prototype.setCursor = function(cursor) {
    var view = this.context.view;
    view.getCanvas().setCursor(cursor);
  };
  CursorAction2.prototype.default = function() {
    this.setCursor("default");
  };
  CursorAction2.prototype.pointer = function() {
    this.setCursor("pointer");
  };
  CursorAction2.prototype.move = function() {
    this.setCursor("move");
  };
  CursorAction2.prototype.crosshair = function() {
    this.setCursor("crosshair");
  };
  CursorAction2.prototype.wait = function() {
    this.setCursor("wait");
  };
  CursorAction2.prototype.help = function() {
    this.setCursor("help");
  };
  CursorAction2.prototype.text = function() {
    this.setCursor("text");
  };
  CursorAction2.prototype.eResize = function() {
    this.setCursor("e-resize");
  };
  CursorAction2.prototype.wResize = function() {
    this.setCursor("w-resize");
  };
  CursorAction2.prototype.nResize = function() {
    this.setCursor("n-resize");
  };
  CursorAction2.prototype.sResize = function() {
    this.setCursor("s-resize");
  };
  CursorAction2.prototype.neResize = function() {
    this.setCursor("ne-resize");
  };
  CursorAction2.prototype.nwResize = function() {
    this.setCursor("nw-resize");
  };
  CursorAction2.prototype.seResize = function() {
    this.setCursor("se-resize");
  };
  CursorAction2.prototype.swResize = function() {
    this.setCursor("sw-resize");
  };
  CursorAction2.prototype.nsResize = function() {
    this.setCursor("ns-resize");
  };
  CursorAction2.prototype.ewResize = function() {
    this.setCursor("ew-resize");
  };
  return CursorAction2;
}(Action);
var DataFilter = function(_super) {
  __extends$2(DataFilter2, _super);
  function DataFilter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataFilter2.prototype.filterView = function(view, field2, filter2) {
    var _this = this;
    if (view.getScaleByField(field2)) {
      view.filter(field2, filter2);
    }
    if (view.views && view.views.length) {
      each$1(view.views, function(subView) {
        _this.filterView(subView, field2, filter2);
      });
    }
  };
  DataFilter2.prototype.filter = function() {
    var delegateObject = getDelegationObject(this.context);
    if (delegateObject) {
      var view = this.context.view;
      var component2 = delegateObject.component;
      var field2 = component2.get("field");
      if (isList(delegateObject)) {
        if (field2) {
          var unCheckedItems = component2.getItemsByState("unchecked");
          var scale_1 = getScaleByField(view, field2);
          var names_1 = unCheckedItems.map(function(item) {
            return item.name;
          });
          if (names_1.length) {
            this.filterView(view, field2, function(value2) {
              var text2 = scale_1.getText(value2);
              return !names_1.includes(text2);
            });
          } else {
            this.filterView(view, field2, null);
          }
          view.render(true);
        }
      } else if (isSlider(delegateObject)) {
        var range = component2.getValue();
        var min_1 = range[0], max_1 = range[1];
        this.filterView(view, field2, function(value2) {
          return value2 >= min_1 && value2 <= max_1;
        });
        view.render(true);
      }
    }
  };
  return DataFilter2;
}(Action);
function getFilter(scale2, dim, point1, point2) {
  var min2 = Math.min(point1[dim], point2[dim]);
  var max2 = Math.max(point1[dim], point2[dim]);
  var _a2 = scale2.range, rangeMin = _a2[0], rangeMax = _a2[1];
  if (min2 < rangeMin) {
    min2 = rangeMin;
  }
  if (max2 > rangeMax) {
    max2 = rangeMax;
  }
  if (min2 === rangeMax && max2 === rangeMax) {
    return null;
  }
  var minValue = scale2.invert(min2);
  var maxValue = scale2.invert(max2);
  if (scale2.isCategory) {
    var minIndex = scale2.values.indexOf(minValue);
    var maxIndex = scale2.values.indexOf(maxValue);
    var arr_1 = scale2.values.slice(minIndex, maxIndex + 1);
    return function(value2) {
      return arr_1.includes(value2);
    };
  } else {
    return function(value2) {
      return value2 >= minValue && value2 <= maxValue;
    };
  }
}
var EVENTS;
(function(EVENTS2) {
  EVENTS2["FILTER"] = "brush-filter-processing";
  EVENTS2["RESET"] = "brush-filter-reset";
  EVENTS2["BEFORE_FILTER"] = "brush-filter:beforefilter";
  EVENTS2["AFTER_FILTER"] = "brush-filter:afterfilter";
  EVENTS2["BEFORE_RESET"] = "brush-filter:beforereset";
  EVENTS2["AFTER_RESET"] = "brush-filter:afterreset";
})(EVENTS || (EVENTS = {}));
var RangeFilter = function(_super) {
  __extends$2(RangeFilter2, _super);
  function RangeFilter2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.dims = ["x", "y"];
    _this.startPoint = null;
    _this.isStarted = false;
    return _this;
  }
  RangeFilter2.prototype.hasDim = function(dim) {
    return this.dims.includes(dim);
  };
  RangeFilter2.prototype.start = function() {
    var context = this.context;
    this.isStarted = true;
    this.startPoint = context.getCurrentPoint();
  };
  RangeFilter2.prototype.filter = function() {
    var startPoint;
    var currentPoint;
    if (isMask(this.context)) {
      var maskShape = this.context.event.target;
      var bbox = maskShape.getCanvasBBox();
      startPoint = { x: bbox.x, y: bbox.y };
      currentPoint = { x: bbox.maxX, y: bbox.maxY };
    } else {
      if (!this.isStarted) {
        return;
      }
      startPoint = this.startPoint;
      currentPoint = this.context.getCurrentPoint();
    }
    if (Math.abs(startPoint.x - currentPoint.x) < 5 || Math.abs(startPoint.x - currentPoint.y) < 5) {
      return;
    }
    var _a2 = this.context, view = _a2.view, event = _a2.event;
    var payload = { view, event, dims: this.dims };
    view.emit(EVENTS.BEFORE_FILTER, Event.fromData(view, EVENTS.BEFORE_FILTER, payload));
    var coord2 = view.getCoordinate();
    var normalCurrent = coord2.invert(currentPoint);
    var normalStart = coord2.invert(startPoint);
    if (this.hasDim("x")) {
      var xScale = view.getXScale();
      var filter2 = getFilter(xScale, "x", normalCurrent, normalStart);
      this.filterView(view, xScale.field, filter2);
    }
    if (this.hasDim("y")) {
      var yScale = view.getYScales()[0];
      var filter2 = getFilter(yScale, "y", normalCurrent, normalStart);
      this.filterView(view, yScale.field, filter2);
    }
    this.reRender(view, { source: EVENTS.FILTER });
    view.emit(EVENTS.AFTER_FILTER, Event.fromData(view, EVENTS.AFTER_FILTER, payload));
  };
  RangeFilter2.prototype.end = function() {
    this.isStarted = false;
  };
  RangeFilter2.prototype.reset = function() {
    var view = this.context.view;
    view.emit(EVENTS.BEFORE_RESET, Event.fromData(view, EVENTS.BEFORE_RESET, {}));
    this.isStarted = false;
    if (this.hasDim("x")) {
      var xScale = view.getXScale();
      this.filterView(view, xScale.field, null);
    }
    if (this.hasDim("y")) {
      var yScale = view.getYScales()[0];
      this.filterView(view, yScale.field, null);
    }
    this.reRender(view, { source: EVENTS.RESET });
    view.emit(EVENTS.AFTER_RESET, Event.fromData(view, EVENTS.AFTER_RESET, {}));
  };
  RangeFilter2.prototype.filterView = function(view, field2, filter2) {
    view.filter(field2, filter2);
  };
  RangeFilter2.prototype.reRender = function(view, payload) {
    view.render(true, payload);
  };
  return RangeFilter2;
}(Action);
var SiblingFilter$1 = function(_super) {
  __extends$2(SiblingFilter2, _super);
  function SiblingFilter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SiblingFilter2.prototype.filterView = function(view, field2, filter2) {
    var siblings = getSilbings(view);
    each$1(siblings, function(sibling) {
      sibling.filter(field2, filter2);
    });
  };
  SiblingFilter2.prototype.reRender = function(view) {
    var siblings = getSilbings(view);
    each$1(siblings, function(sibling) {
      sibling.render(true);
    });
  };
  return SiblingFilter2;
}(RangeFilter);
var ElementFilter = function(_super) {
  __extends$2(ElementFilter2, _super);
  function ElementFilter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ElementFilter2.prototype.filter = function() {
    var delegateObject = getDelegationObject(this.context);
    var view = this.context.view;
    var elements = getElements(view);
    if (isMask(this.context)) {
      var maskElements_1 = getMaskedElements(this.context, 10);
      if (maskElements_1) {
        each$1(elements, function(el) {
          if (maskElements_1.includes(el)) {
            el.show();
          } else {
            el.hide();
          }
        });
      }
    } else if (delegateObject) {
      var component2 = delegateObject.component;
      var field_1 = component2.get("field");
      if (isList(delegateObject)) {
        if (field_1) {
          var unCheckedItems = component2.getItemsByState("unchecked");
          var scale_1 = getScaleByField(view, field_1);
          var names_1 = unCheckedItems.map(function(item) {
            return item.name;
          });
          each$1(elements, function(el) {
            var value2 = getElementValue$1(el, field_1);
            var text2 = scale_1.getText(value2);
            if (names_1.indexOf(text2) >= 0) {
              el.hide();
            } else {
              el.show();
            }
          });
        }
      } else if (isSlider(delegateObject)) {
        var range = component2.getValue();
        var min_1 = range[0], max_1 = range[1];
        each$1(elements, function(el) {
          var value2 = getElementValue$1(el, field_1);
          if (value2 >= min_1 && value2 <= max_1) {
            el.show();
          } else {
            el.hide();
          }
        });
      }
    }
  };
  ElementFilter2.prototype.clear = function() {
    var elements = getElements(this.context.view);
    each$1(elements, function(el) {
      el.show();
    });
  };
  ElementFilter2.prototype.reset = function() {
    this.clear();
  };
  return ElementFilter2;
}(Action);
var SiblingFilter = function(_super) {
  __extends$2(SiblingFilter2, _super);
  function SiblingFilter2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.byRecord = false;
    return _this;
  }
  SiblingFilter2.prototype.filter = function() {
    if (isMask(this.context)) {
      if (this.byRecord) {
        this.filterByRecord();
      } else {
        this.filterByBBox();
      }
    }
  };
  SiblingFilter2.prototype.filterByRecord = function() {
    var view = this.context.view;
    var maskElements = getMaskedElements(this.context, 10);
    if (!maskElements) {
      return;
    }
    var xFiled = view.getXScale().field;
    var yField = view.getYScales()[0].field;
    var records = maskElements.map(function(el) {
      return el.getModel().data;
    });
    var siblings = getSilbings(view);
    each$1(siblings, function(sibling) {
      var elements = getElements(sibling);
      each$1(elements, function(el) {
        var record = el.getModel().data;
        if (isInRecords(records, record, xFiled, yField)) {
          el.show();
        } else {
          el.hide();
        }
      });
    });
  };
  SiblingFilter2.prototype.filterByBBox = function() {
    var _this = this;
    var view = this.context.view;
    var siblings = getSilbings(view);
    each$1(siblings, function(sibling) {
      var maskElements = getSiblingMaskElements(_this.context, sibling, 10);
      var elements = getElements(sibling);
      if (maskElements) {
        each$1(elements, function(el) {
          if (maskElements.includes(el)) {
            el.show();
          } else {
            el.hide();
          }
        });
      }
    });
  };
  SiblingFilter2.prototype.reset = function() {
    var siblings = getSilbings(this.context.view);
    each$1(siblings, function(sibling) {
      var elements = getElements(sibling);
      each$1(elements, function(el) {
        el.show();
      });
    });
  };
  return SiblingFilter2;
}(Action);
var PADDING_RIGHT$1 = 10;
var PADDING_TOP$2 = 5;
var ButtonAction$1 = function(_super) {
  __extends$2(ButtonAction2, _super);
  function ButtonAction2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.buttonGroup = null;
    _this.buttonCfg = {
      name: "button",
      text: "button",
      textStyle: {
        x: 0,
        y: 0,
        fontSize: 12,
        fill: "#333333",
        cursor: "pointer"
      },
      padding: [8, 10],
      style: {
        fill: "#f7f7f7",
        stroke: "#cccccc",
        cursor: "pointer"
      },
      activeStyle: {
        fill: "#e6e6e6"
      }
    };
    return _this;
  }
  ButtonAction2.prototype.getButtonCfg = function() {
    return deepMix(this.buttonCfg, this.cfg);
  };
  ButtonAction2.prototype.drawButton = function() {
    var config = this.getButtonCfg();
    var group2 = this.context.view.foregroundGroup.addGroup({
      name: config.name
    });
    var textShape = group2.addShape({
      type: "text",
      name: "button-text",
      attrs: __assign$1({ text: config.text }, config.textStyle)
    });
    var textBBox = textShape.getBBox();
    var padding2 = parsePadding(config.padding);
    var buttonShape = group2.addShape({
      type: "rect",
      name: "button-rect",
      attrs: __assign$1({ x: textBBox.x - padding2[3], y: textBBox.y - padding2[0], width: textBBox.width + padding2[1] + padding2[3], height: textBBox.height + padding2[0] + padding2[2] }, config.style)
    });
    buttonShape.toBack();
    group2.on("mouseenter", function() {
      buttonShape.attr(config.activeStyle);
    });
    group2.on("mouseleave", function() {
      buttonShape.attr(config.style);
    });
    this.buttonGroup = group2;
  };
  ButtonAction2.prototype.resetPosition = function() {
    var view = this.context.view;
    var coord2 = view.getCoordinate();
    var point2 = coord2.convert({ x: 1, y: 1 });
    var buttonGroup = this.buttonGroup;
    var bbox = buttonGroup.getBBox();
    var matrix = transform$7(null, [
      ["t", point2.x - bbox.width - PADDING_RIGHT$1, point2.y + bbox.height + PADDING_TOP$2]
    ]);
    buttonGroup.setMatrix(matrix);
  };
  ButtonAction2.prototype.show = function() {
    if (!this.buttonGroup) {
      this.drawButton();
    }
    this.resetPosition();
    this.buttonGroup.show();
  };
  ButtonAction2.prototype.hide = function() {
    if (this.buttonGroup) {
      this.buttonGroup.hide();
    }
  };
  ButtonAction2.prototype.destroy = function() {
    var buttonGroup = this.buttonGroup;
    if (buttonGroup) {
      buttonGroup.remove();
    }
    _super.prototype.destroy.call(this);
  };
  return ButtonAction2;
}(Action);
var DISTANCE = 4;
var Drag = function(_super) {
  __extends$2(Drag2, _super);
  function Drag2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.starting = false;
    _this.dragStart = false;
    return _this;
  }
  Drag2.prototype.start = function() {
    this.starting = true;
    this.startPoint = this.context.getCurrentPoint();
  };
  Drag2.prototype.drag = function() {
    if (!this.startPoint) {
      return;
    }
    var current = this.context.getCurrentPoint();
    var view = this.context.view;
    var event = this.context.event;
    if (!this.dragStart) {
      if (distance$2(current, this.startPoint) > DISTANCE) {
        view.emit("dragstart", {
          target: event.target,
          x: event.x,
          y: event.y
        });
        this.dragStart = true;
      }
    } else {
      view.emit("drag", {
        target: event.target,
        x: event.x,
        y: event.y
      });
    }
  };
  Drag2.prototype.end = function() {
    if (this.dragStart) {
      var view = this.context.view;
      var event_1 = this.context.event;
      view.emit("dragend", {
        target: event_1.target,
        x: event_1.x,
        y: event_1.y
      });
    }
    this.starting = false;
    this.dragStart = false;
  };
  return Drag2;
}(Action);
var MIN_DISTANCE = 5;
var Move = function(_super) {
  __extends$2(Move2, _super);
  function Move2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.starting = false;
    _this.isMoving = false;
    _this.startPoint = null;
    _this.startMatrix = null;
    return _this;
  }
  Move2.prototype.start = function() {
    this.starting = true;
    this.startPoint = this.context.getCurrentPoint();
    this.startMatrix = this.context.view.middleGroup.getMatrix();
  };
  Move2.prototype.move = function() {
    if (!this.starting) {
      return;
    }
    var startPoint = this.startPoint;
    var currentPoint = this.context.getCurrentPoint();
    var d = distance$2(startPoint, currentPoint);
    if (d > MIN_DISTANCE && !this.isMoving) {
      this.isMoving = true;
    }
    if (this.isMoving) {
      var view = this.context.view;
      var matrix = transform$7(this.startMatrix, [
        ["t", currentPoint.x - startPoint.x, currentPoint.y - startPoint.y]
      ]);
      view.backgroundGroup.setMatrix(matrix);
      view.foregroundGroup.setMatrix(matrix);
      view.middleGroup.setMatrix(matrix);
    }
  };
  Move2.prototype.end = function() {
    if (this.isMoving) {
      this.isMoving = false;
    }
    this.startMatrix = null;
    this.starting = false;
    this.startPoint = null;
  };
  Move2.prototype.reset = function() {
    this.starting = false;
    this.startPoint = null;
    this.isMoving = false;
    var view = this.context.view;
    view.backgroundGroup.resetMatrix();
    view.foregroundGroup.resetMatrix();
    view.middleGroup.resetMatrix();
    this.isMoving = false;
  };
  return Move2;
}(Action);
var DIM_X = "x";
var DIM_Y = "y";
var ScaleTranslate$2 = function(_super) {
  __extends$2(ScaleTranslate2, _super);
  function ScaleTranslate2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.dims = [DIM_X, DIM_Y];
    _this.cfgFields = ["dims"];
    _this.cacheScaleDefs = {};
    return _this;
  }
  ScaleTranslate2.prototype.hasDim = function(dim) {
    return this.dims.includes(dim);
  };
  ScaleTranslate2.prototype.getScale = function(dim) {
    var view = this.context.view;
    if (dim === "x") {
      return view.getXScale();
    } else {
      return view.getYScales()[0];
    }
  };
  ScaleTranslate2.prototype.resetDim = function(dim) {
    var view = this.context.view;
    if (this.hasDim(dim) && this.cacheScaleDefs[dim]) {
      var scale2 = this.getScale(dim);
      view.scale(scale2.field, this.cacheScaleDefs[dim]);
      this.cacheScaleDefs[dim] = null;
    }
  };
  ScaleTranslate2.prototype.reset = function() {
    this.resetDim(DIM_X);
    this.resetDim(DIM_Y);
    var view = this.context.view;
    view.render(true);
  };
  return ScaleTranslate2;
}(Action);
var ScaleTranslate$1 = function(_super) {
  __extends$2(ScaleTranslate2, _super);
  function ScaleTranslate2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.startPoint = null;
    _this.starting = false;
    _this.startCache = {};
    return _this;
  }
  ScaleTranslate2.prototype.start = function() {
    var _this = this;
    this.startPoint = this.context.getCurrentPoint();
    this.starting = true;
    var dims = this.dims;
    each$1(dims, function(dim) {
      var scale2 = _this.getScale(dim);
      var min2 = scale2.min, max2 = scale2.max, values2 = scale2.values;
      _this.startCache[dim] = { min: min2, max: max2, values: values2 };
    });
  };
  ScaleTranslate2.prototype.end = function() {
    this.startPoint = null;
    this.starting = false;
    this.startCache = {};
  };
  ScaleTranslate2.prototype.translate = function() {
    var _this = this;
    if (!this.starting) {
      return;
    }
    var startPoint = this.startPoint;
    var coord2 = this.context.view.getCoordinate();
    var currentPoint = this.context.getCurrentPoint();
    var normalStart = coord2.invert(startPoint);
    var noramlCurrent = coord2.invert(currentPoint);
    var dx = noramlCurrent.x - normalStart.x;
    var dy = noramlCurrent.y - normalStart.y;
    var view = this.context.view;
    var dims = this.dims;
    each$1(dims, function(dim) {
      _this.translateDim(dim, { x: dx * -1, y: dy * -1 });
    });
    view.render(true);
  };
  ScaleTranslate2.prototype.translateDim = function(dim, normalPoint) {
    if (this.hasDim(dim)) {
      var scale2 = this.getScale(dim);
      if (scale2.isLinear) {
        this.translateLinear(dim, scale2, normalPoint);
      }
    }
  };
  ScaleTranslate2.prototype.translateLinear = function(dim, scale2, normalPoint) {
    var view = this.context.view;
    var _a2 = this.startCache[dim], min2 = _a2.min, max2 = _a2.max;
    var range = max2 - min2;
    var d = normalPoint[dim] * range;
    if (!this.cacheScaleDefs[dim]) {
      this.cacheScaleDefs[dim] = {
        nice: scale2.nice,
        min: min2,
        max: max2
      };
    }
    view.scale(scale2.field, {
      nice: false,
      min: min2 + d,
      max: max2 + d
    });
  };
  ScaleTranslate2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.startPoint = null;
    this.starting = false;
  };
  return ScaleTranslate2;
}(ScaleTranslate$2);
var ScaleTranslate = function(_super) {
  __extends$2(ScaleTranslate2, _super);
  function ScaleTranslate2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.zoomRatio = 0.05;
    return _this;
  }
  ScaleTranslate2.prototype.zoomIn = function() {
    this.zoom(this.zoomRatio);
  };
  ScaleTranslate2.prototype.zoom = function(scale2) {
    var _this = this;
    var dims = this.dims;
    each$1(dims, function(dim) {
      _this.zoomDim(dim, scale2);
    });
    this.context.view.render(true);
  };
  ScaleTranslate2.prototype.zoomOut = function() {
    this.zoom(-1 * this.zoomRatio);
  };
  ScaleTranslate2.prototype.zoomDim = function(dim, dRatio) {
    if (this.hasDim(dim)) {
      var scale2 = this.getScale(dim);
      if (scale2.isLinear) {
        this.zoomLinear(dim, scale2, dRatio);
      }
    }
  };
  ScaleTranslate2.prototype.zoomLinear = function(dim, scale2, dRatio) {
    var view = this.context.view;
    if (!this.cacheScaleDefs[dim]) {
      this.cacheScaleDefs[dim] = {
        nice: scale2.nice,
        min: scale2.min,
        max: scale2.max
      };
    }
    var scaleDef = this.cacheScaleDefs[dim];
    var range = scaleDef.max - scaleDef.min;
    var min2 = scale2.min, max2 = scale2.max;
    var d = dRatio * range;
    var toMin = min2 - d;
    var toMax = max2 + d;
    var curRange = toMax - toMin;
    var scaled = curRange / range;
    if (toMax > toMin && scaled < 100 && scaled > 0.01) {
      view.scale(scale2.field, {
        nice: false,
        min: min2 - d,
        max: max2 + d
      });
    }
  };
  return ScaleTranslate2;
}(ScaleTranslate$2);
function isWheelDown$1(event) {
  var wheelEvent = event.gEvent.originalEvent;
  return wheelEvent.deltaY > 0;
}
var DEFAULT_WHEELDELTA = 1;
var MousewheelScroll = function(_super) {
  __extends$2(MousewheelScroll2, _super);
  function MousewheelScroll2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MousewheelScroll2.prototype.scroll = function(arg) {
    var _a2 = this.context, view = _a2.view, event = _a2.event;
    if (!view.getOptions().scrollbar) {
      return;
    }
    var wheelDelta = (arg === null || arg === void 0 ? void 0 : arg.wheelDelta) || DEFAULT_WHEELDELTA;
    var scrollbarController = view.getController("scrollbar");
    var xScale = view.getXScale();
    var data2 = view.getOptions().data;
    var dataSize = size(valuesOfKey(data2, xScale.field));
    var step = size(xScale.values);
    var currentRatio = scrollbarController.getValue();
    var currentStart = Math.floor((dataSize - step) * currentRatio);
    var nextStart = currentStart + (isWheelDown$1(event) ? wheelDelta : -wheelDelta);
    var correction = wheelDelta / (dataSize - step) / 1e4;
    var nextRatio = clamp(nextStart / (dataSize - step) + correction, 0, 1);
    scrollbarController.setValue(nextRatio);
  };
  return MousewheelScroll2;
}(Action);
registerTheme("dark", createThemeByStyleSheet(antvDark));
registerEngine("canvas", CanvasEngine);
registerEngine("svg", SVGEngine);
registerGeometry("Polygon", Polygon);
registerGeometry("Interval", Interval);
registerGeometry("Schema", Schema);
registerGeometry("Path", Path);
registerGeometry("Point", Point);
registerGeometry("Line", Line$1);
registerGeometry("Area", Area$1);
registerGeometry("Edge", Edge);
registerGeometry("Heatmap", Heatmap);
registerGeometry("Violin", Violin);
registerGeometryLabel("base", GeometryLabel);
registerGeometryLabel("interval", IntervalLabel);
registerGeometryLabel("pie", PieLabel);
registerGeometryLabel("polar", PolarLabel);
registerGeometryLabelLayout("overlap", overlap);
registerGeometryLabelLayout("distribute", distribute);
registerGeometryLabelLayout("fixed-overlap", fixedOverlap);
registerGeometryLabelLayout("hide-overlap", hideOverlap);
registerGeometryLabelLayout("limit-in-shape", limitInShape);
registerGeometryLabelLayout("limit-in-canvas", limitInCanvas);
registerGeometryLabelLayout("limit-in-plot", limitInPlot$3);
registerGeometryLabelLayout("pie-outer", pieOuterLabelLayout);
registerGeometryLabelLayout("adjust-color", adjustColor);
registerGeometryLabelLayout("interval-adjust-position", intervalAdjustPosition);
registerGeometryLabelLayout("interval-hide-overlap", intervalHideOverlap);
registerGeometryLabelLayout("point-adjust-position", pointAdjustPosition);
registerGeometryLabelLayout("pie-spider", pieSpiderLabelLayout);
registerGeometryLabelLayout("path-adjust-position", pathAdjustPosition);
registerAnimation("fade-in", fadeIn);
registerAnimation("fade-out", fadeOut);
registerAnimation("grow-in-x", growInX);
registerAnimation("grow-in-xy", growInXY);
registerAnimation("grow-in-y", growInY);
registerAnimation("scale-in-x", scaleInX);
registerAnimation("scale-in-y", scaleInY);
registerAnimation("wave-in", waveIn);
registerAnimation("zoom-in", zoomIn);
registerAnimation("zoom-out", zoomOut);
registerAnimation("position-update", positionUpdate);
registerAnimation("sector-path-update", sectorPathUpdate);
registerAnimation("path-in", pathIn);
registerFacet("rect", Rect);
registerFacet("mirror", Mirror);
registerFacet("list", List);
registerFacet("matrix", Matrix);
registerFacet("circle", Circle);
registerFacet("tree", Tree);
registerComponentController("axis", Axis);
registerComponentController("legend", Legend);
registerComponentController("tooltip", Tooltip);
registerComponentController("annotation", Annotation);
registerComponentController("slider", Slider);
registerComponentController("scrollbar", Scrollbar);
registerAction("tooltip", TooltipAction);
registerAction("sibling-tooltip", SiblingTooltip);
registerAction("ellipsis-text", EllipsisText);
registerAction("element-active", ElementActive);
registerAction("element-single-active", ElementSingleActive);
registerAction("element-range-active", ElementRangeActive);
registerAction("element-highlight", ElementHighlight);
registerAction("element-highlight-by-x", HighlightX);
registerAction("element-highlight-by-color", HighlightColor);
registerAction("element-single-highlight", ElementSingleHighlight);
registerAction("element-range-highlight", ElementRangeHighlight);
registerAction("element-sibling-highlight", ElementRangeHighlight, {
  effectSiblings: true,
  effectByRecord: true
});
registerAction("element-selected", ElementMultipleSelected);
registerAction("element-single-selected", ElementSingleSelected);
registerAction("element-range-selected", ElementRangeSelected);
registerAction("element-link-by-color", LinkByColor);
registerAction("active-region", ActiveRegion);
registerAction("list-active", ListActive);
registerAction("list-selected", ListSelected);
registerAction("list-highlight", ListHighlight);
registerAction("list-unchecked", ListUnchecked);
registerAction("list-checked", ListChecked);
registerAction("legend-item-highlight", ListHighlight, {
  componentNames: ["legend"]
});
registerAction("axis-label-highlight", ListHighlight, {
  componentNames: ["axis"]
});
registerAction("rect-mask", RectMask);
registerAction("x-rect-mask", DimRect, { dim: "x" });
registerAction("y-rect-mask", DimRect, { dim: "y" });
registerAction("circle-mask", CircleMask);
registerAction("path-mask", PathMask);
registerAction("smooth-path-mask", SmoothPathMask);
registerAction("cursor", CursorAction);
registerAction("data-filter", DataFilter);
registerAction("brush", RangeFilter);
registerAction("brush-x", RangeFilter, { dims: ["x"] });
registerAction("brush-y", RangeFilter, { dims: ["y"] });
registerAction("sibling-filter", SiblingFilter$1);
registerAction("sibling-x-filter", SiblingFilter$1);
registerAction("sibling-y-filter", SiblingFilter$1);
registerAction("element-filter", ElementFilter);
registerAction("element-sibling-filter", SiblingFilter);
registerAction("element-sibling-filter-record", SiblingFilter, { byRecord: true });
registerAction("view-drag", Drag);
registerAction("view-move", Move);
registerAction("scale-translate", ScaleTranslate$1);
registerAction("scale-zoom", ScaleTranslate);
registerAction("reset-button", ButtonAction$1, {
  name: "reset-button",
  text: "reset"
});
registerAction("mousewheel-scroll", MousewheelScroll);
function isPointInView$1(context) {
  return context.isInPlot();
}
registerInteraction("tooltip", {
  start: [
    { trigger: "plot:mousemove", action: "tooltip:show", throttle: { wait: 50, leading: true, trailing: false } },
    { trigger: "plot:touchmove", action: "tooltip:show", throttle: { wait: 50, leading: true, trailing: false } }
  ],
  end: [
    { trigger: "plot:mouseleave", action: "tooltip:hide" },
    { trigger: "plot:leave", action: "tooltip:hide" },
    { trigger: "plot:touchend", action: "tooltip:hide" }
  ]
});
registerInteraction("ellipsis-text", {
  start: [
    {
      trigger: "legend-item-name:mousemove",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    },
    {
      trigger: "legend-item-name:touchstart",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    },
    {
      trigger: "axis-label:mousemove",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    },
    {
      trigger: "axis-label:touchstart",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    }
  ],
  end: [
    { trigger: "legend-item-name:mouseleave", action: "ellipsis-text:hide" },
    { trigger: "legend-item-name:touchend", action: "ellipsis-text:hide" },
    { trigger: "axis-label:mouseleave", action: "ellipsis-text:hide" },
    { trigger: "axis-label:touchend", action: "ellipsis-text:hide" }
  ]
});
registerInteraction("element-active", {
  start: [{ trigger: "element:mouseenter", action: "element-active:active" }],
  end: [{ trigger: "element:mouseleave", action: "element-active:reset" }]
});
registerInteraction("element-selected", {
  start: [{ trigger: "element:click", action: "element-selected:toggle" }]
});
registerInteraction("element-highlight", {
  start: [{ trigger: "element:mouseenter", action: "element-highlight:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "element-highlight:reset" }]
});
registerInteraction("element-highlight-by-x", {
  start: [{ trigger: "element:mouseenter", action: "element-highlight-by-x:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "element-highlight-by-x:reset" }]
});
registerInteraction("element-highlight-by-color", {
  start: [{ trigger: "element:mouseenter", action: "element-highlight-by-color:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "element-highlight-by-color:reset" }]
});
registerInteraction("legend-active", {
  start: [{ trigger: "legend-item:mouseenter", action: ["list-active:active", "element-active:active"] }],
  end: [{ trigger: "legend-item:mouseleave", action: ["list-active:reset", "element-active:reset"] }]
});
registerInteraction("legend-highlight", {
  start: [
    { trigger: "legend-item:mouseenter", action: ["legend-item-highlight:highlight", "element-highlight:highlight"] }
  ],
  end: [{ trigger: "legend-item:mouseleave", action: ["legend-item-highlight:reset", "element-highlight:reset"] }]
});
registerInteraction("axis-label-highlight", {
  start: [
    { trigger: "axis-label:mouseenter", action: ["axis-label-highlight:highlight", "element-highlight:highlight"] }
  ],
  end: [{ trigger: "axis-label:mouseleave", action: ["axis-label-highlight:reset", "element-highlight:reset"] }]
});
registerInteraction("element-list-highlight", {
  start: [{ trigger: "element:mouseenter", action: ["list-highlight:highlight", "element-highlight:highlight"] }],
  end: [{ trigger: "element:mouseleave", action: ["list-highlight:reset", "element-highlight:reset"] }]
});
registerInteraction("element-range-highlight", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "mask:mouseenter", action: "cursor:move" },
    { trigger: "plot:mouseleave", action: "cursor:default" },
    { trigger: "mask:mouseleave", action: "cursor:crosshair" }
  ],
  start: [
    {
      trigger: "plot:mousedown",
      isEnable: function(context) {
        return !context.isInShape("mask");
      },
      action: ["rect-mask:start", "rect-mask:show"]
    },
    {
      trigger: "mask:dragstart",
      action: ["rect-mask:moveStart"]
    }
  ],
  processing: [
    {
      trigger: "plot:mousemove",
      action: ["rect-mask:resize"]
    },
    {
      trigger: "mask:drag",
      action: ["rect-mask:move"]
    },
    {
      trigger: "mask:change",
      action: ["element-range-highlight:highlight"]
    }
  ],
  end: [
    { trigger: "plot:mouseup", action: ["rect-mask:end"] },
    { trigger: "mask:dragend", action: ["rect-mask:moveEnd"] },
    {
      trigger: "document:mouseup",
      isEnable: function(context) {
        return !context.isInPlot();
      },
      action: ["element-range-highlight:clear", "rect-mask:end", "rect-mask:hide"]
    }
  ],
  rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", "rect-mask:hide"] }]
});
registerInteraction("brush", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    {
      trigger: "mousedown",
      isEnable: isPointInView$1,
      action: ["brush:start", "rect-mask:start", "rect-mask:show"]
    }
  ],
  processing: [
    {
      trigger: "mousemove",
      isEnable: isPointInView$1,
      action: ["rect-mask:resize"]
    }
  ],
  end: [
    {
      trigger: "mouseup",
      isEnable: isPointInView$1,
      action: ["brush:filter", "brush:end", "rect-mask:end", "rect-mask:hide", "reset-button:show"]
    }
  ],
  rollback: [{ trigger: "reset-button:click", action: ["brush:reset", "reset-button:hide", "cursor:crosshair"] }]
});
registerInteraction("brush-visible", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    {
      trigger: "plot:mousedown",
      action: ["rect-mask:start", "rect-mask:show"]
    }
  ],
  processing: [
    {
      trigger: "plot:mousemove",
      action: ["rect-mask:resize"]
    },
    { trigger: "mask:change", action: ["element-range-highlight:highlight"] }
  ],
  end: [
    {
      trigger: "plot:mouseup",
      action: ["rect-mask:end", "rect-mask:hide", "element-filter:filter", "element-range-highlight:clear"]
    }
  ],
  rollback: [
    {
      trigger: "dblclick",
      action: ["element-filter:clear"]
    }
  ]
});
registerInteraction("brush-x", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    {
      trigger: "mousedown",
      isEnable: isPointInView$1,
      action: ["brush-x:start", "x-rect-mask:start", "x-rect-mask:show"]
    }
  ],
  processing: [
    {
      trigger: "mousemove",
      isEnable: isPointInView$1,
      action: ["x-rect-mask:resize"]
    }
  ],
  end: [
    {
      trigger: "mouseup",
      isEnable: isPointInView$1,
      action: ["brush-x:filter", "brush-x:end", "x-rect-mask:end", "x-rect-mask:hide"]
    }
  ],
  rollback: [{ trigger: "dblclick", action: ["brush-x:reset"] }]
});
registerInteraction("element-path-highlight", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    { trigger: "mousedown", isEnable: isPointInView$1, action: "path-mask:start" },
    { trigger: "mousedown", isEnable: isPointInView$1, action: "path-mask:show" }
  ],
  processing: [{ trigger: "mousemove", action: "path-mask:addPoint" }],
  end: [{ trigger: "mouseup", action: "path-mask:end" }],
  rollback: [{ trigger: "dblclick", action: "path-mask:hide" }]
});
registerInteraction("element-single-selected", {
  start: [{ trigger: "element:click", action: "element-single-selected:toggle" }]
});
registerInteraction("legend-filter", {
  showEnable: [
    { trigger: "legend-item:mouseenter", action: "cursor:pointer" },
    { trigger: "legend-item:mouseleave", action: "cursor:default" }
  ],
  start: [{ trigger: "legend-item:click", action: ["list-unchecked:toggle", "data-filter:filter"] }]
});
registerInteraction("continuous-filter", {
  start: [{ trigger: "legend:valuechanged", action: "data-filter:filter" }]
});
registerInteraction("continuous-visible-filter", {
  start: [{ trigger: "legend:valuechanged", action: "element-filter:filter" }]
});
registerInteraction("legend-visible-filter", {
  showEnable: [
    { trigger: "legend-item:mouseenter", action: "cursor:pointer" },
    { trigger: "legend-item:mouseleave", action: "cursor:default" }
  ],
  start: [{ trigger: "legend-item:click", action: ["list-unchecked:toggle", "element-filter:filter"] }]
});
registerInteraction("active-region", {
  start: [{ trigger: "plot:mousemove", action: "active-region:show" }],
  end: [{ trigger: "plot:mouseleave", action: "active-region:hide" }]
});
function isWheelDown(event) {
  event.gEvent.preventDefault();
  return event.gEvent.originalEvent.deltaY > 0;
}
registerInteraction("view-zoom", {
  start: [
    {
      trigger: "plot:mousewheel",
      isEnable: function(context) {
        return isWheelDown(context.event);
      },
      action: "scale-zoom:zoomOut",
      throttle: { wait: 100, leading: true, trailing: false }
    },
    {
      trigger: "plot:mousewheel",
      isEnable: function(context) {
        return !isWheelDown(context.event);
      },
      action: "scale-zoom:zoomIn",
      throttle: { wait: 100, leading: true, trailing: false }
    }
  ]
});
registerInteraction("sibling-tooltip", {
  start: [{ trigger: "plot:mousemove", action: "sibling-tooltip:show" }],
  end: [{ trigger: "plot:mouseleave", action: "sibling-tooltip:hide" }]
});
registerInteraction("plot-mousewheel-scroll", {
  start: [{ trigger: "plot:mousewheel", action: "mousewheel-scroll:scroll" }]
});
function flow() {
  var flows = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    flows[_i] = arguments[_i];
  }
  return function(param) {
    return flows.reduce(function(result, f) {
      return f(result);
    }, param);
  };
}
function pick(obj, keys2) {
  var r = {};
  if (obj !== null && typeof obj === "object") {
    keys2.forEach(function(key) {
      var v = obj[key];
      if (v !== void 0) {
        r[key] = v;
      }
    });
  }
  return r;
}
function template(source, data2) {
  if (!data2) {
    return source;
  }
  return reduce(data2, function(r, v, k) {
    return r.replace(new RegExp("{\\s*" + k + "\\s*}", "g"), v);
  }, source);
}
var LEVEL;
(function(LEVEL2) {
  LEVEL2["ERROR"] = "error";
  LEVEL2["WARN"] = "warn";
  LEVEL2["INFO"] = "log";
})(LEVEL || (LEVEL = {}));
var BRAND = "AntV/G2Plot";
function getMessage(format) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var argIndex = 0;
  return BRAND + ": " + format.replace(/%s/g, function() {
    return "" + args[argIndex++];
  });
}
function log(level, condition, format) {
  var args = [];
  for (var _i = 3; _i < arguments.length; _i++) {
    args[_i - 3] = arguments[_i];
  }
  if (!condition) {
    console[level](getMessage.apply(void 0, __spreadArrays([format], args)));
  }
}
function getContainerSize(ele) {
  if (!ele) {
    return { width: 0, height: 0 };
  }
  var style = getComputedStyle(ele);
  return {
    width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
    height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
  };
}
function findGeometry(view, type) {
  return view.geometries.find(function(g) {
    return g.type === type;
  });
}
function getAllElements(view) {
  return reduce(view.geometries, function(r, geometry2) {
    return r.concat(geometry2.elements);
  }, []);
}
function getAllElementsRecursively(view) {
  if (get(view, ["views", "length"], 0) <= 0) {
    return getAllElements(view);
  }
  return reduce(view.views, function(ele, subView) {
    return ele.concat(getAllElementsRecursively(subView));
  }, getAllElements(view));
}
function getAllGeometriesRecursively(view) {
  if (get(view, ["views", "length"], 0) <= 0) {
    return view.geometries;
  }
  return reduce(view.views, function(ele, subView) {
    return ele.concat(subView.geometries);
  }, view.geometries);
}
function findViewById(chart, id) {
  return chart.views.find(function(view) {
    return view.id === id;
  });
}
function getViews(view) {
  var parent = view.parent;
  return parent ? parent.views : [];
}
function getSiblingViews(view) {
  return getViews(view).filter(function(sub2) {
    return sub2 !== view;
  });
}
function transformLabel(labelOptions) {
  if (!isType$1(labelOptions, "Object")) {
    return labelOptions;
  }
  var label2 = __assign$1({}, labelOptions);
  if (label2.formatter && !label2.content) {
    label2.content = label2.formatter;
  }
  return label2;
}
function points2Path(points, isInCircle) {
  var path2 = [];
  if (points.length) {
    path2.push(["M", points[0].x, points[0].y]);
    for (var i = 1, length_1 = points.length; i < length_1; i += 1) {
      var item = points[i];
      path2.push(["L", item.x, item.y]);
    }
    if (isInCircle) {
      path2.push(["Z"]);
    }
  }
  return path2;
}
var smoothBezier = function(points, smooth, isLoop, constraint) {
  var cps = [];
  var prevPoint;
  var nextPoint;
  var hasConstraint = !!constraint;
  var min2;
  var max2;
  if (hasConstraint) {
    min2 = [Infinity, Infinity];
    max2 = [-Infinity, -Infinity];
    for (var i = 0, l = points.length; i < l; i++) {
      var point2 = points[i];
      min2 = min$2([0, 0], min2, point2);
      max2 = max$2([0, 0], max2, point2);
    }
    min2 = min$2([0, 0], min2, constraint[0]);
    max2 = max$2([0, 0], max2, constraint[1]);
  }
  for (var i = 0, len = points.length; i < len; i++) {
    var point2 = points[i];
    if (isLoop) {
      prevPoint = points[i ? i - 1 : len - 1];
      nextPoint = points[(i + 1) % len];
    } else {
      if (i === 0 || i === len - 1) {
        cps.push(point2);
        continue;
      } else {
        prevPoint = points[i - 1];
        nextPoint = points[i + 1];
      }
    }
    var v = [0, 0];
    v = sub(v, nextPoint, prevPoint);
    v = scale$2(v, v, smooth);
    var d0 = distance$6(point2, prevPoint);
    var d1 = distance$6(point2, nextPoint);
    var sum = d0 + d1;
    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }
    var v1 = scale$2([0, 0], v, -d0);
    var v2 = scale$2([0, 0], v, d1);
    var cp0 = add([0, 0], point2, v1);
    var cp1 = add([0, 0], point2, v2);
    if (hasConstraint) {
      cp0 = max$2([0, 0], cp0, min2);
      cp0 = min$2([0, 0], cp0, max2);
      cp1 = max$2([0, 0], cp1, min2);
      cp1 = min$2([0, 0], cp1, max2);
    }
    cps.push(cp0);
    cps.push(cp1);
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
};
function catmullRom2bezier(crp, z, constraint) {
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len - 1; i++) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len];
    cp2 = controlPointList[len + 1];
    p = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  return d1;
}
function getSplinePath(points, isInCircle, constaint) {
  var data2 = [];
  var first = points[0];
  var prePoint = null;
  if (points.length <= 2) {
    return points2Path(points, isInCircle);
  }
  for (var i = 0, len = points.length; i < len; i++) {
    var point2 = points[i];
    if (!prePoint || !(prePoint.x === point2.x && prePoint.y === point2.y)) {
      data2.push(point2.x);
      data2.push(point2.y);
      prePoint = point2;
    }
  }
  var constraint = constaint || [
    [0, 0],
    [1, 1]
  ];
  var splinePath2 = catmullRom2bezier(data2, isInCircle, constraint);
  splinePath2.unshift(["M", first.x, first.y]);
  return splinePath2;
}
var MAX_MIX_LEVEL = 5;
var toString = {}.toString;
var isType = function(value2, type) {
  return toString.call(value2) === "[object " + type + "]";
};
var isArray = function(value2) {
  return isType(value2, "Array");
};
var isObjectLike = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var isPlainObject = function(value2) {
  if (!isObjectLike(value2) || !isType(value2, "Object")) {
    return false;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
var deep = function(dist, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (Object.prototype.hasOwnProperty.call(src, key)) {
      var value2 = src[key];
      if (!value2) {
        dist[key] = value2;
      } else {
        if (isPlainObject(value2)) {
          if (!isPlainObject(dist[key])) {
            dist[key] = {};
          }
          if (level < maxLevel) {
            deep(dist[key], value2, level + 1, maxLevel);
          } else {
            dist[key] = src[key];
          }
        } else if (isArray(value2)) {
          dist[key] = [];
          dist[key] = dist[key].concat(value2);
        } else {
          dist[key] = value2;
        }
      }
    }
  }
};
var deepAssign = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    deep(rst, args[i]);
  }
  return rst;
};
function kebabCase(word) {
  if (!word) {
    return word;
  }
  var result = word.match(/(([A-Z]{0,1}[a-z]*[^A-Z])|([A-Z]{1}))/g);
  return result.map(function(s) {
    return s.toLowerCase();
  }).join("-");
}
function adapteStyle(style) {
  var styleObject = {
    overflow: "hidden",
    "white-space": "nowrap",
    "text-overflow": "ellipsis",
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  };
  var shapeStyleKeys = [
    "stroke",
    "lineWidth",
    "shadowColor",
    "strokeOpacity",
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY",
    "fill"
  ];
  if (get(style, "fill")) {
    styleObject["color"] = style["fill"];
  }
  var _a2 = pick(style, shapeStyleKeys), shadowColor = _a2.shadowColor, _b = _a2.shadowBlur, shadowBlur = _b === void 0 ? 0 : _b, _c = _a2.shadowOffsetX, shadowOffsetX = _c === void 0 ? 0 : _c, _d = _a2.shadowOffsetY, shadowOffsetY = _d === void 0 ? 0 : _d;
  styleObject["text-shadow"] = "" + [shadowColor, shadowOffsetX + "px", shadowOffsetY + "px", shadowBlur + "px"].join(" ");
  var _e = pick(style, shapeStyleKeys), stroke = _e.stroke, _f = _e.lineWidth, lineWidth = _f === void 0 ? 0 : _f;
  styleObject["-webkit-text-stroke"] = "" + [lineWidth + "px", stroke].join(" ");
  each$1(style, function(v, k) {
    if (["fontSize"].includes(k) && isNumber$1(v)) {
      styleObject[kebabCase(k)] = v + "px";
    } else if (k && !shapeStyleKeys.includes(k)) {
      styleObject[kebabCase(k)] = "" + v;
    }
  });
  return styleObject;
}
function setStatisticContainerStyle(container, style) {
  container.style["pointer-events"] = "none";
  each$1(style, function(v, k) {
    if (k && v) {
      container.style[k] = v;
    }
  });
}
var renderStatistic = function(chart, options, datum) {
  var statistic2 = options.statistic, plotType = options.plotType;
  var titleOpt = statistic2.title, contentOpt = statistic2.content;
  [titleOpt, contentOpt].forEach(function(option, idx) {
    if (!option) {
      return;
    }
    var transform2 = "";
    if (idx === 0) {
      transform2 = contentOpt ? "translate(-50%, -100%)" : "translate(-50%, -50%)";
    } else {
      transform2 = titleOpt ? "translate(-50%, 0)" : "translate(-50%, -50%)";
    }
    var style = isFunction(option.style) ? option.style(datum) : option.style;
    chart.annotation().html(__assign$1({
      position: ["50%", "50%"],
      html: function(container, view) {
        var coordinate2 = view.getCoordinate();
        var containerW = 0;
        if (plotType === "pie" || plotType === "ring-progress") {
          containerW = coordinate2.getRadius() * coordinate2.innerRadius * 2;
        } else if (plotType === "liquid") {
          var liquidShape = get(view.geometries, [0, "elements", 0, "shape"]);
          if (liquidShape) {
            var path2 = liquidShape.find(function(t) {
              return t.get("name") === "wrap";
            });
            var width = path2.getCanvasBBox().width;
            containerW = width;
          }
        } else if (!containerW) {
          containerW = coordinate2.getWidth();
        }
        setStatisticContainerStyle(container, __assign$1({ width: containerW + "px", transform: transform2 }, adapteStyle(style)));
        var filteredData = view.getData();
        if (option.customHtml) {
          return option.customHtml(container, view, datum, filteredData);
        }
        var text2 = option.content;
        if (option.formatter) {
          text2 = option.formatter(datum, filteredData);
        }
        return text2 ? isString(text2) ? text2 : "" + text2 : "<div></div>";
      },
      key: (idx === 0 ? "top" : "bottom") + "-statistic"
    }, pick(option, ["offsetX", "offsetY", "rotate", "style", "formatter"])));
  });
};
var renderGaugeStatistic = function(chart, options, datum) {
  var statistic2 = options.statistic;
  var titleOpt = statistic2.title, contentOpt = statistic2.content;
  [titleOpt, contentOpt].forEach(function(option) {
    if (!option) {
      return;
    }
    var style = isFunction(option.style) ? option.style(datum) : option.style;
    chart.annotation().html(__assign$1({ position: ["50%", "100%"], html: function(container, view) {
      var coordinate2 = view.getCoordinate();
      var polarCoord = view.views[0].getCoordinate();
      var polarCenter = polarCoord.getCenter();
      var polarRadius = polarCoord.getRadius();
      var polarMaxY = Math.max(Math.sin(polarCoord.startAngle), Math.sin(polarCoord.endAngle)) * polarRadius;
      var offsetY = polarCenter.y + polarMaxY - coordinate2.y.start - parseFloat(get(style, "fontSize", 0));
      var containerWidth = coordinate2.getRadius() * coordinate2.innerRadius * 2;
      setStatisticContainerStyle(container, __assign$1({ width: containerWidth + "px", transform: "translate(-50%, " + offsetY + "px)" }, adapteStyle(style)));
      var filteredData = view.getData();
      if (option.customHtml) {
        return option.customHtml(container, view, datum, filteredData);
      }
      var text2 = option.content;
      if (option.formatter) {
        text2 = option.formatter(datum, filteredData);
      }
      return text2 ? isString(text2) ? text2 : "" + text2 : "<div></div>";
    } }, pick(option, ["offsetX", "offsetY", "rotate", "style", "formatter"])));
  });
};
var ctx;
function getCanvasContext() {
  if (!ctx) {
    ctx = document.createElement("canvas").getContext("2d");
  }
  return ctx;
}
var measureTextWidth = memoize(function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, _a2 = font.fontFamily, fontFamily = _a2 === void 0 ? "sans-serif" : _a2, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  var ctx2 = getCanvasContext();
  ctx2.font = [fontStyle, fontWeight, fontVariant, fontSize + "px", fontFamily].join(" ");
  var metrics = ctx2.measureText(isString(text2) ? text2 : "");
  return metrics.width;
}, function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text2], values(font)).join("");
});
function isRealNumber(v) {
  return typeof v === "number" && !isNaN(v);
}
function isBetween(value2, start, end) {
  var min2 = Math.min(start, end);
  var max2 = Math.max(start, end);
  return value2 >= min2 && value2 <= max2;
}
function adjustYMetaByZero(data2, field2) {
  var numberData = data2.filter(function(datum) {
    var v = get(datum, [field2]);
    return isNumber$1(v) && !isNaN(v);
  });
  var gtZero = numberData.every(function(datum) {
    return get(datum, [field2]) >= 0;
  });
  var ltZero = numberData.every(function(datum) {
    return get(datum, [field2]) <= 0;
  });
  if (gtZero) {
    return { min: 0 };
  }
  if (ltZero) {
    return { max: 0 };
  }
  return {};
}
function transformDataToNodeLinkData(data2, sourceField, targetField, weightField, rawFields) {
  if (rawFields === void 0) {
    rawFields = [];
  }
  if (!Array.isArray(data2)) {
    return {
      nodes: [],
      links: []
    };
  }
  var links = [];
  var nodesMap = {};
  var nodesIndex = -1;
  data2.forEach(function(datum) {
    var source = datum[sourceField];
    var target = datum[targetField];
    var weight = datum[weightField];
    var rawData = pick(datum, rawFields);
    if (!nodesMap[source]) {
      nodesMap[source] = __assign$1({ id: ++nodesIndex, name: source }, rawData);
    }
    if (!nodesMap[target]) {
      nodesMap[target] = __assign$1({ id: ++nodesIndex, name: target }, rawData);
    }
    links.push(__assign$1({
      source: nodesMap[source].id,
      target: nodesMap[target].id,
      value: weight
    }, rawData));
  });
  return {
    nodes: Object.values(nodesMap).sort(function(a, b) {
      return a.id - b.id;
    }),
    links
  };
}
function processIllegalData(data2, field2) {
  var processData2 = filter(data2, function(d) {
    var v = d[field2];
    return v === null || typeof v === "number" && !isNaN(v);
  });
  log(LEVEL.WARN, processData2.length === data2.length, "illegal data existed in chart data.");
  return processData2;
}
function normalPadding(padding2) {
  if (isNumber$1(padding2)) {
    return [padding2, padding2, padding2, padding2];
  }
  if (isArray$1(padding2)) {
    var length_1 = padding2.length;
    if (length_1 === 1) {
      return [padding2[0], padding2[0], padding2[0], padding2[0]];
    }
    if (length_1 === 2) {
      return [padding2[0], padding2[1], padding2[0], padding2[1]];
    }
    if (length_1 === 3) {
      return [padding2[0], padding2[1], padding2[2], padding2[1]];
    }
    if (length_1 === 4) {
      return padding2;
    }
  }
  return [0, 0, 0, 0];
}
function getAdjustAppendPadding(padding2, position, append) {
  if (position === void 0) {
    position = "bottom";
  }
  if (append === void 0) {
    append = 25;
  }
  var currentAppendPadding = normalPadding(padding2);
  var PADDING2 = [
    position.startsWith("top") ? append : 0,
    position.startsWith("right") ? append : 0,
    position.startsWith("bottom") ? append : 0,
    position.startsWith("left") ? append : 0
  ];
  return [
    currentAppendPadding[0] + PADDING2[0],
    currentAppendPadding[1] + PADDING2[1],
    currentAppendPadding[2] + PADDING2[2],
    currentAppendPadding[3] + PADDING2[3]
  ];
}
function resolveAllPadding(paddings) {
  var normalPaddings = paddings.map(function(item) {
    return normalPadding(item);
  });
  var finalPadding = [0, 0, 0, 0];
  if (normalPaddings.length > 0) {
    finalPadding = finalPadding.map(function(item, index2) {
      normalPaddings.forEach(function(d, i) {
        item += normalPaddings[i][index2];
      });
      return item;
    });
  }
  return finalPadding;
}
var GLOBAL = {
  locale: "en-US"
};
var LocaleMap = {};
function registerLocale(locale, localeObj) {
  LocaleMap[locale] = localeObj;
}
function getLocale(locale) {
  return {
    get: function(key, obj) {
      return template(get(LocaleMap[locale], key) || get(LocaleMap[GLOBAL.locale], key) || get(LocaleMap["en-US"], key) || key, obj);
    }
  };
}
var EN_US_LOCALE = {
  locale: "en-US",
  general: {
    increase: "Increase",
    decrease: "Decrease",
    root: "Root"
  },
  statistic: {
    total: "Total"
  },
  conversionTag: {
    label: "Rate"
  },
  legend: {},
  tooltip: {},
  slider: {},
  scrollbar: {},
  waterfall: {
    total: "Total"
  }
};
var ZH_CN_LOCALE = {
  locale: "zh-CN",
  general: {
    increase: "\u589E\u52A0",
    decrease: "\u51CF\u5C11",
    root: "\u521D\u59CB"
  },
  statistic: {
    total: "\u603B\u8BA1"
  },
  conversionTag: {
    label: "\u8F6C\u5316\u7387"
  },
  legend: {},
  tooltip: {},
  slider: {},
  scrollbar: {},
  waterfall: {
    total: "\u603B\u8BA1"
  }
};
var SOURCE_ATTRIBUTE_NAME = "data-chart-source-type";
var PLOT_CONTAINER_OPTIONS = [
  "padding",
  "appendPadding",
  "renderer",
  "pixelRatio",
  "syncViewPadding",
  "supportCSSTransform",
  "limitInPlot"
];
var Plot = function(_super) {
  __extends$2(Plot2, _super);
  function Plot2(container, options) {
    var _this = _super.call(this) || this;
    _this.container = typeof container === "string" ? document.getElementById(container) : container;
    _this.options = deepAssign({}, _this.getDefaultOptions(), options);
    _this.createG2();
    _this.bindEvents();
    return _this;
  }
  Plot2.getDefaultOptions = function() {
    return {
      renderer: "canvas",
      xAxis: {
        nice: true,
        label: {
          autoRotate: false,
          autoHide: { type: "equidistance", cfg: { minGap: 6 } }
        }
      },
      yAxis: {
        nice: true,
        label: {
          autoHide: true,
          autoRotate: false
        }
      },
      animation: true
    };
  };
  Plot2.prototype.createG2 = function() {
    var _a2 = this.options, width = _a2.width, height = _a2.height, defaultInteractions = _a2.defaultInteractions;
    this.chart = new Chart(__assign$1(__assign$1(__assign$1(__assign$1({ container: this.container, autoFit: false }, this.getChartSize(width, height)), { localRefresh: false }), pick(this.options, PLOT_CONTAINER_OPTIONS)), { defaultInteractions }));
    this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, "G2Plot");
  };
  Plot2.prototype.getChartSize = function(width, height) {
    var chartSize = getContainerSize(this.container);
    return { width: width || chartSize.width || 400, height: height || chartSize.height || 400 };
  };
  Plot2.prototype.bindEvents = function() {
    var _this = this;
    if (this.chart) {
      this.chart.on("*", function(e) {
        if (e === null || e === void 0 ? void 0 : e.type) {
          _this.emit(e.type, e);
        }
      });
    }
  };
  Plot2.prototype.getDefaultOptions = function() {
    return Plot2.getDefaultOptions();
  };
  Plot2.prototype.render = function() {
    this.chart.clear();
    this.chart.options = {
      data: [],
      animate: true
    };
    this.chart.views = [];
    this.execAdaptor();
    this.chart.render();
    this.bindSizeSensor();
  };
  Plot2.prototype.update = function(options) {
    this.updateOption(options);
    this.render();
  };
  Plot2.prototype.updateOption = function(options) {
    this.options = deepAssign({}, this.options, options);
  };
  Plot2.prototype.setState = function(type, condition, status) {
    if (status === void 0) {
      status = true;
    }
    var elements = getAllElementsRecursively(this.chart);
    each$1(elements, function(ele) {
      if (condition(ele.getData())) {
        ele.setState(type, status);
      }
    });
  };
  Plot2.prototype.getStates = function() {
    var elements = getAllElementsRecursively(this.chart);
    var stateObjects = [];
    each$1(elements, function(element) {
      var data2 = element.getData();
      var states = element.getStates();
      each$1(states, function(state2) {
        stateObjects.push({ data: data2, state: state2, geometry: element.geometry, element });
      });
    });
    return stateObjects;
  };
  Plot2.prototype.changeData = function(data2) {
    this.update({ data: data2 });
  };
  Plot2.prototype.changeSize = function(width, height) {
    this.chart.changeSize(width, height);
  };
  Plot2.prototype.addAnnotations = function(annotations) {
    var incoming = __spreadArrays(annotations);
    var controller = this.chart.getController("annotation");
    var current = controller.getComponents().map(function(co) {
      return co.extra;
    });
    controller.clear(true);
    var _loop_1 = function(i2) {
      var annotation2 = current[i2];
      var findIndex2 = incoming.findIndex(function(item) {
        return item.id && item.id === annotation2.id;
      });
      if (findIndex2 !== -1) {
        annotation2 = deepAssign({}, annotation2, incoming[findIndex2]);
        incoming.splice(findIndex2, 1);
      }
      controller.annotation(annotation2);
    };
    for (var i = 0; i < current.length; i++) {
      _loop_1(i);
    }
    incoming.forEach(function(annotation2) {
      return controller.annotation(annotation2);
    });
    this.chart.render(true);
  };
  Plot2.prototype.removeAnnotations = function(annotations) {
    var controller = this.chart.getController("annotation");
    var current = controller.getComponents().map(function(co) {
      return co.extra;
    });
    controller.clear(true);
    var _loop_2 = function(i2) {
      var annotation2 = current[i2];
      if (!annotations.find(function(item) {
        return item.id && item.id === annotation2.id;
      })) {
        controller.annotation(annotation2);
      }
    };
    for (var i = 0; i < current.length; i++) {
      _loop_2(i);
    }
    this.chart.render(true);
  };
  Plot2.prototype.destroy = function() {
    this.unbindSizeSensor();
    this.chart.destroy();
    this.off();
    this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);
  };
  Plot2.prototype.execAdaptor = function() {
    var adaptor2 = this.getSchemaAdaptor();
    var _a2 = this.options, padding2 = _a2.padding, appendPadding = _a2.appendPadding;
    this.chart.padding = padding2;
    this.chart.appendPadding = appendPadding;
    adaptor2({
      chart: this.chart,
      options: this.options
    });
  };
  Plot2.prototype.triggerResize = function() {
    this.chart.forceFit();
  };
  Plot2.prototype.bindSizeSensor = function() {
    var _this = this;
    if (this.unbind) {
      return;
    }
    var _a2 = this.options.autoFit, autoFit = _a2 === void 0 ? true : _a2;
    if (autoFit) {
      this.unbind = bind_1(this.container, function() {
        var _a3 = getContainerSize(_this.container), width = _a3.width, height = _a3.height;
        if (width !== _this.chart.width || height !== _this.chart.height) {
          _this.triggerResize();
        }
      });
    }
  };
  Plot2.prototype.unbindSizeSensor = function() {
    if (this.unbind) {
      this.unbind();
      this.unbind = void 0;
    }
  };
  return Plot2;
}(EventEmitter);
var AXIS_META_CONFIG_KEYS = [
  "type",
  "alias",
  "tickCount",
  "tickInterval",
  "min",
  "max",
  "nice",
  "minLimit",
  "maxLimit",
  "range",
  "tickMethod",
  "base",
  "exponent",
  "mask",
  "sync"
];
function getPixelRatio() {
  return typeof window === "object" ? window === null || window === void 0 ? void 0 : window.devicePixelRatio : 2;
}
function initCanvas(width, height) {
  if (height === void 0) {
    height = width;
  }
  var canvas = document.createElement("canvas");
  var pixelRatio = getPixelRatio();
  canvas.width = width * pixelRatio;
  canvas.height = height * pixelRatio;
  canvas.style.width = width + "px";
  canvas.style.height = height + "px";
  var ctx2 = canvas.getContext("2d");
  ctx2.scale(pixelRatio, pixelRatio);
  return canvas;
}
function drawBackground(context, cfg, width, height) {
  if (height === void 0) {
    height = width;
  }
  var backgroundColor = cfg.backgroundColor, opacity = cfg.opacity;
  context.globalAlpha = opacity;
  context.fillStyle = backgroundColor;
  context.beginPath();
  context.fillRect(0, 0, width, height);
  context.closePath();
}
function getUnitPatternSize(size2, padding2, isStagger) {
  var unitSize = size2 + padding2;
  return isStagger ? unitSize * 2 : unitSize;
}
function getSymbolsPosition(unitSize, isStagger) {
  var symbolsPos = isStagger ? [
    [unitSize * (1 / 4), unitSize * (1 / 4)],
    [unitSize * (3 / 4), unitSize * (3 / 4)]
  ] : [[unitSize * (1 / 2), unitSize * (1 / 2)]];
  return symbolsPos;
}
function transformMatrix(dpr, rotation) {
  var radian = rotation * Math.PI / 180;
  var matrix = {
    a: Math.cos(radian) * (1 / dpr),
    b: Math.sin(radian) * (1 / dpr),
    c: -Math.sin(radian) * (1 / dpr),
    d: Math.cos(radian) * (1 / dpr),
    e: 0,
    f: 0
  };
  return matrix;
}
var defaultDotPatternCfg = {
  size: 6,
  padding: 2,
  backgroundColor: "transparent",
  opacity: 1,
  rotation: 0,
  fill: "#fff",
  fillOpacity: 0.5,
  stroke: "transparent",
  lineWidth: 0,
  isStagger: true
};
function drawDot(context, cfg, x, y) {
  var size2 = cfg.size, fill = cfg.fill, lineWidth = cfg.lineWidth, stroke = cfg.stroke, fillOpacity = cfg.fillOpacity;
  context.beginPath();
  context.globalAlpha = fillOpacity;
  context.fillStyle = fill;
  context.strokeStyle = stroke;
  context.lineWidth = lineWidth;
  context.arc(x, y, size2 / 2, 0, 2 * Math.PI, false);
  context.fill();
  if (lineWidth) {
    context.stroke();
  }
  context.closePath();
}
function createDotPattern(cfg) {
  var dotCfg = deepAssign({}, defaultDotPatternCfg, cfg);
  var size2 = dotCfg.size, padding2 = dotCfg.padding, isStagger = dotCfg.isStagger, rotation = dotCfg.rotation;
  var unitSize = getUnitPatternSize(size2, padding2, isStagger);
  var dots = getSymbolsPosition(unitSize, isStagger);
  var canvas = initCanvas(unitSize, unitSize);
  var ctx2 = canvas.getContext("2d");
  drawBackground(ctx2, dotCfg, unitSize);
  for (var _i = 0, dots_1 = dots; _i < dots_1.length; _i++) {
    var _a2 = dots_1[_i], x = _a2[0], y = _a2[1];
    drawDot(ctx2, dotCfg, x, y);
  }
  var pattern2 = ctx2.createPattern(canvas, "repeat");
  if (pattern2) {
    var dpr = getPixelRatio();
    var matrix = transformMatrix(dpr, rotation);
    pattern2.setTransform(matrix);
  }
  return pattern2;
}
var defaultLinePatternCfg = {
  rotation: 45,
  spacing: 5,
  opacity: 1,
  backgroundColor: "transparent",
  strokeOpacity: 0.5,
  stroke: "#fff",
  lineWidth: 2
};
function drawLine(context, cfg, d) {
  var stroke = cfg.stroke, lineWidth = cfg.lineWidth, strokeOpacity = cfg.strokeOpacity;
  var path2 = new Path2D(d);
  context.globalAlpha = strokeOpacity;
  context.lineCap = "square";
  context.strokeStyle = lineWidth ? stroke : "transparent";
  context.lineWidth = lineWidth;
  context.stroke(path2);
}
function createLinePattern(cfg) {
  var lineCfg = deepAssign({}, defaultLinePatternCfg, cfg);
  var spacing = lineCfg.spacing, rotation = lineCfg.rotation, lineWidth = lineCfg.lineWidth;
  var width = spacing + lineWidth || 1;
  var height = spacing + lineWidth || 1;
  var d = "\n            M 0 0 L " + width + " 0\n            M 0 " + height + " L " + width + " " + height + "\n            ";
  var canvas = initCanvas(width, height);
  var ctx2 = canvas.getContext("2d");
  drawBackground(ctx2, lineCfg, width, height);
  drawLine(ctx2, lineCfg, d);
  var pattern2 = ctx2.createPattern(canvas, "repeat");
  if (pattern2) {
    var dpr = getPixelRatio();
    var matrix = transformMatrix(dpr, rotation);
    pattern2.setTransform(matrix);
  }
  return pattern2;
}
var defaultSquarePatternCfg = {
  size: 6,
  padding: 1,
  isStagger: true,
  backgroundColor: "transparent",
  opacity: 1,
  rotation: 0,
  fill: "#fff",
  fillOpacity: 0.5,
  stroke: "transparent",
  lineWidth: 0
};
function drawSquare(context, cfg, x, y) {
  var stroke = cfg.stroke, size2 = cfg.size, fill = cfg.fill, lineWidth = cfg.lineWidth, fillOpacity = cfg.fillOpacity;
  context.globalAlpha = fillOpacity;
  context.strokeStyle = stroke;
  context.lineWidth = lineWidth;
  context.fillStyle = fill;
  context.strokeRect(x - size2 / 2, y - size2 / 2, size2, size2);
  context.fillRect(x - size2 / 2, y - size2 / 2, size2, size2);
}
function createSquarePattern(cfg) {
  var squareCfg = deepAssign({}, defaultSquarePatternCfg, cfg);
  var size2 = squareCfg.size, padding2 = squareCfg.padding, isStagger = squareCfg.isStagger, rotation = squareCfg.rotation;
  var unitSize = getUnitPatternSize(size2, padding2, isStagger);
  var squares = getSymbolsPosition(unitSize, isStagger);
  var canvas = initCanvas(unitSize, unitSize);
  var ctx2 = canvas.getContext("2d");
  drawBackground(ctx2, squareCfg, unitSize);
  for (var _i = 0, squares_1 = squares; _i < squares_1.length; _i++) {
    var _a2 = squares_1[_i], x = _a2[0], y = _a2[1];
    drawSquare(ctx2, squareCfg, x, y);
  }
  var pattern2 = ctx2.createPattern(canvas, "repeat");
  if (pattern2) {
    var dpr = getPixelRatio();
    var matrix = transformMatrix(dpr, rotation);
    pattern2.setTransform(matrix);
  }
  return pattern2;
}
function getCanvasPattern(options) {
  var type = options.type, cfg = options.cfg;
  var pattern2;
  switch (type) {
    case "dot":
      pattern2 = createDotPattern(cfg);
      break;
    case "line":
      pattern2 = createLinePattern(cfg);
      break;
    case "square":
      pattern2 = createSquarePattern(cfg);
      break;
  }
  return pattern2;
}
function pattern(key) {
  var _this = this;
  return function(params) {
    var _a2;
    var options = params.options, chart = params.chart;
    var patternOption = options.pattern;
    if (!patternOption) {
      return params;
    }
    var style = function(datum) {
      var _a3, _b, _c;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var defaultColor = chart.getTheme().defaultColor;
      var color2 = defaultColor;
      var colorAttribute = (_b = (_a3 = chart.geometries) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b === void 0 ? void 0 : _b.getAttribute("color");
      if (colorAttribute) {
        var colorField = colorAttribute.getFields()[0];
        var seriesValue = get(datum, colorField);
        color2 = Util.getMappingValue(colorAttribute, seriesValue, ((_c = colorAttribute.values) === null || _c === void 0 ? void 0 : _c[0]) || defaultColor);
      }
      var pattern2 = patternOption;
      if (typeof patternOption === "function") {
        pattern2 = patternOption.call(_this, datum, color2);
      }
      if (pattern2 instanceof CanvasPattern === false) {
        pattern2 = getCanvasPattern(deepAssign({}, { cfg: { backgroundColor: color2 } }, pattern2));
      }
      var styleOption = options[key];
      return __assign$1(__assign$1({}, typeof styleOption === "function" ? styleOption.call.apply(styleOption, __spreadArrays([_this, datum], args)) : styleOption || {}), { fill: pattern2 || color2 });
    };
    return deepAssign({}, params, { options: (_a2 = {}, _a2[key] = style, _a2) });
  };
}
function legend$g(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, colorField = options.colorField, seriesField = options.seriesField;
  if (legend2 === false) {
    chart.legend(false);
  } else if (colorField || seriesField) {
    chart.legend(colorField || seriesField, legend2);
  }
  return params;
}
function tooltip$8(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2 !== void 0) {
    chart.tooltip(tooltip2);
  }
  return params;
}
function interaction$6(params) {
  var chart = params.chart, options = params.options;
  var interactions = options.interactions;
  each$1(interactions, function(i) {
    if (i.enable === false) {
      chart.removeInteraction(i.type);
    } else {
      chart.interaction(i.type, i.cfg || {});
    }
  });
  return params;
}
function animation$5(params) {
  var chart = params.chart, options = params.options;
  var animation2 = options.animation;
  if (typeof animation2 === "boolean") {
    chart.animate(animation2);
  } else {
    chart.animate(true);
  }
  each$1(chart.geometries, function(g) {
    g.animate(animation2);
  });
  return params;
}
function theme$2(params) {
  var chart = params.chart, options = params.options;
  var theme2 = options.theme;
  if (theme2) {
    chart.theme(theme2);
  }
  return params;
}
function state(params) {
  var chart = params.chart, options = params.options;
  var state2 = options.state;
  if (state2) {
    each$1(chart.geometries, function(geometry2) {
      geometry2.state(state2);
    });
  }
  return params;
}
function slider$1(params) {
  var chart = params.chart, options = params.options;
  var slider2 = options.slider;
  chart.option("slider", slider2);
  return params;
}
function scrollbar(params) {
  var chart = params.chart, options = params.options;
  var scrollbar2 = options.scrollbar;
  chart.option("scrollbar", scrollbar2);
  return params;
}
function scale$1(axes, meta2) {
  return function(params) {
    var chart = params.chart, options = params.options;
    var scales = {};
    each$1(axes, function(axis2, field2) {
      scales[field2] = pick(axis2, AXIS_META_CONFIG_KEYS);
    });
    scales = deepAssign({}, meta2, options.meta, scales);
    chart.scale(scales);
    return params;
  };
}
function annotation$2(annotationOptions) {
  return function(params) {
    var chart = params.chart, options = params.options;
    var annotationController = chart.getController("annotation");
    each$1(__spreadArrays(options.annotations || [], annotationOptions || []), function(annotationOption) {
      annotationController.annotation(annotationOption);
    });
    return params;
  };
}
function limitInPlot$2(params) {
  var chart = params.chart, options = params.options;
  var yAxis = options.yAxis, limitInPlot2 = options.limitInPlot;
  var value2 = limitInPlot2;
  if (isObject(yAxis) && isNil(limitInPlot2)) {
    if (Object.values(pick(yAxis, ["min", "max", "minLimit", "maxLimit"])).some(function(value3) {
      return !isNil(value3);
    })) {
      value2 = true;
    } else {
      value2 = false;
    }
  }
  chart.limitInPlot = value2;
  return params;
}
function getTooltipMapping(tooltip2, defaultFields) {
  if (tooltip2 === false) {
    return {
      fields: false
    };
  }
  var fields = get(tooltip2, "fields");
  var formatter = get(tooltip2, "formatter");
  if (formatter && !fields) {
    fields = defaultFields;
  }
  return {
    fields,
    formatter
  };
}
function getMappingField(o, field2) {
  var type = o.type, xField = o.xField, yField = o.yField, colorField = o.colorField, shapeField = o.shapeField, sizeField = o.sizeField, styleField = o.styleField, _a2 = o.rawFields, rawFields = _a2 === void 0 ? [] : _a2;
  var fields = [];
  if (field2 === "color") {
    fields = __spreadArrays([colorField || xField], rawFields);
  } else if (field2 === "shape") {
    fields = __spreadArrays([shapeField || xField], rawFields);
  } else if (field2 === "size") {
    fields = __spreadArrays([sizeField || xField], rawFields);
  } else {
    fields = __spreadArrays([xField, yField, colorField, shapeField, sizeField, styleField], rawFields);
    var idx = ["x", "y", "color", "shape", "size", "style"].indexOf(field2);
    var f = fields[idx];
    fields.splice(idx, 1);
    fields.unshift(f);
  }
  var mappingFields = uniq$2(fields.filter(function(f2) {
    return !!f2;
  }));
  var tileMappingField = type === "line" && [xField, yField].includes(mappingFields.join("*")) ? "" : mappingFields.join("*");
  return {
    mappingFields,
    tileMappingField
  };
}
function getMappingFunction(mappingFields, func) {
  if (!func)
    return void 0;
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = {};
    mappingFields.forEach(function(f, idx) {
      params[f] = args[idx];
    });
    delete params["undefined"];
    return func(params);
  };
}
function geometry$w(params) {
  var chart = params.chart, options = params.options;
  var type = options.type, args = options.args, mapping = options.mapping, xField = options.xField, yField = options.yField, colorField = options.colorField, shapeField = options.shapeField, sizeField = options.sizeField, tooltipFields = options.tooltipFields, label2 = options.label, state2 = options.state, customInfo = options.customInfo;
  if (!mapping) {
    return params;
  }
  var color2 = mapping.color, shape = mapping.shape, size2 = mapping.size, style = mapping.style, tooltip2 = mapping.tooltip;
  var geometry2 = chart[type](args).position(xField + "*" + yField);
  if (isString(color2)) {
    colorField ? geometry2.color(colorField, color2) : geometry2.color(color2);
  } else if (isFunction(color2)) {
    var _a2 = getMappingField(options, "color"), mappingFields = _a2.mappingFields, tileMappingField = _a2.tileMappingField;
    geometry2.color(tileMappingField, getMappingFunction(mappingFields, color2));
  } else {
    colorField && geometry2.color(colorField, color2);
  }
  if (isString(shape)) {
    shapeField ? geometry2.shape(shapeField, [shape]) : geometry2.shape(shape);
  } else if (isFunction(shape)) {
    var _b = getMappingField(options, "shape"), mappingFields = _b.mappingFields, tileMappingField = _b.tileMappingField;
    geometry2.shape(tileMappingField, getMappingFunction(mappingFields, shape));
  } else {
    shapeField && geometry2.shape(shapeField, shape);
  }
  if (isNumber$1(size2)) {
    sizeField ? geometry2.size(sizeField, size2) : geometry2.size(size2);
  } else if (isFunction(size2)) {
    var _c = getMappingField(options, "size"), mappingFields = _c.mappingFields, tileMappingField = _c.tileMappingField;
    geometry2.size(tileMappingField, getMappingFunction(mappingFields, size2));
  } else {
    sizeField && geometry2.size(sizeField, size2);
  }
  if (isFunction(style)) {
    var _d = getMappingField(options, "style"), mappingFields = _d.mappingFields, tileMappingField = _d.tileMappingField;
    geometry2.style(tileMappingField, getMappingFunction(mappingFields, style));
  } else if (isObject(style)) {
    geometry2.style(style);
  }
  if (tooltipFields === false) {
    geometry2.tooltip(false);
  } else if (!isEmpty(tooltipFields)) {
    geometry2.tooltip(tooltipFields.join("*"), getMappingFunction(tooltipFields, tooltip2));
  }
  if (label2 === false) {
    geometry2.label(false);
  } else if (label2) {
    var callback = label2.callback, fields = label2.fields, cfg = __rest(label2, ["callback", "fields"]);
    geometry2.label({
      fields: fields || [yField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  if (state2) {
    geometry2.state(state2);
  }
  if (customInfo) {
    geometry2.customInfo(customInfo);
  }
  [xField, yField].filter(function(f) {
    return f !== colorField;
  }).forEach(function(f) {
    chart.legend(f, false);
  });
  return __assign$1(__assign$1({}, params), {
    ext: { geometry: geometry2 }
  });
}
function area(params) {
  var options = params.options;
  var area2 = options.area, xField = options.xField, yField = options.yField, seriesField = options.seriesField, smooth = options.smooth, tooltip2 = options.tooltip;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  return area2 ? geometry$w(deepAssign({}, params, {
    options: {
      type: "area",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$1({ shape: smooth ? "smooth" : "area", tooltip: formatter }, area2)
    }
  })) : params;
}
function line(params) {
  var options = params.options;
  var line2 = options.line, stepType = options.stepType, xField = options.xField, yField = options.yField, seriesField = options.seriesField, smooth = options.smooth, connectNulls = options.connectNulls, tooltip2 = options.tooltip;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  return line2 ? geometry$w(deepAssign({}, params, {
    options: {
      type: "line",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: deepMix({
        shape: stepType || (smooth ? "smooth" : "line"),
        tooltip: formatter
      }, line2),
      args: { connectNulls }
    }
  })) : params;
}
function point(params) {
  var options = params.options;
  var point2 = options.point, xField = options.xField, yField = options.yField, seriesField = options.seriesField, sizeField = options.sizeField, shapeField = options.shapeField, tooltip2 = options.tooltip;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField, sizeField, shapeField]), fields = _a2.fields, formatter = _a2.formatter;
  return point2 ? geometry$w(deepAssign({}, params, {
    options: {
      type: "point",
      colorField: seriesField,
      shapeField,
      tooltipFields: fields,
      mapping: __assign$1({ tooltip: formatter }, point2)
    }
  })) : params;
}
function otherAdaptor(params) {
  var chart = params.chart, options = params.options, ext = params.ext;
  var seriesField = options.seriesField, isGroup = options.isGroup, isStack = options.isStack, marginRatio = options.marginRatio, widthRatio = options.widthRatio, groupField = options.groupField, theme2 = options.theme;
  var adjust2 = [];
  if (seriesField) {
    if (isGroup) {
      adjust2.push({
        type: "dodge",
        dodgeBy: groupField || seriesField,
        marginRatio
      });
    }
    if (isStack) {
      adjust2.push({
        type: "stack",
        marginRatio
      });
    }
  }
  if (adjust2.length && (ext === null || ext === void 0 ? void 0 : ext.geometry)) {
    var g = ext === null || ext === void 0 ? void 0 : ext.geometry;
    g.adjust(adjust2);
  }
  if (!isNil(widthRatio)) {
    chart.theme(deepAssign({}, isObject(theme2) ? theme2 : getTheme(theme2), {
      columnWidthRatio: widthRatio
    }));
  }
  return params;
}
function interval(params) {
  var options = params.options;
  var xField = options.xField, yField = options.yField, interval2 = options.interval, seriesField = options.seriesField, tooltip2 = options.tooltip, minColumnWidth = options.minColumnWidth, maxColumnWidth = options.maxColumnWidth, columnBackground = options.columnBackground, dodgePadding = options.dodgePadding, intervalPadding = options.intervalPadding;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  var ext = (interval2 ? geometry$w(deepAssign({}, params, {
    options: {
      type: "interval",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$1({ tooltip: formatter }, interval2),
      args: { dodgePadding, intervalPadding, minColumnWidth, maxColumnWidth, background: columnBackground }
    }
  })) : params).ext;
  return otherAdaptor(__assign$1(__assign$1({}, params), { ext }));
}
function polygon(params) {
  var options = params.options;
  var polygon2 = options.polygon, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip2 = options.tooltip;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  return polygon2 ? geometry$w(deepAssign({}, params, {
    options: {
      type: "polygon",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$1({ tooltip: formatter }, polygon2)
    }
  })) : params;
}
function edge(params) {
  var options = params.options;
  var edge2 = options.edge, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip2 = options.tooltip;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  return edge2 ? geometry$w(deepAssign({}, params, {
    options: {
      type: "edge",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$1({ tooltip: formatter }, edge2)
    }
  })) : params;
}
function schema(params) {
  var options = params.options;
  var schema2 = options.schema, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip2 = options.tooltip;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  return schema2 ? geometry$w(deepAssign({}, params, {
    options: {
      type: "schema",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$1({ tooltip: formatter }, schema2)
    }
  })) : params;
}
function violin(params) {
  var options = params.options;
  var violin2 = options.violin, xField = options.xField, yField = options.yField, seriesField = options.seriesField, sizeField = options.sizeField, tooltip2 = options.tooltip;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField, sizeField]), fields = _a2.fields, formatter = _a2.formatter;
  return violin2 ? geometry$w(deepAssign({}, params, {
    options: {
      type: "violin",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$1({ tooltip: formatter }, violin2)
    }
  })) : params;
}
function geometry$v(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, color2 = options.color, lineStyle = options.lineStyle, lineShape = options.lineShape, pointMapping = options.point, areaMapping = options.area, seriesField = options.seriesField;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  chart.data(data2);
  var primary = deepAssign({}, params, {
    options: {
      shapeField: seriesField,
      line: {
        color: color2,
        style: lineStyle,
        shape: lineShape
      },
      point: pointMapping && __assign$1({ color: color2, shape: "circle" }, pointMapping),
      area: areaMapping && __assign$1({ color: color2 }, areaMapping),
      label: void 0
    }
  });
  var second = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  var areaParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  line(primary);
  point(second);
  area(areaParams);
  return params;
}
function meta$l(params) {
  var _a2, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, data2 = options.data;
  return flow(scale$1((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2), (_b = {}, _b[xField] = {
    type: "cat"
  }, _b[yField] = adjustYMetaByZero(data2, yField), _b)))(params);
}
function coordinate$8(params) {
  var chart = params.chart, options = params.options;
  var reflect = options.reflect;
  if (reflect) {
    var p = reflect;
    if (!isArray$1(p)) {
      p = [p];
    }
    var actions = p.map(function(d) {
      return ["reflect", d];
    });
    chart.coordinate({ type: "rect", actions });
  }
  return params;
}
function axis$k(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function legend$f(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, seriesField = options.seriesField;
  if (legend2 && seriesField) {
    chart.legend(seriesField, legend2);
  } else if (legend2 === false) {
    chart.legend(false);
  }
  return params;
}
function label$e(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField;
  var lineGeometry = findGeometry(chart, "line");
  if (!label2) {
    lineGeometry.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    lineGeometry.label({
      fields: [yField],
      callback,
      cfg: __assign$1({ layout: [
        { type: "limit-in-plot" },
        { type: "path-adjust-position" },
        { type: "point-adjust-position" },
        { type: "limit-in-plot", cfg: { action: "hide" } }
      ] }, transformLabel(cfg))
    });
  }
  return params;
}
function adjust$1(params) {
  var chart = params.chart, options = params.options;
  var isStack = options.isStack;
  if (isStack) {
    each$1(chart.geometries, function(g) {
      g.adjust("stack");
    });
  }
  return params;
}
function adaptor$y(params) {
  return flow(geometry$v, meta$l, adjust$1, theme$2, coordinate$8, axis$k, legend$f, tooltip$8, label$e, slider$1, interaction$6, animation$5, annotation$2(), limitInPlot$2)(params);
}
var DEFAULT_OPTIONS$z = deepAssign({}, Plot.getDefaultOptions(), {
  tooltip: {
    shared: true,
    showMarkers: true,
    showCrosshairs: true,
    crosshairs: {
      type: "x"
    }
  },
  legend: {
    position: "top-left"
  },
  isStack: false
});
var MarkerActiveAction = function(_super) {
  __extends$2(MarkerActiveAction2, _super);
  function MarkerActiveAction2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MarkerActiveAction2.prototype.active = function() {
    var view = this.getView();
    var evt = this.context.event;
    if (evt.data) {
      var items_1 = evt.data.items;
      var points = view.geometries.filter(function(geom) {
        return geom.type === "point";
      });
      each$1(points, function(point2) {
        each$1(point2.elements, function(element) {
          var active = findIndex(items_1, function(item) {
            return item.data === element.data;
          }) !== -1;
          element.setState("active", active);
        });
      });
    }
  };
  MarkerActiveAction2.prototype.reset = function() {
    var view = this.getView();
    var points = view.geometries.filter(function(geom) {
      return geom.type === "point";
    });
    each$1(points, function(point2) {
      each$1(point2.elements, function(element) {
        element.setState("active", false);
      });
    });
  };
  MarkerActiveAction2.prototype.getView = function() {
    return this.context.view;
  };
  return MarkerActiveAction2;
}(Action);
registerAction("marker-active", MarkerActiveAction);
registerInteraction("marker-active", {
  start: [
    {
      trigger: "tooltip:show",
      action: "marker-active:active"
    }
  ],
  end: [
    {
      trigger: "tooltip:hide",
      action: "marker-active:reset"
    }
  ]
});
var Line = function(_super) {
  __extends$2(Line2, _super);
  function Line2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "line";
    return _this;
  }
  Line2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$z;
  };
  Line2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = this, chart = _a2.chart, options = _a2.options;
    meta$l({ chart, options });
    this.chart.changeData(data2);
  };
  Line2.prototype.getDefaultOptions = function() {
    return Line2.getDefaultOptions();
  };
  Line2.prototype.getSchemaAdaptor = function() {
    return adaptor$y;
  };
  return Line2;
}(Plot);
function percent(data2, measure, groupField, as) {
  var sumMap = reduce(data2, function(map2, datum) {
    var groupValue = datum[groupField];
    var sum = map2.has(groupValue) ? map2.get(groupValue) : 0;
    var v = datum[measure];
    sum = isRealNumber(v) ? sum + v : sum;
    map2.set(groupValue, sum);
    return map2;
  }, new Map());
  return map$2(data2, function(datum) {
    var _a2;
    var v = datum[measure];
    var groupValue = datum[groupField];
    var percentage = isRealNumber(v) ? v / sumMap.get(groupValue) : 0;
    return __assign$1(__assign$1({}, datum), (_a2 = {}, _a2[as] = percentage, _a2));
  });
}
function getDeepPercent(data2, measure, fields, percent2) {
  var sumMap = reduce(data2, function(map2, datum) {
    var groupValue = reduce(fields, function(value2, field2) {
      return "" + value2 + datum[field2];
    }, "");
    var sum = map2.has(groupValue) ? map2.get(groupValue) : 0;
    var v = datum[measure];
    sum = isRealNumber(v) ? sum + v : sum;
    map2.set(groupValue, sum);
    return map2;
  }, new Map());
  return map$2(data2, function(datum) {
    var _a2;
    var v = datum[measure];
    var groupValue = reduce(fields, function(value2, field2) {
      return "" + value2 + datum[field2];
    }, "");
    var percentage = isRealNumber(v) ? v / sumMap.get(groupValue) : 0;
    return __assign$1(__assign$1({}, datum), (_a2 = {}, _a2[percent2] = percentage, _a2));
  });
}
function getDataWhetherPecentage(data2, yField, groupField, asField, isPercent) {
  return !isPercent ? data2 : percent(data2, yField, groupField, asField);
}
function geometry$u(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, areaStyle = options.areaStyle, color2 = options.color, pointMapping = options.point, lineMapping = options.line, isPercent = options.isPercent, xField = options.xField, yField = options.yField, tooltip2 = options.tooltip, seriesField = options.seriesField, startOnZero = options.startOnZero;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  var chartData = getDataWhetherPecentage(data2, yField, xField, yField, isPercent);
  chart.data(chartData);
  var tooltipOptions = isPercent ? __assign$1({ formatter: function(datum) {
    return {
      name: datum[seriesField] || datum[xField],
      value: (Number(datum[yField]) * 100).toFixed(2) + "%"
    };
  } }, tooltip2) : tooltip2;
  var primary = deepAssign({}, params, {
    options: {
      area: { color: color2, style: areaStyle },
      line: lineMapping && __assign$1({ color: color2 }, lineMapping),
      point: pointMapping && __assign$1({ color: color2 }, pointMapping),
      tooltip: tooltipOptions,
      label: void 0,
      args: {
        startOnZero
      }
    }
  });
  var lineParams = deepAssign({ options: { line: { size: 2 } } }, primary, {
    options: { sizeField: seriesField, tooltip: false }
  });
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  area(primary);
  line(lineParams);
  point(pointParams);
  return params;
}
function label$d(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField;
  var areaGeometry = findGeometry(chart, "area");
  if (!label2) {
    areaGeometry.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    areaGeometry.label({
      fields: [yField],
      callback,
      cfg: __assign$1({ layout: [
        { type: "limit-in-plot" },
        { type: "path-adjust-position" },
        { type: "point-adjust-position" },
        { type: "limit-in-plot", cfg: { action: "hide" } }
      ] }, transformLabel(cfg))
    });
  }
  return params;
}
function adjust(params) {
  var chart = params.chart, options = params.options;
  var isStack = options.isStack, isPercent = options.isPercent, seriesField = options.seriesField;
  if ((isPercent || isStack) && seriesField) {
    each$1(chart.geometries, function(g) {
      g.adjust("stack");
    });
  }
  return params;
}
function adaptor$x(params) {
  return flow(theme$2, pattern("areaStyle"), geometry$u, meta$l, adjust, axis$k, legend$f, tooltip$8, label$d, slider$1, annotation$2(), interaction$6, animation$5, limitInPlot$2)(params);
}
var DEFAULT_OPTIONS$y = deepAssign({}, Plot.getDefaultOptions(), {
  tooltip: {
    shared: true,
    showMarkers: true,
    showCrosshairs: true,
    crosshairs: {
      type: "x"
    }
  },
  isStack: true,
  line: {},
  legend: {
    position: "top-left"
  }
});
var Area = function(_super) {
  __extends$2(Area2, _super);
  function Area2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "area";
    return _this;
  }
  Area2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$y;
  };
  Area2.prototype.getDefaultOptions = function() {
    return Area2.getDefaultOptions();
  };
  Area2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = this.options, isPercent = _a2.isPercent, xField = _a2.xField, yField = _a2.yField;
    var _b = this, chart = _b.chart, options = _b.options;
    meta$l({ chart, options });
    this.chart.changeData(getDataWhetherPecentage(data2, yField, xField, yField, isPercent));
  };
  Area2.prototype.getSchemaAdaptor = function() {
    return adaptor$x;
  };
  return Area2;
}(Plot);
function conversionTagFormatter(prev, next) {
  if (!isNumber$1(prev) || !isNumber$1(next)) {
    return "-";
  }
  if (prev === next) {
    return "100%";
  }
  if (prev === 0) {
    return "\u221E";
  }
  if (next === 0) {
    return "-\u221E";
  }
  return (100 * next / prev).toFixed(2) + "%";
}
function getConversionTagOptionsWithDefaults(options, horizontal) {
  return deepAssign({
    size: horizontal ? 32 : 80,
    spacing: horizontal ? 8 : 12,
    offset: horizontal ? 32 : 0,
    arrow: options.arrow !== false && {
      headSize: 12,
      style: {
        fill: "rgba(0, 0, 0, 0.05)"
      }
    },
    text: options.text !== false && {
      style: {
        fontSize: 12,
        fill: "rgba(0, 0, 0, 0.85)",
        textAlign: "center",
        textBaseline: "middle"
      },
      formatter: conversionTagFormatter
    }
  }, options);
}
function parsePoints(coordinate2, element) {
  return map$2(element.getModel().points, function(point2) {
    return coordinate2.convertPoint(point2);
  });
}
function renderArrowTag(config, elemPrev, elemNext) {
  var view = config.view, geometry2 = config.geometry, group2 = config.group, options = config.options, horizontal = config.horizontal;
  var offset = options.offset, size2 = options.size, arrow = options.arrow;
  var coordinate2 = view.getCoordinate();
  var pointPrev = parsePoints(coordinate2, elemPrev)[horizontal ? 3 : 0];
  var pointNext = parsePoints(coordinate2, elemNext)[horizontal ? 0 : 3];
  var totalHeight = pointNext.y - pointPrev.y;
  var totalWidth = pointNext.x - pointPrev.x;
  if (typeof arrow === "boolean") {
    return;
  }
  var headSize = arrow.headSize;
  var spacing = options.spacing;
  var points;
  if (horizontal) {
    if ((totalWidth - headSize) / 2 < spacing) {
      spacing = Math.max(1, (totalWidth - headSize) / 2);
      points = [
        [pointPrev.x + spacing, pointPrev.y - offset],
        [pointPrev.x + spacing, pointPrev.y - offset - size2],
        [pointNext.x - spacing, pointNext.y - offset - size2 / 2]
      ];
    } else {
      points = [
        [pointPrev.x + spacing, pointPrev.y - offset],
        [pointPrev.x + spacing, pointPrev.y - offset - size2],
        [pointNext.x - spacing - headSize, pointNext.y - offset - size2],
        [pointNext.x - spacing, pointNext.y - offset - size2 / 2],
        [pointNext.x - spacing - headSize, pointNext.y - offset]
      ];
    }
  } else {
    if ((totalHeight - headSize) / 2 < spacing) {
      spacing = Math.max(1, (totalHeight - headSize) / 2);
      points = [
        [pointPrev.x + offset, pointPrev.y + spacing],
        [pointPrev.x + offset + size2, pointPrev.y + spacing],
        [pointNext.x + offset + size2 / 2, pointNext.y - spacing]
      ];
    } else {
      points = [
        [pointPrev.x + offset, pointPrev.y + spacing],
        [pointPrev.x + offset + size2, pointPrev.y + spacing],
        [pointNext.x + offset + size2, pointNext.y - spacing - headSize],
        [pointNext.x + offset + size2 / 2, pointNext.y - spacing],
        [pointNext.x + offset, pointNext.y - spacing - headSize]
      ];
    }
  }
  group2.addShape("polygon", {
    id: view.id + "-conversion-tag-arrow-" + geometry2.getElementId(elemPrev.getModel().mappingData),
    name: "conversion-tag-arrow",
    origin: {
      element: elemPrev,
      nextElement: elemNext
    },
    attrs: __assign$1(__assign$1({}, arrow.style || {}), { points })
  });
}
function renderTextTag(config, elemPrev, elemNext) {
  var _a2, _b, _c;
  var view = config.view, geometry2 = config.geometry, group2 = config.group, options = config.options, field2 = config.field, horizontal = config.horizontal;
  var offset = options.offset, size2 = options.size;
  if (typeof options.text === "boolean") {
    return;
  }
  var coordinate2 = view.getCoordinate();
  var text2 = ((_a2 = options.text) === null || _a2 === void 0 ? void 0 : _a2.formatter) && ((_b = options.text) === null || _b === void 0 ? void 0 : _b.formatter(elemPrev.getData()[field2], elemNext.getData()[field2]));
  var pointPrev = parsePoints(coordinate2, elemPrev)[horizontal ? 3 : 0];
  var pointNext = parsePoints(coordinate2, elemNext)[horizontal ? 0 : 3];
  var textShape = group2.addShape("text", {
    id: view.id + "-conversion-tag-text-" + geometry2.getElementId(elemPrev.getModel().mappingData),
    name: "conversion-tag-text",
    origin: {
      element: elemPrev,
      nextElement: elemNext
    },
    attrs: __assign$1(__assign$1({}, ((_c = options.text) === null || _c === void 0 ? void 0 : _c.style) || {}), { text: text2, x: horizontal ? (pointPrev.x + pointNext.x) / 2 : pointPrev.x + offset + size2 / 2, y: horizontal ? pointPrev.y - offset - size2 / 2 : (pointPrev.y + pointNext.y) / 2 })
  });
  if (horizontal) {
    var totalWidth = pointNext.x - pointPrev.x;
    var textWidth = textShape.getBBox().width;
    if (textWidth > totalWidth) {
      var cWidth = textWidth / text2.length;
      var cEnd = Math.max(1, Math.ceil(totalWidth / cWidth) - 1);
      var textAdjusted = text2.slice(0, cEnd) + "...";
      textShape.attr("text", textAdjusted);
    }
  }
}
function renderTag(options, elemPrev, elemNext) {
  renderArrowTag(options, elemPrev, elemNext);
  renderTextTag(options, elemPrev, elemNext);
}
function conversionTag$3(field2, horizontal, disabled) {
  if (horizontal === void 0) {
    horizontal = true;
  }
  if (disabled === void 0) {
    disabled = false;
  }
  return function(params) {
    var options = params.options, chart = params.chart;
    var conversionTag2 = options.conversionTag, theme2 = options.theme;
    if (conversionTag2 && !disabled) {
      chart.theme(deepAssign({}, isObject(theme2) ? theme2 : getTheme(theme2), {
        columnWidthRatio: 1 / 3
      }));
      chart.annotation().shape({
        render: function(container, view) {
          var group2 = container.addGroup({
            id: chart.id + "-conversion-tag-group",
            name: "conversion-tag-group"
          });
          var interval2 = find$1(chart.geometries, function(geom) {
            return geom.type === "interval";
          });
          var config = {
            view,
            geometry: interval2,
            group: group2,
            field: field2,
            horizontal,
            options: getConversionTagOptionsWithDefaults(conversionTag2, horizontal)
          };
          var elements = horizontal ? interval2.elements : interval2.elements.slice().reverse();
          each$1(elements, function(elem, idx) {
            if (idx > 0) {
              renderTag(config, elements[idx - 1], elem);
            }
          });
        }
      });
    }
    return params;
  };
}
var INTERACTION_MAP = {
  hover: "__interval-connected-area-hover__",
  click: "__interval-connected-area-click__"
};
var getStartStages = function(trigger, style) {
  if (trigger === "hover") {
    return [
      {
        trigger: "interval:mouseenter",
        action: ["element-highlight-by-color:highlight", "element-link-by-color:link"],
        arg: [null, { style }]
      }
    ];
  }
  return [
    {
      trigger: "interval:click",
      action: [
        "element-highlight-by-color:clear",
        "element-highlight-by-color:highlight",
        "element-link-by-color:clear",
        "element-link-by-color:unlink",
        "element-link-by-color:link"
      ],
      arg: [null, null, null, null, { style }]
    }
  ];
};
registerInteraction(INTERACTION_MAP.hover, {
  start: getStartStages(INTERACTION_MAP.hover),
  end: [
    {
      trigger: "interval:mouseleave",
      action: ["element-highlight-by-color:reset", "element-link-by-color:unlink"]
    }
  ]
});
registerInteraction(INTERACTION_MAP.click, {
  start: getStartStages(INTERACTION_MAP.click),
  end: [
    {
      trigger: "document:mousedown",
      action: ["element-highlight-by-color:clear", "element-link-by-color:clear"]
    }
  ]
});
function connectedArea(disable) {
  if (disable === void 0) {
    disable = false;
  }
  return function(params) {
    var chart = params.chart, options = params.options;
    var connectedArea2 = options.connectedArea;
    var clear = function() {
      chart.removeInteraction(INTERACTION_MAP.hover);
      chart.removeInteraction(INTERACTION_MAP.click);
    };
    if (!disable && connectedArea2) {
      var trigger = connectedArea2.trigger || "hover";
      clear();
      chart.interaction(INTERACTION_MAP[trigger], {
        start: getStartStages(trigger, connectedArea2.style)
      });
    } else {
      clear();
    }
    return params;
  };
}
var PADDING_RIGHT = 10;
var PADDING_TOP$1 = 5;
var BUTTON_ACTION_CONFIG = {
  padding: [8, 10],
  text: "reset",
  textStyle: {
    default: {
      x: 0,
      y: 0,
      fontSize: 12,
      fill: "#333333",
      cursor: "pointer"
    }
  },
  buttonStyle: {
    default: {
      fill: "#f7f7f7",
      stroke: "#cccccc",
      cursor: "pointer"
    },
    active: {
      fill: "#e6e6e6"
    }
  }
};
var ButtonAction = function(_super) {
  __extends$2(ButtonAction2, _super);
  function ButtonAction2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.buttonGroup = null;
    _this.buttonCfg = __assign$1({ name: "button" }, BUTTON_ACTION_CONFIG);
    return _this;
  }
  ButtonAction2.prototype.getButtonCfg = function() {
    var view = this.context.view;
    var buttonCfg = get(view, ["interactions", "filter-action", "cfg", "buttonConfig"]);
    return deepAssign(this.buttonCfg, buttonCfg, this.cfg);
  };
  ButtonAction2.prototype.drawButton = function() {
    var config = this.getButtonCfg();
    var group2 = this.context.view.foregroundGroup.addGroup({
      name: config.name
    });
    var textShape = this.drawText(group2);
    this.drawBackground(group2, textShape.getBBox());
    this.buttonGroup = group2;
  };
  ButtonAction2.prototype.drawText = function(group2) {
    var _a2;
    var config = this.getButtonCfg();
    return group2.addShape({
      type: "text",
      name: "button-text",
      attrs: __assign$1({ text: config.text }, (_a2 = config.textStyle) === null || _a2 === void 0 ? void 0 : _a2.default)
    });
  };
  ButtonAction2.prototype.drawBackground = function(group2, bbox) {
    var _a2;
    var config = this.getButtonCfg();
    var padding2 = normalPadding(config.padding);
    var buttonShape = group2.addShape({
      type: "rect",
      name: "button-rect",
      attrs: __assign$1({ x: bbox.x - padding2[3], y: bbox.y - padding2[0], width: bbox.width + padding2[1] + padding2[3], height: bbox.height + padding2[0] + padding2[2] }, (_a2 = config.buttonStyle) === null || _a2 === void 0 ? void 0 : _a2.default)
    });
    buttonShape.toBack();
    group2.on("mouseenter", function() {
      var _a3;
      buttonShape.attr((_a3 = config.buttonStyle) === null || _a3 === void 0 ? void 0 : _a3.active);
    });
    group2.on("mouseleave", function() {
      var _a3;
      buttonShape.attr((_a3 = config.buttonStyle) === null || _a3 === void 0 ? void 0 : _a3.default);
    });
    return buttonShape;
  };
  ButtonAction2.prototype.resetPosition = function() {
    var view = this.context.view;
    var coord2 = view.getCoordinate();
    var point2 = coord2.convert({ x: 1, y: 1 });
    var buttonGroup = this.buttonGroup;
    var bbox = buttonGroup.getBBox();
    var matrix = Util.transform(null, [
      ["t", point2.x - bbox.width - PADDING_RIGHT, point2.y + bbox.height + PADDING_TOP$1]
    ]);
    buttonGroup.setMatrix(matrix);
  };
  ButtonAction2.prototype.show = function() {
    if (!this.buttonGroup) {
      this.drawButton();
    }
    this.resetPosition();
    this.buttonGroup.show();
  };
  ButtonAction2.prototype.hide = function() {
    if (this.buttonGroup) {
      this.buttonGroup.hide();
    }
  };
  ButtonAction2.prototype.destroy = function() {
    var buttonGroup = this.buttonGroup;
    if (buttonGroup) {
      buttonGroup.remove();
    }
    _super.prototype.destroy.call(this);
  };
  return ButtonAction2;
}(Action);
registerAction("brush-reset-button", ButtonAction, {
  name: "brush-reset-button"
});
registerInteraction("filter-action", {});
function isPointInView(context) {
  return context.isInPlot();
}
function getInteractionCfg(interactionType, brushType, mask) {
  var maskType = brushType || "rect";
  switch (interactionType) {
    case "brush":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair" },
          { trigger: "plot:mouseleave", action: "cursor:default" }
        ],
        start: [
          {
            trigger: "mousedown",
            isEnable: isPointInView,
            action: ["brush:start", maskType + "-mask:start", maskType + "-mask:show"],
            arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          }
        ],
        processing: [
          {
            trigger: "mousemove",
            isEnable: isPointInView,
            action: [maskType + "-mask:resize"]
          }
        ],
        end: [
          {
            trigger: "mouseup",
            isEnable: isPointInView,
            action: [
              "brush:filter",
              "brush:end",
              maskType + "-mask:end",
              maskType + "-mask:hide",
              "brush-reset-button:show"
            ]
          }
        ],
        rollback: [
          {
            trigger: "brush-reset-button:click",
            action: ["brush:reset", "brush-reset-button:hide", "cursor:crosshair"]
          }
        ]
      };
    case "brush-highlight":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair" },
          { trigger: "mask:mouseenter", action: "cursor:move" },
          { trigger: "plot:mouseleave", action: "cursor:default" },
          { trigger: "mask:mouseleave", action: "cursor:crosshair" }
        ],
        start: [
          {
            trigger: "plot:mousedown",
            isEnable: function(context) {
              return !context.isInShape("mask");
            },
            action: [maskType + "-mask:start", maskType + "-mask:show"],
            arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          },
          {
            trigger: "mask:dragstart",
            action: [maskType + "-mask:moveStart"]
          }
        ],
        processing: [
          {
            trigger: "plot:mousemove",
            action: [maskType + "-mask:resize"]
          },
          {
            trigger: "mask:drag",
            action: [maskType + "-mask:move"]
          },
          {
            trigger: "mask:change",
            action: ["element-range-highlight:highlight"]
          }
        ],
        end: [
          { trigger: "plot:mouseup", action: [maskType + "-mask:end"] },
          { trigger: "mask:dragend", action: [maskType + "-mask:moveEnd"] },
          {
            trigger: "document:mouseup",
            isEnable: function(context) {
              return !context.isInPlot();
            },
            action: ["element-range-highlight:clear", maskType + "-mask:end", maskType + "-mask:hide"]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", maskType + "-mask:hide"] }]
      };
    case "brush-x":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair" },
          { trigger: "plot:mouseleave", action: "cursor:default" }
        ],
        start: [
          {
            trigger: "mousedown",
            isEnable: isPointInView,
            action: ["brush-x:start", maskType + "-mask:start", maskType + "-mask:show"],
            arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          }
        ],
        processing: [
          {
            trigger: "mousemove",
            isEnable: isPointInView,
            action: [maskType + "-mask:resize"]
          }
        ],
        end: [
          {
            trigger: "mouseup",
            isEnable: isPointInView,
            action: ["brush-x:filter", "brush-x:end", maskType + "-mask:end", maskType + "-mask:hide"]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["brush-x:reset"] }]
      };
    case "brush-x-highlight":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair" },
          { trigger: "mask:mouseenter", action: "cursor:move" },
          { trigger: "plot:mouseleave", action: "cursor:default" },
          { trigger: "mask:mouseleave", action: "cursor:crosshair" }
        ],
        start: [
          {
            trigger: "plot:mousedown",
            isEnable: function(context) {
              return !context.isInShape("mask");
            },
            action: [maskType + "-mask:start", maskType + "-mask:show"],
            arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          },
          {
            trigger: "mask:dragstart",
            action: [maskType + "-mask:moveStart"]
          }
        ],
        processing: [
          {
            trigger: "plot:mousemove",
            action: [maskType + "-mask:resize"]
          },
          {
            trigger: "mask:drag",
            action: [maskType + "-mask:move"]
          },
          {
            trigger: "mask:change",
            action: ["element-range-highlight:highlight"]
          }
        ],
        end: [
          { trigger: "plot:mouseup", action: [maskType + "-mask:end"] },
          { trigger: "mask:dragend", action: [maskType + "-mask:moveEnd"] },
          {
            trigger: "document:mouseup",
            isEnable: function(context) {
              return !context.isInPlot();
            },
            action: ["element-range-highlight:clear", maskType + "-mask:end", maskType + "-mask:hide"]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", maskType + "-mask:hide"] }]
      };
    case "brush-y":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair" },
          { trigger: "plot:mouseleave", action: "cursor:default" }
        ],
        start: [
          {
            trigger: "mousedown",
            isEnable: isPointInView,
            action: ["brush-y:start", maskType + "-mask:start", maskType + "-mask:show"],
            arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          }
        ],
        processing: [
          {
            trigger: "mousemove",
            isEnable: isPointInView,
            action: [maskType + "-mask:resize"]
          }
        ],
        end: [
          {
            trigger: "mouseup",
            isEnable: isPointInView,
            action: ["brush-y:filter", "brush-y:end", maskType + "-mask:end", maskType + "-mask:hide"]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["brush-y:reset"] }]
      };
    case "brush-y-highlight":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair" },
          { trigger: "mask:mouseenter", action: "cursor:move" },
          { trigger: "plot:mouseleave", action: "cursor:default" },
          { trigger: "mask:mouseleave", action: "cursor:crosshair" }
        ],
        start: [
          {
            trigger: "plot:mousedown",
            isEnable: function(context) {
              return !context.isInShape("mask");
            },
            action: [maskType + "-mask:start", maskType + "-mask:show"],
            arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          },
          {
            trigger: "mask:dragstart",
            action: [maskType + "-mask:moveStart"]
          }
        ],
        processing: [
          {
            trigger: "plot:mousemove",
            action: [maskType + "-mask:resize"]
          },
          {
            trigger: "mask:drag",
            action: [maskType + "-mask:move"]
          },
          {
            trigger: "mask:change",
            action: ["element-range-highlight:highlight"]
          }
        ],
        end: [
          { trigger: "plot:mouseup", action: [maskType + "-mask:end"] },
          { trigger: "mask:dragend", action: [maskType + "-mask:moveEnd"] },
          {
            trigger: "document:mouseup",
            isEnable: function(context) {
              return !context.isInPlot();
            },
            action: ["element-range-highlight:clear", maskType + "-mask:end", maskType + "-mask:hide"]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", maskType + "-mask:hide"] }]
      };
    default:
      return {};
  }
}
registerInteraction("brush", getInteractionCfg("brush"));
registerInteraction("brush-highlight", getInteractionCfg("brush-highlight"));
registerInteraction("brush-x", getInteractionCfg("brush-x", "x-rect"));
registerInteraction("brush-y", getInteractionCfg("brush-y", "y-rect"));
registerInteraction("brush-x-highlight", getInteractionCfg("brush-x-highlight", "x-rect"));
registerInteraction("brush-y-highlight", getInteractionCfg("brush-y-highlight", "y-rect"));
var BRUSH_TYPES = ["brush", "brush-x", "brush-y", "brush-highlight", "brush-x-highlight", "brush-y-highlight"];
function brushInteraction(params) {
  var options = params.options;
  var brush = options.brush;
  var interactions = filter(options.interactions || [], function(i) {
    return BRUSH_TYPES.indexOf(i.type) === -1;
  });
  if (brush === null || brush === void 0 ? void 0 : brush.enabled) {
    BRUSH_TYPES.forEach(function(type) {
      var _a2;
      var enable = false;
      switch (brush.type) {
        case "x-rect":
          enable = type === (brush.action === "highlight" ? "brush-x-highlight" : "brush-x");
          break;
        case "y-rect":
          enable = type === (brush.action === "highlight" ? "brush-y-highlight" : "brush-y");
          break;
        default:
          enable = type === (brush.action === "highlight" ? "brush-highlight" : "brush");
          break;
      }
      var obj = { type, enable };
      if (((_a2 = brush.mask) === null || _a2 === void 0 ? void 0 : _a2.style) || brush.type) {
        obj.cfg = getInteractionCfg(type, brush.type, brush.mask);
      }
      interactions.push(obj);
    });
    if ((brush === null || brush === void 0 ? void 0 : brush.action) !== "highlight") {
      interactions.push({
        type: "filter-action",
        cfg: {
          buttonConfig: brush.button
        }
      });
    }
  }
  return deepAssign({}, params, { options: { interactions } });
}
function defaultOptions$5(params) {
  var options = params.options;
  var legend2 = options.legend;
  var seriesField = options.seriesField, isStack = options.isStack;
  if (seriesField) {
    if (legend2 !== false) {
      legend2 = __assign$1({ position: isStack ? "right-top" : "top-left" }, legend2);
    }
  } else {
    legend2 = false;
  }
  params.options.legend = legend2;
  return params;
}
function geometry$t(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, columnStyle = options.columnStyle, color2 = options.color, columnWidthRatio = options.columnWidthRatio, isPercent = options.isPercent, isGroup = options.isGroup, isStack = options.isStack, xField = options.xField, yField = options.yField, seriesField = options.seriesField, groupField = options.groupField, tooltip2 = options.tooltip, shape = options.shape;
  var percentData = isPercent && isGroup && isStack ? getDeepPercent(data2, yField, [xField, groupField], yField) : getDataWhetherPecentage(data2, yField, xField, yField, isPercent);
  var chartData = [];
  if (isStack && seriesField && !isGroup) {
    percentData.forEach(function(item) {
      var stackedItem = chartData.find(function(v) {
        return v[xField] === item[xField] && v[seriesField] === item[seriesField];
      });
      if (stackedItem) {
        stackedItem[yField] += item[yField] || 0;
      } else {
        chartData.push(__assign$1({}, item));
      }
    });
  } else {
    chartData = percentData;
  }
  chart.data(chartData);
  var tooltipOptions = isPercent ? __assign$1({ formatter: function(datum) {
    return {
      name: isGroup && isStack ? datum[seriesField] + " - " + datum[groupField] : datum[seriesField] || datum[xField],
      value: (Number(datum[yField]) * 100).toFixed(2) + "%"
    };
  } }, tooltip2) : tooltip2;
  var p = deepAssign({}, params, {
    options: {
      data: chartData,
      widthRatio: columnWidthRatio,
      tooltip: tooltipOptions,
      interval: {
        shape,
        style: columnStyle,
        color: color2
      }
    }
  });
  interval(p);
  return p;
}
function meta$k(params) {
  var _a2, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, data2 = options.data, isPercent = options.isPercent;
  var percentYMeta = isPercent ? { max: 1, min: 0, minLimit: 0, maxLimit: 1 } : {};
  return flow(scale$1((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2), (_b = {}, _b[xField] = {
    type: "cat"
  }, _b[yField] = __assign$1(__assign$1({}, adjustYMetaByZero(data2, yField)), percentYMeta), _b)))(params);
}
function axis$j(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function legend$e(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, seriesField = options.seriesField;
  if (legend2 && seriesField) {
    chart.legend(seriesField, legend2);
  } else if (legend2 === false) {
    chart.legend(false);
  }
  return params;
}
function label$c(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField, isRange = options.isRange;
  var geometry2 = findGeometry(chart, "interval");
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    geometry2.label({
      fields: [yField],
      callback,
      cfg: __assign$1({
        layout: (cfg === null || cfg === void 0 ? void 0 : cfg.position) ? void 0 : [
          { type: "interval-adjust-position" },
          { type: "interval-hide-overlap" },
          { type: "adjust-color" },
          { type: "limit-in-plot", cfg: { action: "hide" } }
        ]
      }, transformLabel(isRange ? __assign$1({ content: function(item) {
        var _a2;
        return (_a2 = item[yField]) === null || _a2 === void 0 ? void 0 : _a2.join("-");
      } }, cfg) : cfg))
    });
  }
  return params;
}
function columnTooltip(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip, isGroup = options.isGroup, isStack = options.isStack, groupField = options.groupField, data2 = options.data, xField = options.xField, yField = options.yField, seriesField = options.seriesField;
  if (tooltip2 === false) {
    chart.tooltip(false);
  } else {
    var tooltipOptions = tooltip2;
    if (isGroup && isStack) {
      var tooltipFormatter_1 = (tooltipOptions === null || tooltipOptions === void 0 ? void 0 : tooltipOptions.formatter) || function(datum) {
        return { name: datum[seriesField] + " - " + datum[groupField], value: datum[yField] };
      };
      tooltipOptions = __assign$1(__assign$1({}, tooltipOptions), { customItems: function(originalItems) {
        var items = [];
        each$1(originalItems, function(item) {
          var datas = filter(data2, function(d) {
            return isMatch(d, pick(item.data, [xField, seriesField]));
          });
          datas.forEach(function(datum) {
            items.push(__assign$1(__assign$1(__assign$1({}, item), { value: datum[yField], data: datum, mappingData: { _origin: datum } }), tooltipFormatter_1(datum)));
          });
        });
        return items;
      } });
    }
    chart.tooltip(tooltipOptions);
  }
  return params;
}
function adaptor$w(params, isBar) {
  if (isBar === void 0) {
    isBar = false;
  }
  var options = params.options;
  var seriesField = options.seriesField;
  return flow(defaultOptions$5, theme$2, pattern("columnStyle"), state, geometry$t, meta$k, axis$j, legend$e, columnTooltip, slider$1, scrollbar, label$c, brushInteraction, interaction$6, animation$5, annotation$2(), conversionTag$3(options.yField, !isBar, !!seriesField), connectedArea(!options.isStack), limitInPlot$2)(params);
}
var DEFAULT_OPTIONS$x = deepAssign({}, Plot.getDefaultOptions(), {
  columnWidthRatio: 0.6,
  marginRatio: 1 / 32,
  tooltip: {
    shared: true,
    showMarkers: false,
    offset: 20
  },
  interactions: [{ type: "active-region" }]
});
var Column = function(_super) {
  __extends$2(Column2, _super);
  function Column2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "column";
    return _this;
  }
  Column2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$x;
  };
  Column2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = this.options, yField = _a2.yField, xField = _a2.xField, isPercent = _a2.isPercent;
    var _b = this, chart = _b.chart, options = _b.options;
    meta$k({ chart, options });
    this.chart.changeData(getDataWhetherPecentage(data2, yField, xField, yField, isPercent));
  };
  Column2.prototype.getDefaultOptions = function() {
    return Column2.getDefaultOptions();
  };
  Column2.prototype.getSchemaAdaptor = function() {
    return adaptor$w;
  };
  return Column2;
}(Plot);
function transformBarData(data2) {
  return data2 ? data2.slice().reverse() : data2;
}
function adaptor$v(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis, barStyle = options.barStyle, barWidthRatio = options.barWidthRatio, label2 = options.label, data2 = options.data, seriesField = options.seriesField, isStack = options.isStack, minBarWidth = options.minBarWidth, maxBarWidth = options.maxBarWidth;
  if (label2 && !label2.position) {
    label2.position = "left";
    if (!label2.layout) {
      label2.layout = [
        { type: "interval-adjust-position" },
        { type: "interval-hide-overlap" },
        { type: "adjust-color" },
        { type: "limit-in-plot", cfg: { action: "hide" } }
      ];
    }
  }
  var legend2 = options.legend;
  if (seriesField) {
    if (legend2 !== false) {
      legend2 = __assign$1({ position: isStack ? "top-left" : "right-top", reversed: isStack ? false : true }, legend2 || {});
    }
  } else {
    legend2 = false;
  }
  params.options.legend = legend2;
  var tooltip2 = options.tooltip;
  if (seriesField) {
    if (tooltip2 !== false) {
      tooltip2 = __assign$1({ reversed: isStack ? false : true }, tooltip2 || {});
    }
  }
  params.options.tooltip = tooltip2;
  chart.coordinate().transpose();
  return adaptor$w({
    chart,
    options: __assign$1(__assign$1({}, options), {
      label: label2,
      xField: yField,
      yField: xField,
      xAxis: yAxis,
      yAxis: xAxis,
      columnStyle: barStyle,
      columnWidthRatio: barWidthRatio,
      minColumnWidth: minBarWidth,
      maxColumnWidth: maxBarWidth,
      columnBackground: options.barBackground,
      data: transformBarData(data2)
    })
  }, true);
}
var DEFAULT_OPTIONS$w = deepAssign({}, Plot.getDefaultOptions(), {
  barWidthRatio: 0.6,
  marginRatio: 1 / 32,
  tooltip: {
    shared: true,
    showMarkers: false,
    offset: 20
  },
  interactions: [{ type: "active-region" }]
});
var Bar = function(_super) {
  __extends$2(Bar2, _super);
  function Bar2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "bar";
    return _this;
  }
  Bar2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$w;
  };
  Bar2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = this, chart = _a2.chart, options = _a2.options;
    var xField = options.xField, yField = options.yField, isPercent = options.isPercent;
    var switchedFieldOptions = __assign$1(__assign$1({}, options), { xField: yField, yField: xField });
    meta$k({ chart, options: switchedFieldOptions });
    chart.changeData(getDataWhetherPecentage(transformBarData(data2), xField, yField, xField, isPercent));
  };
  Bar2.prototype.getDefaultOptions = function() {
    return Bar2.getDefaultOptions();
  };
  Bar2.prototype.getSchemaAdaptor = function() {
    return adaptor$v;
  };
  return Bar2;
}(Plot);
var DEFAULT_OPTIONS$v = deepAssign({}, Plot.getDefaultOptions(), {
  legend: {
    position: "right"
  },
  tooltip: {
    shared: false,
    showTitle: false,
    showMarkers: false
  },
  label: {
    layout: { type: "limit-in-plot", cfg: { action: "ellipsis" } }
  },
  pieStyle: {
    stroke: "white",
    lineWidth: 1
  },
  statistic: {
    title: {
      style: { fontWeight: 300, color: "#4B535E", textAlign: "center", fontSize: "20px", lineHeight: 1 }
    },
    content: {
      style: {
        fontWeight: "bold",
        color: "rgba(44,53,66,0.85)",
        textAlign: "center",
        fontSize: "32px",
        lineHeight: 1
      }
    }
  },
  theme: {
    components: {
      annotation: {
        text: {
          animate: false
        }
      }
    }
  }
});
function getTotalValue(data2, field2) {
  var total = null;
  each$1(data2, function(item) {
    if (typeof item[field2] === "number") {
      total += item[field2];
    }
  });
  return total;
}
function adaptOffset(type, offset) {
  var defaultOffset;
  switch (type) {
    case "inner":
      defaultOffset = "-30%";
      if (isString(offset) && offset.endsWith("%")) {
        return parseFloat(offset) * 0.01 > 0 ? defaultOffset : offset;
      }
      return offset < 0 ? offset : defaultOffset;
    case "outer":
      defaultOffset = 12;
      if (isString(offset) && offset.endsWith("%")) {
        return parseFloat(offset) * 0.01 < 0 ? defaultOffset : offset;
      }
      return offset > 0 ? offset : defaultOffset;
    default:
      return offset;
  }
}
function isAllZero(data2, angleField) {
  return every(processIllegalData(data2, angleField), function(d) {
    return d[angleField] === 0;
  });
}
var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function transform$2(actions, matrix) {
  var ulMatrix = matrix ? __spreadArrays(matrix) : __spreadArrays(ORIGIN_MATRIX);
  return Util.transform(ulMatrix, actions);
}
var PieLegendAction = function(_super) {
  __extends$2(PieLegendAction2, _super);
  function PieLegendAction2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PieLegendAction2.prototype.getActiveElements = function() {
    var delegateObject = Util.getDelegationObject(this.context);
    if (delegateObject) {
      var view = this.context.view;
      var component2 = delegateObject.component, item_1 = delegateObject.item;
      var field_1 = component2.get("field");
      if (field_1) {
        var elements = view.geometries[0].elements;
        return elements.filter(function(ele) {
          return ele.getModel().data[field_1] === item_1.value;
        });
      }
    }
    return [];
  };
  PieLegendAction2.prototype.getActiveElementLabels = function() {
    var view = this.context.view;
    var elements = this.getActiveElements();
    var labels = view.geometries[0].labelsContainer.getChildren();
    return labels.filter(function(label2) {
      return elements.find(function(ele) {
        return isEqual$2(ele.getData(), label2.get("data"));
      });
    });
  };
  PieLegendAction2.prototype.transfrom = function(offset) {
    if (offset === void 0) {
      offset = 7.5;
    }
    var elements = this.getActiveElements();
    var elementLabels = this.getActiveElementLabels();
    elements.forEach(function(element, idx) {
      var labelShape = elementLabels[idx];
      var coordinate2 = element.geometry.coordinate;
      if (coordinate2.isPolar && coordinate2.isTransposed) {
        var _a2 = Util.getAngle(element.getModel(), coordinate2), startAngle = _a2.startAngle, endAngle = _a2.endAngle;
        var middleAngle = (startAngle + endAngle) / 2;
        var r = offset;
        var x = r * Math.cos(middleAngle);
        var y = r * Math.sin(middleAngle);
        element.shape.setMatrix(transform$2([["t", x, y]]));
        labelShape.setMatrix(transform$2([["t", x, y]]));
      }
    });
  };
  PieLegendAction2.prototype.active = function() {
    this.transfrom();
  };
  PieLegendAction2.prototype.reset = function() {
    this.transfrom(0);
  };
  return PieLegendAction2;
}(Action);
function getCurrentElement(context) {
  var event = context.event;
  var element;
  var target = event.target;
  if (target) {
    element = target.get("element");
  }
  return element;
}
var StatisticAction = function(_super) {
  __extends$2(StatisticAction2, _super);
  function StatisticAction2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  StatisticAction2.prototype.getAnnotations = function(_view) {
    var view = _view || this.context.view;
    return view.getController("annotation").option;
  };
  StatisticAction2.prototype.getInitialAnnotation = function() {
    return this.initialAnnotation;
  };
  StatisticAction2.prototype.init = function() {
    var _this = this;
    var view = this.context.view;
    view.removeInteraction("tooltip");
    view.on("afterchangesize", function() {
      var annotations = _this.getAnnotations(view);
      _this.initialAnnotation = annotations;
    });
  };
  StatisticAction2.prototype.change = function(arg) {
    var _a2 = this.context, view = _a2.view, event = _a2.event;
    if (!this.initialAnnotation) {
      this.initialAnnotation = this.getAnnotations();
    }
    var data2 = get(event, ["data", "data"]);
    if (event.type.match("legend-item")) {
      var delegateObject = Util.getDelegationObject(this.context);
      var colorField_1 = view.getGroupedFields()[0];
      if (delegateObject && colorField_1) {
        var item_1 = delegateObject.item;
        data2 = view.getData().find(function(d) {
          return d[colorField_1] === item_1.value;
        });
      }
    }
    if (data2) {
      var annotations = get(arg, "annotations", []);
      var statistic2 = get(arg, "statistic", {});
      view.getController("annotation").clear(true);
      each$1(annotations, function(annotation2) {
        if (typeof annotation2 === "object") {
          view.annotation()[annotation2.type](annotation2);
        }
      });
      renderStatistic(view, { statistic: statistic2, plotType: "pie" }, data2);
      view.render(true);
    }
    var ele = getCurrentElement(this.context);
    if (ele) {
      ele.shape.toFront();
    }
  };
  StatisticAction2.prototype.reset = function() {
    var view = this.context.view;
    var annotationController = view.getController("annotation");
    annotationController.clear(true);
    var initialStatistic = this.getInitialAnnotation();
    each$1(initialStatistic, function(a) {
      view.annotation()[a.type](a);
    });
    view.render(true);
  };
  return StatisticAction2;
}(Action);
var PIE_STATISTIC = "pie-statistic";
registerAction(PIE_STATISTIC, StatisticAction);
registerInteraction("pie-statistic-active", {
  start: [{ trigger: "element:mouseenter", action: "pie-statistic:change" }],
  end: [{ trigger: "element:mouseleave", action: "pie-statistic:reset" }]
});
registerAction("pie-legend", PieLegendAction);
registerInteraction("pie-legend-active", {
  start: [{ trigger: "legend-item:mouseenter", action: "pie-legend:active" }],
  end: [{ trigger: "legend-item:mouseleave", action: "pie-legend:reset" }]
});
function geometry$s(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, angleField = options.angleField, colorField = options.colorField, color2 = options.color, pieStyle = options.pieStyle;
  var processData2 = processIllegalData(data2, angleField);
  if (isAllZero(processData2, angleField)) {
    var percentageField_1 = "$$percentage$$";
    processData2 = processData2.map(function(d) {
      var _a2;
      return __assign$1(__assign$1({}, d), (_a2 = {}, _a2[percentageField_1] = 1 / processData2.length, _a2));
    });
    chart.data(processData2);
    var p = deepAssign({}, params, {
      options: {
        xField: "1",
        yField: percentageField_1,
        seriesField: colorField,
        isStack: true,
        interval: {
          color: color2,
          style: pieStyle
        },
        args: {
          zIndexReversed: true
        }
      }
    });
    interval(p);
  } else {
    chart.data(processData2);
    var p = deepAssign({}, params, {
      options: {
        xField: "1",
        yField: angleField,
        seriesField: colorField,
        isStack: true,
        interval: {
          color: color2,
          style: pieStyle
        },
        args: {
          zIndexReversed: true
        }
      }
    });
    interval(p);
  }
  return params;
}
function meta$j(params) {
  var _a2;
  var chart = params.chart, options = params.options;
  var meta2 = options.meta, colorField = options.colorField;
  var scales = deepAssign({}, meta2);
  chart.scale(scales, (_a2 = {}, _a2[colorField] = { type: "cat" }, _a2));
  return params;
}
function coordinate$7(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate({
    type: "theta",
    cfg: {
      radius,
      innerRadius,
      startAngle,
      endAngle
    }
  });
  return params;
}
function label$b(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, colorField = options.colorField, angleField = options.angleField;
  var geometry2 = chart.geometries[0];
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    var labelCfg = transformLabel(cfg);
    if (labelCfg.content) {
      var content_1 = labelCfg.content;
      labelCfg.content = function(data2, dataum, index2) {
        var name = data2[colorField];
        var value2 = data2[angleField];
        var angleScale = chart.getScaleByField(angleField);
        var percent2 = angleScale === null || angleScale === void 0 ? void 0 : angleScale.scale(value2);
        return isFunction(content_1) ? content_1(__assign$1(__assign$1({}, data2), { percent: percent2 }), dataum, index2) : isString(content_1) ? template(content_1, {
          value: value2,
          name,
          percentage: isNumber$1(percent2) && !isNil(value2) ? (percent2 * 100).toFixed(2) + "%" : null
        }) : content_1;
      };
    }
    var LABEL_LAYOUT_TYPE_MAP = {
      inner: "",
      outer: "pie-outer",
      spider: "pie-spider"
    };
    var labelLayoutType = labelCfg.type ? LABEL_LAYOUT_TYPE_MAP[labelCfg.type] : "pie-outer";
    var labelLayoutCfg = labelCfg.layout ? !isArray$1(labelCfg.layout) ? [labelCfg.layout] : labelCfg.layout : [];
    labelCfg.layout = (labelLayoutType ? [{ type: labelLayoutType }] : []).concat(labelLayoutCfg);
    geometry2.label({
      fields: colorField ? [angleField, colorField] : [angleField],
      callback,
      cfg: __assign$1(__assign$1({}, labelCfg), { offset: adaptOffset(labelCfg.type, labelCfg.offset), type: "pie" })
    });
  }
  return params;
}
function transformStatisticOptions(options) {
  var innerRadius = options.innerRadius, statistic2 = options.statistic, angleField = options.angleField, colorField = options.colorField, meta2 = options.meta, locale = options.locale;
  var i18n = getLocale(locale);
  if (innerRadius && statistic2) {
    var _a2 = deepAssign({}, DEFAULT_OPTIONS$v.statistic, statistic2), titleOpt_1 = _a2.title, contentOpt_1 = _a2.content;
    if (titleOpt_1 !== false) {
      titleOpt_1 = deepAssign({}, {
        formatter: function(datum) {
          if (datum) {
            return datum[colorField];
          }
          return !isNil(titleOpt_1.content) ? titleOpt_1.content : i18n.get(["statistic", "total"]);
        }
      }, titleOpt_1);
    }
    if (contentOpt_1 !== false) {
      contentOpt_1 = deepAssign({}, {
        formatter: function(datum, data2) {
          var dataValue = datum ? datum[angleField] : getTotalValue(data2, angleField);
          var metaFormatter = get(meta2, [angleField, "formatter"]) || function(v) {
            return v;
          };
          if (datum) {
            return metaFormatter(dataValue);
          }
          return !isNil(contentOpt_1.content) ? contentOpt_1.content : metaFormatter(dataValue);
        }
      }, contentOpt_1);
    }
    return deepAssign({}, { statistic: { title: titleOpt_1, content: contentOpt_1 } }, options);
  }
  return options;
}
function pieAnnotation(params) {
  var chart = params.chart, options = params.options;
  var _a2 = transformStatisticOptions(options), innerRadius = _a2.innerRadius, statistic2 = _a2.statistic;
  chart.getController("annotation").clear(true);
  flow(annotation$2())(params);
  if (innerRadius && statistic2) {
    renderStatistic(chart, { statistic: statistic2, plotType: "pie" });
  }
  return params;
}
function tooltip$7(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip, colorField = options.colorField, angleField = options.angleField, data2 = options.data;
  if (tooltip2 === false) {
    chart.tooltip(tooltip2);
  } else {
    chart.tooltip(deepAssign({}, tooltip2, { shared: false }));
    if (isAllZero(data2, angleField)) {
      var fields = get(tooltip2, "fields");
      var formatter = get(tooltip2, "formatter");
      if (isEmpty(get(tooltip2, "fields"))) {
        fields = [colorField, angleField];
        formatter = formatter || function(datum) {
          return { name: datum[colorField], value: toString$2(datum[angleField]) };
        };
      }
      chart.geometries[0].tooltip(fields.join("*"), getMappingFunction(fields, formatter));
    }
  }
  return params;
}
function interaction$5(params) {
  var chart = params.chart, options = params.options;
  var _a2 = transformStatisticOptions(options), interactions = _a2.interactions, statistic2 = _a2.statistic, annotations = _a2.annotations;
  each$1(interactions, function(i) {
    var _a3, _b;
    if (i.enable === false) {
      chart.removeInteraction(i.type);
    } else if (i.type === "pie-statistic-active") {
      var startStages_1 = [];
      if (!((_a3 = i.cfg) === null || _a3 === void 0 ? void 0 : _a3.start)) {
        startStages_1 = [
          {
            trigger: "element:mouseenter",
            action: PIE_STATISTIC + ":change",
            arg: { statistic: statistic2, annotations }
          }
        ];
      }
      each$1((_b = i.cfg) === null || _b === void 0 ? void 0 : _b.start, function(stage) {
        startStages_1.push(__assign$1(__assign$1({}, stage), { arg: { statistic: statistic2, annotations } }));
      });
      chart.interaction(i.type, deepAssign({}, i.cfg, { start: startStages_1 }));
    } else {
      chart.interaction(i.type, i.cfg || {});
    }
  });
  return params;
}
function adaptor$u(params) {
  return flow(pattern("pieStyle"), geometry$s, meta$j, theme$2, coordinate$7, legend$g, tooltip$7, label$b, state, pieAnnotation, interaction$5, animation$5)(params);
}
var Pie = function(_super) {
  __extends$2(Pie2, _super);
  function Pie2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "pie";
    return _this;
  }
  Pie2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$v;
  };
  Pie2.prototype.changeData = function(data2) {
    this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    var prevOptions = this.options;
    var angleField = this.options.angleField;
    var prevData = processIllegalData(prevOptions.data, angleField);
    var curData = processIllegalData(data2, angleField);
    if (isAllZero(prevData, angleField) || isAllZero(curData, angleField)) {
      this.update({ data: data2 });
    } else {
      this.updateOption({ data: data2 });
      this.chart.data(curData);
      pieAnnotation({ chart: this.chart, options: this.options });
      this.chart.render(true);
    }
    this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  Pie2.prototype.getDefaultOptions = function() {
    return Pie2.getDefaultOptions();
  };
  Pie2.prototype.getSchemaAdaptor = function() {
    return adaptor$u;
  };
  return Pie2;
}(Plot);
function geometry$r(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, sectorStyle = options.sectorStyle, color2 = options.color;
  chart.data(data2);
  flow(interval)(deepAssign({}, params, {
    options: {
      marginRatio: 1,
      interval: {
        style: sectorStyle,
        color: color2
      }
    }
  }));
  return params;
}
function label$a(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, xField = options.xField;
  var geometry2 = findGeometry(chart, "interval");
  if (label2 === false) {
    geometry2.label(false);
  } else if (isObject(label2)) {
    var callback = label2.callback, fields = label2.fields, cfg = __rest(label2, ["callback", "fields"]);
    var offset = cfg.offset;
    var layout = cfg.layout;
    if (offset === void 0 || offset >= 0) {
      layout = layout ? isArray$1(layout) ? layout : [layout] : [];
      cfg.layout = filter(layout, function(v) {
        return v.type !== "limit-in-shape";
      });
      cfg.layout.length || delete cfg.layout;
    }
    geometry2.label({
      fields: fields || [xField],
      callback,
      cfg: transformLabel(cfg)
    });
  } else {
    log(LEVEL.WARN, label2 === null, "the label option must be an Object.");
    geometry2.label({ fields: [xField] });
  }
  return params;
}
function legend$d(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, seriesField = options.seriesField;
  if (legend2 === false) {
    chart.legend(false);
  } else if (seriesField) {
    chart.legend(seriesField, legend2);
  }
  return params;
}
function coordinate$6(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate({
    type: "polar",
    cfg: {
      radius,
      innerRadius,
      startAngle,
      endAngle
    }
  });
  return params;
}
function meta$i(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale$1((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2)))(params);
}
function axis$i(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (!xAxis) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (!yAxis) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function adaptor$t(params) {
  flow(pattern("sectorStyle"), geometry$r, meta$i, label$a, coordinate$6, axis$i, legend$d, tooltip$8, interaction$6, animation$5, theme$2, annotation$2(), state)(params);
}
var DEFAULT_OPTIONS$u = deepAssign({}, Plot.getDefaultOptions(), {
  xAxis: false,
  yAxis: false,
  legend: {
    position: "right"
  },
  sectorStyle: {
    stroke: "#fff",
    lineWidth: 1
  },
  label: {
    layout: {
      type: "limit-in-shape"
    }
  },
  tooltip: {
    shared: true,
    showMarkers: false
  },
  interactions: [{ type: "active-region" }]
});
(function(_super) {
  __extends$2(Rose, _super);
  function Rose() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "rose";
    return _this;
  }
  Rose.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$u;
  };
  Rose.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    this.chart.changeData(data2);
  };
  Rose.prototype.getDefaultOptions = function() {
    return Rose.getDefaultOptions();
  };
  Rose.prototype.getSchemaAdaptor = function() {
    return adaptor$t;
  };
  return Rose;
})(Plot);
var DEFAULT_OPTIONS$t = {
  font: function() {
    return "serif";
  },
  padding: 1,
  size: [500, 500],
  spiral: "archimedean",
  timeInterval: 3e3
};
function wordCloud(words, options) {
  options = mix({}, DEFAULT_OPTIONS$t, options);
  return transform$1(words, options);
}
function transform$1(words, options) {
  var layout = tagCloud();
  ["font", "fontSize", "fontWeight", "padding", "rotate", "size", "spiral", "timeInterval", "random"].forEach(function(key) {
    if (!isNil(options[key])) {
      layout[key](options[key]);
    }
  });
  layout.words(words);
  if (options.imageMask) {
    layout.createMask(options.imageMask);
  }
  var result = layout.start();
  var tags = result._tags;
  tags.forEach(function(tag) {
    tag.x += options.size[0] / 2;
    tag.y += options.size[1] / 2;
  });
  var _a2 = options.size, w = _a2[0], h = _a2[1];
  tags.push({
    text: "",
    value: 0,
    x: 0,
    y: 0,
    opacity: 0
  });
  tags.push({
    text: "",
    value: 0,
    x: w,
    y: h,
    opacity: 0
  });
  return tags;
}
var cloudRadians = Math.PI / 180, cw = 1 << 11 >> 5, ch = 1 << 11;
function cloudText(d) {
  return d.text;
}
function cloudFont() {
  return "serif";
}
function cloudFontNormal() {
  return "normal";
}
function cloudFontSize(d) {
  return d.value;
}
function cloudRotate() {
  return ~~(Math.random() * 2) * 90;
}
function cloudPadding() {
  return 1;
}
function cloudSprite(contextAndRatio, d, data2, di) {
  if (d.sprite)
    return;
  var c = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x = 0, y = 0, maxh = 0;
  var n = data2.length;
  --di;
  while (++di < n) {
    d = data2[di];
    c.save();
    c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
    var w = c.measureText(d.text + "m").width * ratio, h = d.size << 1;
    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians), cr = Math.cos(d.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w = w + 31 >> 5 << 5;
    }
    if (h > maxh)
      maxh = h;
    if (x + w >= cw << 5) {
      x = 0;
      y += maxh;
      maxh = 0;
    }
    if (y + h >= ch)
      break;
    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
    if (d.rotate)
      c.rotate(d.rotate * cloudRadians);
    c.fillText(d.text, 0, 0);
    if (d.padding) {
      c.lineWidth = 2 * d.padding;
      c.strokeText(d.text, 0, 0);
    }
    c.restore();
    d.width = w;
    d.height = h;
    d.xoff = x;
    d.yoff = y;
    d.x1 = w >> 1;
    d.y1 = h >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x += w;
  }
  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d = data2[di];
    if (!d.hasText)
      continue;
    var w = d.width, w32 = w >> 5;
    var h = d.y1 - d.y0;
    for (var i = 0; i < h * w32; i++)
      sprite[i] = 0;
    x = d.xoff;
    if (x == null)
      return;
    y = d.yoff;
    var seen = 0, seenRow = -1;
    for (var j = 0; j < h; j++) {
      for (var i = 0; i < w; i++) {
        var k = w32 * j + (i >> 5), m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k] |= m;
        seen |= m;
      }
      if (seen)
        seenRow = j;
      else {
        d.y0++;
        h--;
        j--;
        y++;
      }
    }
    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
  var x = (tag.y + tag.y0) * sw + (lx >> 5), last2;
  for (var j = 0; j < h; j++) {
    last2 = 0;
    for (var i = 0; i <= w; i++) {
      if ((last2 << msx | (i < w ? (last2 = sprite[j * w + i]) >>> sx : 0)) & board[x + i])
        return true;
    }
    x += sw;
  }
  return false;
}
function cloudBounds(bounds, d) {
  var b0 = bounds[0], b1 = bounds[1];
  if (d.x + d.x0 < b0.x)
    b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y)
    b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x)
    b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y)
    b1.y = d.y + d.y1;
}
function collideRects(a, b) {
  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}
function archimedeanSpiral(size2) {
  var e = size2[0] / size2[1];
  return function(t) {
    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function rectangularSpiral(size2) {
  var dy = 4, dx = dy * size2[0] / size2[1];
  var x = 0, y = 0;
  return function(t) {
    var sign = t < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {
      case 0:
        x += dx;
        break;
      case 1:
        y += dy;
        break;
      case 2:
        x -= dx;
        break;
      default:
        y -= dy;
        break;
    }
    return [x, y];
  };
}
function zeroArray(n) {
  var a = [];
  var i = -1;
  while (++i < n)
    a[i] = 0;
  return a;
}
function cloudCanvas() {
  return document.createElement("canvas");
}
function functor(d) {
  return isFunction(d) ? d : function() {
    return d;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
function tagCloud() {
  var size2 = [256, 256], font = cloudFont, fontSize = cloudFontSize, fontWeight = cloudFontNormal, rotate2 = cloudRotate, padding2 = cloudPadding, spiral = archimedeanSpiral, random = Math.random, words = [], timeInterval = Infinity;
  var text2 = cloudText;
  var fontStyle = cloudFontNormal;
  var canvas = cloudCanvas;
  var cloud = {};
  cloud.start = function() {
    var width = size2[0], height = size2[1];
    var contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size2[0] >> 5) * size2[1]), n = words.length, tags = [], data2 = words.map(function(d, i2, data3) {
      d.text = text2.call(this, d, i2, data3);
      d.font = font.call(this, d, i2, data3);
      d.style = fontStyle.call(this, d, i2, data3);
      d.weight = fontWeight.call(this, d, i2, data3);
      d.rotate = rotate2.call(this, d, i2, data3);
      d.size = ~~fontSize.call(this, d, i2, data3);
      d.padding = padding2.call(this, d, i2, data3);
      return d;
    }).sort(function(a, b) {
      return b.size - a.size;
    });
    var i = -1, bounds = !cloud.board ? null : [
      {
        x: 0,
        y: 0
      },
      {
        x: width,
        y: height
      }
    ];
    step();
    function step() {
      var start = Date.now();
      while (Date.now() - start < timeInterval && ++i < n) {
        var d = data2[i];
        d.x = width * (random() + 0.5) >> 1;
        d.y = height * (random() + 0.5) >> 1;
        cloudSprite(contextAndRatio, d, data2, i);
        if (d.hasText && place(board, d, bounds)) {
          tags.push(d);
          if (bounds) {
            if (!cloud.hasImage) {
              cloudBounds(bounds, d);
            }
          } else {
            bounds = [
              { x: d.x + d.x0, y: d.y + d.y0 },
              { x: d.x + d.x1, y: d.y + d.y1 }
            ];
          }
          d.x -= size2[0] >> 1;
          d.y -= size2[1] >> 1;
        }
      }
      cloud._tags = tags;
      cloud._bounds = bounds;
    }
    return cloud;
  };
  function getContext(canvas2) {
    canvas2.width = canvas2.height = 1;
    var ratio = Math.sqrt(canvas2.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas2.width = (cw << 5) / ratio;
    canvas2.height = ch / ratio;
    var context = canvas2.getContext("2d");
    context.fillStyle = context.strokeStyle = "red";
    context.textAlign = "center";
    return { context, ratio };
  }
  function place(board, tag, bounds) {
    var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size2[0] * size2[0] + size2[1] * size2[1]), s = spiral(size2), dt = random() < 0.5 ? 1 : -1;
    var dxdy, t = -dt, dx, dy;
    while (dxdy = s(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
        break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size2[0] || tag.y + tag.y1 > size2[1])
        continue;
      if (!bounds || !cloudCollide(tag, board, size2[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          var sprite = tag.sprite, w = tag.width >> 5, sw = size2[0] >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
          var last2 = void 0, x = (tag.y + tag.y0) * sw + (lx >> 5);
          for (var j = 0; j < h; j++) {
            last2 = 0;
            for (var i = 0; i <= w; i++) {
              board[x + i] |= last2 << msx | (i < w ? (last2 = sprite[j * w + i]) >>> sx : 0);
            }
            x += sw;
          }
          delete tag.sprite;
          return true;
        }
      }
    }
    return false;
  }
  cloud.createMask = function(img) {
    var can = document.createElement("canvas");
    var width = size2[0], height = size2[1];
    if (!width || !height) {
      return;
    }
    var w32 = width >> 5;
    var board = zeroArray((width >> 5) * height);
    can.width = width;
    can.height = height;
    var cxt = can.getContext("2d");
    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
    var imageData = cxt.getImageData(0, 0, width, height).data;
    for (var j = 0; j < height; j++) {
      for (var i = 0; i < width; i++) {
        var k = w32 * j + (i >> 5);
        var tmp = j * width + i << 2;
        var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;
        var m = flag ? 1 << 31 - i % 32 : 0;
        board[k] |= m;
      }
    }
    cloud.board = board;
    cloud.hasImage = true;
  };
  cloud.timeInterval = function(_) {
    timeInterval = _ == null ? Infinity : _;
  };
  cloud.words = function(_) {
    words = _;
  };
  cloud.size = function(_) {
    size2 = [+_[0], +_[1]];
  };
  cloud.font = function(_) {
    font = functor(_);
  };
  cloud.fontWeight = function(_) {
    fontWeight = functor(_);
  };
  cloud.rotate = function(_) {
    rotate2 = functor(_);
  };
  cloud.spiral = function(_) {
    spiral = spirals[_] || _;
  };
  cloud.fontSize = function(_) {
    fontSize = functor(_);
  };
  cloud.padding = function(_) {
    padding2 = functor(_);
  };
  cloud.random = function(_) {
    random = functor(_);
  };
  return cloud;
}
function transform(params) {
  var rawOptions = params.options, chart = params.chart;
  var _a2 = chart, width = _a2.width, height = _a2.height, chartPadding = _a2.padding, appendPadding = _a2.appendPadding, ele = _a2.ele;
  var data2 = rawOptions.data, imageMask = rawOptions.imageMask, wordField = rawOptions.wordField, weightField = rawOptions.weightField, colorField = rawOptions.colorField, wordStyle = rawOptions.wordStyle, timeInterval = rawOptions.timeInterval, random = rawOptions.random, spiral = rawOptions.spiral, _b = rawOptions.autoFit, autoFit = _b === void 0 ? true : _b, placementStrategy = rawOptions.placementStrategy;
  if (!data2 || !data2.length) {
    return [];
  }
  var fontFamily = wordStyle.fontFamily, fontWeight = wordStyle.fontWeight, padding2 = wordStyle.padding, fontSize = wordStyle.fontSize;
  var arr = getSingleKeyValues(data2, weightField);
  var range = [min(arr), max(arr)];
  var words = data2.map(function(datum) {
    return {
      text: datum[wordField],
      value: datum[weightField],
      color: datum[colorField],
      datum
    };
  });
  var options = {
    imageMask,
    font: fontFamily,
    fontSize: getFontSizeMapping(fontSize, range),
    fontWeight,
    size: getSize({
      width,
      height,
      padding: chartPadding,
      appendPadding,
      autoFit,
      container: ele
    }),
    padding: padding2,
    timeInterval,
    random,
    spiral,
    rotate: getRotate(rawOptions)
  };
  if (isFunction(placementStrategy)) {
    var result = words.map(function(word, index2, words2) {
      return __assign$1(__assign$1(__assign$1({}, word), { hasText: !!word.text, font: functor(options.font)(word, index2, words2), weight: functor(options.fontWeight)(word, index2, words2), rotate: functor(options.rotate)(word, index2, words2), size: functor(options.fontSize)(word, index2, words2), style: "normal" }), placementStrategy.call(chart, word, index2, words2));
    });
    result.push({
      text: "",
      value: 0,
      x: 0,
      y: 0,
      opacity: 0
    });
    result.push({
      text: "",
      value: 0,
      x: options.size[0],
      y: options.size[1],
      opacity: 0
    });
    return result;
  }
  return wordCloud(words, options);
}
function getSize(options) {
  var width = options.width, height = options.height;
  var container = options.container, autoFit = options.autoFit, padding2 = options.padding, appendPadding = options.appendPadding;
  if (autoFit) {
    var containerSize = getContainerSize(container);
    width = containerSize.width;
    height = containerSize.height;
  }
  width = width || 400;
  height = height || 400;
  var _a2 = resolvePadding({ padding: padding2, appendPadding }), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
  var result = [width - (left2 + right2), height - (top + bottom)];
  return result;
}
function resolvePadding(options) {
  var padding2 = normalPadding(options.padding);
  var appendPadding = normalPadding(options.appendPadding);
  var top = padding2[0] + appendPadding[0];
  var right2 = padding2[1] + appendPadding[1];
  var bottom = padding2[2] + appendPadding[2];
  var left2 = padding2[3] + appendPadding[3];
  return [top, right2, bottom, left2];
}
function processImageMask(img) {
  return new Promise(function(res, rej) {
    if (img instanceof HTMLImageElement) {
      res(img);
      return;
    }
    if (isString(img)) {
      var image_1 = new Image();
      image_1.crossOrigin = "anonymous";
      image_1.src = img;
      image_1.onload = function() {
        res(image_1);
      };
      image_1.onerror = function() {
        log(LEVEL.ERROR, false, "image %s load failed !!!", img);
        rej();
      };
      return;
    }
    log(LEVEL.WARN, img === void 0, "The type of imageMask option must be String or HTMLImageElement.");
    rej();
  });
}
function getFontSizeMapping(fontSize, range) {
  if (isFunction(fontSize)) {
    return fontSize;
  }
  if (isArray$1(fontSize)) {
    var fMin_1 = fontSize[0], fMax_1 = fontSize[1];
    if (!range) {
      return function() {
        return (fMax_1 + fMin_1) / 2;
      };
    }
    var min_1 = range[0], max_1 = range[1];
    if (max_1 === min_1) {
      return function() {
        return (fMax_1 + fMin_1) / 2;
      };
    }
    return function fontSize2(_a2) {
      var value2 = _a2.value;
      return (fMax_1 - fMin_1) / (max_1 - min_1) * (value2 - min_1) + fMin_1;
    };
  }
  return function() {
    return fontSize;
  };
}
function getSingleKeyValues(data2, key) {
  return data2.map(function(v) {
    return v[key];
  }).filter(function(v) {
    if (typeof v === "number" && !isNaN(v))
      return true;
    return false;
  });
}
function getRotate(options) {
  var _a2 = resolveRotate(options), rotation = _a2.rotation, rotationSteps = _a2.rotationSteps;
  if (!isArray$1(rotation))
    return rotation;
  var min2 = rotation[0];
  var max2 = rotation[1];
  var perSize = rotationSteps === 1 ? 0 : (max2 - min2) / (rotationSteps - 1);
  return function rotate2() {
    if (max2 === min2)
      return max2;
    return Math.floor(Math.random() * rotationSteps) * perSize;
  };
}
function resolveRotate(options) {
  var rotationSteps = options.wordStyle.rotationSteps;
  if (rotationSteps < 1) {
    log(LEVEL.WARN, false, "The rotationSteps option must be greater than or equal to 1.");
    rotationSteps = 1;
  }
  return {
    rotation: options.wordStyle.rotation,
    rotationSteps
  };
}
function min(numbers) {
  return Math.min.apply(Math, numbers);
}
function max(numbers) {
  return Math.max.apply(Math, numbers);
}
var WORD_CLOUD_COLOR_FIELD = "color";
var DEFAULT_OPTIONS$s = deepAssign({}, Plot.getDefaultOptions(), {
  timeInterval: 2e3,
  legend: false,
  tooltip: {
    showTitle: false,
    showMarkers: false,
    showCrosshairs: false,
    fields: ["text", "value", WORD_CLOUD_COLOR_FIELD],
    formatter: function(datum) {
      return { name: datum.text, value: datum.value };
    }
  },
  wordStyle: {
    fontFamily: "Verdana",
    fontWeight: "normal",
    padding: 1,
    fontSize: [12, 60],
    rotation: [0, 90],
    rotationSteps: 2,
    rotateRatio: 0.5
  }
});
function geometry$q(params) {
  var chart = params.chart, options = params.options;
  var colorField = options.colorField, color2 = options.color;
  var data2 = transform(params);
  chart.data(data2);
  var p = deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField && WORD_CLOUD_COLOR_FIELD,
      rawFields: isFunction(color2) && __spreadArrays(get(options, "rawFields", []), ["datum"]),
      point: {
        color: color2,
        shape: "word-cloud"
      }
    }
  });
  var ext = point(p).ext;
  ext.geometry.label(false);
  chart.coordinate().reflect("y");
  chart.axis(false);
  return params;
}
function meta$h(params) {
  return flow(scale$1({
    x: { nice: false },
    y: { nice: false }
  }))(params);
}
function legend$c(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, colorField = options.colorField;
  if (legend2 === false) {
    chart.legend(false);
  } else if (colorField) {
    chart.legend(WORD_CLOUD_COLOR_FIELD, legend2);
  }
  return params;
}
function adaptor$s(params) {
  flow(geometry$q, meta$h, tooltip$8, legend$c, interaction$6, animation$5, theme$2, state)(params);
}
registerShape("point", "word-cloud", {
  draw: function(cfg, group2) {
    var cx = cfg.x;
    var cy = cfg.y;
    var shape = group2.addShape("text", {
      attrs: __assign$1(__assign$1({}, getTextAttrs(cfg)), { x: cx, y: cy })
    });
    var rotate2 = cfg.data.rotate;
    if (typeof rotate2 === "number") {
      Util.rotate(shape, rotate2 * Math.PI / 180);
    }
    return shape;
  }
});
function getTextAttrs(cfg) {
  return {
    fontSize: cfg.data.size,
    text: cfg.data.text,
    textAlign: "center",
    fontFamily: cfg.data.font,
    fontWeight: cfg.data.weight,
    fill: cfg.color || cfg.defaultStyle.stroke,
    textBaseline: "alphabetic"
  };
}
(function(_super) {
  __extends$2(WordCloud, _super);
  function WordCloud() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "word-cloud";
    return _this;
  }
  WordCloud.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$s;
  };
  WordCloud.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    if (this.options.imageMask) {
      this.render();
    } else {
      this.chart.changeData(transform({ chart: this.chart, options: this.options }));
    }
  };
  WordCloud.prototype.getDefaultOptions = function() {
    return WordCloud.getDefaultOptions();
  };
  WordCloud.prototype.render = function() {
    var _this = this;
    return new Promise(function(res) {
      var imageMask = _this.options.imageMask;
      if (!imageMask) {
        _super.prototype.render.call(_this);
        res();
        return;
      }
      var handler = function(img) {
        _this.options = __assign$1(__assign$1({}, _this.options), { imageMask: img || null });
        _super.prototype.render.call(_this);
        res();
      };
      processImageMask(imageMask).then(handler).catch(handler);
    });
  };
  WordCloud.prototype.getSchemaAdaptor = function() {
    return adaptor$s;
  };
  WordCloud.prototype.triggerResize = function() {
    var _this = this;
    if (!this.chart.destroyed) {
      this.execAdaptor();
      window.setTimeout(function() {
        _super.prototype.triggerResize.call(_this);
      });
    }
  };
  return WordCloud;
})(Plot);
var REGRESSION_MAP = {
  exp: exponential,
  linear: linear$1,
  loess,
  log: logarithmic,
  poly: polynomial,
  pow: power,
  quad
};
function getQuadrantDefaultConfig(xBaseline, yBaseline) {
  var textOffset = 10;
  var defaultConfig = {
    regionStyle: [
      {
        position: {
          start: [xBaseline, "max"],
          end: ["max", yBaseline]
        },
        style: {
          fill: "#d8d0c0",
          opacity: 0.4
        }
      },
      {
        position: {
          start: ["min", "max"],
          end: [xBaseline, yBaseline]
        },
        style: {
          fill: "#a3dda1",
          opacity: 0.4
        }
      },
      {
        position: {
          start: ["min", yBaseline],
          end: [xBaseline, "min"]
        },
        style: {
          fill: "#d8d0c0",
          opacity: 0.4
        }
      },
      {
        position: {
          start: [xBaseline, yBaseline],
          end: ["max", "min"]
        },
        style: {
          fill: "#a3dda1",
          opacity: 0.4
        }
      }
    ],
    lineStyle: {
      stroke: "#9ba29a",
      lineWidth: 1
    },
    labelStyle: [
      {
        position: ["max", yBaseline],
        offsetX: -textOffset,
        offsetY: -textOffset,
        style: {
          textAlign: "right",
          textBaseline: "bottom",
          fontSize: 14,
          fill: "#ccc"
        }
      },
      {
        position: ["min", yBaseline],
        offsetX: textOffset,
        offsetY: -textOffset,
        style: {
          textAlign: "left",
          textBaseline: "bottom",
          fontSize: 14,
          fill: "#ccc"
        }
      },
      {
        position: ["min", yBaseline],
        offsetX: textOffset,
        offsetY: textOffset,
        style: {
          textAlign: "left",
          textBaseline: "top",
          fontSize: 14,
          fill: "#ccc"
        }
      },
      {
        position: ["max", yBaseline],
        offsetX: -textOffset,
        offsetY: textOffset,
        style: {
          textAlign: "right",
          textBaseline: "top",
          fontSize: 14,
          fill: "#ccc"
        }
      }
    ]
  };
  return defaultConfig;
}
var splinePath = function(data2, config) {
  var view = config.view, _a2 = config.options, xField = _a2.xField, yField = _a2.yField;
  var xScaleView = view.getScaleByField(xField);
  var yScaleView = view.getScaleByField(yField);
  var pathData = data2.map(function(d) {
    return view.getCoordinate().convert({ x: xScaleView.scale(d[0]), y: yScaleView.scale(d[1]) });
  });
  return getSplinePath(pathData, false);
};
var getPath = function(config) {
  var options = config.options;
  var xField = options.xField, yField = options.yField, data2 = options.data, regressionLine2 = options.regressionLine;
  var _a2 = regressionLine2.type, type = _a2 === void 0 ? "linear" : _a2, algorithm = regressionLine2.algorithm;
  var pathData;
  if (algorithm) {
    pathData = isArray$1(algorithm) ? algorithm : algorithm(data2);
  } else {
    var reg = REGRESSION_MAP[type]().x(function(d) {
      return d[xField];
    }).y(function(d) {
      return d[yField];
    });
    pathData = reg(data2);
  }
  return splinePath(pathData, config);
};
var getMeta = function(options) {
  var _a2;
  var _b = options.meta, meta2 = _b === void 0 ? {} : _b, xField = options.xField, yField = options.yField, data2 = options.data;
  var xFieldValue = data2[0][xField];
  var yFieldValue = data2[0][yField];
  var xIsPositiveNumber = xFieldValue > 0;
  var yIsPositiveNumber = yFieldValue > 0;
  function getMetaMinMax(field2, axis2) {
    var fieldMeta = get(meta2, [field2]);
    function getCustomValue(type) {
      return get(fieldMeta, type);
    }
    var range = {};
    if (axis2 === "x") {
      if (isNumber$1(xFieldValue)) {
        if (!isNumber$1(getCustomValue("min"))) {
          range["min"] = xIsPositiveNumber ? 0 : xFieldValue * 2;
        }
        if (!isNumber$1(getCustomValue("max"))) {
          range["max"] = xIsPositiveNumber ? xFieldValue * 2 : 0;
        }
      }
      return range;
    }
    if (isNumber$1(yFieldValue)) {
      if (!isNumber$1(getCustomValue("min"))) {
        range["min"] = yIsPositiveNumber ? 0 : yFieldValue * 2;
      }
      if (!isNumber$1(getCustomValue("max"))) {
        range["max"] = yIsPositiveNumber ? yFieldValue * 2 : 0;
      }
    }
    return range;
  }
  return __assign$1(__assign$1({}, meta2), (_a2 = {}, _a2[xField] = __assign$1(__assign$1({}, meta2[xField]), getMetaMinMax(xField, "x")), _a2[yField] = __assign$1(__assign$1({}, meta2[yField]), getMetaMinMax(yField, "y")), _a2));
};
function transformOptions$1(options) {
  var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, xField = options.xField, yField = options.yField;
  if (data2.length) {
    var isOneX = true;
    var isOneY = true;
    var prev = data2[0];
    var curr = void 0;
    for (var i = 1; i < data2.length; i++) {
      curr = data2[i];
      if (prev[xField] !== curr[xField]) {
        isOneX = false;
      }
      if (prev[yField] !== curr[yField]) {
        isOneY = false;
      }
      if (!isOneX && !isOneY) {
        break;
      }
      prev = curr;
    }
    var keys2 = [];
    isOneX && keys2.push(xField);
    isOneY && keys2.push(yField);
    var meta_1 = pick(getMeta(options), keys2);
    return deepAssign({}, options, { meta: meta_1 });
  }
  return options;
}
function geometry$p(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, type = options.type, color2 = options.color, shape = options.shape, pointStyle = options.pointStyle, shapeField = options.shapeField, colorField = options.colorField, xField = options.xField, yField = options.yField, sizeField = options.sizeField;
  var size2 = options.size;
  var tooltip2 = options.tooltip;
  if (sizeField) {
    if (!size2) {
      size2 = [2, 8];
    }
    if (isNumber$1(size2)) {
      size2 = [size2, size2];
    }
  }
  if (tooltip2 && !tooltip2.fields) {
    tooltip2 = __assign$1(__assign$1({}, tooltip2), { fields: [xField, yField, colorField, sizeField, shapeField] });
  }
  chart.data(data2);
  point(deepAssign({}, params, {
    options: {
      seriesField: colorField,
      point: {
        color: color2,
        shape,
        size: size2,
        style: pointStyle
      },
      tooltip: tooltip2
    }
  }));
  var geometry2 = findGeometry(chart, "point");
  if (type) {
    geometry2.adjust(type);
  }
  return params;
}
function meta$g(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  var newOptions = transformOptions$1(options);
  return flow(scale$1((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2)))(deepAssign({}, params, { options: newOptions }));
}
function axis$h(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  chart.axis(xField, xAxis);
  chart.axis(yField, yAxis);
  return params;
}
function legend$b(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, colorField = options.colorField, shapeField = options.shapeField, sizeField = options.sizeField, shapeLegend = options.shapeLegend, sizeLegend = options.sizeLegend;
  var showLegend = legend2 !== false;
  if (colorField) {
    chart.legend(colorField, showLegend ? legend2 : false);
  }
  if (shapeField) {
    if (shapeLegend) {
      chart.legend(shapeField, shapeLegend);
    } else {
      chart.legend(shapeField, shapeLegend === false ? false : legend2);
    }
  }
  if (sizeField) {
    chart.legend(sizeField, sizeLegend ? sizeLegend : false);
  }
  if (!showLegend && !shapeLegend && !sizeLegend) {
    chart.legend(false);
  }
  return params;
}
function label$9(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField;
  var scatterGeometry = findGeometry(chart, "point");
  if (!label2) {
    scatterGeometry.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    scatterGeometry.label({
      fields: [yField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function scatterAnnotation(params) {
  var options = params.options;
  var quadrant = options.quadrant;
  var annotationOptions = [];
  if (quadrant) {
    var _a2 = quadrant.xBaseline, xBaseline = _a2 === void 0 ? 0 : _a2, _b = quadrant.yBaseline, yBaseline = _b === void 0 ? 0 : _b, labels_1 = quadrant.labels, regionStyle_1 = quadrant.regionStyle, lineStyle = quadrant.lineStyle;
    var defaultConfig_1 = getQuadrantDefaultConfig(xBaseline, yBaseline);
    var quadrants = new Array(4).join(",").split(",");
    quadrants.forEach(function(_, index2) {
      annotationOptions.push(__assign$1(__assign$1({ type: "region", top: false }, defaultConfig_1.regionStyle[index2].position), { style: deepAssign({}, defaultConfig_1.regionStyle[index2].style, regionStyle_1 === null || regionStyle_1 === void 0 ? void 0 : regionStyle_1[index2]) }), __assign$1({ type: "text", top: true }, deepAssign({}, defaultConfig_1.labelStyle[index2], labels_1 === null || labels_1 === void 0 ? void 0 : labels_1[index2])));
    });
    annotationOptions.push({
      type: "line",
      top: false,
      start: ["min", yBaseline],
      end: ["max", yBaseline],
      style: deepAssign({}, defaultConfig_1.lineStyle, lineStyle)
    }, {
      type: "line",
      top: false,
      start: [xBaseline, "min"],
      end: [xBaseline, "max"],
      style: deepAssign({}, defaultConfig_1.lineStyle, lineStyle)
    });
  }
  return flow(annotation$2(annotationOptions))(params);
}
function regressionLine(params) {
  var options = params.options, chart = params.chart;
  var regressionLine2 = options.regressionLine;
  if (regressionLine2) {
    var style_1 = regressionLine2.style, _a2 = regressionLine2.top, top_1 = _a2 === void 0 ? false : _a2;
    var defaultStyle_1 = {
      stroke: "#9ba29a",
      lineWidth: 2,
      opacity: 0.5
    };
    chart.annotation().shape({
      top: top_1,
      render: function(container, view) {
        var group2 = container.addGroup({
          id: chart.id + "-regression-line",
          name: "regression-line-group"
        });
        var path2 = getPath({
          view,
          options
        });
        group2.addShape("path", {
          name: "regression-line",
          attrs: __assign$1(__assign$1({ path: path2 }, defaultStyle_1), style_1)
        });
      }
    });
  }
  return params;
}
function tooltip$6(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2) {
    chart.tooltip(tooltip2);
  } else if (tooltip2 === false) {
    chart.tooltip(false);
  }
  return params;
}
function adaptor$r(params) {
  return flow(geometry$p, meta$g, axis$h, legend$b, tooltip$6, label$9, brushInteraction, interaction$6, scatterAnnotation, animation$5, theme$2, regressionLine)(params);
}
var DEFAULT_OPTIONS$r = deepAssign({}, Plot.getDefaultOptions(), {
  size: 4,
  tooltip: {
    showTitle: false,
    showMarkers: false,
    showCrosshairs: true,
    crosshairs: {
      type: "xy"
    }
  }
});
registerInteraction("drag-move", {
  start: [{ trigger: "plot:mousedown", action: "scale-translate:start" }],
  processing: [
    {
      trigger: "plot:mousemove",
      action: "scale-translate:translate",
      throttle: { wait: 100, leading: true, trailing: false }
    }
  ],
  end: [{ trigger: "plot:mouseup", action: "scale-translate:end" }]
});
var Scatter = function(_super) {
  __extends$2(Scatter2, _super);
  function Scatter2(container, options) {
    var _this = _super.call(this, container, options) || this;
    _this.type = "scatter";
    _this.on(VIEW_LIFE_CIRCLE.BEFORE_RENDER, function(evt) {
      var _a2, _b;
      var _c = _this, options2 = _c.options, chart = _c.chart;
      if (((_a2 = evt.data) === null || _a2 === void 0 ? void 0 : _a2.source) === EVENTS.FILTER) {
        var filteredData = _this.chart.filterData(_this.chart.getData());
        meta$g({ chart, options: __assign$1(__assign$1({}, options2), { data: filteredData }) });
      }
      if (((_b = evt.data) === null || _b === void 0 ? void 0 : _b.source) === EVENTS.RESET) {
        meta$g({ chart, options: options2 });
      }
    });
    return _this;
  }
  Scatter2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$r;
  };
  Scatter2.prototype.changeData = function(data2) {
    this.updateOption(transformOptions$1(deepAssign({}, this.options, { data: data2 })));
    var _a2 = this, options = _a2.options, chart = _a2.chart;
    meta$g({ chart, options });
    this.chart.changeData(data2);
  };
  Scatter2.prototype.getSchemaAdaptor = function() {
    return adaptor$r;
  };
  Scatter2.prototype.getDefaultOptions = function() {
    return Scatter2.getDefaultOptions();
  };
  return Scatter2;
}(Plot);
function geometry$o(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, lineStyle = options.lineStyle, color2 = options.color, pointOptions = options.point, areaOptions = options.area;
  chart.data(data2);
  var primary = deepAssign({}, params, {
    options: {
      line: {
        style: lineStyle,
        color: color2
      },
      point: pointOptions ? __assign$1({ color: color2 }, pointOptions) : pointOptions,
      area: areaOptions ? __assign$1({ color: color2 }, areaOptions) : areaOptions,
      label: void 0
    }
  });
  var second = deepAssign({}, primary, {
    options: {
      tooltip: false
    }
  });
  var pointState = (pointOptions === null || pointOptions === void 0 ? void 0 : pointOptions.state) || options.state;
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  line(primary);
  point(pointParams);
  area(second);
  return params;
}
function meta$f(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale$1((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2)))(params);
}
function coord(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate("polar", {
    radius,
    startAngle,
    endAngle
  });
  return params;
}
function axis$g(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, xAxis = options.xAxis, yField = options.yField, yAxis = options.yAxis;
  chart.axis(xField, xAxis);
  chart.axis(yField, yAxis);
  return params;
}
function label$8(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField;
  var geometry2 = findGeometry(chart, "line");
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    geometry2.label({
      fields: [yField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function adaptor$q(params) {
  return flow(geometry$o, meta$f, theme$2, coord, axis$g, legend$g, tooltip$8, label$8, interaction$6, animation$5, annotation$2())(params);
}
var RadarTooltipController = function(_super) {
  __extends$2(RadarTooltipController2, _super);
  function RadarTooltipController2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Object.defineProperty(RadarTooltipController2.prototype, "name", {
    get: function() {
      return "radar-tooltip";
    },
    enumerable: false,
    configurable: true
  });
  RadarTooltipController2.prototype.getTooltipItems = function(point2) {
    var _a2 = this.getTooltipCfg(), shared = _a2.shared, cfgTitle = _a2.title;
    var hintItems = _super.prototype.getTooltipItems.call(this, point2);
    if (hintItems.length > 0) {
      var geometry_1 = this.view.geometries[0];
      var dataArray = geometry_1.dataArray;
      var title_1 = hintItems[0].name;
      var result_1 = [];
      dataArray.forEach(function(mappingData) {
        mappingData.forEach(function(d) {
          var items = Util.getTooltipItems(d, geometry_1);
          var item = items[0];
          if (!shared && item && item.name === title_1) {
            var displayTitle = isNil(cfgTitle) ? title_1 : cfgTitle;
            result_1.push(__assign$1(__assign$1({}, item), { name: item.title, title: displayTitle }));
          } else if (shared && item) {
            var displayTitle = isNil(cfgTitle) ? item.name || title_1 : cfgTitle;
            result_1.push(__assign$1(__assign$1({}, item), { name: item.title, title: displayTitle }));
          }
        });
      });
      return result_1;
    }
    return [];
  };
  return RadarTooltipController2;
}(Tooltip);
registerComponentController("radar-tooltip", RadarTooltipController);
var RadarTooltipAction = function(_super) {
  __extends$2(RadarTooltipAction2, _super);
  function RadarTooltipAction2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RadarTooltipAction2.prototype.init = function() {
    var view = this.context.view;
    view.removeInteraction("tooltip");
  };
  RadarTooltipAction2.prototype.show = function() {
    var event = this.context.event;
    var controller = this.getTooltipController();
    controller.showTooltip({ x: event.x, y: event.y });
  };
  RadarTooltipAction2.prototype.hide = function() {
    var controller = this.getTooltipController();
    controller.hideTooltip();
  };
  RadarTooltipAction2.prototype.getTooltipController = function() {
    var view = this.context.view;
    return view.getController("radar-tooltip");
  };
  return RadarTooltipAction2;
}(Action);
registerAction("radar-tooltip", RadarTooltipAction);
registerInteraction("radar-tooltip", {
  start: [{ trigger: "plot:mousemove", action: "radar-tooltip:show" }],
  end: [{ trigger: "plot:mouseleave", action: "radar-tooltip:hide" }]
});
(function(_super) {
  __extends$2(Radar, _super);
  function Radar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "radar";
    return _this;
  }
  Radar.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    this.chart.changeData(data2);
  };
  Radar.prototype.getDefaultOptions = function() {
    return deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      xAxis: {
        label: {
          offset: 15
        },
        grid: {
          line: {
            type: "line"
          }
        }
      },
      yAxis: {
        grid: {
          line: {
            type: "circle"
          }
        }
      },
      legend: {
        position: "top"
      },
      tooltip: {
        shared: true,
        showCrosshairs: true,
        showMarkers: true,
        crosshairs: {
          type: "xy",
          line: {
            style: {
              stroke: "#565656",
              lineDash: [4]
            }
          },
          follow: true
        }
      }
    });
  };
  Radar.prototype.getSchemaAdaptor = function() {
    return adaptor$q;
  };
  return Radar;
})(Plot);
var AxisType;
(function(AxisType2) {
  AxisType2["Left"] = "Left";
  AxisType2["Right"] = "Right";
})(AxisType || (AxisType = {}));
var DualAxesGeometry;
(function(DualAxesGeometry2) {
  DualAxesGeometry2["Line"] = "line";
  DualAxesGeometry2["Column"] = "column";
})(DualAxesGeometry || (DualAxesGeometry = {}));
var LEFT_AXES_VIEW = "left-axes-view";
var RIGHT_AXES_VIEW = "right-axes-view";
var DEFAULT_YAXIS_CONFIG = {
  nice: true,
  label: {
    autoHide: true,
    autoRotate: false
  }
};
var DEFAULT_LEFT_YAXIS_CONFIG = __assign$1(__assign$1({}, DEFAULT_YAXIS_CONFIG), { position: "left" });
var DEFAULT_RIGHT_YAXIS_CONFIG = __assign$1(__assign$1({}, DEFAULT_YAXIS_CONFIG), { position: "right", grid: null });
function isLine(geometryOption) {
  return get(geometryOption, "geometry") === DualAxesGeometry.Line;
}
function isColumn(geometryOption) {
  return get(geometryOption, "geometry") === DualAxesGeometry.Column;
}
function getGeometryOption(xField, yField, geometryOption) {
  return isColumn(geometryOption) ? deepAssign({}, {
    geometry: DualAxesGeometry.Column,
    label: geometryOption.label && geometryOption.isRange ? {
      content: function(item) {
        var _a2;
        return (_a2 = item[yField]) === null || _a2 === void 0 ? void 0 : _a2.join("-");
      }
    } : void 0
  }, geometryOption) : __assign$1({ geometry: DualAxesGeometry.Line }, geometryOption);
}
function transformObjectToArray(yField, transformAttribute) {
  var y1 = yField[0], y2 = yField[1];
  if (isArray$1(transformAttribute)) {
    var a1_1 = transformAttribute[0], a2_1 = transformAttribute[1];
    return [a1_1, a2_1];
  }
  var a1 = get(transformAttribute, y1);
  var a2 = get(transformAttribute, y2);
  return [a1, a2];
}
function getYAxisWithDefault(yAxis, axisType) {
  if (axisType === AxisType.Left) {
    return yAxis === false ? false : deepAssign({}, DEFAULT_LEFT_YAXIS_CONFIG, yAxis);
  } else if (axisType === AxisType.Right) {
    return yAxis === false ? false : deepAssign({}, DEFAULT_RIGHT_YAXIS_CONFIG, yAxis);
  }
  return yAxis;
}
function getViewLegendItems(params) {
  var view = params.view, geometryOption = params.geometryOption, yField = params.yField, legend2 = params.legend;
  var userMarker = get(legend2, "marker");
  var geometry2 = findGeometry(view, isLine(geometryOption) ? "line" : "interval");
  if (!geometryOption.seriesField) {
    var legendItemName = get(view, "options.scales." + yField + ".alias") || yField;
    var colorAttribute = geometry2.getAttribute("color");
    var color2 = view.getTheme().defaultColor;
    if (colorAttribute) {
      color2 = Util.getMappingValue(colorAttribute, legendItemName, get(colorAttribute, ["values", 0], color2));
    }
    var marker = (isFunction(userMarker) ? userMarker : !isEmpty(userMarker) && deepAssign({}, {
      style: {
        stroke: color2,
        fill: color2
      }
    }, userMarker)) || (isLine(geometryOption) ? {
      symbol: function(x, y, r) {
        return [
          ["M", x - r, y],
          ["L", x + r, y]
        ];
      },
      style: {
        lineWidth: 2,
        r: 6,
        stroke: color2
      }
    } : {
      symbol: "square",
      style: {
        fill: color2
      }
    });
    return [
      {
        value: yField,
        name: legendItemName,
        marker,
        isGeometry: true,
        viewId: view.id
      }
    ];
  }
  var attributes = geometry2.getGroupAttributes();
  return reduce(attributes, function(items, attr) {
    var attrItems = Util.getLegendItems(view, geometry2, attr, view.getTheme(), userMarker);
    return items.concat(attrItems);
  }, []);
}
function drawSingleGeometry(params) {
  var options = params.options, chart = params.chart;
  var geometryOption = options.geometryOption;
  var isStack = geometryOption.isStack, color2 = geometryOption.color, seriesField = geometryOption.seriesField, groupField = geometryOption.groupField, isGroup = geometryOption.isGroup;
  var FIELD_KEY = ["xField", "yField"];
  if (isLine(geometryOption)) {
    line(deepAssign({}, params, {
      options: __assign$1(__assign$1(__assign$1({}, pick(options, FIELD_KEY)), geometryOption), { line: {
        color: geometryOption.color,
        style: geometryOption.lineStyle
      } })
    }));
    point(deepAssign({}, params, {
      options: __assign$1(__assign$1(__assign$1({}, pick(options, FIELD_KEY)), geometryOption), { point: geometryOption.point && __assign$1({ color: color2, shape: "circle" }, geometryOption.point) })
    }));
    var adjust_1 = [];
    if (isGroup) {
      adjust_1.push({
        type: "dodge",
        dodgeBy: groupField || seriesField,
        customOffset: 0
      });
    }
    if (isStack) {
      adjust_1.push({
        type: "stack"
      });
    }
    if (adjust_1.length) {
      each$1(chart.geometries, function(g) {
        g.adjust(adjust_1);
      });
    }
  }
  if (isColumn(geometryOption)) {
    adaptor$w(deepAssign({}, params, {
      options: __assign$1(__assign$1(__assign$1({}, pick(options, FIELD_KEY)), geometryOption), { widthRatio: geometryOption.columnWidthRatio, interval: __assign$1(__assign$1({}, pick(geometryOption, ["color"])), { style: geometryOption.columnStyle }) })
    }));
  }
  return params;
}
var doSliderFilter = function(view, sliderValue) {
  var min2 = sliderValue[0], max2 = sliderValue[1];
  var data2 = view.getOptions().data;
  var xScale = view.getXScale();
  var dataSize = size(data2);
  if (!xScale || !dataSize) {
    return;
  }
  var values2 = valuesOfKey(data2, xScale.field);
  var xValues = values2;
  var xTickCount = size(xValues);
  var minIndex = Math.floor(min2 * (xTickCount - 1));
  var maxIndex = Math.floor(max2 * (xTickCount - 1));
  view.filter(xScale.field, function(value2) {
    var idx = xValues.indexOf(value2);
    return idx > -1 ? isBetween(idx, minIndex, maxIndex) : true;
  });
  view.render(true);
};
function transformOptions(params) {
  var _a2;
  var options = params.options;
  var _b = options.geometryOptions, geometryOptions = _b === void 0 ? [] : _b, xField = options.xField, yField = options.yField;
  var allLine = every(geometryOptions, function(_a3) {
    var geometry2 = _a3.geometry;
    return geometry2 === DualAxesGeometry.Line || geometry2 === void 0;
  });
  return deepAssign({}, {
    options: {
      geometryOptions: [],
      meta: (_a2 = {}, _a2[xField] = {
        type: "cat",
        sync: true,
        range: allLine ? [0, 1] : void 0
      }, _a2),
      tooltip: {
        showMarkers: allLine,
        showCrosshairs: allLine,
        shared: true,
        crosshairs: {
          type: "x"
        }
      },
      interactions: !allLine ? [{ type: "legend-visible-filter" }, { type: "active-region" }] : [{ type: "legend-visible-filter" }],
      legend: {
        position: "top-left"
      }
    }
  }, params, {
    options: {
      yAxis: transformObjectToArray(yField, options.yAxis),
      geometryOptions: [
        getGeometryOption(xField, yField[0], geometryOptions[0]),
        getGeometryOption(xField, yField[1], geometryOptions[1])
      ],
      annotations: transformObjectToArray(yField, options.annotations)
    }
  });
}
function createViews(params) {
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var geometryOptions = options.geometryOptions;
  var SORT_MAP = { line: 0, column: 1 };
  var geometries = [
    { type: (_a2 = geometryOptions[0]) === null || _a2 === void 0 ? void 0 : _a2.geometry, id: LEFT_AXES_VIEW },
    { type: (_b = geometryOptions[1]) === null || _b === void 0 ? void 0 : _b.geometry, id: RIGHT_AXES_VIEW }
  ];
  geometries.sort(function(a, b) {
    return -SORT_MAP[a.type] + SORT_MAP[b.type];
  }).forEach(function(g) {
    return chart.createView({ id: g.id });
  });
  return params;
}
function geometry$n(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, geometryOptions = options.geometryOptions, data2 = options.data, tooltip2 = options.tooltip;
  var geometries = [
    __assign$1(__assign$1({}, geometryOptions[0]), { id: LEFT_AXES_VIEW, data: data2[0], yField: yField[0] }),
    __assign$1(__assign$1({}, geometryOptions[1]), { id: RIGHT_AXES_VIEW, data: data2[1], yField: yField[1] })
  ];
  geometries.forEach(function(geometry2) {
    var id = geometry2.id, data3 = geometry2.data, yField2 = geometry2.yField;
    var isPercent = isColumn(geometry2) && geometry2.isPercent;
    var formatData = isPercent ? percent(data3, yField2, xField, yField2) : data3;
    var view = findViewById(chart, id).data(formatData);
    var tooltipOptions = isPercent ? __assign$1({ formatter: function(datum) {
      return {
        name: datum[geometry2.seriesField] || yField2,
        value: (Number(datum[yField2]) * 100).toFixed(2) + "%"
      };
    } }, tooltip2) : tooltip2;
    drawSingleGeometry({
      chart: view,
      options: {
        xField,
        yField: yField2,
        tooltip: tooltipOptions,
        geometryOption: geometry2
      }
    });
  });
  return params;
}
function color(params) {
  var _a2;
  var chart = params.chart, options = params.options;
  var geometryOptions = options.geometryOptions;
  var themeColor = ((_a2 = chart.getTheme()) === null || _a2 === void 0 ? void 0 : _a2.colors10) || [];
  var start = 0;
  chart.once("beforepaint", function() {
    each$1(geometryOptions, function(geometryOption, index2) {
      var view = findViewById(chart, index2 === 0 ? LEFT_AXES_VIEW : RIGHT_AXES_VIEW);
      if (geometryOption.color)
        return;
      var groupScale = view.getGroupScales();
      var count = get(groupScale, [0, "values", "length"], 1);
      var color2 = themeColor.slice(start, start + count).concat(index2 === 0 ? [] : themeColor);
      view.geometries.forEach(function(geometry2) {
        if (geometryOption.seriesField) {
          geometry2.color(geometryOption.seriesField, color2);
        } else {
          geometry2.color(color2[0]);
        }
      });
      start += count;
    });
    chart.render(true);
  });
  return params;
}
function meta$e(params) {
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  scale$1((_a2 = {}, _a2[xField] = xAxis, _a2[yField[0]] = yAxis[0], _a2))(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  scale$1((_b = {}, _b[xField] = xAxis, _b[yField[1]] = yAxis[1], _b))(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  return params;
}
function axis$f(params) {
  var chart = params.chart, options = params.options;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
  chart.axis(xField, false);
  chart.axis(yField[0], false);
  chart.axis(yField[1], false);
  leftView.axis(xField, xAxis);
  leftView.axis(yField[0], getYAxisWithDefault(yAxis[0], AxisType.Left));
  rightView.axis(xField, false);
  rightView.axis(yField[1], getYAxisWithDefault(yAxis[1], AxisType.Right));
  return params;
}
function tooltip$5(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  chart.tooltip(tooltip2);
  leftView.tooltip({
    shared: true
  });
  rightView.tooltip({
    shared: true
  });
  return params;
}
function interaction$4(params) {
  var chart = params.chart;
  interaction$6(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  interaction$6(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  return params;
}
function annotation$1(params) {
  var chart = params.chart, options = params.options;
  var annotations = options.annotations;
  var a1 = get(annotations, [0]);
  var a2 = get(annotations, [1]);
  annotation$2(a1)(deepAssign({}, params, {
    chart: findViewById(chart, LEFT_AXES_VIEW),
    options: {
      annotations: a1
    }
  }));
  annotation$2(a2)(deepAssign({}, params, {
    chart: findViewById(chart, RIGHT_AXES_VIEW),
    options: {
      annotations: a2
    }
  }));
  return params;
}
function theme$1(params) {
  var chart = params.chart;
  theme$2(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  theme$2(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  theme$2(params);
  return params;
}
function animation$4(params) {
  var chart = params.chart;
  animation$5(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  animation$5(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  return params;
}
function limitInPlot$1(params) {
  var chart = params.chart, options = params.options;
  var yAxis = options.yAxis;
  limitInPlot$2(deepAssign({}, params, {
    chart: findViewById(chart, LEFT_AXES_VIEW),
    options: {
      yAxis: yAxis[0]
    }
  }));
  limitInPlot$2(deepAssign({}, params, {
    chart: findViewById(chart, RIGHT_AXES_VIEW),
    options: {
      yAxis: yAxis[1]
    }
  }));
  return params;
}
function legend$a(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, geometryOptions = options.geometryOptions, yField = options.yField, data2 = options.data;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  if (legend2 === false) {
    chart.legend(false);
  } else if (isObject(legend2) && legend2.custom === true) {
    chart.legend(legend2);
  } else {
    var leftLegend_1 = get(geometryOptions, [0, "legend"], legend2);
    var rightLegend_1 = get(geometryOptions, [1, "legend"], legend2);
    chart.once("beforepaint", function() {
      var leftItems = data2[0].length ? getViewLegendItems({
        view: leftView,
        geometryOption: geometryOptions[0],
        yField: yField[0],
        legend: leftLegend_1
      }) : [];
      var rightItems = data2[1].length ? getViewLegendItems({
        view: rightView,
        geometryOption: geometryOptions[1],
        yField: yField[1],
        legend: rightLegend_1
      }) : [];
      chart.legend(deepAssign({}, legend2, {
        custom: true,
        items: leftItems.concat(rightItems)
      }));
    });
    if (geometryOptions[0].seriesField) {
      leftView.legend(geometryOptions[0].seriesField, leftLegend_1);
    }
    if (geometryOptions[1].seriesField) {
      rightView.legend(geometryOptions[1].seriesField, rightLegend_1);
    }
    chart.on("legend-item:click", function(evt) {
      var delegateObject = get(evt, "gEvent.delegateObject", {});
      if (delegateObject && delegateObject.item) {
        var _a2 = delegateObject.item, field_1 = _a2.value, isGeometry = _a2.isGeometry, viewId = _a2.viewId;
        if (isGeometry) {
          var idx = findIndex(yField, function(yF) {
            return yF === field_1;
          });
          if (idx > -1) {
            var geometries = get(findViewById(chart, viewId), "geometries");
            each$1(geometries, function(g) {
              g.changeVisible(!delegateObject.item.unchecked);
            });
          }
        } else {
          var legendItem_1 = get(chart.getController("legend"), "option.items", []);
          each$1(chart.views, function(view) {
            var groupScale = view.getGroupScales();
            each$1(groupScale, function(scale2) {
              if (scale2.values && scale2.values.indexOf(field_1) > -1) {
                view.filter(scale2.field, function(value2) {
                  var curLegendItem = find$1(legendItem_1, function(item) {
                    return item.value === value2;
                  });
                  return !curLegendItem.unchecked;
                });
              }
            });
            chart.render(true);
          });
        }
      }
    });
  }
  return params;
}
function slider(params) {
  var chart = params.chart, options = params.options;
  var slider2 = options.slider;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  if (slider2) {
    leftView.option("slider", slider2);
    leftView.on("slider:valuechanged", function(evt) {
      var _a2 = evt.event, value2 = _a2.value, originValue = _a2.originValue;
      if (isEqual$2(value2, originValue)) {
        return;
      }
      doSliderFilter(rightView, value2);
    });
    chart.once("afterpaint", function() {
      if (!isBoolean(slider2)) {
        var start = slider2.start, end = slider2.end;
        if (start || end) {
          doSliderFilter(rightView, [start, end]);
        }
      }
    });
  }
  return params;
}
function adaptor$p(params) {
  return flow(transformOptions, createViews, theme$1, geometry$n, meta$e, axis$f, limitInPlot$1, tooltip$5, interaction$4, annotation$1, animation$4, color, legend$a, slider)(params);
}
(function(_super) {
  __extends$2(DualAxes, _super);
  function DualAxes() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "dual-axes";
    return _this;
  }
  DualAxes.prototype.getDefaultOptions = function() {
    return deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      yAxis: [],
      syncViewPadding: true
    });
  };
  DualAxes.prototype.getSchemaAdaptor = function() {
    return adaptor$p;
  };
  return DualAxes;
})(Plot);
var X_FIELD$3 = "x";
var Y_FIELD$4 = "y";
var DEFAULT_TOOLTIP_OPTIONS$2 = {
  showTitle: false,
  shared: true,
  showMarkers: false,
  customContent: function(x, data2) {
    return "" + get(data2, [0, "data", "y"], 0);
  },
  containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
  itemTpl: "<span>{value}</span>",
  domStyles: {
    "g2-tooltip": {
      padding: "2px 4px",
      fontSize: "10px"
    }
  },
  showCrosshairs: true,
  crosshairs: {
    type: "x"
  }
};
var DEFAULT_OPTIONS$q = {
  appendPadding: 2,
  tooltip: __assign$1({}, DEFAULT_TOOLTIP_OPTIONS$2),
  animation: {}
};
function getTinyData(data2) {
  return map$2(data2 || [], function(y, x) {
    return { x: "" + x, y };
  });
}
function geometry$m(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, color2 = options.color, areaStyle = options.areaStyle, pointOptions = options.point, lineOptions = options.line;
  var pointState = pointOptions === null || pointOptions === void 0 ? void 0 : pointOptions.state;
  var seriesData = getTinyData(data2);
  chart.data(seriesData);
  var primary = deepAssign({}, params, {
    options: {
      xField: X_FIELD$3,
      yField: Y_FIELD$4,
      area: { color: color2, style: areaStyle },
      line: lineOptions,
      point: pointOptions
    }
  });
  var second = deepAssign({}, primary, { options: { tooltip: false } });
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  area(primary);
  line(second);
  point(pointParams);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function meta$d(params) {
  var _a2, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, data2 = options.data;
  var seriesData = getTinyData(data2);
  return flow(scale$1((_a2 = {}, _a2[X_FIELD$3] = xAxis, _a2[Y_FIELD$4] = yAxis, _a2), (_b = {}, _b[X_FIELD$3] = {
    type: "cat"
  }, _b[Y_FIELD$4] = adjustYMetaByZero(seriesData, Y_FIELD$4), _b)))(params);
}
function adaptor$o(params) {
  return flow(pattern("areaStyle"), geometry$m, meta$d, tooltip$8, theme$2, animation$5, annotation$2())(params);
}
function geometry$l(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, color2 = options.color, lineStyle = options.lineStyle, pointMapping = options.point;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  var seriesData = getTinyData(data2);
  chart.data(seriesData);
  var primary = deepAssign({}, params, {
    options: {
      xField: X_FIELD$3,
      yField: Y_FIELD$4,
      line: {
        color: color2,
        style: lineStyle
      },
      point: pointMapping
    }
  });
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  line(primary);
  point(pointParams);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function adaptor$n(params) {
  return flow(geometry$l, meta$d, theme$2, tooltip$8, animation$5, annotation$2())(params);
}
var TinyLine = function(_super) {
  __extends$2(TinyLine2, _super);
  function TinyLine2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "tiny-line";
    return _this;
  }
  TinyLine2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$q;
  };
  TinyLine2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = this, chart = _a2.chart, options = _a2.options;
    meta$d({ chart, options });
    chart.changeData(getTinyData(data2));
  };
  TinyLine2.prototype.getDefaultOptions = function() {
    return TinyLine2.getDefaultOptions();
  };
  TinyLine2.prototype.getSchemaAdaptor = function() {
    return adaptor$n;
  };
  return TinyLine2;
}(Plot);
function geometry$k(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, color2 = options.color, columnStyle = options.columnStyle, columnWidthRatio = options.columnWidthRatio;
  var seriesData = getTinyData(data2);
  chart.data(seriesData);
  var p = deepAssign({}, params, {
    options: {
      xField: X_FIELD$3,
      yField: Y_FIELD$4,
      widthRatio: columnWidthRatio,
      interval: {
        style: columnStyle,
        color: color2
      }
    }
  });
  interval(p);
  chart.axis(false);
  chart.legend(false);
  chart.interaction("element-active");
  return params;
}
function adaptor$m(params) {
  return flow(theme$2, pattern("columnStyle"), geometry$k, meta$d, tooltip$8, animation$5, annotation$2())(params);
}
var DEFAULT_TOOLTIP_OPTIONS$1 = {
  showTitle: false,
  shared: true,
  showMarkers: false,
  customContent: function(x, data2) {
    return "" + get(data2, [0, "data", "y"], 0);
  },
  containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
  itemTpl: "<span>{value}</span>",
  domStyles: {
    "g2-tooltip": {
      padding: "2px 4px",
      fontSize: "10px"
    }
  }
};
var DEFAULT_OPTIONS$p = {
  appendPadding: 2,
  tooltip: __assign$1({}, DEFAULT_TOOLTIP_OPTIONS$1),
  animation: {}
};
var TinyColumn = function(_super) {
  __extends$2(TinyColumn2, _super);
  function TinyColumn2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "tiny-column";
    return _this;
  }
  TinyColumn2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$p;
  };
  TinyColumn2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = this, chart = _a2.chart, options = _a2.options;
    meta$d({ chart, options });
    chart.changeData(getTinyData(data2));
  };
  TinyColumn2.prototype.getDefaultOptions = function() {
    return TinyColumn2.getDefaultOptions();
  };
  TinyColumn2.prototype.getSchemaAdaptor = function() {
    return adaptor$m;
  };
  return TinyColumn2;
}(Plot);
var DEFAULT_OPTIONS$o = {
  appendPadding: 2,
  tooltip: __assign$1({}, DEFAULT_TOOLTIP_OPTIONS$2),
  color: "l(90) 0:#E5EDFE 1:#ffffff",
  areaStyle: {
    fillOpacity: 0.6
  },
  line: {
    size: 1,
    color: "#5B8FF9"
  },
  animation: {}
};
var TinyArea = function(_super) {
  __extends$2(TinyArea2, _super);
  function TinyArea2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "tiny-area";
    return _this;
  }
  TinyArea2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$o;
  };
  TinyArea2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = this, chart = _a2.chart, options = _a2.options;
    meta$d({ chart, options });
    chart.changeData(getTinyData(data2));
  };
  TinyArea2.prototype.getDefaultOptions = function() {
    return TinyArea2.getDefaultOptions();
  };
  TinyArea2.prototype.getSchemaAdaptor = function() {
    return adaptor$o;
  };
  return TinyArea2;
}(Plot);
function getBinKey(value2, binWidth, binNumber) {
  if (binNumber === 1) {
    return [0, binWidth];
  }
  var index2 = Math.floor(value2 / binWidth);
  return [binWidth * index2, binWidth * (index2 + 1)];
}
function sturges(values2) {
  return Math.ceil(Math.log(values2.length) / Math.LN2) + 1;
}
function binHistogram(data2, binField, binWidth, binNumber, stackField) {
  var originData_copy = clone(data2);
  sortBy(originData_copy, binField);
  var values2 = valuesOfKey(originData_copy, binField);
  var range = getRange(values2);
  var rangeWidth = range.max - range.min;
  var _binWidth = binWidth;
  if (!binWidth && binNumber) {
    _binWidth = binNumber > 1 ? rangeWidth / (binNumber - 1) : range.max;
  }
  if (!binWidth && !binNumber) {
    var _defaultBinNumber = sturges(values2);
    _binWidth = rangeWidth / _defaultBinNumber;
  }
  var bins = {};
  var groups = groupBy(originData_copy, stackField);
  if (isEmpty(groups)) {
    each$1(originData_copy, function(data3) {
      var value2 = data3[binField];
      var bin = getBinKey(value2, _binWidth, binNumber);
      var binKey = bin[0] + "-" + bin[1];
      if (!has(bins, binKey)) {
        bins[binKey] = { range: bin, count: 0 };
      }
      bins[binKey].count += 1;
    });
  } else {
    Object.keys(groups).forEach(function(groupKey) {
      each$1(groups[groupKey], function(data3) {
        var value2 = data3[binField];
        var bin = getBinKey(value2, _binWidth, binNumber);
        var binKey = bin[0] + "-" + bin[1];
        var groupKeyBinKey = binKey + "-" + groupKey;
        if (!has(bins, groupKeyBinKey)) {
          bins[groupKeyBinKey] = { range: bin, count: 0 };
          bins[groupKeyBinKey][stackField] = groupKey;
        }
        bins[groupKeyBinKey].count += 1;
      });
    });
  }
  var plotData = [];
  each$1(bins, function(bin) {
    plotData.push(bin);
  });
  return plotData;
}
var HISTOGRAM_X_FIELD = "range";
var HISTOGRAM_Y_FIELD = "count";
var DEFAULT_OPTIONS$n = deepAssign({}, Plot.getDefaultOptions(), {
  columnStyle: {
    stroke: "#FFFFFF"
  },
  tooltip: {
    shared: true,
    showMarkers: false
  },
  interactions: [{ type: "active-region" }]
});
function geometry$j(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, binField = options.binField, binNumber = options.binNumber, binWidth = options.binWidth, color2 = options.color, stackField = options.stackField, legend2 = options.legend, columnStyle = options.columnStyle;
  var plotData = binHistogram(data2, binField, binWidth, binNumber, stackField);
  chart.data(plotData);
  var p = deepAssign({}, params, {
    options: {
      xField: HISTOGRAM_X_FIELD,
      yField: HISTOGRAM_Y_FIELD,
      seriesField: stackField,
      isStack: true,
      interval: {
        color: color2,
        style: columnStyle
      }
    }
  });
  interval(p);
  if (legend2 && stackField) {
    chart.legend(stackField, legend2);
  }
  return params;
}
function meta$c(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis;
  return flow(scale$1((_a2 = {}, _a2[HISTOGRAM_X_FIELD] = xAxis, _a2[HISTOGRAM_Y_FIELD] = yAxis, _a2)))(params);
}
function axis$e(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis;
  if (xAxis === false) {
    chart.axis(HISTOGRAM_X_FIELD, false);
  } else {
    chart.axis(HISTOGRAM_X_FIELD, xAxis);
  }
  if (yAxis === false) {
    chart.axis(HISTOGRAM_Y_FIELD, false);
  } else {
    chart.axis(HISTOGRAM_Y_FIELD, yAxis);
  }
  return params;
}
function label$7(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label;
  var geometry2 = findGeometry(chart, "interval");
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    geometry2.label({
      fields: [HISTOGRAM_Y_FIELD],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function adaptor$l(params) {
  return flow(theme$2, pattern("columnStyle"), geometry$j, meta$c, axis$e, state, label$7, tooltip$8, interaction$6, animation$5)(params);
}
var Histogram = function(_super) {
  __extends$2(Histogram2, _super);
  function Histogram2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "histogram";
    return _this;
  }
  Histogram2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$n;
  };
  Histogram2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = this.options, binField = _a2.binField, binNumber = _a2.binNumber, binWidth = _a2.binWidth, stackField = _a2.stackField;
    this.chart.changeData(binHistogram(data2, binField, binWidth, binNumber, stackField));
  };
  Histogram2.prototype.getDefaultOptions = function() {
    return Histogram2.getDefaultOptions();
  };
  Histogram2.prototype.getSchemaAdaptor = function() {
    return adaptor$l;
  };
  return Histogram2;
}(Plot);
var DEFAULT_COLOR$1 = ["#FAAD14", "#E8EDF3"];
var DEFAULT_OPTIONS$m = {
  percent: 0.2,
  color: DEFAULT_COLOR$1,
  animation: {}
};
function getProgressData(percent2) {
  var clampPercent = clamp(isRealNumber(percent2) ? percent2 : 0, 0, 1);
  return [
    {
      type: "current",
      percent: clampPercent
    },
    {
      type: "target",
      percent: 1 - clampPercent
    }
  ];
}
function geometry$i(params) {
  var chart = params.chart, options = params.options;
  var percent2 = options.percent, progressStyle = options.progressStyle, color2 = options.color, barWidthRatio = options.barWidthRatio;
  chart.data(getProgressData(percent2));
  var p = deepAssign({}, params, {
    options: {
      xField: "1",
      yField: "percent",
      seriesField: "type",
      isStack: true,
      widthRatio: barWidthRatio,
      interval: {
        style: progressStyle,
        color: isString(color2) ? [color2, DEFAULT_COLOR$1[1]] : color2
      },
      args: {
        zIndexReversed: true
      }
    }
  });
  interval(p);
  chart.tooltip(false);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function coordinate$5(params) {
  var chart = params.chart;
  chart.coordinate("rect").transpose();
  return params;
}
function adaptor$k(params) {
  return flow(geometry$i, scale$1({}), coordinate$5, animation$5, theme$2, annotation$2())(params);
}
var Progress = function(_super) {
  __extends$2(Progress2, _super);
  function Progress2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "process";
    return _this;
  }
  Progress2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$m;
  };
  Progress2.prototype.changeData = function(percent2) {
    this.updateOption({ percent: percent2 });
    this.chart.changeData(getProgressData(percent2));
  };
  Progress2.prototype.getDefaultOptions = function() {
    return Progress2.getDefaultOptions();
  };
  Progress2.prototype.getSchemaAdaptor = function() {
    return adaptor$k;
  };
  return Progress2;
}(Plot);
function coordinate$4(params) {
  var chart = params.chart, options = params.options;
  var innerRadius = options.innerRadius, radius = options.radius;
  chart.coordinate("theta", {
    innerRadius,
    radius
  });
  return params;
}
function statistic$2(params, updated) {
  var chart = params.chart, options = params.options;
  var innerRadius = options.innerRadius, statistic2 = options.statistic, percent2 = options.percent, meta2 = options.meta;
  chart.getController("annotation").clear(true);
  if (innerRadius && statistic2) {
    var metaFormatter = get(meta2, ["percent", "formatter"]) || function(v) {
      return (v * 100).toFixed(2) + "%";
    };
    var contentOpt = statistic2.content;
    if (contentOpt) {
      contentOpt = deepAssign({}, contentOpt, {
        content: !isNil(contentOpt.content) ? contentOpt.content : metaFormatter(percent2)
      });
    }
    renderStatistic(chart, { statistic: __assign$1(__assign$1({}, statistic2), { content: contentOpt }), plotType: "ring-progress" }, { percent: percent2 });
  }
  if (updated) {
    chart.render(true);
  }
  return params;
}
function adaptor$j(params) {
  return flow(geometry$i, scale$1({}), coordinate$4, statistic$2, animation$5, theme$2, annotation$2())(params);
}
var DEFAULT_OPTIONS$l = {
  percent: 0.2,
  innerRadius: 0.8,
  radius: 0.98,
  color: ["#FAAD14", "#E8EDF3"],
  statistic: {
    title: false,
    content: {
      style: {
        fontSize: "14px",
        fontWeight: 300,
        fill: "#4D4D4D",
        textAlign: "center",
        textBaseline: "middle"
      }
    }
  },
  animation: {}
};
var RingProgress = function(_super) {
  __extends$2(RingProgress2, _super);
  function RingProgress2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "ring-process";
    return _this;
  }
  RingProgress2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$l;
  };
  RingProgress2.prototype.changeData = function(percent2) {
    this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    this.updateOption({ percent: percent2 });
    this.chart.data(getProgressData(percent2));
    statistic$2({ chart: this.chart, options: this.options }, true);
    this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  RingProgress2.prototype.getDefaultOptions = function() {
    return RingProgress2.getDefaultOptions();
  };
  RingProgress2.prototype.getSchemaAdaptor = function() {
    return adaptor$j;
  };
  return RingProgress2;
}(Plot);
function geometry$h(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, type = options.type, xField = options.xField, yField = options.yField, colorField = options.colorField, sizeField = options.sizeField, sizeRatio = options.sizeRatio, shape = options.shape, color2 = options.color, tooltip2 = options.tooltip, heatmapStyle = options.heatmapStyle;
  chart.data(data2);
  var geometryType = "polygon";
  if (type === "density") {
    geometryType = "heatmap";
  }
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, colorField]), fields = _a2.fields, formatter = _a2.formatter;
  var checkedSizeRatio = 1;
  if (sizeRatio || sizeRatio === 0) {
    if (!shape && !sizeField) {
      console.warn("sizeRatio is not in effect: Must define shape or sizeField first");
    } else if (sizeRatio < 0 || sizeRatio > 1) {
      console.warn("sizeRatio is not in effect: It must be a number in [0,1]");
    } else {
      checkedSizeRatio = sizeRatio;
    }
  }
  geometry$w(deepAssign({}, params, {
    options: {
      type: geometryType,
      colorField,
      tooltipFields: fields,
      shapeField: sizeField || "",
      label: void 0,
      mapping: {
        tooltip: formatter,
        shape: shape && (sizeField ? function(dautm) {
          var field2 = data2.map(function(row) {
            return row[sizeField];
          });
          var min2 = Math.min.apply(Math, field2);
          var max2 = Math.max.apply(Math, field2);
          return [shape, (get(dautm, sizeField) - min2) / (max2 - min2), checkedSizeRatio];
        } : function() {
          return [shape, 1, checkedSizeRatio];
        }),
        color: color2 || colorField && chart.getTheme().sequenceColors.join("-"),
        style: heatmapStyle
      }
    }
  }));
  return params;
}
function meta$b(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale$1((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2)))(params);
}
function axis$d(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function legend$9(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, colorField = options.colorField, sizeField = options.sizeField, sizeLegend = options.sizeLegend;
  var showLegend = legend2 !== false;
  if (colorField) {
    chart.legend(colorField, showLegend ? legend2 : false);
  }
  if (sizeField) {
    chart.legend(sizeField, sizeLegend === void 0 ? legend2 : sizeLegend);
  }
  if (!showLegend && !sizeLegend) {
    chart.legend(false);
  }
  return params;
}
function label$6(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, colorField = options.colorField, type = options.type;
  var geometry2 = findGeometry(chart, type === "density" ? "heatmap" : "polygon");
  if (!label2) {
    geometry2.label(false);
  } else if (colorField) {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    geometry2.label({
      fields: [colorField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function coordinate$3(params) {
  var chart = params.chart, options = params.options;
  var coordinate2 = options.coordinate, reflect = options.reflect;
  if (coordinate2) {
    chart.coordinate({
      type: coordinate2.type || "rect",
      cfg: coordinate2.cfg
    });
  }
  if (reflect) {
    chart.coordinate().reflect(reflect);
  }
  return params;
}
function adaptor$i(params) {
  return flow(theme$2, pattern("heatmapStyle"), meta$b, coordinate$3, geometry$h, axis$d, legend$9, tooltip$8, label$6, annotation$2(), interaction$6, animation$5, state)(params);
}
var DEFAULT_OPTIONS$k = deepAssign({}, Plot.getDefaultOptions(), {
  type: "polygon",
  legend: false,
  coordinate: {
    type: "rect"
  },
  xAxis: {
    tickLine: null,
    line: null,
    grid: {
      alignTick: false,
      line: {
        style: {
          lineWidth: 1,
          lineDash: null,
          stroke: "#f0f0f0"
        }
      }
    }
  },
  yAxis: {
    grid: {
      alignTick: false,
      line: {
        style: {
          lineWidth: 1,
          lineDash: null,
          stroke: "#f0f0f0"
        }
      }
    }
  }
});
registerShape("polygon", "circle", {
  draw: function(cfg, group2) {
    var _a2, _b;
    var cx = cfg.x;
    var cy = cfg.y;
    var points = this.parsePoints(cfg.points);
    var width = Math.abs(points[2].x - points[1].x);
    var height = Math.abs(points[1].y - points[0].y);
    var maxRadius = Math.min(width, height) / 2;
    var value2 = Number(cfg.shape[1]);
    var sizeRatio = Number(cfg.shape[2]);
    var radiusRatio = Math.sqrt(sizeRatio);
    var radius = maxRadius * radiusRatio * Math.sqrt(value2);
    var fill = ((_a2 = cfg.style) === null || _a2 === void 0 ? void 0 : _a2.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
    var polygon2 = group2.addShape("circle", {
      attrs: __assign$1(__assign$1(__assign$1({ x: cx, y: cy, r: radius }, cfg.defaultStyle), cfg.style), { fill })
    });
    return polygon2;
  }
});
registerShape("polygon", "square", {
  draw: function(cfg, group2) {
    var _a2, _b;
    var cx = cfg.x;
    var cy = cfg.y;
    var points = this.parsePoints(cfg.points);
    var width = Math.abs(points[2].x - points[1].x);
    var height = Math.abs(points[1].y - points[0].y);
    var maxSideLength = Math.min(width, height);
    var value2 = Number(cfg.shape[1]);
    var sizeRatio = Number(cfg.shape[2]);
    var lenRatio = Math.sqrt(sizeRatio);
    var sideLength = maxSideLength * lenRatio * Math.sqrt(value2);
    var fill = ((_a2 = cfg.style) === null || _a2 === void 0 ? void 0 : _a2.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
    var polygon2 = group2.addShape("rect", {
      attrs: __assign$1(__assign$1(__assign$1({ x: cx - sideLength / 2, y: cy - sideLength / 2, width: sideLength, height: sideLength }, cfg.defaultStyle), cfg.style), { fill })
    });
    return polygon2;
  }
});
(function(_super) {
  __extends$2(Heatmap2, _super);
  function Heatmap2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "heatmap";
    return _this;
  }
  Heatmap2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$k;
  };
  Heatmap2.prototype.getSchemaAdaptor = function() {
    return adaptor$i;
  };
  Heatmap2.prototype.getDefaultOptions = function() {
    return Heatmap2.getDefaultOptions();
  };
  return Heatmap2;
})(Plot);
var _a$2;
var BOX_RANGE = "$$range$$";
var BOX_RANGE_ALIAS = "low-q1-median-q3-high";
var BOX_SYNC_NAME = "$$y_outliers$$";
var OUTLIERS_VIEW_ID = "outliers_view";
var DEFAULT_OPTIONS$j = deepAssign({}, Plot.getDefaultOptions(), {
  meta: (_a$2 = {}, _a$2[BOX_RANGE] = { min: 0, alias: BOX_RANGE_ALIAS }, _a$2),
  interactions: [{ type: "active-region" }],
  tooltip: {
    showMarkers: false,
    shared: true
  },
  boxStyle: {
    lineWidth: 1
  }
});
var transformData$8 = function(data2, yField) {
  var newData = data2;
  if (Array.isArray(yField)) {
    var low_1 = yField[0], q1_1 = yField[1], median_1 = yField[2], q3_1 = yField[3], high_1 = yField[4];
    newData = map$2(data2, function(obj) {
      obj[BOX_RANGE] = [obj[low_1], obj[q1_1], obj[median_1], obj[q3_1], obj[high_1]];
      return obj;
    });
  }
  return newData;
};
function field$4(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, groupField = options.groupField, color2 = options.color, tooltip2 = options.tooltip, boxStyle = options.boxStyle;
  chart.data(transformData$8(options.data, yField));
  var yFieldName = isArray$1(yField) ? BOX_RANGE : yField;
  var rawFields = yField ? isArray$1(yField) ? yField : [yField] : [];
  var tooltipOptions = tooltip2;
  if (tooltipOptions !== false) {
    tooltipOptions = deepAssign({}, { fields: isArray$1(yField) ? yField : [] }, tooltipOptions);
  }
  var ext = schema(deepAssign({}, params, {
    options: {
      xField,
      yField: yFieldName,
      seriesField: groupField,
      tooltip: tooltipOptions,
      rawFields,
      label: false,
      schema: {
        shape: "box",
        color: color2,
        style: boxStyle
      }
    }
  })).ext;
  if (groupField) {
    ext.geometry.adjust("dodge");
  }
  return params;
}
function outliersPoint(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, data2 = options.data, outliersField = options.outliersField, outliersStyle = options.outliersStyle, padding2 = options.padding, label2 = options.label;
  if (!outliersField)
    return params;
  var outliersView = chart.createView({ padding: padding2, id: OUTLIERS_VIEW_ID });
  var outliersViewData = data2.reduce(function(ret, datum) {
    var outliersData = datum[outliersField];
    outliersData.forEach(function(d) {
      var _a2;
      return ret.push(__assign$1(__assign$1({}, datum), (_a2 = {}, _a2[outliersField] = d, _a2)));
    });
    return ret;
  }, []);
  outliersView.data(outliersViewData);
  point({
    chart: outliersView,
    options: {
      xField,
      yField: outliersField,
      point: { shape: "circle", style: outliersStyle },
      label: label2
    }
  });
  outliersView.axis(false);
  return params;
}
function meta$a(params) {
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var meta2 = options.meta, xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, outliersField = options.outliersField;
  var yFieldName = Array.isArray(yField) ? BOX_RANGE : yField;
  var baseMeta = {};
  if (outliersField) {
    var syncName = BOX_SYNC_NAME;
    baseMeta = (_a2 = {}, _a2[outliersField] = { sync: syncName, nice: true }, _a2[yFieldName] = { sync: syncName, nice: true }, _a2);
  }
  var scales = deepAssign(baseMeta, meta2, (_b = {}, _b[xField] = pick(xAxis, AXIS_META_CONFIG_KEYS), _b[yFieldName] = pick(yAxis, AXIS_META_CONFIG_KEYS), _b));
  chart.scale(scales);
  return params;
}
function axis$c(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  var yFieldName = Array.isArray(yField) ? BOX_RANGE : yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(BOX_RANGE, false);
  } else {
    chart.axis(yFieldName, yAxis);
  }
  return params;
}
function legend$8(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, groupField = options.groupField;
  if (groupField) {
    if (legend2) {
      chart.legend(groupField, legend2);
    } else {
      chart.legend(groupField, { position: "bottom" });
    }
  } else {
    chart.legend(false);
  }
  return params;
}
function adaptor$h(params) {
  return flow(field$4, outliersPoint, meta$a, axis$c, legend$8, tooltip$8, interaction$6, animation$5, theme$2)(params);
}
(function(_super) {
  __extends$2(Box, _super);
  function Box() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "box";
    return _this;
  }
  Box.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$j;
  };
  Box.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var yField = this.options.yField;
    var outliersView = this.chart.views.find(function(v) {
      return v.id === OUTLIERS_VIEW_ID;
    });
    if (outliersView) {
      outliersView.data(data2);
    }
    this.chart.changeData(transformData$8(data2, yField));
  };
  Box.prototype.getDefaultOptions = function() {
    return Box.getDefaultOptions();
  };
  Box.prototype.getSchemaAdaptor = function() {
    return adaptor$h;
  };
  return Box;
})(Plot);
function quantileSorted(x, p) {
  var idx = x.length * p;
  if (x.length === 0) {
    throw new Error("quantile requires at least one data point.");
  } else if (p < 0 || p > 1) {
    throw new Error("quantiles must be between 0 and 1");
  } else if (p === 1) {
    return x[x.length - 1];
  } else if (p === 0) {
    return x[0];
  } else if (idx % 1 !== 0) {
    return x[Math.ceil(idx) - 1];
  } else if (x.length % 2 === 0) {
    return (x[idx - 1] + x[idx]) / 2;
  } else {
    return x[idx];
  }
}
function swap(arr, i, j) {
  var tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function quickselect(arr, k, left2, right2) {
  left2 = left2 || 0;
  right2 = right2 || arr.length - 1;
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      var n = right2 - left2 + 1;
      var m = k - left2 + 1;
      var z = Math.log(n);
      var s = 0.5 * Math.exp(2 * z / 3);
      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n);
      if (m - n / 2 < 0)
        sd *= -1;
      var newLeft = Math.max(left2, Math.floor(k - m * s / n + sd));
      var newRight = Math.min(right2, Math.floor(k + (n - m) * s / n + sd));
      quickselect(arr, k, newLeft, newRight);
    }
    var t = arr[k];
    var i = left2;
    var j = right2;
    swap(arr, left2, k);
    if (arr[right2] > t)
      swap(arr, left2, right2);
    while (i < j) {
      swap(arr, i, j);
      i++;
      j--;
      while (arr[i] < t)
        i++;
      while (arr[j] > t)
        j--;
    }
    if (arr[left2] === t)
      swap(arr, left2, j);
    else {
      j++;
      swap(arr, j, right2);
    }
    if (j <= k)
      left2 = j + 1;
    if (k <= j)
      right2 = j - 1;
  }
}
function quantile(x, p) {
  var copy = x.slice();
  if (Array.isArray(p)) {
    multiQuantileSelect(copy, p);
    var results = [];
    for (var i = 0; i < p.length; i++) {
      results[i] = quantileSorted(copy, p[i]);
    }
    return results;
  } else {
    var idx = quantileIndex(copy.length, p);
    quantileSelect(copy, idx, 0, copy.length - 1);
    return quantileSorted(copy, p);
  }
}
function quantileSelect(arr, k, left2, right2) {
  if (k % 1 === 0) {
    quickselect(arr, k, left2, right2);
  } else {
    k = Math.floor(k);
    quickselect(arr, k, left2, right2);
    quickselect(arr, k + 1, k + 1, right2);
  }
}
function multiQuantileSelect(arr, p) {
  var indices = [0];
  for (var i = 0; i < p.length; i++) {
    indices.push(quantileIndex(arr.length, p[i]));
  }
  indices.push(arr.length - 1);
  indices.sort(compare);
  var stack = [0, indices.length - 1];
  while (stack.length) {
    var r = Math.ceil(stack.pop());
    var l = Math.floor(stack.pop());
    if (r - l <= 1)
      continue;
    var m = Math.floor((l + r) / 2);
    quantileSelect(arr, indices[m], Math.floor(indices[l]), Math.ceil(indices[r]));
    stack.push(l, m, m, r);
  }
}
function compare(a, b) {
  return a - b;
}
function quantileIndex(len, p) {
  var idx = len * p;
  if (p === 1) {
    return len - 1;
  } else if (p === 0) {
    return 0;
  } else if (idx % 1 !== 0) {
    return Math.ceil(idx) - 1;
  } else if (len % 2 === 0) {
    return idx - 0.5;
  } else {
    return idx;
  }
}
var toBoxValue = function(values2) {
  return {
    low: min$1(values2),
    high: max$1(values2),
    q1: quantile(values2, 0.25),
    q3: quantile(values2, 0.75),
    median: quantile(values2, [0.5]),
    minMax: [min$1(values2), max$1(values2)],
    quantile: [quantile(values2, 0.25), quantile(values2, 0.75)]
  };
};
var toViolinValue = function(values2, pdfOptions) {
  var pdfResults = pdf.create(values2, pdfOptions);
  return {
    violinSize: pdfResults.map(function(result) {
      return result.y;
    }),
    violinY: pdfResults.map(function(result) {
      return result.x;
    })
  };
};
var transformViolinData = function(options) {
  var xField = options.xField, yField = options.yField, seriesField = options.seriesField, data2 = options.data, kde = options.kde;
  var pdfOptions = {
    min: kde.min,
    max: kde.max,
    size: kde.sampleSize,
    width: kde.width
  };
  if (!seriesField) {
    var group_1 = groupBy(data2, xField);
    return Object.keys(group_1).map(function(x) {
      var records = group_1[x];
      var values2 = records.map(function(record) {
        return record[yField];
      });
      return __assign$1(__assign$1({ x }, toViolinValue(values2, pdfOptions)), toBoxValue(values2));
    });
  }
  var resultList = [];
  var seriesGroup = groupBy(data2, seriesField);
  Object.keys(seriesGroup).forEach(function(series) {
    var group2 = groupBy(seriesGroup[series], xField);
    return Object.keys(group2).forEach(function(key) {
      var _a2;
      var records = group2[key];
      var values2 = records.map(function(record) {
        return record[yField];
      });
      resultList.push(__assign$1(__assign$1((_a2 = { x: key }, _a2[seriesField] = series, _a2), toViolinValue(values2, pdfOptions)), toBoxValue(values2)));
    });
  });
  return resultList;
};
var X_FIELD$2 = "x";
var VIOLIN_Y_FIELD = "violinY";
var VIOLIN_SIZE_FIELD = "violinSize";
var MIN_MAX_FIELD = "minMax";
var QUANTILE_FIELD = "quantile";
var MEDIAN_FIELD = "median";
var VIOLIN_VIEW_ID = "violin_view";
var MIN_MAX_VIEW_ID = "min_max_view";
var QUANTILE_VIEW_ID = "quantile_view";
var MEDIAN_VIEW_ID = "median_view";
var DEFAULT_OPTIONS$i = deepAssign({}, Plot.getDefaultOptions(), {
  syncViewPadding: true,
  kde: {
    type: "triangular",
    sampleSize: 32,
    width: 3
  },
  violinStyle: {
    lineWidth: 1,
    fillOpacity: 0.3,
    strokeOpacity: 0.75
  },
  xAxis: {
    grid: {
      line: null
    },
    tickLine: {
      alignTick: false
    }
  },
  yAxis: {
    grid: {
      line: {
        style: {
          lineWidth: 0.5,
          lineDash: [4, 4]
        }
      }
    }
  },
  legend: {
    position: "top-left"
  },
  tooltip: {
    showMarkers: false
  }
});
var TOOLTIP_FIELDS = ["low", "high", "q1", "q3", "median"];
var adjustCfg = [
  {
    type: "dodge",
    marginRatio: 1 / 32
  }
];
function data$1(params) {
  var chart = params.chart, options = params.options;
  chart.data(transformViolinData(options));
  return params;
}
function violinView(params) {
  var chart = params.chart, options = params.options;
  var seriesField = options.seriesField, color2 = options.color, _a2 = options.shape, shape = _a2 === void 0 ? "violin" : _a2, violinStyle = options.violinStyle, tooltip2 = options.tooltip, state2 = options.state;
  var view = chart.createView({ id: VIOLIN_VIEW_ID });
  violin({
    chart: view,
    options: {
      xField: X_FIELD$2,
      yField: VIOLIN_Y_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD$2,
      sizeField: VIOLIN_SIZE_FIELD,
      tooltip: __assign$1({ fields: TOOLTIP_FIELDS }, tooltip2),
      violin: {
        style: violinStyle,
        color: color2,
        shape
      },
      state: state2
    }
  });
  view.geometries[0].adjust(adjustCfg);
  return params;
}
function boxView(params) {
  var chart = params.chart, options = params.options;
  var seriesField = options.seriesField, color2 = options.color, tooltip2 = options.tooltip, box2 = options.box;
  if (box2 === false)
    return params;
  var minMaxView = chart.createView({ id: MIN_MAX_VIEW_ID });
  interval({
    chart: minMaxView,
    options: {
      xField: X_FIELD$2,
      yField: MIN_MAX_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD$2,
      tooltip: __assign$1({ fields: TOOLTIP_FIELDS }, tooltip2),
      state: typeof box2 === "object" ? box2.state : {},
      interval: {
        color: color2,
        size: 1,
        style: {
          lineWidth: 0
        }
      }
    }
  });
  minMaxView.geometries[0].adjust(adjustCfg);
  var quantileView = chart.createView({ id: QUANTILE_VIEW_ID });
  interval({
    chart: quantileView,
    options: {
      xField: X_FIELD$2,
      yField: QUANTILE_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD$2,
      tooltip: __assign$1({ fields: TOOLTIP_FIELDS }, tooltip2),
      state: typeof box2 === "object" ? box2.state : {},
      interval: {
        color: color2,
        size: 8,
        style: {
          fillOpacity: 1
        }
      }
    }
  });
  quantileView.geometries[0].adjust(adjustCfg);
  var medianView = chart.createView({ id: MEDIAN_VIEW_ID });
  point({
    chart: medianView,
    options: {
      xField: X_FIELD$2,
      yField: MEDIAN_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD$2,
      tooltip: __assign$1({ fields: TOOLTIP_FIELDS }, tooltip2),
      state: typeof box2 === "object" ? box2.state : {},
      point: {
        color: color2,
        size: 1,
        style: {
          fill: "white",
          lineWidth: 0
        }
      }
    }
  });
  medianView.geometries[0].adjust(adjustCfg);
  quantileView.axis(false);
  minMaxView.axis(false);
  medianView.axis(false);
  medianView.legend(false);
  minMaxView.legend(false);
  quantileView.legend(false);
  return params;
}
function meta$9(params) {
  var _a2;
  var chart = params.chart, options = params.options;
  var meta2 = options.meta, xAxis = options.xAxis, yAxis = options.yAxis;
  var baseMeta = {};
  var scales = deepAssign(baseMeta, meta2, (_a2 = {}, _a2[X_FIELD$2] = __assign$1(__assign$1({ sync: true }, pick(xAxis, AXIS_META_CONFIG_KEYS)), {
    type: "cat"
  }), _a2[VIOLIN_Y_FIELD] = __assign$1({ sync: true }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a2[MIN_MAX_FIELD] = __assign$1({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a2[QUANTILE_FIELD] = __assign$1({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a2[MEDIAN_FIELD] = __assign$1({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a2));
  chart.scale(scales);
  return params;
}
function axis$b(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis;
  var view = findViewById(chart, VIOLIN_VIEW_ID);
  if (xAxis === false) {
    view.axis(X_FIELD$2, false);
  } else {
    view.axis(X_FIELD$2, xAxis);
  }
  if (yAxis === false) {
    view.axis(VIOLIN_Y_FIELD, false);
  } else {
    view.axis(VIOLIN_Y_FIELD, yAxis);
  }
  chart.axis(false);
  return params;
}
function legend$7(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, seriesField = options.seriesField, shape = options.shape;
  if (legend2 === false) {
    chart.legend(false);
  } else {
    var legendField_1 = seriesField ? seriesField : X_FIELD$2;
    var legendOptions = omit$1(legend2, ["selected"]);
    if (!shape || !shape.startsWith("hollow")) {
      if (!get(legendOptions, ["marker", "style", "lineWidth"])) {
        set(legendOptions, ["marker", "style", "lineWidth"], 0);
      }
    }
    chart.legend(legendField_1, legendOptions);
    if (get(legend2, "selected")) {
      each$1(chart.views, function(view) {
        return view.legend(legendField_1, legend2);
      });
    }
  }
  return params;
}
function annotation(params) {
  var chart = params.chart;
  var violinView2 = findViewById(chart, VIOLIN_VIEW_ID);
  annotation$2()(__assign$1(__assign$1({}, params), { chart: violinView2 }));
  return params;
}
function animation$3(params) {
  var chart = params.chart, options = params.options;
  var animation2 = options.animation;
  each$1(chart.views, function(view) {
    if (typeof animation2 === "boolean") {
      view.animate(animation2);
    } else {
      view.animate(true);
    }
    each$1(view.geometries, function(g) {
      g.animate(animation2);
    });
  });
  return params;
}
function adaptor$g(params) {
  return flow(theme$2, data$1, violinView, boxView, meta$9, tooltip$8, axis$b, legend$7, interaction$6, annotation, animation$3)(params);
}
(function(_super) {
  __extends$2(Violin2, _super);
  function Violin2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "violin";
    return _this;
  }
  Violin2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$i;
  };
  Violin2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    this.chart.changeData(transformViolinData(this.options));
  };
  Violin2.prototype.getDefaultOptions = function() {
    return Violin2.getDefaultOptions();
  };
  Violin2.prototype.getSchemaAdaptor = function() {
    return adaptor$g;
  };
  return Violin2;
})(Plot);
var each = function(f) {
  return function(c0, c1) {
    var out = [];
    out[0] = f(c0[0], c1[0]);
    out[1] = f(c0[1], c1[1]);
    out[2] = f(c0[2], c1[2]);
    return out;
  };
};
var blendObject = {
  normal: function(a) {
    return a;
  },
  multiply: function(a, b) {
    return a * b / 255;
  },
  screen: function(a, b) {
    return 255 * (1 - (1 - a / 255) * (1 - b / 255));
  },
  overlay: function(a, b) {
    return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));
  },
  darken: function(a, b) {
    return a > b ? b : a;
  },
  lighten: function(a, b) {
    return a > b ? a : b;
  },
  dodge: function(a, b) {
    if (a === 255)
      return 255;
    a = 255 * (b / 255) / (1 - a / 255);
    return a > 255 ? 255 : a;
  },
  burn: function(a, b) {
    if (b === 255)
      return 255;
    else if (a === 0)
      return 0;
    else
      return 255 * (1 - Math.min(1, (1 - b / 255) / (a / 255)));
  }
};
var innerBlend = function(mode) {
  if (!blendObject[mode]) {
    throw new Error("unknown blend mode " + mode);
  }
  return blendObject[mode];
};
function blend(c0, c1, mode) {
  if (mode === void 0) {
    mode = "normal";
  }
  var blendRgbArr = each(innerBlend(mode))(colorToArr(c0), colorToArr(c1));
  var _a2 = colorToArr(c0), r0 = _a2[0], g0 = _a2[1], b0 = _a2[2], a0 = _a2[3];
  var _b = colorToArr(c1), r1 = _b[0], g1 = _b[1], b1 = _b[2], a1 = _b[3];
  var a = Number((a0 + a1 * (1 - a0)).toFixed(2));
  var r = Math.round((a0 * (1 - a1) * (r0 / 255) + a0 * a1 * (blendRgbArr[0] / 255) + (1 - a0) * a1 * (r1 / 255)) / a * 255);
  var g = Math.round((a0 * (1 - a1) * (g0 / 255) + a0 * a1 * (blendRgbArr[1] / 255) + (1 - a0) * a1 * (g1 / 255)) / a * 255);
  var b = Math.round((a0 * (1 - a1) * (b0 / 255) + a0 * a1 * (blendRgbArr[2] / 255) + (1 - a0) * a1 * (b1 / 255)) / a * 255);
  return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
}
function colorToArr(c) {
  var color2 = c.replace("/s+/g", "");
  var rgbaArr;
  if (typeof color2 === "string" && !color2.startsWith("rgba") && !color2.startsWith("#")) {
    return rgbaArr = colorUtil.rgb2arr(colorUtil.toRGB(color2)).concat([1]);
  }
  if (color2.startsWith("rgba"))
    rgbaArr = color2.replace("rgba(", "").replace(")", "").split(",");
  if (color2.startsWith("#"))
    rgbaArr = colorUtil.rgb2arr(color2).concat([1]);
  return rgbaArr.map(function(item, index2) {
    return index2 === 3 ? Number(item) : item | 0;
  });
}
var SMALL$1 = 1e-10;
function intersectionArea(circles, stats) {
  var intersectionPoints = getIntersectionPoints(circles);
  var innerPoints = intersectionPoints.filter(function(p3) {
    return containedInCircles(p3, circles);
  });
  var arcArea = 0, polygonArea = 0, i;
  var arcs = [];
  if (innerPoints.length > 1) {
    var center2 = getCenter(innerPoints);
    for (i = 0; i < innerPoints.length; ++i) {
      var p = innerPoints[i];
      p.angle = Math.atan2(p.x - center2.x, p.y - center2.y);
    }
    innerPoints.sort(function(a3, b) {
      return b.angle - a3.angle;
    });
    var p2 = innerPoints[innerPoints.length - 1];
    for (i = 0; i < innerPoints.length; ++i) {
      var p1 = innerPoints[i];
      polygonArea += (p2.x + p1.x) * (p1.y - p2.y);
      var midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      var arc2 = null;
      for (var j = 0; j < p1.parentIndex.length; ++j) {
        if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
          var circle2 = circles[p1.parentIndex[j]], a1 = Math.atan2(p1.x - circle2.x, p1.y - circle2.y), a2 = Math.atan2(p2.x - circle2.x, p2.y - circle2.y);
          var angleDiff = a2 - a1;
          if (angleDiff < 0) {
            angleDiff += 2 * Math.PI;
          }
          var a = a2 - angleDiff / 2;
          var width = distance(midPoint, {
            x: circle2.x + circle2.radius * Math.sin(a),
            y: circle2.y + circle2.radius * Math.cos(a)
          });
          if (width > circle2.radius * 2) {
            width = circle2.radius * 2;
          }
          if (arc2 === null || arc2.width > width) {
            arc2 = { circle: circle2, width, p1, p2 };
          }
        }
      }
      if (arc2 !== null) {
        arcs.push(arc2);
        arcArea += circleArea(arc2.circle.radius, arc2.width);
        p2 = p1;
      }
    }
  } else {
    var smallest = circles[0];
    for (i = 1; i < circles.length; ++i) {
      if (circles[i].radius < smallest.radius) {
        smallest = circles[i];
      }
    }
    var disjoint = false;
    for (i = 0; i < circles.length; ++i) {
      if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
        disjoint = true;
        break;
      }
    }
    if (disjoint) {
      arcArea = polygonArea = 0;
    } else {
      arcArea = smallest.radius * smallest.radius * Math.PI;
      arcs.push({
        circle: smallest,
        p1: { x: smallest.x, y: smallest.y + smallest.radius },
        p2: { x: smallest.x - SMALL$1, y: smallest.y + smallest.radius },
        width: smallest.radius * 2
      });
    }
  }
  polygonArea /= 2;
  if (stats) {
    stats.area = arcArea + polygonArea;
    stats.arcArea = arcArea;
    stats.polygonArea = polygonArea;
    stats.arcs = arcs;
    stats.innerPoints = innerPoints;
    stats.intersectionPoints = intersectionPoints;
  }
  return arcArea + polygonArea;
}
function containedInCircles(point2, circles) {
  for (var i = 0; i < circles.length; ++i) {
    if (distance(point2, circles[i]) > circles[i].radius + SMALL$1) {
      return false;
    }
  }
  return true;
}
function getIntersectionPoints(circles) {
  var ret = [];
  for (var i = 0; i < circles.length; ++i) {
    for (var j = i + 1; j < circles.length; ++j) {
      var intersect2 = circleCircleIntersection(circles[i], circles[j]);
      for (var k = 0; k < intersect2.length; ++k) {
        var p = intersect2[k];
        p.parentIndex = [i, j];
        ret.push(p);
      }
    }
  }
  return ret;
}
function circleArea(r, width) {
  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));
}
function distance(p1, p2) {
  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
function circleOverlap(r1, r2, d) {
  if (d >= r1 + r2) {
    return 0;
  }
  if (d <= Math.abs(r1 - r2)) {
    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
  }
  var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d), w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);
  return circleArea(r1, w1) + circleArea(r2, w2);
}
function circleCircleIntersection(p1, p2) {
  var d = distance(p1, p2), r1 = p1.radius, r2 = p2.radius;
  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {
    return [];
  }
  var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d), h = Math.sqrt(r1 * r1 - a * a), x0 = p1.x + a * (p2.x - p1.x) / d, y0 = p1.y + a * (p2.y - p1.y) / d, rx = -(p2.y - p1.y) * (h / d), ry = -(p2.x - p1.x) * (h / d);
  return [
    { x: x0 + rx, y: y0 - ry },
    { x: x0 - rx, y: y0 + ry }
  ];
}
function getCenter(points) {
  var center2 = { x: 0, y: 0 };
  for (var i = 0; i < points.length; ++i) {
    center2.x += points[i].x;
    center2.y += points[i].y;
  }
  center2.x /= points.length;
  center2.y /= points.length;
  return center2;
}
function venn(areas, parameters) {
  parameters = parameters || {};
  parameters.maxIterations = parameters.maxIterations || 500;
  var initialLayout = parameters.initialLayout || bestInitialLayout;
  var loss = parameters.lossFunction || lossFunction;
  areas = addMissingAreas(areas);
  var circles = initialLayout(areas, parameters);
  var initial = [], setids = [];
  var setid;
  for (setid in circles) {
    if (circles.hasOwnProperty(setid)) {
      initial.push(circles[setid].x);
      initial.push(circles[setid].y);
      setids.push(setid);
    }
  }
  var solution = nelderMead(function(values2) {
    var current = {};
    for (var i2 = 0; i2 < setids.length; ++i2) {
      var setid_1 = setids[i2];
      current[setid_1] = {
        x: values2[2 * i2],
        y: values2[2 * i2 + 1],
        radius: circles[setid_1].radius
      };
    }
    return loss(current, areas);
  }, initial, parameters);
  var positions = solution.x;
  for (var i = 0; i < setids.length; ++i) {
    setid = setids[i];
    circles[setid].x = positions[2 * i];
    circles[setid].y = positions[2 * i + 1];
  }
  return circles;
}
var SMALL = 1e-10;
function distanceFromIntersectArea(r1, r2, overlap2) {
  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap2 + SMALL) {
    return Math.abs(r1 - r2);
  }
  return bisect(function(distance2) {
    return circleOverlap(r1, r2, distance2) - overlap2;
  }, 0, r1 + r2);
}
function addMissingAreas(areas) {
  areas = areas.slice();
  var ids = [], pairs = {};
  var i, j, a, b;
  for (i = 0; i < areas.length; ++i) {
    var area2 = areas[i];
    if (area2.sets.length == 1) {
      ids.push(area2.sets[0]);
    } else if (area2.sets.length == 2) {
      a = area2.sets[0];
      b = area2.sets[1];
      pairs[[a, b]] = true;
      pairs[[b, a]] = true;
    }
  }
  ids.sort(function(a2, b2) {
    return a2 > b2 ? 1 : -1;
  });
  for (i = 0; i < ids.length; ++i) {
    a = ids[i];
    for (j = i + 1; j < ids.length; ++j) {
      b = ids[j];
      if (!([a, b] in pairs)) {
        areas.push({ sets: [a, b], size: 0 });
      }
    }
  }
  return areas;
}
function getDistanceMatrices(areas, sets, setids) {
  var distances = zerosM(sets.length, sets.length), constraints = zerosM(sets.length, sets.length);
  areas.filter(function(x) {
    return x.sets.length == 2;
  }).map(function(current) {
    var left2 = setids[current.sets[0]], right2 = setids[current.sets[1]], r1 = Math.sqrt(sets[left2].size / Math.PI), r2 = Math.sqrt(sets[right2].size / Math.PI), distance2 = distanceFromIntersectArea(r1, r2, current.size);
    distances[left2][right2] = distances[right2][left2] = distance2;
    var c = 0;
    if (current.size + 1e-10 >= Math.min(sets[left2].size, sets[right2].size)) {
      c = 1;
    } else if (current.size <= 1e-10) {
      c = -1;
    }
    constraints[left2][right2] = constraints[right2][left2] = c;
  });
  return { distances, constraints };
}
function constrainedMDSGradient(x, fxprime, distances, constraints) {
  var loss = 0, i;
  for (i = 0; i < fxprime.length; ++i) {
    fxprime[i] = 0;
  }
  for (i = 0; i < distances.length; ++i) {
    var xi = x[2 * i], yi = x[2 * i + 1];
    for (var j = i + 1; j < distances.length; ++j) {
      var xj = x[2 * j], yj = x[2 * j + 1], dij = distances[i][j], constraint = constraints[i][j];
      var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi), distance_1 = Math.sqrt(squaredDistance), delta = squaredDistance - dij * dij;
      if (constraint > 0 && distance_1 <= dij || constraint < 0 && distance_1 >= dij) {
        continue;
      }
      loss += 2 * delta * delta;
      fxprime[2 * i] += 4 * delta * (xi - xj);
      fxprime[2 * i + 1] += 4 * delta * (yi - yj);
      fxprime[2 * j] += 4 * delta * (xj - xi);
      fxprime[2 * j + 1] += 4 * delta * (yj - yi);
    }
  }
  return loss;
}
function bestInitialLayout(areas, params) {
  var initial = greedyLayout(areas, params);
  var loss = params.lossFunction || lossFunction;
  if (areas.length >= 8) {
    var constrained = constrainedMDSLayout(areas, params), constrainedLoss = loss(constrained, areas), greedyLoss = loss(initial, areas);
    if (constrainedLoss + 1e-8 < greedyLoss) {
      initial = constrained;
    }
  }
  return initial;
}
function constrainedMDSLayout(areas, params) {
  params = params || {};
  var restarts = params.restarts || 10;
  var sets = [], setids = {};
  var i;
  for (i = 0; i < areas.length; ++i) {
    var area2 = areas[i];
    if (area2.sets.length == 1) {
      setids[area2.sets[0]] = sets.length;
      sets.push(area2);
    }
  }
  var matrices = getDistanceMatrices(areas, sets, setids);
  var distances = matrices.distances;
  var constraints = matrices.constraints;
  var norm = norm2(distances.map(norm2)) / distances.length;
  distances = distances.map(function(row) {
    return row.map(function(value2) {
      return value2 / norm;
    });
  });
  var obj = function(x, fxprime) {
    return constrainedMDSGradient(x, fxprime, distances, constraints);
  };
  var best, current;
  for (i = 0; i < restarts; ++i) {
    var initial = zeros(distances.length * 2).map(Math.random);
    current = conjugateGradient(obj, initial, params);
    if (!best || current.fx < best.fx) {
      best = current;
    }
  }
  var positions = best.x;
  var circles = {};
  for (i = 0; i < sets.length; ++i) {
    var set2 = sets[i];
    circles[set2.sets[0]] = {
      x: positions[2 * i] * norm,
      y: positions[2 * i + 1] * norm,
      radius: Math.sqrt(set2.size / Math.PI)
    };
  }
  if (params.history) {
    for (i = 0; i < params.history.length; ++i) {
      scale$3(params.history[i].x, norm);
    }
  }
  return circles;
}
function greedyLayout(areas, params) {
  var loss = params && params.lossFunction ? params.lossFunction : lossFunction;
  var circles = {}, setOverlaps = {};
  var set2;
  for (var i = 0; i < areas.length; ++i) {
    var area2 = areas[i];
    if (area2.sets.length == 1) {
      set2 = area2.sets[0];
      circles[set2] = {
        x: 1e10,
        y: 1e10,
        rowid: Object.keys(circles).length,
        size: area2.size,
        radius: Math.sqrt(area2.size / Math.PI)
      };
      setOverlaps[set2] = [];
    }
  }
  areas = areas.filter(function(a) {
    return a.sets.length == 2;
  });
  for (var i = 0; i < areas.length; ++i) {
    var current = areas[i];
    var weight = current.hasOwnProperty("weight") ? current.weight : 1;
    var left2 = current.sets[0], right2 = current.sets[1];
    if (current.size + SMALL >= Math.min(circles[left2].size, circles[right2].size)) {
      weight = 0;
    }
    setOverlaps[left2].push({ set: right2, size: current.size, weight });
    setOverlaps[right2].push({ set: left2, size: current.size, weight });
  }
  var mostOverlapped = [];
  for (set2 in setOverlaps) {
    if (setOverlaps.hasOwnProperty(set2)) {
      var size2 = 0;
      for (var i = 0; i < setOverlaps[set2].length; ++i) {
        size2 += setOverlaps[set2][i].size * setOverlaps[set2][i].weight;
      }
      mostOverlapped.push({ set: set2, size: size2 });
    }
  }
  function sortOrder(a, b) {
    return b.size - a.size;
  }
  mostOverlapped.sort(sortOrder);
  var positioned = {};
  function isPositioned(element) {
    return element.set in positioned;
  }
  function positionSet(point2, index2) {
    circles[index2].x = point2.x;
    circles[index2].y = point2.y;
    positioned[index2] = true;
  }
  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);
  for (var i = 1; i < mostOverlapped.length; ++i) {
    var setIndex = mostOverlapped[i].set, overlap2 = setOverlaps[setIndex].filter(isPositioned);
    set2 = circles[setIndex];
    overlap2.sort(sortOrder);
    if (overlap2.length === 0) {
      throw "ERROR: missing pairwise overlap information";
    }
    var points = [];
    for (var j = 0; j < overlap2.length; ++j) {
      var p1 = circles[overlap2[j].set], d1 = distanceFromIntersectArea(set2.radius, p1.radius, overlap2[j].size);
      points.push({ x: p1.x + d1, y: p1.y });
      points.push({ x: p1.x - d1, y: p1.y });
      points.push({ y: p1.y + d1, x: p1.x });
      points.push({ y: p1.y - d1, x: p1.x });
      for (var k = j + 1; k < overlap2.length; ++k) {
        var p2 = circles[overlap2[k].set], d2 = distanceFromIntersectArea(set2.radius, p2.radius, overlap2[k].size);
        var extraPoints = circleCircleIntersection({ x: p1.x, y: p1.y, radius: d1 }, { x: p2.x, y: p2.y, radius: d2 });
        for (var l = 0; l < extraPoints.length; ++l) {
          points.push(extraPoints[l]);
        }
      }
    }
    var bestLoss = 1e50, bestPoint = points[0];
    for (var j = 0; j < points.length; ++j) {
      circles[setIndex].x = points[j].x;
      circles[setIndex].y = points[j].y;
      var localLoss = loss(circles, areas);
      if (localLoss < bestLoss) {
        bestLoss = localLoss;
        bestPoint = points[j];
      }
    }
    positionSet(bestPoint, setIndex);
  }
  return circles;
}
function lossFunction(sets, overlaps) {
  var output = 0;
  function getCircles(indices) {
    return indices.map(function(i2) {
      return sets[i2];
    });
  }
  for (var i = 0; i < overlaps.length; ++i) {
    var area2 = overlaps[i];
    var overlap2 = void 0;
    if (area2.sets.length == 1) {
      continue;
    } else if (area2.sets.length == 2) {
      var left2 = sets[area2.sets[0]], right2 = sets[area2.sets[1]];
      overlap2 = circleOverlap(left2.radius, right2.radius, distance(left2, right2));
    } else {
      overlap2 = intersectionArea(getCircles(area2.sets));
    }
    var weight = area2.hasOwnProperty("weight") ? area2.weight : 1;
    output += weight * (overlap2 - area2.size) * (overlap2 - area2.size);
  }
  return output;
}
function getBoundingBox(circles) {
  var minMax = function(d) {
    var hi = Math.max.apply(null, circles.map(function(c) {
      return c[d] + c.radius;
    })), lo = Math.min.apply(null, circles.map(function(c) {
      return c[d] - c.radius;
    }));
    return { max: hi, min: lo };
  };
  return { xRange: minMax("x"), yRange: minMax("y") };
}
function scaleSolution(solution, width, height, padding2) {
  var circles = [], setids = [];
  for (var setid in solution) {
    if (solution.hasOwnProperty(setid)) {
      setids.push(setid);
      circles.push(solution[setid]);
    }
  }
  width -= 2 * padding2;
  height -= 2 * padding2;
  var bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;
  if (xRange.max == xRange.min || yRange.max == yRange.min) {
    console.log("not scaling solution: zero size detected");
    return solution;
  }
  var xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
  var scaled = {};
  for (var i = 0; i < circles.length; ++i) {
    var circle2 = circles[i];
    scaled[setids[i]] = {
      radius: scaling * circle2.radius,
      x: padding2 + xOffset + (circle2.x - xRange.min) * scaling,
      y: padding2 + yOffset + (circle2.y - yRange.min) * scaling
    };
  }
  return scaled;
}
function circleMargin(current, interior, exterior) {
  var margin = interior[0].radius - distance(interior[0], current), i, m;
  for (i = 1; i < interior.length; ++i) {
    m = interior[i].radius - distance(interior[i], current);
    if (m <= margin) {
      margin = m;
    }
  }
  for (i = 0; i < exterior.length; ++i) {
    m = distance(exterior[i], current) - exterior[i].radius;
    if (m <= margin) {
      margin = m;
    }
  }
  return margin;
}
function computeTextCentre(interior, exterior) {
  var points = [];
  var i;
  for (i = 0; i < interior.length; ++i) {
    var c = interior[i];
    points.push({ x: c.x, y: c.y });
    points.push({ x: c.x + c.radius / 2, y: c.y });
    points.push({ x: c.x - c.radius / 2, y: c.y });
    points.push({ x: c.x, y: c.y + c.radius / 2 });
    points.push({ x: c.x, y: c.y - c.radius / 2 });
  }
  var initial = points[0], margin = circleMargin(points[0], interior, exterior);
  for (i = 1; i < points.length; ++i) {
    var m = circleMargin(points[i], interior, exterior);
    if (m >= margin) {
      initial = points[i];
      margin = m;
    }
  }
  var solution = nelderMead(function(p) {
    return -1 * circleMargin({ x: p[0], y: p[1] }, interior, exterior);
  }, [initial.x, initial.y], { maxIterations: 500, minErrorDelta: 1e-10 }).x;
  var ret = { x: solution[0], y: solution[1] };
  var valid = true;
  for (i = 0; i < interior.length; ++i) {
    if (distance(ret, interior[i]) > interior[i].radius) {
      valid = false;
      break;
    }
  }
  for (i = 0; i < exterior.length; ++i) {
    if (distance(ret, exterior[i]) < exterior[i].radius) {
      valid = false;
      break;
    }
  }
  if (!valid) {
    if (interior.length == 1) {
      ret = { x: interior[0].x, y: interior[0].y };
    } else {
      var areaStats = {};
      intersectionArea(interior, areaStats);
      if (areaStats.arcs.length === 0) {
        ret = { x: 0, y: -1e3, disjoint: true };
      } else if (areaStats.arcs.length == 1) {
        ret = { x: areaStats.arcs[0].circle.x, y: areaStats.arcs[0].circle.y };
      } else if (exterior.length) {
        ret = computeTextCentre(interior, []);
      } else {
        ret = getCenter(areaStats.arcs.map(function(a) {
          return a.p1;
        }));
      }
    }
  }
  return ret;
}
function getOverlappingCircles(circles) {
  var ret = {}, circleids = [];
  for (var circleid in circles) {
    circleids.push(circleid);
    ret[circleid] = [];
  }
  for (var i = 0; i < circleids.length; i++) {
    var a = circles[circleids[i]];
    for (var j = i + 1; j < circleids.length; ++j) {
      var b = circles[circleids[j]], d = distance(a, b);
      if (d + b.radius <= a.radius + 1e-10) {
        ret[circleids[j]].push(circleids[i]);
      } else if (d + a.radius <= b.radius + 1e-10) {
        ret[circleids[i]].push(circleids[j]);
      }
    }
  }
  return ret;
}
function computeTextCentres(circles, areas) {
  var ret = {}, overlapped = getOverlappingCircles(circles);
  for (var i = 0; i < areas.length; ++i) {
    var area2 = areas[i].sets, areaids = {}, exclude = {};
    for (var j = 0; j < area2.length; ++j) {
      areaids[area2[j]] = true;
      var overlaps = overlapped[area2[j]];
      for (var k = 0; k < overlaps.length; ++k) {
        exclude[overlaps[k]] = true;
      }
    }
    var interior = [], exterior = [];
    for (var setid in circles) {
      if (setid in areaids) {
        interior.push(circles[setid]);
      } else if (!(setid in exclude)) {
        exterior.push(circles[setid]);
      }
    }
    var centre = computeTextCentre(interior, exterior);
    ret[area2] = centre;
    if (centre.disjoint && areas[i].size > 0) {
      console.log("WARNING: area " + area2 + " not represented on screen");
    }
  }
  return ret;
}
function circlePath(x, y, r) {
  var ret = [];
  var x0 = x - r;
  var y0 = y;
  ret.push("M", x0, y0);
  ret.push("A", r, r, 0, 1, 0, x0 + 2 * r, y0);
  ret.push("A", r, r, 0, 1, 0, x0, y0);
  return ret.join(" ");
}
function intersectionAreaPath(circles) {
  var stats = {};
  intersectionArea(circles, stats);
  var arcs = stats.arcs;
  if (arcs.length === 0) {
    return "M 0 0";
  } else if (arcs.length == 1) {
    var circle2 = arcs[0].circle;
    return circlePath(circle2.x, circle2.y, circle2.radius);
  } else {
    var ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];
    for (var i = 0; i < arcs.length; ++i) {
      var arc2 = arcs[i], r = arc2.circle.radius, wide = arc2.width > r;
      ret.push("\nA", r, r, 0, wide ? 1 : 0, 1, arc2.p1.x, arc2.p1.y);
    }
    return ret.join(" ");
  }
}
var ID_FIELD = "id";
var PATH_FIELD = "path";
var DEFAULT_OPTIONS$h = {
  appendPadding: [10, 0, 20, 0],
  blendMode: "multiply",
  tooltip: {
    showTitle: false,
    showMarkers: false,
    fields: ["id", "size"],
    formatter: function(datum) {
      return { name: datum.id, value: datum.size };
    }
  },
  legend: { position: "top-left" },
  label: {
    style: {
      textAlign: "center",
      fill: "#fff"
    }
  },
  interactions: [{ type: "legend-filter", enable: false }],
  state: {
    active: {
      style: {
        stroke: "#000"
      }
    },
    selected: {
      style: {
        stroke: "#000",
        lineWidth: 2
      }
    },
    inactive: {
      style: {
        fillOpacity: 0.3,
        strokeOpacity: 0.3
      }
    }
  },
  defaultInteractions: ["tooltip", "venn-legend-active"]
};
var getColorMap = memoize(function(colorPalette, data2, blendMode, setsField) {
  var colorMap2 = new Map();
  var colorPaletteLen = colorPalette.length;
  data2.forEach(function(d, idx) {
    if (d[setsField].length === 1) {
      colorMap2.set(d[ID_FIELD], colorPalette[(idx + colorPaletteLen) % colorPaletteLen]);
    } else {
      var colorArr = d[setsField].map(function(id) {
        return colorMap2.get(id);
      });
      colorMap2.set(d[ID_FIELD], colorArr.slice(1).reduce(function(a, b) {
        return blend(a, b, blendMode);
      }, colorArr[0]));
    }
  });
  return colorMap2;
}, function() {
  var params = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    params[_i] = arguments[_i];
  }
  return JSON.stringify(params);
});
function layoutVennData(options, width, height, padding2) {
  if (padding2 === void 0) {
    padding2 = 0;
  }
  var data2 = options.data, setsField = options.setsField, sizeField = options.sizeField;
  if (data2.length === 0) {
    log(LEVEL.WARN, false, "warn: %s", "\u6570\u636E\u4E0D\u80FD\u4E3A\u7A7A");
    return [];
  }
  var vennData = data2.map(function(d) {
    var _a2;
    return __assign$1(__assign$1({}, d), (_a2 = { sets: d[setsField] || [], size: d[sizeField] }, _a2[PATH_FIELD] = "", _a2[ID_FIELD] = "", _a2));
  });
  vennData.sort(function(a, b) {
    return a.sets.length - b.sets.length;
  });
  var solution = venn(vennData);
  var circles = scaleSolution(solution, width, height, padding2);
  var textCenters = computeTextCentres(circles, vennData);
  vennData.forEach(function(row) {
    var sets = row.sets;
    var id = sets.join(",");
    row[ID_FIELD] = id;
    var setCircles = sets.map(function(set2) {
      return circles[set2];
    });
    var path2 = intersectionAreaPath(setCircles);
    if (!/[zZ]$/.test(path2)) {
      path2 += " Z";
    }
    row[PATH_FIELD] = path2;
    var center2 = textCenters[id] || { x: 0, y: 0 };
    mix(row, center2);
  });
  return vennData;
}
function islegalSets(legalArr, testArr) {
  for (var i = 0; i < testArr.length; i++) {
    if (!legalArr.includes(testArr[i])) {
      return false;
    }
  }
  return true;
}
function getFillAttrs$2(cfg) {
  return deepAssign({}, cfg.defaultStyle, { fill: cfg.color }, cfg.style);
}
registerShape("schema", "venn", {
  draw: function(cfg, container) {
    var data2 = cfg.data;
    var segments = parsePathString$1(data2[PATH_FIELD]);
    var fillAttrs = getFillAttrs$2(cfg);
    var group2 = container.addGroup({ name: "venn-shape" });
    group2.addShape("path", {
      attrs: __assign$1(__assign$1({}, fillAttrs), { path: segments }),
      name: "venn-path"
    });
    var _a2 = cfg.customInfo, offsetX = _a2.offsetX, offsetY = _a2.offsetY;
    var matrix = Util.transform(null, [["t", offsetX, offsetY]]);
    group2.setMatrix(matrix);
    return group2;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        lineWidth: 0,
        stroke: color2,
        fill: color2,
        r: 4
      }
    };
  }
});
var VennLabel = function(_super) {
  __extends$2(VennLabel2, _super);
  function VennLabel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  VennLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index2) {
    var _a2 = labelCfg.data, x = _a2.x, y = _a2.y;
    var _b = labelCfg.customLabelInfo, offsetX = _b.offsetX, offsetY = _b.offsetY;
    return {
      content: labelCfg.content[index2],
      x: x + offsetX,
      y: y + offsetY
    };
  };
  return VennLabel2;
}(GeometryLabel);
registerGeometryLabel("venn", VennLabel);
function placeElementsOrdered(view) {
  if (!view) {
    return;
  }
  var elements = view.geometries[0].elements;
  elements.forEach(function(elem) {
    elem.shape.toFront();
  });
}
var ElementActiveAction = getActionClass("element-active");
var VennElementActive = function(_super) {
  __extends$2(VennElementActive2, _super);
  function VennElementActive2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  VennElementActive2.prototype.syncElementsPos = function() {
    placeElementsOrdered(this.context.view);
  };
  VennElementActive2.prototype.active = function() {
    _super.prototype.active.call(this);
    this.syncElementsPos();
  };
  VennElementActive2.prototype.toggle = function() {
    _super.prototype.toggle.call(this);
    this.syncElementsPos();
  };
  VennElementActive2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.syncElementsPos();
  };
  return VennElementActive2;
}(ElementActiveAction);
var ElementHighlightAction = getActionClass("element-highlight");
var VennElementHighlight = function(_super) {
  __extends$2(VennElementHighlight2, _super);
  function VennElementHighlight2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  VennElementHighlight2.prototype.syncElementsPos = function() {
    placeElementsOrdered(this.context.view);
  };
  VennElementHighlight2.prototype.highlight = function() {
    _super.prototype.highlight.call(this);
    this.syncElementsPos();
  };
  VennElementHighlight2.prototype.toggle = function() {
    _super.prototype.toggle.call(this);
    this.syncElementsPos();
  };
  VennElementHighlight2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this.syncElementsPos();
  };
  VennElementHighlight2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.syncElementsPos();
  };
  return VennElementHighlight2;
}(ElementHighlightAction);
var ElementSelectedAction = getActionClass("element-selected");
var ElementSingleSelectedAction = getActionClass("element-single-selected");
var VennElementSelected = function(_super) {
  __extends$2(VennElementSelected2, _super);
  function VennElementSelected2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  VennElementSelected2.prototype.syncElementsPos = function() {
    placeElementsOrdered(this.context.view);
  };
  VennElementSelected2.prototype.selected = function() {
    _super.prototype.selected.call(this);
    this.syncElementsPos();
  };
  VennElementSelected2.prototype.toggle = function() {
    _super.prototype.toggle.call(this);
    this.syncElementsPos();
  };
  VennElementSelected2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.syncElementsPos();
  };
  return VennElementSelected2;
}(ElementSelectedAction);
var VennElementSingleSelected = function(_super) {
  __extends$2(VennElementSingleSelected2, _super);
  function VennElementSingleSelected2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  VennElementSingleSelected2.prototype.syncElementsPos = function() {
    placeElementsOrdered(this.context.view);
  };
  VennElementSingleSelected2.prototype.selected = function() {
    _super.prototype.selected.call(this);
    this.syncElementsPos();
  };
  VennElementSingleSelected2.prototype.toggle = function() {
    _super.prototype.toggle.call(this);
    this.syncElementsPos();
  };
  VennElementSingleSelected2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.syncElementsPos();
  };
  return VennElementSingleSelected2;
}(ElementSingleSelectedAction);
registerAction("venn-element-active", VennElementActive);
registerAction("venn-element-highlight", VennElementHighlight);
registerAction("venn-element-selected", VennElementSelected);
registerAction("venn-element-single-selected", VennElementSingleSelected);
registerInteraction("venn-element-active", {
  start: [{ trigger: "element:mouseenter", action: "venn-element-active:active" }],
  end: [{ trigger: "element:mouseleave", action: "venn-element-active:reset" }]
});
registerInteraction("venn-element-highlight", {
  start: [{ trigger: "element:mouseenter", action: "venn-element-highlight:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "venn-element-highlight:reset" }]
});
registerInteraction("venn-element-selected", {
  start: [{ trigger: "element:click", action: "venn-element-selected:toggle" }],
  rollback: [{ trigger: "dblclick", action: ["venn-element-selected:reset"] }]
});
registerInteraction("venn-element-single-selected", {
  start: [{ trigger: "element:click", action: "venn-element-single-selected:toggle" }],
  rollback: [{ trigger: "dblclick", action: ["venn-element-single-selected:reset"] }]
});
registerInteraction("venn-legend-active", {
  start: [{ trigger: "legend-item:mouseenter", action: ["list-active:active", "venn-element-active:active"] }],
  end: [{ trigger: "legend-item:mouseleave", action: ["list-active:reset", "venn-element-active:reset"] }]
});
registerInteraction("venn-legend-highlight", {
  start: [
    {
      trigger: "legend-item:mouseenter",
      action: ["legend-item-highlight:highlight", "venn-element-highlight:highlight"]
    }
  ],
  end: [{ trigger: "legend-item:mouseleave", action: ["legend-item-highlight:reset", "venn-element-highlight:reset"] }]
});
var LEGEND_SPACE = 40;
function colorMap(params, data2, colorPalette) {
  var chart = params.chart, options = params.options;
  var blendMode = options.blendMode, setsField = options.setsField;
  var _a2 = chart.getTheme(), colors10 = _a2.colors10, colors20 = _a2.colors20;
  var palette = colorPalette;
  if (!isArray$1(palette)) {
    palette = data2.filter(function(d) {
      return d[setsField].length === 1;
    }).length <= 10 ? colors10 : colors20;
  }
  var map2 = getColorMap(palette, data2, blendMode, setsField);
  return function(id) {
    return map2.get(id) || palette[0];
  };
}
function transformColor(params, data2) {
  var options = params.options;
  var color2 = options.color;
  if (typeof color2 !== "function") {
    var colorPalette = typeof color2 === "string" ? [color2] : color2;
    var map_1 = colorMap(params, data2, colorPalette);
    return function(datum) {
      return map_1(datum[ID_FIELD]);
    };
  }
  return color2;
}
function padding$1(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, appendPadding = options.appendPadding, padding2 = options.padding;
  var tempPadding = normalPadding(appendPadding);
  if (legend2 !== false) {
    tempPadding = getAdjustAppendPadding(appendPadding, get(legend2, "position"), LEGEND_SPACE);
  }
  chart.appendPadding = resolveAllPadding([tempPadding, padding2]);
  return params;
}
function data(params) {
  var options = params.options;
  var data2 = options["data"];
  if (!data2) {
    log(LEVEL.WARN, false, "warn: %s", "\u6570\u636E\u4E0D\u80FD\u4E3A\u7A7A");
    data2 = [];
  }
  var currSets = data2.filter(function(datum) {
    return datum.sets.length === 1;
  }).map(function(datum) {
    return datum.sets[0];
  });
  var filterSets = data2.filter(function(datum) {
    var sets = datum.sets;
    return islegalSets(currSets, sets);
  });
  if (!isEqual$2(filterSets, data2))
    log(LEVEL.WARN, false, "warn: %s", "\u4EA4\u96C6\u4E2D\u4E0D\u80FD\u51FA\u73B0\u4E0D\u5B58\u5728\u7684\u96C6\u5408, \u8BF7\u8F93\u5165\u5408\u6CD5\u6570\u636E");
  return deepMix({}, params, {
    options: {
      data: filterSets
    }
  });
}
function geometry$g(params) {
  var chart = params.chart, options = params.options;
  var pointStyle = options.pointStyle, setsField = options.setsField, sizeField = options.sizeField;
  var _a2 = normalPadding(chart.appendPadding), t = _a2[0], r = _a2[1], b = _a2[2], l = _a2[3];
  var customInfo = { offsetX: l, offsetY: t };
  var _b = chart.viewBBox, width = _b.width, height = _b.height;
  var vennData = layoutVennData(options, Math.max(width - (r + l), 0), Math.max(height - (t + b), 0), 0);
  chart.data(vennData);
  var ext = schema(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      sizeField,
      seriesField: ID_FIELD,
      rawFields: [setsField, sizeField],
      schema: {
        shape: "venn",
        style: pointStyle
      }
    }
  })).ext;
  var geometry2 = ext.geometry;
  geometry2.customInfo(customInfo);
  var colorOptions = transformColor(params, vennData);
  if (typeof colorOptions === "function") {
    geometry2.color(ID_FIELD, function(id) {
      var datum = vennData.find(function(d) {
        return d[ID_FIELD] === id;
      });
      var defaultColor = colorMap(params, vennData)(id);
      return colorOptions(datum, defaultColor);
    });
  }
  return params;
}
function label$5(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label;
  var _a2 = normalPadding(chart.appendPadding), t = _a2[0], l = _a2[3];
  var customLabelInfo = { offsetX: l, offsetY: t };
  var geometry2 = findGeometry(chart, "schema");
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    geometry2.label({
      fields: ["id"],
      callback,
      cfg: deepMix({}, transformLabel(cfg), {
        type: "venn",
        customLabelInfo
      })
    });
  }
  return params;
}
function legend$6(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, sizeField = options.sizeField;
  chart.legend(ID_FIELD, legend2);
  chart.legend(sizeField, false);
  return params;
}
function axis$a(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function vennInteraction(params) {
  var options = params.options, chart = params.chart;
  var interactions = options.interactions;
  if (interactions) {
    var MAP_1 = {
      "legend-active": "venn-legend-active",
      "legend-highlight": "venn-legend-highlight"
    };
    interaction$6(deepAssign({}, params, {
      options: {
        interactions: interactions.map(function(i) {
          return __assign$1(__assign$1({}, i), { type: MAP_1[i.type] || i.type });
        })
      }
    }));
  }
  chart.removeInteraction("legend-active");
  chart.removeInteraction("legend-highlight");
  return params;
}
function adaptor$f(params) {
  return flow(padding$1, theme$2, data, geometry$g, label$5, scale$1({}), legend$6, axis$a, tooltip$8, vennInteraction, animation$5)(params);
}
(function(_super) {
  __extends$2(Venn, _super);
  function Venn() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "venn";
    return _this;
  }
  Venn.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$h;
  };
  Venn.prototype.getDefaultOptions = function() {
    return Venn.getDefaultOptions();
  };
  Venn.prototype.getSchemaAdaptor = function() {
    return adaptor$f;
  };
  Venn.prototype.triggerResize = function() {
    if (!this.chart.destroyed) {
      this.chart.forceFit();
      this.chart.clear();
      this.execAdaptor();
      this.chart.render(true);
    }
  };
  return Venn;
})(Plot);
var Y_FIELD$3 = "$$stock-range$$";
var TREND_FIELD = "trend";
var TREND_UP = "up";
var TREND_DOWN = "down";
var DEFAULT_TOOLTIP_OPTIONS = {
  showMarkers: false,
  showCrosshairs: true,
  shared: true,
  crosshairs: {
    type: "xy",
    follow: true,
    text: function(type, defaultContent, items) {
      var textContent;
      if (type === "x") {
        var item = items[0];
        textContent = item ? item.title : defaultContent;
      } else {
        textContent = defaultContent;
      }
      return {
        position: type === "y" ? "start" : "end",
        content: textContent,
        style: {
          fill: "#dfdfdf"
        }
      };
    },
    textBackground: {
      padding: [2, 4],
      style: {
        fill: "#666"
      }
    }
  }
};
var DEFAULT_OPTIONS$g = deepAssign({}, Plot.getDefaultOptions(), {
  tooltip: DEFAULT_TOOLTIP_OPTIONS,
  interactions: [{ type: "tooltip" }],
  legend: {
    position: "top-left"
  },
  risingFill: "#ef5350",
  fallingFill: "#26a69a"
});
function getStockData(data2, yField) {
  return map$2(data2, function(obj) {
    if (isArray$1(yField)) {
      var open_1 = yField[0], close_1 = yField[1], high = yField[2], low = yField[3];
      obj[TREND_FIELD] = obj[open_1] <= obj[close_1] ? TREND_UP : TREND_DOWN;
      obj[Y_FIELD$3] = [obj[open_1], obj[close_1], obj[high], obj[low]];
    }
    return obj;
  });
}
function geometry$f(params) {
  var chart = params.chart, options = params.options;
  var yField = options.yField;
  var data2 = options.data, risingFill = options.risingFill, fallingFill = options.fallingFill, tooltip2 = options.tooltip, stockStyle = options.stockStyle;
  chart.data(getStockData(data2, yField));
  var tooltipOptions = tooltip2;
  if (tooltipOptions !== false) {
    tooltipOptions = deepAssign({}, { fields: yField }, tooltipOptions);
  }
  schema(deepAssign({}, params, {
    options: {
      schema: {
        shape: "candle",
        color: [risingFill, fallingFill],
        style: stockStyle
      },
      yField: Y_FIELD$3,
      seriesField: TREND_FIELD,
      rawFields: yField,
      tooltip: tooltipOptions
    }
  }));
  return params;
}
function meta$8(params) {
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var meta2 = options.meta, xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField;
  var baseMeta = (_a2 = {}, _a2[xField] = {
    type: "timeCat",
    tickCount: 6
  }, _a2[TREND_FIELD] = {
    values: [TREND_UP, TREND_DOWN]
  }, _a2);
  var scales = deepAssign(baseMeta, meta2, (_b = {}, _b[xField] = pick(xAxis, AXIS_META_CONFIG_KEYS), _b[Y_FIELD$3] = pick(yAxis, AXIS_META_CONFIG_KEYS), _b));
  chart.scale(scales);
  return params;
}
function axis$9(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(Y_FIELD$3, false);
  } else {
    chart.axis(Y_FIELD$3, yAxis);
  }
  return params;
}
function tooltip$4(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2 !== false) {
    chart.tooltip(tooltip2);
  } else {
    chart.tooltip(false);
  }
  return params;
}
function legend$5(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend;
  if (legend2) {
    chart.legend(TREND_FIELD, legend2);
  } else if (legend2 === false) {
    chart.legend(false);
  }
  return params;
}
function adaptor$e(params) {
  flow(theme$2, geometry$f, meta$8, axis$9, tooltip$4, legend$5, interaction$6, animation$5, annotation$2(), slider$1)(params);
}
(function(_super) {
  __extends$2(Stock, _super);
  function Stock() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "stock";
    return _this;
  }
  Stock.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$g;
  };
  Stock.prototype.getDefaultOptions = function() {
    return Stock.getDefaultOptions();
  };
  Stock.prototype.getSchemaAdaptor = function() {
    return adaptor$e;
  };
  Stock.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var yField = this.options.yField;
    this.chart.changeData(getStockData(data2, yField));
  };
  return Stock;
})(Plot);
var _a$1;
var FUNNEL_PERCENT = "$$percentage$$";
var FUNNEL_MAPPING_VALUE = "$$mappingValue$$";
var FUNNEL_CONVERSATION = "$$conversion$$";
var FUNNEL_TOTAL_PERCENT = "$$totalPercentage$$";
var PLOYGON_X = "$$x$$";
var PLOYGON_Y = "$$y$$";
var DEFAULT_OPTIONS$f = {
  appendPadding: [0, 80],
  minSize: 0,
  maxSize: 1,
  meta: (_a$1 = {}, _a$1[FUNNEL_MAPPING_VALUE] = {
    min: 0,
    max: 1,
    nice: false
  }, _a$1),
  label: {
    style: {
      fill: "#fff",
      fontSize: 12
    }
  },
  tooltip: {
    showTitle: false,
    showMarkers: false,
    shared: false
  },
  conversionTag: {
    offsetX: 10,
    offsetY: 0,
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.45)"
    }
  }
};
function transformData$7(data2, originData, options) {
  var formatData = [];
  var yField = options.yField, maxSize = options.maxSize, minSize = options.minSize;
  var maxYFieldValue = get(maxBy(originData, yField), [yField]);
  var max2 = isNumber$1(maxSize) ? maxSize : 1;
  var min2 = isNumber$1(minSize) ? minSize : 0;
  formatData = map$2(data2, function(row, index2) {
    var percent2 = (row[yField] || 0) / maxYFieldValue;
    row[FUNNEL_PERCENT] = percent2;
    row[FUNNEL_MAPPING_VALUE] = (max2 - min2) * percent2 + min2;
    row[FUNNEL_CONVERSATION] = [get(data2, [index2 - 1, yField]), row[yField]];
    return row;
  });
  return formatData;
}
function conversionTagComponent(getLineCoordinate) {
  return function(params) {
    var chart = params.chart, options = params.options;
    var conversionTag2 = options.conversionTag;
    var data2 = chart.getOptions().data;
    if (conversionTag2) {
      var formatter_1 = conversionTag2.formatter;
      data2.forEach(function(obj, index2) {
        if (index2 <= 0 || Number.isNaN(obj[FUNNEL_MAPPING_VALUE]))
          return;
        var lineOption = getLineCoordinate(obj, index2, data2, {
          top: true,
          text: {
            content: isFunction(formatter_1) ? formatter_1(obj, data2) : formatter_1,
            offsetX: conversionTag2.offsetX,
            offsetY: conversionTag2.offsetY,
            position: "end",
            autoRotate: false,
            style: __assign$1({ textAlign: "start", textBaseline: "middle" }, conversionTag2.style)
          }
        });
        chart.annotation().line(lineOption);
      });
    }
    return params;
  };
}
function field$3(params) {
  var chart = params.chart, options = params.options;
  var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, yField = options.yField, maxSize = options.maxSize, minSize = options.minSize;
  var formatData = transformData$7(data2, data2, {
    yField,
    maxSize,
    minSize
  });
  chart.data(formatData);
  return params;
}
function geometry$e(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, color2 = options.color, tooltip2 = options.tooltip, label2 = options.label, _a2 = options.shape, shape = _a2 === void 0 ? "funnel" : _a2, funnelStyle = options.funnelStyle, state2 = options.state;
  var _b = getTooltipMapping(tooltip2, [xField, yField]), fields = _b.fields, formatter = _b.formatter;
  geometry$w({
    chart,
    options: {
      type: "interval",
      xField,
      yField: FUNNEL_MAPPING_VALUE,
      colorField: xField,
      tooltipFields: isArray$1(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
      mapping: {
        shape,
        tooltip: formatter,
        color: color2,
        style: funnelStyle
      },
      label: label2,
      state: state2
    }
  });
  var geo = findGeometry(params.chart, "interval");
  geo.adjust("symmetric");
  return params;
}
function transpose$1(params) {
  var chart = params.chart, options = params.options;
  var isTransposed = options.isTransposed;
  chart.coordinate({
    type: "rect",
    actions: !isTransposed ? [["transpose"], ["scale", 1, -1]] : []
  });
  return params;
}
function conversionTag$2(params) {
  var options = params.options;
  var maxSize = options.maxSize;
  var getLineCoordinate = function(datum, datumIndex, data2, initLineOption) {
    var percent2 = maxSize - (maxSize - datum[FUNNEL_MAPPING_VALUE]) / 2;
    return __assign$1(__assign$1({}, initLineOption), { start: [datumIndex - 0.5, percent2], end: [datumIndex - 0.5, percent2 + 0.05] });
  };
  conversionTagComponent(getLineCoordinate)(params);
  return params;
}
function basicFunnel(params) {
  return flow(field$3, geometry$e, transpose$1, conversionTag$2)(params);
}
function field$2(params) {
  var _a2;
  var chart = params.chart, options = params.options;
  var _b = options.data, data2 = _b === void 0 ? [] : _b, yField = options.yField;
  chart.data(data2);
  chart.scale((_a2 = {}, _a2[yField] = {
    sync: true
  }, _a2));
  return params;
}
function geometry$d(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, xField = options.xField, yField = options.yField, color2 = options.color, compareField = options.compareField, isTransposed = options.isTransposed, tooltip2 = options.tooltip, maxSize = options.maxSize, minSize = options.minSize, label2 = options.label, funnelStyle = options.funnelStyle, state2 = options.state;
  chart.facet("mirror", {
    fields: [compareField],
    transpose: !isTransposed,
    padding: isTransposed ? 0 : [32, 0, 0, 0],
    eachView: function(view, facet) {
      var index2 = isTransposed ? facet.rowIndex : facet.columnIndex;
      if (!isTransposed) {
        view.coordinate({
          type: "rect",
          actions: [["transpose"], ["scale", index2 === 0 ? -1 : 1, -1]]
        });
      }
      var formatterData = transformData$7(facet.data, data2, {
        yField,
        maxSize,
        minSize
      });
      view.data(formatterData);
      var _a2 = getTooltipMapping(tooltip2, [xField, yField, compareField]), fields = _a2.fields, formatter = _a2.formatter;
      var defaultFacetLabel = isTransposed ? {
        offset: index2 === 0 ? 10 : -23,
        position: index2 === 0 ? "bottom" : "top"
      } : {
        offset: 10,
        position: "left",
        style: {
          textAlign: index2 === 0 ? "end" : "start"
        }
      };
      geometry$w({
        chart: view,
        options: {
          type: "interval",
          xField,
          yField: FUNNEL_MAPPING_VALUE,
          colorField: xField,
          tooltipFields: isArray$1(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
          mapping: {
            shape: "funnel",
            tooltip: formatter,
            color: color2,
            style: funnelStyle
          },
          label: label2 === false ? false : deepAssign({}, defaultFacetLabel, label2),
          state: state2
        }
      });
    }
  });
  return params;
}
function conversionTag$1(params) {
  var chart = params.chart, options = params.options;
  var conversionTag2 = options.conversionTag, isTransposed = options.isTransposed;
  chart.once("beforepaint", function() {
    chart.views.forEach(function(view, viewIndex) {
      var getLineCoordinate = function(datum, datumIndex, data2, initLineOption) {
        var ratio = viewIndex === 0 ? -1 : 1;
        return deepAssign({}, initLineOption, {
          start: [datumIndex - 0.5, datum[FUNNEL_MAPPING_VALUE]],
          end: [datumIndex - 0.5, datum[FUNNEL_MAPPING_VALUE] + 0.05],
          text: isTransposed ? {
            style: {
              textAlign: "start"
            }
          } : {
            offsetX: conversionTag2 !== false ? ratio * conversionTag2.offsetX : 0,
            style: {
              textAlign: viewIndex === 0 ? "end" : "start"
            }
          }
        });
      };
      conversionTagComponent(getLineCoordinate)(deepAssign({}, {
        chart: view,
        options
      }));
    });
  });
  return params;
}
function compareFunnel(params) {
  return flow(field$2, geometry$d, conversionTag$1)(params);
}
function field$1(params) {
  var _a2;
  var chart = params.chart, options = params.options;
  var _b = options.data, data2 = _b === void 0 ? [] : _b, yField = options.yField;
  chart.data(data2);
  chart.scale((_a2 = {}, _a2[yField] = {
    sync: true
  }, _a2));
  return params;
}
function geometry$c(params) {
  var chart = params.chart, options = params.options;
  var seriesField = options.seriesField, isTransposed = options.isTransposed;
  chart.facet("rect", {
    fields: [seriesField],
    padding: [isTransposed ? 0 : 32, 10, 0, 10],
    eachView: function(view, facet) {
      basicFunnel(deepAssign({}, params, {
        chart: view,
        options: {
          data: facet.data
        }
      }));
    }
  });
  return params;
}
function facetFunnel(params) {
  return flow(field$1, geometry$c)(params);
}
function field(params) {
  var chart = params.chart, options = params.options;
  var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, yField = options.yField;
  var sum = reduce(data2, function(total, item) {
    return total + (item[yField] || 0);
  }, 0);
  var max2 = maxBy(data2, yField)[yField];
  var formatData = map$2(data2, function(row, index2) {
    var x = [];
    var y = [];
    row[FUNNEL_TOTAL_PERCENT] = (row[yField] || 0) / sum;
    if (index2) {
      var preItemX = data2[index2 - 1][PLOYGON_X];
      var preItemY = data2[index2 - 1][PLOYGON_Y];
      x[0] = preItemX[3];
      y[0] = preItemY[3];
      x[1] = preItemX[2];
      y[1] = preItemY[2];
    } else {
      x[0] = -0.5;
      y[0] = 1;
      x[1] = 0.5;
      y[1] = 1;
    }
    y[2] = y[1] - row[FUNNEL_TOTAL_PERCENT];
    x[2] = (y[2] + 1) / 4;
    y[3] = y[2];
    x[3] = -x[2];
    row[PLOYGON_X] = x;
    row[PLOYGON_Y] = y;
    row[FUNNEL_PERCENT] = (row[yField] || 0) / max2;
    row[FUNNEL_CONVERSATION] = [get(data2, [index2 - 1, yField]), row[yField]];
    return row;
  });
  chart.data(formatData);
  return params;
}
function geometry$b(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, color2 = options.color, tooltip2 = options.tooltip, label2 = options.label, funnelStyle = options.funnelStyle, state2 = options.state;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField]), fields = _a2.fields, formatter = _a2.formatter;
  geometry$w({
    chart,
    options: {
      type: "polygon",
      xField: PLOYGON_X,
      yField: PLOYGON_Y,
      colorField: xField,
      tooltipFields: isArray$1(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
      label: label2,
      state: state2,
      mapping: {
        tooltip: formatter,
        color: color2,
        style: funnelStyle
      }
    }
  });
  return params;
}
function transpose(params) {
  var chart = params.chart, options = params.options;
  var isTransposed = options.isTransposed;
  chart.coordinate({
    type: "rect",
    actions: isTransposed ? [["transpose"], ["reflect", "x"]] : []
  });
  return params;
}
function conversionTag(params) {
  var getLineCoordinate = function(datum, datumIndex, data2, initLineOption) {
    return __assign$1(__assign$1({}, initLineOption), { start: [datum[PLOYGON_X][1], datum[PLOYGON_Y][1]], end: [datum[PLOYGON_X][1] + 0.05, datum[PLOYGON_Y][1]] });
  };
  conversionTagComponent(getLineCoordinate)(params);
  return params;
}
function dynamicHeightFunnel(params) {
  return flow(field, geometry$b, transpose, conversionTag)(params);
}
function defaultOptions$4(params) {
  var options = params.options;
  var compareField = options.compareField, xField = options.xField, yField = options.yField, locale = options.locale, funnelStyle = options.funnelStyle, data2 = options.data;
  var i18n = getLocale(locale);
  var defaultOption = {
    label: compareField ? {
      fields: [xField, yField, compareField, FUNNEL_PERCENT, FUNNEL_CONVERSATION],
      formatter: function(datum) {
        return "" + datum[yField];
      }
    } : {
      fields: [xField, yField, FUNNEL_PERCENT, FUNNEL_CONVERSATION],
      offset: 0,
      position: "middle",
      formatter: function(datum) {
        return datum[xField] + " " + datum[yField];
      }
    },
    tooltip: {
      title: xField,
      formatter: function(datum) {
        return { name: datum[xField], value: datum[yField] };
      }
    },
    conversionTag: {
      formatter: function(datum) {
        return i18n.get(["conversionTag", "label"]) + ": " + conversionTagFormatter.apply(void 0, datum[FUNNEL_CONVERSATION]);
      }
    }
  };
  var style;
  if (compareField || funnelStyle) {
    style = function(datum) {
      return deepAssign({}, compareField && { lineWidth: 1, stroke: "#fff" }, isFunction(funnelStyle) ? funnelStyle(datum) : funnelStyle);
    };
  }
  return deepAssign({ options: defaultOption }, params, { options: { funnelStyle: style, data: clone(data2) } });
}
function geometry$a(params) {
  var options = params.options;
  var compareField = options.compareField, dynamicHeight = options.dynamicHeight, seriesField = options.seriesField;
  if (seriesField) {
    return facetFunnel(params);
  }
  if (compareField) {
    return compareFunnel(params);
  }
  if (dynamicHeight) {
    return dynamicHeightFunnel(params);
  }
  return basicFunnel(params);
}
function meta$7(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale$1((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2)))(params);
}
function axis$8(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function legend$4(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend;
  if (legend2 === false) {
    chart.legend(false);
  } else {
    chart.legend(legend2);
  }
  return params;
}
function adaptor$d(params) {
  return flow(defaultOptions$4, geometry$a, meta$7, axis$8, tooltip$8, interaction$6, legend$4, animation$5, theme$2, annotation$2())(params);
}
var Funnel = function(_super) {
  __extends$2(Funnel2, _super);
  function Funnel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "funnel";
    return _this;
  }
  Funnel2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$f;
  };
  Funnel2.prototype.getDefaultOptions = function() {
    return Funnel2.getDefaultOptions();
  };
  Funnel2.prototype.getSchemaAdaptor = function() {
    return adaptor$d;
  };
  Funnel2.prototype.setState = function(type, condition, status) {
    if (status === void 0) {
      status = true;
    }
    var elements = getAllElementsRecursively(this.chart);
    each$1(elements, function(ele) {
      if (condition(ele.getData())) {
        ele.setState(type, status);
      }
    });
  };
  Funnel2.prototype.getStates = function() {
    var elements = getAllElementsRecursively(this.chart);
    var stateObjects = [];
    each$1(elements, function(element) {
      var data2 = element.getData();
      var states = element.getStates();
      each$1(states, function(state2) {
        stateObjects.push({ data: data2, state: state2, geometry: element.geometry, element });
      });
    });
    return stateObjects;
  };
  Funnel2.CONVERSATION_FIELD = FUNNEL_CONVERSATION;
  Funnel2.PERCENT_FIELD = FUNNEL_PERCENT;
  Funnel2.TOTAL_PERCENT_FIELD = FUNNEL_TOTAL_PERCENT;
  return Funnel2;
}(Plot);
var CAT_VALUE = "liquid";
function getLiquidData(percent2) {
  return [{ percent: percent2, type: CAT_VALUE }];
}
function geometry$9(params) {
  var chart = params.chart, options = params.options;
  var percent2 = options.percent, liquidStyle = options.liquidStyle, radius = options.radius, outline = options.outline, wave = options.wave, shape = options.shape;
  chart.scale({
    percent: {
      min: 0,
      max: 1
    }
  });
  chart.data(getLiquidData(percent2));
  var color2 = options.color || chart.getTheme().defaultColor;
  var p = deepAssign({}, params, {
    options: {
      xField: "type",
      yField: "percent",
      widthRatio: radius,
      interval: {
        color: color2,
        style: liquidStyle,
        shape: "liquid-fill-gauge"
      }
    }
  });
  var ext = interval(p).ext;
  var geometry2 = ext.geometry;
  var background = chart.getTheme().background;
  var customInfo = {
    radius,
    outline,
    wave,
    shape,
    background
  };
  geometry2.customInfo(customInfo);
  chart.legend(false);
  chart.axis(false);
  chart.tooltip(false);
  return params;
}
function statistic$1(params, updated) {
  var chart = params.chart, options = params.options;
  var statistic2 = options.statistic, percent2 = options.percent, meta2 = options.meta;
  chart.getController("annotation").clear(true);
  var metaFormatter = get(meta2, ["percent", "formatter"]) || function(v) {
    return (v * 100).toFixed(2) + "%";
  };
  var contentOpt = statistic2.content;
  if (contentOpt) {
    contentOpt = deepAssign({}, contentOpt, {
      content: !isNil(contentOpt.content) ? contentOpt.content : metaFormatter(percent2)
    });
  }
  renderStatistic(chart, { statistic: __assign$1(__assign$1({}, statistic2), { content: contentOpt }), plotType: "liquid" }, { percent: percent2 });
  if (updated) {
    chart.render(true);
  }
  return params;
}
function adaptor$c(params) {
  return flow(theme$2, pattern("liquidStyle"), geometry$9, statistic$1, scale$1({}), animation$5, interaction$6)(params);
}
var DEFAULT_OPTIONS$e = {
  radius: 0.9,
  statistic: {
    title: false,
    content: {
      style: {
        opacity: 0.75,
        fontSize: "30px",
        lineHeight: "30px",
        textAlign: "center"
      }
    }
  },
  outline: {
    border: 2,
    distance: 0
  },
  wave: {
    count: 3,
    length: 192
  },
  shape: "circle"
};
var DURATION = 5e3;
function lerp(min2, max2, factor) {
  return min2 + (max2 - min2) * factor;
}
function getFillAttrs$1(cfg) {
  var attrs = __assign$1({ opacity: 1 }, cfg.style);
  if (cfg.color && !attrs.fill) {
    attrs.fill = cfg.color;
  }
  return attrs;
}
function getLineAttrs(cfg) {
  var defaultAttrs = {
    fill: "#fff",
    fillOpacity: 0,
    lineWidth: 4
  };
  var attrs = mix({}, defaultAttrs, cfg.style);
  if (cfg.color && !attrs.stroke) {
    attrs.stroke = cfg.color;
  }
  if (isNumber$1(cfg.opacity)) {
    attrs.opacity = attrs.strokeOpacity = cfg.opacity;
  }
  return attrs;
}
function getWaterWavePositions(x, stage, waveLength, amplitude) {
  if (stage === 0) {
    return [
      [x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2],
      [x + 1 / 2 * waveLength / Math.PI, amplitude],
      [x + waveLength / 4, amplitude]
    ];
  }
  if (stage === 1) {
    return [
      [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude],
      [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude / 2],
      [x + waveLength / 4, 0]
    ];
  }
  if (stage === 2) {
    return [
      [x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2],
      [x + 1 / 2 * waveLength / Math.PI, -amplitude],
      [x + waveLength / 4, -amplitude]
    ];
  }
  return [
    [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude],
    [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude / 2],
    [x + waveLength / 4, 0]
  ];
}
function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {
  var curves = Math.ceil(2 * radius / waveLength * 4) * 4;
  var path2 = [];
  var _phase = phase;
  while (_phase < -Math.PI * 2) {
    _phase += Math.PI * 2;
  }
  while (_phase > 0) {
    _phase -= Math.PI * 2;
  }
  _phase = _phase / Math.PI / 2 * waveLength;
  var left2 = cx - radius + _phase - radius * 2;
  path2.push(["M", left2, waterLevel]);
  var waveRight = 0;
  for (var c = 0; c < curves; ++c) {
    var stage = c % 4;
    var pos = getWaterWavePositions(c * waveLength / 4, stage, waveLength, amplitude);
    path2.push([
      "C",
      pos[0][0] + left2,
      -pos[0][1] + waterLevel,
      pos[1][0] + left2,
      -pos[1][1] + waterLevel,
      pos[2][0] + left2,
      -pos[2][1] + waterLevel
    ]);
    if (c === curves - 1) {
      waveRight = pos[2][0];
    }
  }
  path2.push(["L", waveRight + left2, cy + radius]);
  path2.push(["L", left2, cy + radius]);
  path2.push(["Z"]);
  return path2;
}
function addWaterWave(x, y, level, waveCount, waveAttrs, group2, clip, radius, waveLength) {
  var fill = waveAttrs.fill, opacity = waveAttrs.opacity;
  var bbox = clip.getBBox();
  var width = bbox.maxX - bbox.minX;
  var height = bbox.maxY - bbox.minY;
  for (var idx = 0; idx < waveCount; idx++) {
    var factor = waveCount <= 1 ? 0 : idx / (waveCount - 1);
    var wave = group2.addShape("path", {
      name: "waterwave-path",
      attrs: {
        path: getWaterWavePath(radius, bbox.minY + height * level, waveLength, 0, width / 32, x, y),
        fill,
        opacity: lerp(0.2, 0.9, factor) * opacity
      }
    });
    try {
      var matrix = transform$2([["t", waveLength, 0]]);
      wave.stopAnimate();
      wave.animate({ matrix }, {
        duration: lerp(0.5 * DURATION, DURATION, factor),
        repeat: true
      });
    } catch (e) {
      console.warn("off-screen group animate error!");
    }
  }
}
function pin(x, y, width, height) {
  var w = width * 2 / 3;
  var h = Math.max(w, height);
  var r = w / 2;
  var cx = x;
  var cy = r + y - h / 2;
  var theta = Math.asin(r / ((h - r) * 0.85));
  var dy = Math.sin(theta) * r;
  var dx = Math.cos(theta) * r;
  var x0 = cx - dx;
  var y0 = cy + dy;
  var cpX = x;
  var cpY = cy + r / Math.sin(theta);
  return "\n      M " + x0 + " " + y0 + "\n      A " + r + " " + r + " 0 1 1 " + (x0 + dx * 2) + " " + y0 + "\n      Q " + cpX + " " + cpY + " " + x + " " + (y + h / 2) + "\n      Q " + cpX + " " + cpY + " " + x0 + " " + y0 + "\n      Z \n    ";
}
function circle(x, y, width, height) {
  var rx = width / 2;
  var ry = height / 2;
  return "\n      M " + x + " " + (y - ry) + " \n      a " + rx + " " + ry + " 0 1 0 0 " + ry * 2 + "\n      a " + rx + " " + ry + " 0 1 0 0 " + -ry * 2 + "\n      Z\n    ";
}
function diamond(x, y, width, height) {
  var h = height / 2;
  var w = width / 2;
  return "\n      M " + x + " " + (y - h) + "\n      L " + (x + w) + " " + y + "\n      L " + x + " " + (y + h) + "\n      L " + (x - w) + " " + y + "\n      Z\n    ";
}
function triangle(x, y, width, height) {
  var h = height / 2;
  var w = width / 2;
  return "\n      M " + x + " " + (y - h) + "\n      L " + (x + w) + " " + (y + h) + "\n      L " + (x - w) + " " + (y + h) + "\n      Z\n    ";
}
function rect(x, y, width, height) {
  var GOLDEN_SECTION_RATIO = 0.618;
  var h = height / 2;
  var w = width / 2 * GOLDEN_SECTION_RATIO;
  return "\n      M " + (x - w) + " " + (y - h) + "\n      L " + (x + w) + " " + (y - h) + "\n      L " + (x + w) + " " + (y + h) + "\n      L " + (x - w) + " " + (y + h) + "\n      Z\n    ";
}
registerShape("interval", "liquid-fill-gauge", {
  draw: function(cfg, container) {
    var cx = 0.5;
    var cy = 0.5;
    var customInfo = cfg.customInfo;
    var _a2 = customInfo, radio = _a2.radius, shape = _a2.shape, background = _a2.background;
    var outline = customInfo.outline;
    var wave = customInfo.wave;
    var border = outline.border, distance2 = outline.distance;
    var waveCount = wave.count, waveLength = wave.length;
    var minX = reduce(cfg.points, function(r, p) {
      return Math.min(r, p.x);
    }, Infinity);
    var center2 = this.parsePoint({ x: cx, y: cy });
    var minXPoint = this.parsePoint({ x: minX, y: cy });
    var halfWidth = center2.x - minXPoint.x;
    var radius = Math.min(halfWidth, minXPoint.y * radio);
    var waveAttrs = getFillAttrs$1(cfg);
    var outlineAttrs = getLineAttrs(mix({}, cfg, outline));
    var innerRadius = radius - border / 2;
    var builtInShapeByName = {
      pin,
      circle,
      diamond,
      triangle,
      rect
    };
    var buildPath = typeof shape === "function" ? shape : builtInShapeByName[shape] || builtInShapeByName["circle"];
    var shapePath = buildPath(center2.x, center2.y, innerRadius * 2, innerRadius * 2);
    var waves = container.addGroup({
      name: "waves"
    });
    var clipPath = waves.setClip({
      type: "path",
      attrs: {
        path: shapePath
      }
    });
    addWaterWave(center2.x, center2.y, 1 - cfg.points[1].y, waveCount, waveAttrs, waves, clipPath, radius * 2, waveLength);
    container.addShape("path", {
      name: "distance",
      attrs: {
        path: shapePath,
        fill: "transparent",
        lineWidth: border + distance2 * 2,
        stroke: background === "transparent" ? "#fff" : background
      }
    });
    container.addShape("path", {
      name: "wrap",
      attrs: mix(outlineAttrs, {
        path: shapePath,
        fill: "transparent",
        lineWidth: border
      })
    });
    return container;
  }
});
var Liquid = function(_super) {
  __extends$2(Liquid2, _super);
  function Liquid2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "liquid";
    return _this;
  }
  Liquid2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$e;
  };
  Liquid2.prototype.getDefaultOptions = function() {
    return Liquid2.getDefaultOptions();
  };
  Liquid2.prototype.changeData = function(percent2) {
    this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    this.updateOption({ percent: percent2 });
    this.chart.data(getLiquidData(percent2));
    statistic$1({ chart: this.chart, options: this.options }, true);
    this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  Liquid2.prototype.getSchemaAdaptor = function() {
    return adaptor$c;
  };
  return Liquid2;
}(Plot);
function transformData$6(options) {
  var data2 = options.data, xField = options.xField, measureField = options.measureField, rangeField = options.rangeField, targetField = options.targetField, layout = options.layout;
  var ds = [];
  var scales = [];
  data2.forEach(function(item, index2) {
    var _a2;
    item[rangeField].sort(function(a, b) {
      return a - b;
    });
    item[rangeField].forEach(function(d, i) {
      var _a3;
      var range = i === 0 ? d : item[rangeField][i] - item[rangeField][i - 1];
      ds.push((_a3 = {
        rKey: rangeField + "_" + i
      }, _a3[xField] = xField ? item[xField] : String(index2), _a3[rangeField] = range, _a3));
    });
    item[measureField].forEach(function(d, i) {
      var _a3;
      ds.push((_a3 = {
        mKey: item[measureField].length > 1 ? measureField + "_" + i : "" + measureField
      }, _a3[xField] = xField ? item[xField] : String(index2), _a3[measureField] = d, _a3));
    });
    ds.push((_a2 = {
      tKey: "" + targetField
    }, _a2[xField] = xField ? item[xField] : String(index2), _a2[targetField] = item[targetField], _a2));
    scales.push(item[rangeField], item[measureField], item[targetField]);
  });
  var min2 = Math.min.apply(Math, scales.flat(Infinity));
  var max2 = Math.max.apply(Math, scales.flat(Infinity));
  min2 = min2 > 0 ? 0 : min2;
  if (layout === "vertical") {
    ds.reverse();
  }
  return { min: min2, max: max2, ds };
}
function geometry$8(params) {
  var chart = params.chart, options = params.options;
  var bulletStyle = options.bulletStyle, targetField = options.targetField, rangeField = options.rangeField, measureField = options.measureField, xField = options.xField, color2 = options.color, layout = options.layout, size2 = options.size, label2 = options.label;
  var _a2 = transformData$6(options), min2 = _a2.min, max2 = _a2.max, ds = _a2.ds;
  chart.data(ds);
  var r = deepAssign({}, params, {
    options: {
      xField,
      yField: rangeField,
      seriesField: "rKey",
      isStack: true,
      label: get(label2, "range"),
      interval: {
        color: get(color2, "range"),
        style: get(bulletStyle, "range"),
        size: get(size2, "range")
      }
    }
  });
  interval(r);
  chart.geometries[0].tooltip(false);
  var m = deepAssign({}, params, {
    options: {
      xField,
      yField: measureField,
      seriesField: "mKey",
      isStack: true,
      label: get(label2, "measure"),
      interval: {
        color: get(color2, "measure"),
        style: get(bulletStyle, "measure"),
        size: get(size2, "measure")
      }
    }
  });
  interval(m);
  var t = deepAssign({}, params, {
    options: {
      xField,
      yField: targetField,
      seriesField: "tKey",
      label: get(label2, "target"),
      point: {
        color: get(color2, "target"),
        style: get(bulletStyle, "target"),
        size: isFunction(get(size2, "target")) ? function(data2) {
          return get(size2, "target")(data2) / 2;
        } : get(size2, "target") / 2,
        shape: layout === "horizontal" ? "line" : "hyphen"
      }
    }
  });
  point(t);
  if (layout === "horizontal") {
    chart.coordinate().transpose();
  }
  return __assign$1(__assign$1({}, params), { ext: { data: { min: min2, max: max2 } } });
}
function meta$6(params) {
  var _a2, _b;
  var options = params.options, ext = params.ext;
  var xAxis = options.xAxis, yAxis = options.yAxis, targetField = options.targetField, rangeField = options.rangeField, measureField = options.measureField, xField = options.xField;
  var extData = ext.data;
  return flow(scale$1((_a2 = {}, _a2[xField] = xAxis, _a2[measureField] = yAxis, _a2), (_b = {}, _b[measureField] = { min: extData === null || extData === void 0 ? void 0 : extData.min, max: extData === null || extData === void 0 ? void 0 : extData.max, sync: true }, _b[targetField] = {
    sync: "" + measureField
  }, _b[rangeField] = {
    sync: "" + measureField
  }, _b)))(params);
}
function axis$7(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, measureField = options.measureField, rangeField = options.rangeField, targetField = options.targetField;
  chart.axis("" + rangeField, false);
  chart.axis("" + targetField, false);
  if (xAxis === false) {
    chart.axis("" + xField, false);
  } else {
    chart.axis("" + xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis("" + measureField, false);
  } else {
    chart.axis("" + measureField, yAxis);
  }
  return params;
}
function legend$3(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend;
  chart.removeInteraction("legend-filter");
  chart.legend(legend2);
  chart.legend("rKey", false);
  chart.legend("mKey", false);
  chart.legend("tKey", false);
  return params;
}
function label$4(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, measureField = options.measureField, targetField = options.targetField, rangeField = options.rangeField;
  var _a2 = chart.geometries, rangeGeometry = _a2[0], measureGeometry = _a2[1], targetGeometry = _a2[2];
  if (get(label2, "range")) {
    rangeGeometry.label("" + rangeField, __assign$1({ layout: [{ type: "limit-in-plot" }] }, transformLabel(label2.range)));
  } else {
    rangeGeometry.label(false);
  }
  if (get(label2, "measure")) {
    measureGeometry.label("" + measureField, __assign$1({ layout: [{ type: "limit-in-plot" }] }, transformLabel(label2.measure)));
  } else {
    measureGeometry.label(false);
  }
  if (get(label2, "target")) {
    targetGeometry.label("" + targetField, __assign$1({ layout: [{ type: "limit-in-plot" }] }, transformLabel(label2.target)));
  } else {
    targetGeometry.label(false);
  }
  return params;
}
function adaptor$b(params) {
  flow(geometry$8, meta$6, axis$7, legend$3, theme$2, label$4, tooltip$8, interaction$6, animation$5)(params);
}
var DEFAULT_OPTIONS$d = deepAssign({}, Plot.getDefaultOptions(), {
  layout: "horizontal",
  size: {
    range: 30,
    measure: 20,
    target: 20
  },
  xAxis: {
    tickLine: false,
    line: null
  },
  bulletStyle: {
    range: {
      fillOpacity: 0.5
    }
  },
  label: {
    measure: {
      position: "right"
    }
  },
  tooltip: {
    showMarkers: false
  }
});
(function(_super) {
  __extends$2(Bullet, _super);
  function Bullet() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "bullet";
    return _this;
  }
  Bullet.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$d;
  };
  Bullet.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = transformData$6(this.options), min2 = _a2.min, max2 = _a2.max, ds = _a2.ds;
    meta$6({ options: this.options, ext: { data: { min: min2, max: max2 } }, chart: this.chart });
    this.chart.changeData(ds);
  };
  Bullet.prototype.getSchemaAdaptor = function() {
    return adaptor$b;
  };
  Bullet.prototype.getDefaultOptions = function() {
    return Bullet.getDefaultOptions();
  };
  return Bullet;
})(Plot);
var NODE_INDEX_FIELD = "nodeIndex";
var CHILD_NODE_COUNT = "childNodeCount";
var NODE_ANCESTORS_FIELD = "nodeAncestor";
var INVALID_FIELD_ERR_MSG = "Invalid field: it must be a string!";
function getField(options, defaultField) {
  var field2 = options.field, fields = options.fields;
  if (isString(field2)) {
    return field2;
  }
  if (isArray$1(field2)) {
    console.warn(INVALID_FIELD_ERR_MSG);
    return field2[0];
  }
  console.warn(INVALID_FIELD_ERR_MSG + " will try to get fields instead.");
  if (isString(fields)) {
    return fields;
  }
  if (isArray$1(fields) && fields.length) {
    return fields[0];
  }
  if (defaultField) {
    return defaultField;
  }
  throw new TypeError(INVALID_FIELD_ERR_MSG);
}
function getAllNodes(root) {
  var nodes = [];
  if (root && root.each) {
    var parent_1;
    var index_1;
    root.each(function(node) {
      var _a2, _b;
      if (node.parent !== parent_1) {
        parent_1 = node.parent;
        index_1 = 0;
      } else {
        index_1 += 1;
      }
      var ancestors = filter((((_a2 = node.ancestors) === null || _a2 === void 0 ? void 0 : _a2.call(node)) || []).map(function(d) {
        return nodes.find(function(n) {
          return n.name === d.name;
        }) || d;
      }), function(_a3) {
        var depth = _a3.depth;
        return depth > 0 && depth < node.depth;
      });
      node[NODE_ANCESTORS_FIELD] = ancestors;
      node[CHILD_NODE_COUNT] = ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) || 0;
      node[NODE_INDEX_FIELD] = index_1;
      nodes.push(node);
    });
  } else if (root && root.eachNode) {
    root.eachNode(function(node) {
      nodes.push(node);
    });
  }
  return nodes;
}
var SUNBURST_ANCESTOR_FIELD = "ancestor-node";
var SUNBURST_Y_FIELD = "value";
var SUNBURST_PATH_FIELD = "path";
var RAW_FIELDS$1 = [
  SUNBURST_PATH_FIELD,
  NODE_INDEX_FIELD,
  NODE_ANCESTORS_FIELD,
  CHILD_NODE_COUNT,
  "name",
  "depth",
  "height"
];
var DEFAULT_OPTIONS$c = deepAssign({}, Plot.getDefaultOptions(), {
  innerRadius: 0,
  radius: 0.85,
  hierarchyConfig: {
    field: "value"
  },
  tooltip: {
    shared: true,
    showMarkers: false,
    offset: 20,
    showTitle: false
  },
  sunburstStyle: {
    lineWidth: 0.5,
    stroke: "#FFF"
  },
  drilldown: { enabled: true }
});
var PADDING = 4;
var PADDING_LEFT = 0;
var PADDING_TOP = 5;
var BREAD_CRUMB_NAME = "drilldown-bread-crumb";
var DEFAULT_BREAD_CRUMB_CONFIG = {
  position: "top-left",
  dividerText: "/",
  textStyle: {
    fontSize: 12,
    fill: "rgba(0, 0, 0, 0.65)",
    cursor: "pointer"
  },
  activeTextStyle: {
    fill: "#87B5FF"
  }
};
var HIERARCHY_DATA_TRANSFORM_PARAMS = "hierarchy-data-transform-params";
var DrillDownAction = function(_super) {
  __extends$2(DrillDownAction2, _super);
  function DrillDownAction2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.name = "drill-down";
    _this.historyCache = [];
    _this.breadCrumbGroup = null;
    _this.breadCrumbCfg = DEFAULT_BREAD_CRUMB_CONFIG;
    return _this;
  }
  DrillDownAction2.prototype.click = function() {
    var data2 = get(this.context, ["event", "data", "data"]);
    if (!data2)
      return false;
    this.drill(data2);
    this.drawBreadCrumb();
  };
  DrillDownAction2.prototype.resetPosition = function() {
    if (!this.breadCrumbGroup)
      return;
    var coordinate2 = this.context.view.getCoordinate();
    var breadCrumbGroup = this.breadCrumbGroup;
    var bbox = breadCrumbGroup.getBBox();
    var position = this.getButtonCfg().position;
    var point2 = { x: coordinate2.start.x, y: coordinate2.end.y - (bbox.height + PADDING_TOP * 2) };
    if (coordinate2.isPolar) {
      point2 = { x: 0, y: 0 };
    }
    if (position === "bottom-left") {
      point2 = { x: coordinate2.start.x, y: coordinate2.start.y };
    }
    var matrix = Util.transform(null, [["t", point2.x + PADDING_LEFT, point2.y + bbox.height + PADDING_TOP]]);
    breadCrumbGroup.setMatrix(matrix);
  };
  DrillDownAction2.prototype.back = function() {
    if (size(this.historyCache)) {
      this.backTo(this.historyCache.slice(0, -1));
    }
  };
  DrillDownAction2.prototype.reset = function() {
    if (this.historyCache[0]) {
      this.backTo(this.historyCache.slice(0, 1));
    }
    this.historyCache = [];
    this.hideCrumbGroup();
  };
  DrillDownAction2.prototype.drill = function(nodeInfo) {
    var view = this.context.view;
    var transformData2 = get(view, ["interactions", "drill-down", "cfg", "transformData"], function(v) {
      return v;
    });
    var drillData = transformData2(__assign$1({ data: nodeInfo.data }, nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS]));
    view.changeData(drillData);
    var historyCache = [];
    var node = nodeInfo;
    while (node) {
      var nodeData = node.data;
      historyCache.unshift({
        id: nodeData.name + "_" + node.height + "_" + node.depth,
        name: nodeData.name,
        children: transformData2(__assign$1({ data: nodeData }, nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS]))
      });
      node = node.parent;
    }
    this.historyCache = (this.historyCache || []).slice(0, -1).concat(historyCache);
  };
  DrillDownAction2.prototype.backTo = function(historyCache) {
    if (!historyCache || historyCache.length <= 0) {
      return;
    }
    var view = this.context.view;
    var data2 = last(historyCache).children;
    view.changeData(data2);
    if (historyCache.length > 1) {
      this.historyCache = historyCache;
      this.drawBreadCrumb();
    } else {
      this.historyCache = [];
      this.hideCrumbGroup();
    }
  };
  DrillDownAction2.prototype.getButtonCfg = function() {
    var view = this.context.view;
    var drillDownConfig = get(view, ["interactions", "drill-down", "cfg", "drillDownConfig"]);
    return deepAssign(this.breadCrumbCfg, drillDownConfig === null || drillDownConfig === void 0 ? void 0 : drillDownConfig.breadCrumb, this.cfg);
  };
  DrillDownAction2.prototype.drawBreadCrumb = function() {
    this.drawBreadCrumbGroup();
    this.resetPosition();
    this.breadCrumbGroup.show();
  };
  DrillDownAction2.prototype.drawBreadCrumbGroup = function() {
    var _this = this;
    var config = this.getButtonCfg();
    var cache2 = this.historyCache;
    if (!this.breadCrumbGroup) {
      this.breadCrumbGroup = this.context.view.foregroundGroup.addGroup({
        name: BREAD_CRUMB_NAME
      });
    } else {
      this.breadCrumbGroup.clear();
    }
    var left2 = 0;
    cache2.forEach(function(record, index2) {
      var textShape = _this.breadCrumbGroup.addShape({
        type: "text",
        id: record.id,
        name: BREAD_CRUMB_NAME + "_" + record.name + "_text",
        attrs: __assign$1(__assign$1({ text: index2 === 0 && !isNil(config.rootText) ? config.rootText : record.name }, config.textStyle), { x: left2, y: 0 })
      });
      var textShapeBox = textShape.getBBox();
      left2 += textShapeBox.width + PADDING;
      textShape.on("click", function(event) {
        var _a2;
        var targetId = event.target.get("id");
        if (targetId !== ((_a2 = last(cache2)) === null || _a2 === void 0 ? void 0 : _a2.id)) {
          var newHistoryCache = cache2.slice(0, cache2.findIndex(function(d) {
            return d.id === targetId;
          }) + 1);
          _this.backTo(newHistoryCache);
        }
      });
      textShape.on("mouseenter", function(event) {
        var _a2;
        var targetId = event.target.get("id");
        if (targetId !== ((_a2 = last(cache2)) === null || _a2 === void 0 ? void 0 : _a2.id)) {
          textShape.attr(config.activeTextStyle);
        } else {
          textShape.attr({ cursor: "default" });
        }
      });
      textShape.on("mouseleave", function() {
        textShape.attr(config.textStyle);
      });
      if (index2 < cache2.length - 1) {
        var dividerShape = _this.breadCrumbGroup.addShape({
          type: "text",
          name: config.name + "_" + record.name + "_divider",
          attrs: __assign$1(__assign$1({ text: config.dividerText }, config.textStyle), { x: left2, y: 0 })
        });
        var dividerBox = dividerShape.getBBox();
        left2 += dividerBox.width + PADDING;
      }
    });
  };
  DrillDownAction2.prototype.hideCrumbGroup = function() {
    if (this.breadCrumbGroup) {
      this.breadCrumbGroup.hide();
    }
  };
  DrillDownAction2.prototype.destroy = function() {
    if (this.breadCrumbGroup) {
      this.breadCrumbGroup.remove();
    }
    _super.prototype.destroy.call(this);
  };
  return DrillDownAction2;
}(Action);
var DEFAULT_OPTIONS$b = {
  field: "value",
  size: [1, 1],
  round: false,
  padding: 0,
  sort: function(a, b) {
    return b.value - a.value;
  },
  as: ["x", "y"],
  ignoreParentValue: true
};
function partition(data2, options) {
  options = mix({}, DEFAULT_OPTIONS$b, options);
  var as = options.as;
  if (!isArray$1(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }
  var field2;
  try {
    field2 = getField(options);
  } catch (e) {
    console.warn(e);
  }
  var partition2 = function(data3) {
    return partition$1().size(options.size).round(options.round).padding(options.padding)(hierarchy(data3).sum(function(d) {
      return size(d.children) ? options.ignoreParentValue ? 0 : d[field2] - reduce(d.children, function(a, b) {
        return a + b[field2];
      }, 0) : d[field2];
    }).sort(options.sort));
  };
  var root = partition2(data2);
  var x = as[0];
  var y = as[1];
  root.each(function(node) {
    var _a2, _b;
    node[x] = [node.x0, node.x1, node.x1, node.x0];
    node[y] = [node.y1, node.y1, node.y0, node.y0];
    node.name = node.name || ((_a2 = node.data) === null || _a2 === void 0 ? void 0 : _a2.name) || ((_b = node.data) === null || _b === void 0 ? void 0 : _b.label);
    node.data.name = node.name;
    ["x0", "x1", "y0", "y1"].forEach(function(prop) {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return getAllNodes(root);
}
var DEFAULT_OPTIONS$a = {
  field: "value",
  tile: "treemapSquarify",
  size: [1, 1],
  round: false,
  ignoreParentValue: true,
  padding: 0,
  paddingInner: 0,
  paddingOuter: 0,
  paddingTop: 0,
  paddingRight: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  as: ["x", "y"],
  sort: function(a, b) {
    return b.value - a.value;
  },
  ratio: 0.5 * (1 + Math.sqrt(5))
};
function getTileMethod(tile, ratio) {
  return tile === "treemapSquarify" ? d3Hierarchy[tile].ratio(ratio) : d3Hierarchy[tile];
}
function treemap(data2, options) {
  options = mix({}, DEFAULT_OPTIONS$a, options);
  var as = options.as;
  if (!isArray$1(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }
  var field2;
  try {
    field2 = getField(options);
  } catch (e) {
    console.warn(e);
  }
  var tileMethod = getTileMethod(options.tile, options.ratio);
  var partition2 = function(data3) {
    return index().tile(tileMethod).size(options.size).round(options.round).padding(options.padding).paddingInner(options.paddingInner).paddingOuter(options.paddingOuter).paddingTop(options.paddingTop).paddingRight(options.paddingRight).paddingBottom(options.paddingBottom).paddingLeft(options.paddingLeft)(hierarchy(data3).sum(function(d) {
      return options.ignoreParentValue && d.children ? 0 : d[field2];
    }).sort(options.sort));
  };
  var root = partition2(data2);
  var x = as[0];
  var y = as[1];
  root.each(function(node) {
    node[x] = [node.x0, node.x1, node.x1, node.x0];
    node[y] = [node.y1, node.y1, node.y0, node.y0];
    ["x0", "x1", "y0", "y1"].forEach(function(prop) {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return getAllNodes(root);
}
function transformData$5(options) {
  var data2 = options.data, colorField = options.colorField, rawFields = options.rawFields, _a2 = options.hierarchyConfig, hierarchyConfig = _a2 === void 0 ? {} : _a2;
  var activeDepth = hierarchyConfig.activeDepth;
  var transform2 = {
    partition,
    treemap
  };
  var seriesField = options.seriesField;
  var type = options.type || "partition";
  var nodes = transform2[type](data2, __assign$1(__assign$1({ field: seriesField || "value" }, omit$1(hierarchyConfig, ["activeDepth"])), {
    type: "hierarchy." + type,
    as: ["x", "y"]
  }));
  var result = [];
  nodes.forEach(function(node) {
    var _a3;
    var _b, _c, _d, _e, _f;
    if (node.depth === 0) {
      return null;
    }
    if (activeDepth > 0 && node.depth > activeDepth) {
      return null;
    }
    var path2 = node.data.name;
    var ancestorNode = __assign$1({}, node);
    while (ancestorNode.depth > 1) {
      path2 = ((_b = ancestorNode.parent.data) === null || _b === void 0 ? void 0 : _b.name) + " / " + path2;
      ancestorNode = ancestorNode.parent;
    }
    var nodeInfo = __assign$1(__assign$1(__assign$1({}, pick(node.data, __spreadArrays(rawFields || [], [hierarchyConfig.field]))), (_a3 = {}, _a3[SUNBURST_PATH_FIELD] = path2, _a3[SUNBURST_ANCESTOR_FIELD] = ancestorNode.data.name, _a3)), node);
    if (seriesField) {
      nodeInfo[seriesField] = node.data[seriesField] || ((_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[seriesField]);
    }
    if (colorField) {
      nodeInfo[colorField] = node.data[colorField] || ((_f = (_e = node.parent) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f[colorField]);
    }
    nodeInfo.ext = hierarchyConfig;
    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig, colorField, rawFields };
    result.push(nodeInfo);
  });
  return result;
}
function geometry$7(params) {
  var chart = params.chart, options = params.options;
  var color2 = options.color, _a2 = options.colorField, colorField = _a2 === void 0 ? SUNBURST_ANCESTOR_FIELD : _a2, sunburstStyle = options.sunburstStyle, _b = options.rawFields, rawFields = _b === void 0 ? [] : _b;
  var data2 = transformData$5(options);
  chart.data(data2);
  var style;
  if (sunburstStyle) {
    style = function(datum) {
      return deepAssign({}, {
        fillOpacity: Math.pow(0.85, datum.depth)
      }, isFunction(sunburstStyle) ? sunburstStyle(datum) : sunburstStyle);
    };
  }
  polygon(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField,
      rawFields: uniq$2(__spreadArrays(RAW_FIELDS$1, rawFields)),
      polygon: {
        color: color2,
        style
      }
    }
  }));
  return params;
}
function axis$6(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function legend$2(params) {
  var chart = params.chart;
  chart.legend(false);
  return params;
}
function label$3(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label;
  var geometry2 = findGeometry(chart, "polygon");
  if (!label2) {
    geometry2.label(false);
  } else {
    var _a2 = label2.fields, fields = _a2 === void 0 ? ["name"] : _a2, callback = label2.callback, cfg = __rest(label2, ["fields", "callback"]);
    geometry2.label({
      fields,
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function coordinate$2(params) {
  var chart = params.chart, options = params.options;
  var innerRadius = options.innerRadius, radius = options.radius, reflect = options.reflect;
  var coord2 = chart.coordinate({
    type: "polar",
    cfg: {
      innerRadius,
      radius
    }
  });
  if (reflect) {
    coord2.reflect(reflect);
  }
  return params;
}
function meta$5(params) {
  var _a2;
  var options = params.options;
  var hierarchyConfig = options.hierarchyConfig, meta2 = options.meta;
  return flow(scale$1({}, (_a2 = {}, _a2[SUNBURST_Y_FIELD] = get(meta2, get(hierarchyConfig, ["field"], "value")), _a2)))(params);
}
function tooltip$3(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2 === false) {
    chart.tooltip(false);
  } else {
    var tooltipOptions = tooltip2;
    if (!get(tooltip2, "fields")) {
      tooltipOptions = deepAssign({}, {
        customItems: function(items) {
          return items.map(function(item) {
            var scales = get(chart.getOptions(), "scales");
            var pathFormatter = get(scales, [SUNBURST_PATH_FIELD, "formatter"], function(v) {
              return v;
            });
            var valueFormatter = get(scales, [SUNBURST_Y_FIELD, "formatter"], function(v) {
              return v;
            });
            return __assign$1(__assign$1({}, item), { name: pathFormatter(item.data[SUNBURST_PATH_FIELD]), value: valueFormatter(item.data.value) });
          });
        }
      }, tooltipOptions);
    }
    chart.tooltip(tooltipOptions);
  }
  return params;
}
function adaptorInteraction$2(options) {
  var drilldown = options.drilldown, _a2 = options.interactions, interactions = _a2 === void 0 ? [] : _a2;
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    return deepAssign({}, options, {
      interactions: __spreadArrays(interactions, [
        {
          type: "drill-down",
          cfg: { drillDownConfig: drilldown, transformData: transformData$5 }
        }
      ])
    });
  }
  return options;
}
function interaction$3(params) {
  var chart = params.chart, options = params.options;
  var drilldown = options.drilldown;
  interaction$6({
    chart,
    options: adaptorInteraction$2(options)
  });
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    chart.appendPadding = getAdjustAppendPadding(chart.appendPadding, get(drilldown, ["breadCrumb", "position"]));
  }
  return params;
}
function adaptor$a(params) {
  return flow(theme$2, pattern("sunburstStyle"), geometry$7, axis$6, meta$5, legend$2, coordinate$2, tooltip$3, label$3, interaction$3, animation$5, annotation$2())(params);
}
function isParentNode(context) {
  var data2 = get(context, ["event", "data", "data"], {});
  return isArray$1(data2.children) && data2.children.length > 0;
}
function inCenter(context) {
  var coordinate2 = context.view.getCoordinate();
  var innerRadius = coordinate2.innerRadius;
  if (innerRadius) {
    var _a2 = context.event, x = _a2.x, y = _a2.y;
    var _b = coordinate2.center, centerX = _b.x, centerY = _b.y;
    var r = coordinate2.getRadius() * innerRadius;
    var distance2 = Math.sqrt(Math.pow(centerX - x, 2) + Math.pow(centerY - y, 2));
    return distance2 < r;
  }
  return false;
}
registerAction("drill-down-action", DrillDownAction);
registerInteraction("drill-down", {
  showEnable: [
    { trigger: "element:mouseenter", action: "cursor:pointer", isEnable: isParentNode },
    { trigger: "element:mouseleave", action: "cursor:default" },
    { trigger: "element:mouseleave", action: "cursor:pointer", isEnable: inCenter }
  ],
  start: [
    {
      trigger: "element:click",
      isEnable: isParentNode,
      action: ["drill-down-action:click"]
    },
    {
      trigger: "afterchangesize",
      action: ["drill-down-action:resetPosition"]
    },
    {
      trigger: "click",
      isEnable: inCenter,
      action: ["drill-down-action:back"]
    }
  ]
});
(function(_super) {
  __extends$2(Sunburst, _super);
  function Sunburst() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "sunburst";
    return _this;
  }
  Sunburst.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$c;
  };
  Sunburst.prototype.getDefaultOptions = function() {
    return Sunburst.getDefaultOptions();
  };
  Sunburst.prototype.getSchemaAdaptor = function() {
    return adaptor$a;
  };
  Sunburst.SUNBURST_ANCESTOR_FIELD = SUNBURST_ANCESTOR_FIELD;
  Sunburst.SUNBURST_PATH_FIELD = SUNBURST_PATH_FIELD;
  Sunburst.NODE_ANCESTORS_FIELD = NODE_ANCESTORS_FIELD;
  return Sunburst;
})(Plot);
var _a;
var RANGE_VALUE = "range";
var RANGE_TYPE = "type";
var PERCENT = "percent";
var DEFAULT_COLOR = "#f0f0f0";
var INDICATEOR_VIEW_ID = "indicator-view";
var RANGE_VIEW_ID = "range-view";
var DEFAULT_OPTIONS$9 = {
  percent: 0,
  range: {
    ticks: []
  },
  innerRadius: 0.9,
  radius: 0.95,
  startAngle: -7 / 6 * Math.PI,
  endAngle: 1 / 6 * Math.PI,
  syncViewPadding: true,
  axis: {
    line: null,
    label: {
      offset: -24,
      style: {
        textAlign: "center",
        textBaseline: "middle"
      }
    },
    subTickLine: {
      length: -8
    },
    tickLine: {
      length: -12
    },
    grid: null
  },
  indicator: {
    pointer: {
      style: {
        lineWidth: 5,
        lineCap: "round"
      }
    },
    pin: {
      style: {
        r: 9.75,
        lineWidth: 4.5,
        fill: "#fff"
      }
    }
  },
  statistic: {
    title: false
  },
  meta: (_a = {}, _a[RANGE_VALUE] = {
    sync: "v"
  }, _a[PERCENT] = {
    sync: "v",
    tickCount: 5,
    tickInterval: 0.2
  }, _a),
  animation: false
};
function processRangeData(range, percent2) {
  return range.map(function(r, idx) {
    var _a2;
    return _a2 = {}, _a2[RANGE_VALUE] = r - (range[idx - 1] || 0), _a2[RANGE_TYPE] = "" + idx, _a2[PERCENT] = percent2, _a2;
  }).filter(function(d) {
    return !!d[RANGE_VALUE];
  });
}
function getIndicatorData(percent2) {
  var _a2;
  return [(_a2 = {}, _a2[PERCENT] = clamp(percent2, 0, 1), _a2)];
}
function getRangeData(percent2, range) {
  var ticks = get(range, ["ticks"], []);
  var clampTicks = size(ticks) ? ticks : [0, clamp(percent2, 0, 1), 1];
  return processRangeData(clampTicks, percent2);
}
function geometry$6(params) {
  var chart = params.chart, options = params.options;
  var percent2 = options.percent, range = options.range, radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle, axis2 = options.axis, indicator = options.indicator, gaugeStyle = options.gaugeStyle, type = options.type, meter = options.meter;
  var color2 = range.color, rangeWidth = range.width;
  if (indicator) {
    var indicatorData = getIndicatorData(percent2);
    var v1 = chart.createView({ id: INDICATEOR_VIEW_ID });
    v1.data(indicatorData);
    v1.point().position(PERCENT + "*1").shape(indicator.shape || "gauge-indicator").customInfo({
      defaultColor: chart.getTheme().defaultColor,
      indicator
    });
    v1.coordinate("polar", {
      startAngle,
      endAngle,
      radius: innerRadius * radius
    });
    v1.axis(PERCENT, axis2);
    v1.scale(PERCENT, pick(axis2, AXIS_META_CONFIG_KEYS));
  }
  var rangeData = getRangeData(percent2, options.range);
  var v2 = chart.createView({ id: RANGE_VIEW_ID });
  v2.data(rangeData);
  var rangeColor = isString(color2) ? [color2, DEFAULT_COLOR] : color2;
  var ext = interval({
    chart: v2,
    options: {
      xField: "1",
      yField: RANGE_VALUE,
      seriesField: RANGE_TYPE,
      rawFields: [PERCENT],
      isStack: true,
      interval: {
        color: rangeColor,
        style: gaugeStyle,
        shape: type === "meter" ? "meter-gauge" : null
      },
      args: {
        zIndexReversed: true
      },
      minColumnWidth: rangeWidth,
      maxColumnWidth: rangeWidth
    }
  }).ext;
  var geometry2 = ext.geometry;
  geometry2.customInfo({ meter });
  v2.coordinate("polar", {
    innerRadius,
    radius,
    startAngle,
    endAngle
  }).transpose();
  return params;
}
function meta$4(params) {
  var _a2;
  return flow(scale$1((_a2 = {
    range: {
      min: 0,
      max: 1,
      maxLimit: 1,
      minLimit: 0
    }
  }, _a2[PERCENT] = {}, _a2)))(params);
}
function statistic(params, updated) {
  var chart = params.chart, options = params.options;
  var statistic2 = options.statistic, percent2 = options.percent;
  chart.getController("annotation").clear(true);
  if (statistic2) {
    var contentOption = statistic2.content;
    var transformContent = void 0;
    if (contentOption) {
      transformContent = deepAssign({}, {
        content: (percent2 * 100).toFixed(2) + "%",
        style: {
          opacity: 0.75,
          fontSize: "30px",
          lineHeight: 1,
          textAlign: "center",
          color: "rgba(44,53,66,0.85)"
        }
      }, contentOption);
    }
    renderGaugeStatistic(chart, { statistic: __assign$1(__assign$1({}, statistic2), { content: transformContent }) }, { percent: percent2 });
  }
  if (updated) {
    chart.render(true);
  }
  return params;
}
function other(params) {
  var chart = params.chart;
  chart.legend(false);
  chart.tooltip(false);
  return params;
}
function adaptor$9(params) {
  return flow(theme$2, animation$5, geometry$6, meta$4, statistic, interaction$6, annotation$2(), other)(params);
}
registerShape("point", "gauge-indicator", {
  draw: function(cfg, container) {
    var _a2 = cfg.customInfo, indicator = _a2.indicator, defaultColor = _a2.defaultColor;
    var _b = indicator, pointer = _b.pointer, pin2 = _b.pin;
    var group2 = container.addGroup();
    var center2 = this.parsePoint({ x: 0, y: 0 });
    if (pointer) {
      group2.addShape("line", {
        name: "pointer",
        attrs: __assign$1({ x1: center2.x, y1: center2.y, x2: cfg.x, y2: cfg.y, stroke: defaultColor }, pointer.style)
      });
    }
    if (pin2) {
      group2.addShape("circle", {
        name: "pin",
        attrs: __assign$1({ x: center2.x, y: center2.y, stroke: defaultColor }, pin2.style)
      });
    }
    return group2;
  }
});
registerShape("interval", "meter-gauge", {
  draw: function(cfg, container) {
    var _a2 = cfg.customInfo.meter, meter = _a2 === void 0 ? {} : _a2;
    var _b = meter.steps, STEP = _b === void 0 ? 50 : _b, _c = meter.stepRatio, STEP_RATIO = _c === void 0 ? 0.5 : _c;
    STEP = STEP < 1 ? 1 : STEP;
    STEP_RATIO = clamp(STEP_RATIO, 0, 1);
    var _d = this.coordinate, COORD_START_ANGLE = _d.startAngle, COORD_END_ANGLE = _d.endAngle;
    var GAP2 = 0;
    if (STEP_RATIO > 0 && STEP_RATIO < 1) {
      var TOTAL = COORD_END_ANGLE - COORD_START_ANGLE;
      GAP2 = TOTAL / STEP / (STEP_RATIO / (1 - STEP_RATIO) + 1 - 1 / STEP);
    }
    var INTERVAL = GAP2 / (1 - STEP_RATIO) * STEP_RATIO;
    var group2 = container.addGroup();
    var center2 = this.coordinate.getCenter();
    var radius = this.coordinate.getRadius();
    var _e = Util.getAngle(cfg, this.coordinate), START_ANGLE = _e.startAngle, END_ANGLE = _e.endAngle;
    for (var startAngle = START_ANGLE; startAngle < END_ANGLE; ) {
      var endAngle = void 0;
      var r = (startAngle - COORD_START_ANGLE) % (INTERVAL + GAP2);
      if (r < INTERVAL) {
        endAngle = startAngle + (INTERVAL - r);
      } else {
        startAngle += INTERVAL + GAP2 - r;
        endAngle = startAngle + INTERVAL;
      }
      var path2 = Util.getSectorPath(center2.x, center2.y, radius, startAngle, Math.min(endAngle, END_ANGLE), radius * this.coordinate.innerRadius);
      group2.addShape("path", {
        name: "meter-gauge",
        attrs: {
          path: path2,
          fill: cfg.color,
          stroke: cfg.color,
          lineWidth: 0.5
        }
      });
      startAngle = endAngle + GAP2;
    }
    return group2;
  }
});
var Gauge = function(_super) {
  __extends$2(Gauge2, _super);
  function Gauge2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "gauge";
    return _this;
  }
  Gauge2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$9;
  };
  Gauge2.prototype.changeData = function(percent2) {
    this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    this.updateOption({ percent: percent2 });
    var indicatorView = this.chart.views.find(function(v) {
      return v.id === INDICATEOR_VIEW_ID;
    });
    if (indicatorView) {
      indicatorView.data(getIndicatorData(percent2));
    }
    var rangeView = this.chart.views.find(function(v) {
      return v.id === RANGE_VIEW_ID;
    });
    if (rangeView) {
      rangeView.data(getRangeData(percent2, this.options.range));
    }
    statistic({ chart: this.chart, options: this.options }, true);
    this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  Gauge2.prototype.getDefaultOptions = function() {
    return Gauge2.getDefaultOptions();
  };
  Gauge2.prototype.getSchemaAdaptor = function() {
    return adaptor$9;
  };
  return Gauge2;
}(Plot);
var Y_FIELD$2 = "$$yField$$";
var DIFF_FIELD = "$$diffField$$";
var ABSOLUTE_FIELD = "$$absoluteField$$";
var IS_TOTAL = "$$isTotal$$";
var DEFAULT_OPTIONS$8 = {
  label: {},
  leaderLine: {
    style: {
      lineWidth: 1,
      stroke: "#8c8c8c",
      lineDash: [4, 2]
    }
  },
  total: {
    style: {
      fill: "rgba(0, 0, 0, 0.25)"
    }
  },
  interactions: [{ type: "element-active" }],
  risingFill: "#f4664a",
  fallingFill: "#30bf78",
  waterfallStyle: {
    fill: "rgba(0, 0, 0, 0.25)"
  },
  yAxis: {
    grid: {
      line: {
        style: {
          lineDash: [4, 2]
        }
      }
    }
  }
};
function processData(data2, xField, yField, newYField, total) {
  var _a2;
  var newData = [];
  reduce(data2, function(r, d) {
    var _a3;
    log(LEVEL.WARN, isNumber$1(d[yField]), d[yField] + " is not a valid number");
    var value2 = isUndefined(d[yField]) ? null : d[yField];
    newData.push(__assign$1(__assign$1({}, d), (_a3 = {}, _a3[newYField] = [r, r + value2], _a3)));
    return r + value2;
  }, 0);
  if (newData.length && total) {
    var sum = get(newData, [[data2.length - 1], newYField, [1]]);
    newData.push((_a2 = {}, _a2[xField] = total.label, _a2[yField] = sum, _a2[newYField] = [0, sum], _a2));
  }
  return newData;
}
function transformData$4(data2, xField, yField, total) {
  var processed = processData(data2, xField, yField, Y_FIELD$2, total);
  return processed.map(function(d, dIdx) {
    var _a2;
    if (!isObject(d)) {
      return d;
    }
    return __assign$1(__assign$1({}, d), (_a2 = {}, _a2[ABSOLUTE_FIELD] = d[Y_FIELD$2][1], _a2[DIFF_FIELD] = d[Y_FIELD$2][1] - d[Y_FIELD$2][0], _a2[IS_TOTAL] = dIdx === data2.length, _a2));
  });
}
function getRectPath(points) {
  var path2 = [];
  for (var i = 0; i < points.length; i++) {
    var point2 = points[i];
    if (point2) {
      var action = i === 0 ? "M" : "L";
      path2.push([action, point2.x, point2.y]);
    }
  }
  var first = points[0];
  path2.push(["L", first.x, first.y]);
  path2.push(["z"]);
  return path2;
}
function getFillAttrs(cfg) {
  return deepAssign({}, cfg.defaultStyle, cfg.style, { fill: cfg.color });
}
registerShape("interval", "waterfall", {
  draw: function(cfg, container) {
    var customInfo = cfg.customInfo, points = cfg.points, nextPoints = cfg.nextPoints;
    var group2 = container.addGroup();
    var rectPath2 = this.parsePath(getRectPath(points));
    var fillAttrs = getFillAttrs(cfg);
    group2.addShape("path", {
      attrs: __assign$1(__assign$1({}, fillAttrs), { path: rectPath2 })
    });
    var leaderLineCfg = get(customInfo, "leaderLine");
    if (leaderLineCfg && nextPoints) {
      var linkPath = [
        ["M", points[2].x, points[2].y],
        ["L", nextPoints[0].x, nextPoints[0].y]
      ];
      if (points[2].y === nextPoints[1].y) {
        linkPath[1] = ["L", nextPoints[1].x, nextPoints[1].y];
      }
      linkPath = this.parsePath(linkPath);
      group2.addShape("path", {
        attrs: __assign$1({ path: linkPath }, leaderLineCfg.style || {})
      });
    }
    return group2;
  }
});
function defaultOptions$3(params) {
  var _a2 = params.options, locale = _a2.locale, total = _a2.total;
  var localeTotalLabel = getLocale(locale).get(["waterfall", "total"]);
  if (total && typeof total.label !== "string" && localeTotalLabel) {
    params.options.total.label = localeTotalLabel;
  }
  return params;
}
function geometry$5(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, xField = options.xField, yField = options.yField, total = options.total, leaderLine = options.leaderLine, columnWidthRatio = options.columnWidthRatio, waterfallStyle = options.waterfallStyle, risingFill = options.risingFill, fallingFill = options.fallingFill, color2 = options.color;
  chart.data(transformData$4(data2, xField, yField, total));
  var colorMapping = color2 || function(datum) {
    if (get(datum, [IS_TOTAL])) {
      return get(total, ["style", "fill"], "");
    }
    return get(datum, [Y_FIELD$2, 1]) - get(datum, [Y_FIELD$2, 0]) > 0 ? risingFill : fallingFill;
  };
  var p = deepAssign({}, params, {
    options: {
      xField,
      yField: Y_FIELD$2,
      seriesField: xField,
      rawFields: [yField, DIFF_FIELD, IS_TOTAL, Y_FIELD$2],
      widthRatio: columnWidthRatio,
      interval: {
        style: waterfallStyle,
        shape: "waterfall",
        color: colorMapping
      }
    }
  });
  var ext = interval(p).ext;
  var geometry2 = ext.geometry;
  geometry2.customInfo({ leaderLine });
  return params;
}
function meta$3(params) {
  var _a2, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, meta2 = options.meta;
  var Y_FIELD_META = deepAssign({}, { alias: yField }, get(meta2, yField));
  return flow(scale$1((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2[Y_FIELD$2] = yAxis, _a2), deepAssign({}, meta2, (_b = {}, _b[Y_FIELD$2] = Y_FIELD_META, _b[DIFF_FIELD] = Y_FIELD_META, _b[ABSOLUTE_FIELD] = Y_FIELD_META, _b))))(params);
}
function axis$5(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
    chart.axis(Y_FIELD$2, false);
  } else {
    chart.axis(yField, yAxis);
    chart.axis(Y_FIELD$2, yAxis);
  }
  return params;
}
function legend$1(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, total = options.total, risingFill = options.risingFill, fallingFill = options.fallingFill, locale = options.locale;
  var i18n = getLocale(locale);
  if (legend2 === false) {
    chart.legend(false);
  } else {
    var items = [
      {
        name: i18n.get(["general", "increase"]),
        value: "increase",
        marker: { symbol: "square", style: { r: 5, fill: risingFill } }
      },
      {
        name: i18n.get(["general", "decrease"]),
        value: "decrease",
        marker: { symbol: "square", style: { r: 5, fill: fallingFill } }
      }
    ];
    if (total) {
      items.push({
        name: total.label || "",
        value: "total",
        marker: {
          symbol: "square",
          style: deepAssign({}, { r: 5 }, get(total, "style"))
        }
      });
    }
    chart.legend(deepAssign({}, {
      custom: true,
      position: "top",
      items
    }, legend2));
    chart.removeInteraction("legend-filter");
  }
  return params;
}
function label$2(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, labelMode = options.labelMode, xField = options.xField;
  var geometry2 = findGeometry(chart, "interval");
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    geometry2.label({
      fields: labelMode === "absolute" ? [ABSOLUTE_FIELD, xField] : [DIFF_FIELD, xField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function tooltip$2(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip, xField = options.xField, yField = options.yField;
  if (tooltip2 !== false) {
    chart.tooltip(__assign$1({
      showCrosshairs: false,
      showMarkers: false,
      shared: true,
      fields: [yField]
    }, tooltip2));
    var geometry_1 = chart.geometries[0];
    (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.formatter) ? geometry_1.tooltip(xField + "*" + yField, tooltip2.formatter) : geometry_1.tooltip(yField);
  } else {
    chart.tooltip(false);
  }
  return params;
}
function adaptor$8(params) {
  return flow(defaultOptions$3, theme$2, geometry$5, meta$3, axis$5, legend$1, tooltip$2, label$2, state, interaction$6, animation$5, annotation$2())(params);
}
(function(_super) {
  __extends$2(Waterfall, _super);
  function Waterfall() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "waterfall";
    return _this;
  }
  Waterfall.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$8;
  };
  Waterfall.prototype.changeData = function(data2) {
    var _a2 = this.options, xField = _a2.xField, yField = _a2.yField, total = _a2.total;
    this.updateOption({ data: data2 });
    this.chart.changeData(transformData$4(data2, xField, yField, total));
  };
  Waterfall.prototype.getSchemaAdaptor = function() {
    return adaptor$8;
  };
  Waterfall.prototype.getDefaultOptions = function() {
    return Waterfall.getDefaultOptions();
  };
  return Waterfall;
})(Plot);
function getScaleMax(maxAngle, yField, data2) {
  var yData = data2.map(function(item) {
    return item[yField];
  }).filter(function(v) {
    return v !== void 0;
  });
  var maxValue = yData.length > 0 ? Math.max.apply(Math, yData) : 0;
  var formatRadian = Math.abs(maxAngle) % 360;
  if (!formatRadian) {
    return maxValue;
  }
  return maxValue * 360 / formatRadian;
}
function getStackedData(data2, xField, yField) {
  var stackedData = [];
  data2.forEach(function(item) {
    var valueItem = stackedData.find(function(v) {
      return v[xField] === item[xField];
    });
    if (valueItem) {
      valueItem[yField] += item[yField] || null;
    } else {
      stackedData.push(__assign$1({}, item));
    }
  });
  return stackedData;
}
function geometry$4(params) {
  var chart = params.chart, options = params.options;
  var style = options.barStyle, color2 = options.color, tooltip2 = options.tooltip, colorField = options.colorField, type = options.type, xField = options.xField, yField = options.yField, data2 = options.data;
  var processData2 = processIllegalData(data2, yField);
  chart.data(processData2);
  var p = deepAssign({}, params, {
    options: {
      tooltip: tooltip2,
      seriesField: colorField,
      interval: {
        style,
        color: color2,
        shape: type === "line" ? "line" : "intervel"
      },
      minColumnWidth: options.minBarWidth,
      maxColumnWidth: options.maxBarWidth,
      columnBackground: options.barBackground
    }
  });
  interval(p);
  if (type === "line") {
    point({
      chart,
      options: { xField, yField, seriesField: colorField, point: { shape: "circle", color: color2 } }
    });
  }
  return params;
}
function meta$2(params) {
  var _a2;
  var options = params.options;
  var yField = options.yField, xField = options.xField, data2 = options.data, isStack = options.isStack, isGroup = options.isGroup, colorField = options.colorField, maxAngle = options.maxAngle;
  var actualData = isStack && !isGroup && colorField ? getStackedData(data2, xField, yField) : data2;
  var processData2 = processIllegalData(actualData, yField);
  return flow(scale$1((_a2 = {}, _a2[yField] = {
    min: 0,
    max: getScaleMax(maxAngle, yField, processData2)
  }, _a2)))(params);
}
function coordinate$1(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate({
    type: "polar",
    cfg: {
      radius,
      innerRadius,
      startAngle,
      endAngle
    }
  }).transpose();
  return params;
}
function axis$4(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, xAxis = options.xAxis;
  chart.axis(xField, xAxis);
  return params;
}
function label$1(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField;
  var intervalGeometry = findGeometry(chart, "interval");
  if (!label2) {
    intervalGeometry.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    intervalGeometry.label({
      fields: [yField],
      callback,
      cfg: __assign$1(__assign$1({}, transformLabel(cfg)), { type: "polar" })
    });
  }
  return params;
}
function adaptor$7(params) {
  return flow(pattern("barStyle"), geometry$4, meta$2, axis$4, coordinate$1, interaction$6, animation$5, theme$2, tooltip$8, legend$g, annotation$2(), label$1)(params);
}
var DEFAULT_OPTIONS$7 = deepAssign({}, Plot.getDefaultOptions(), {
  interactions: [{ type: "element-active" }],
  legend: false,
  tooltip: {
    showMarkers: false
  },
  xAxis: {
    grid: null,
    tickLine: null,
    line: null
  },
  maxAngle: 240
});
(function(_super) {
  __extends$2(RadialBar, _super);
  function RadialBar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "radial-bar";
    return _this;
  }
  RadialBar.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$7;
  };
  RadialBar.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    meta$2({ chart: this.chart, options: this.options });
    this.chart.changeData(data2);
  };
  RadialBar.prototype.getDefaultOptions = function() {
    return RadialBar.getDefaultOptions();
  };
  RadialBar.prototype.getSchemaAdaptor = function() {
    return adaptor$7;
  };
  return RadialBar;
})(Plot);
var FIRST_AXES_VIEW = "first-axes-view";
var SECOND_AXES_VIEW = "second-axes-view";
var SERIES_FIELD_KEY = "series-field-key";
function transformData$3(xField, yField, seriesField, data2, reverse) {
  var hopeData = [];
  yField.forEach(function(d) {
    data2.forEach(function(k) {
      var _a3;
      var obj = (_a3 = {}, _a3[xField] = k[xField], _a3[seriesField] = d, _a3[d] = k[d], _a3);
      hopeData.push(obj);
    });
  });
  var groupData = Object.values(groupBy(hopeData, seriesField));
  var _a2 = groupData[0], data1 = _a2 === void 0 ? [] : _a2, _b = groupData[1], data22 = _b === void 0 ? [] : _b;
  return reverse ? [data1.reverse(), data22.reverse()] : [data1, data22];
}
function isHorizontal(layout) {
  return layout !== "vertical";
}
function syncViewPadding(chart, views, p) {
  var v1 = views[0], v2 = views[1];
  var p1 = v1.autoPadding;
  var p2 = v2.autoPadding;
  var _a2 = chart.__axisPosition, layout = _a2.layout, position = _a2.position;
  if (isHorizontal(layout) && position === "top") {
    v1.autoPadding = p.instance(p1.top, 0, p1.bottom, p1.left);
    v2.autoPadding = p.instance(p2.top, p1.left, p2.bottom, 0);
  }
  if (isHorizontal(layout) && position === "bottom") {
    v1.autoPadding = p.instance(p1.top, p1.right / 2 + 5, p1.bottom, p1.left);
    v2.autoPadding = p.instance(p2.top, p2.right, p2.bottom, p1.right / 2 + 5);
  }
  if (!isHorizontal(layout) && position === "bottom") {
    var left2 = p1.left >= p2.left ? p1.left : p2.left;
    v1.autoPadding = p.instance(p1.top, p1.right, p1.bottom / 2 + 5, left2);
    v2.autoPadding = p.instance(p1.bottom / 2 + 5, p2.right, p2.bottom, left2);
  }
  if (!isHorizontal(layout) && position === "top") {
    var left2 = p1.left >= p2.left ? p1.left : p2.left;
    v1.autoPadding = p.instance(p1.top, p1.right, 0, left2);
    v2.autoPadding = p.instance(0, p2.right, p1.top, left2);
  }
}
function geometry$3(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, xField = options.xField, yField = options.yField, color2 = options.color, barStyle = options.barStyle, widthRatio = options.widthRatio, legend2 = options.legend, layout = options.layout;
  var groupData = transformData$3(xField, yField, SERIES_FIELD_KEY, data2, isHorizontal(layout));
  if (legend2) {
    chart.legend(SERIES_FIELD_KEY, legend2);
  } else if (legend2 === false) {
    chart.legend(false);
  }
  var firstView;
  var secondView;
  var firstViewData = groupData[0], secondViewData = groupData[1];
  if (isHorizontal(layout)) {
    firstView = chart.createView({
      region: {
        start: { x: 0, y: 0 },
        end: { x: 0.5, y: 1 }
      },
      id: FIRST_AXES_VIEW
    });
    firstView.coordinate().transpose().reflect("x");
    secondView = chart.createView({
      region: {
        start: { x: 0.5, y: 0 },
        end: { x: 1, y: 1 }
      },
      id: SECOND_AXES_VIEW
    });
    secondView.coordinate().transpose();
    firstView.data(firstViewData);
    secondView.data(secondViewData);
  } else {
    firstView = chart.createView({
      region: {
        start: { x: 0, y: 0 },
        end: { x: 1, y: 0.5 }
      },
      id: FIRST_AXES_VIEW
    });
    secondView = chart.createView({
      region: {
        start: { x: 0, y: 0.5 },
        end: { x: 1, y: 1 }
      },
      id: SECOND_AXES_VIEW
    });
    secondView.coordinate().reflect("y");
    firstView.data(firstViewData);
    secondView.data(secondViewData);
  }
  var left2 = deepAssign({}, params, {
    chart: firstView,
    options: {
      widthRatio,
      xField,
      yField: yField[0],
      seriesField: SERIES_FIELD_KEY,
      interval: {
        color: color2,
        style: barStyle
      }
    }
  });
  interval(left2);
  var right2 = deepAssign({}, params, {
    chart: secondView,
    options: {
      xField,
      yField: yField[1],
      seriesField: SERIES_FIELD_KEY,
      widthRatio,
      interval: {
        color: color2,
        style: barStyle
      }
    }
  });
  interval(right2);
  return params;
}
function meta$1(params) {
  var _a2, _b, _c;
  var options = params.options, chart = params.chart;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  var firstView = findViewById(chart, FIRST_AXES_VIEW);
  var secondView = findViewById(chart, SECOND_AXES_VIEW);
  var aliasMap = {};
  keys((options === null || options === void 0 ? void 0 : options.meta) || {}).map(function(metaKey) {
    if (get(options === null || options === void 0 ? void 0 : options.meta, [metaKey, "alias"])) {
      aliasMap[metaKey] = options.meta[metaKey].alias;
    }
  });
  chart.scale((_a2 = {}, _a2[SERIES_FIELD_KEY] = {
    sync: true,
    formatter: function(v) {
      return get(aliasMap, v, v);
    }
  }, _a2));
  scale$1((_b = {}, _b[xField] = xAxis, _b[yField[0]] = yAxis[yField[0]], _b))(deepAssign({}, params, { chart: firstView }));
  scale$1((_c = {}, _c[xField] = xAxis, _c[yField[1]] = yAxis[yField[1]], _c))(deepAssign({}, params, { chart: secondView }));
  return params;
}
function axis$3(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, layout = options.layout;
  var firstView = findViewById(chart, FIRST_AXES_VIEW);
  var secondView = findViewById(chart, SECOND_AXES_VIEW);
  if ((xAxis === null || xAxis === void 0 ? void 0 : xAxis.position) === "bottom") {
    secondView.axis(xField, __assign$1(__assign$1({}, xAxis), { label: { formatter: function() {
      return "";
    } } }));
  } else {
    secondView.axis(xField, false);
  }
  if (xAxis === false) {
    firstView.axis(xField, false);
  } else {
    firstView.axis(xField, __assign$1({
      position: isHorizontal(layout) ? "top" : "bottom"
    }, xAxis));
  }
  if (yAxis === false) {
    firstView.axis(yField[0], false);
    secondView.axis(yField[1], false);
  } else {
    firstView.axis(yField[0], yAxis[yField[0]]);
    secondView.axis(yField[1], yAxis[yField[1]]);
  }
  chart.__axisPosition = {
    position: firstView.getOptions().axes[xField].position,
    layout
  };
  return params;
}
function interaction$2(params) {
  var chart = params.chart;
  interaction$6(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
  interaction$6(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
  return params;
}
function limitInPlot(params) {
  var chart = params.chart, options = params.options;
  var yField = options.yField, yAxis = options.yAxis;
  limitInPlot$2(deepAssign({}, params, {
    chart: findViewById(chart, FIRST_AXES_VIEW),
    options: {
      yAxis: yAxis[yField[0]]
    }
  }));
  limitInPlot$2(deepAssign({}, params, {
    chart: findViewById(chart, SECOND_AXES_VIEW),
    options: {
      yAxis: yAxis[yField[1]]
    }
  }));
  return params;
}
function theme(params) {
  var chart = params.chart;
  theme$2(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
  theme$2(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
  return params;
}
function animation$2(params) {
  var chart = params.chart;
  animation$5(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
  animation$5(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
  return params;
}
function label(params) {
  var _this = this;
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField, layout = options.layout;
  var firstView = findViewById(chart, FIRST_AXES_VIEW);
  var secondView = findViewById(chart, SECOND_AXES_VIEW);
  var leftGeometry = findGeometry(firstView, "interval");
  var rightGeometry = findGeometry(secondView, "interval");
  if (!label2) {
    leftGeometry.label(false);
    rightGeometry.label(false);
  } else {
    var callback = label2.callback, cfg_1 = __rest(label2, ["callback"]);
    if (!cfg_1.position) {
      cfg_1.position = "middle";
    }
    if (cfg_1.offset === void 0) {
      cfg_1.offset = 2;
    }
    var leftLabelCfg = __assign$1({}, cfg_1);
    if (isHorizontal(layout)) {
      var textAlign = ((_a2 = leftLabelCfg.style) === null || _a2 === void 0 ? void 0 : _a2.textAlign) || (cfg_1.position === "middle" ? "center" : "left");
      cfg_1.style = deepAssign({}, cfg_1.style, { textAlign });
      var textAlignMap = { left: "right", right: "left", center: "center" };
      leftLabelCfg.style = deepAssign({}, leftLabelCfg.style, { textAlign: textAlignMap[textAlign] });
    } else {
      var positionMap_1 = { top: "bottom", bottom: "top", middle: "middle" };
      if (typeof cfg_1.position === "string") {
        cfg_1.position = positionMap_1[cfg_1.position];
      } else if (typeof cfg_1.position === "function") {
        cfg_1.position = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return positionMap_1[cfg_1.position.apply(_this, args)];
        };
      }
      var textBaseline = ((_b = leftLabelCfg.style) === null || _b === void 0 ? void 0 : _b.textBaseline) || "bottom";
      leftLabelCfg.style = deepAssign({}, leftLabelCfg.style, { textBaseline });
      var textBaselineMap = { top: "bottom", bottom: "top", middle: "middle" };
      cfg_1.style = deepAssign({}, cfg_1.style, { textBaseline: textBaselineMap[textBaseline] });
    }
    leftGeometry.label({
      fields: [yField[0]],
      callback,
      cfg: transformLabel(leftLabelCfg)
    });
    rightGeometry.label({
      fields: [yField[1]],
      callback,
      cfg: transformLabel(cfg_1)
    });
  }
  return params;
}
function adaptor$6(params) {
  return flow(geometry$3, meta$1, axis$3, limitInPlot, theme, label, tooltip$8, interaction$2, animation$2)(params);
}
(function(_super) {
  __extends$2(BidirectionalBar, _super);
  function BidirectionalBar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "bidirectional-bar";
    return _this;
  }
  BidirectionalBar.getDefaultOptions = function() {
    return deepAssign({}, _super.getDefaultOptions.call(this), {
      syncViewPadding
    });
  };
  BidirectionalBar.prototype.changeData = function(data2) {
    if (data2 === void 0) {
      data2 = [];
    }
    this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    this.updateOption({ data: data2 });
    var _a2 = this.options, xField = _a2.xField, yField = _a2.yField, layout = _a2.layout;
    var groupData = transformData$3(xField, yField, SERIES_FIELD_KEY, data2, isHorizontal(layout));
    var firstViewData = groupData[0], secondViewData = groupData[1];
    var firstView = findViewById(this.chart, FIRST_AXES_VIEW);
    var secondView = findViewById(this.chart, SECOND_AXES_VIEW);
    firstView.data(firstViewData);
    secondView.data(secondViewData);
    this.chart.render(true);
    this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  BidirectionalBar.prototype.getDefaultOptions = function() {
    return BidirectionalBar.getDefaultOptions();
  };
  BidirectionalBar.prototype.getSchemaAdaptor = function() {
    return adaptor$6;
  };
  BidirectionalBar.SERIES_FIELD_KEY = SERIES_FIELD_KEY;
  return BidirectionalBar;
})(Plot);
function findInteraction(interactions, interactionType) {
  if (!isArray$1(interactions))
    return void 0;
  return interactions.find(function(i) {
    return i.type === interactionType;
  });
}
function enableInteraction(interactions, interactionType) {
  var interaction2 = findInteraction(interactions, interactionType);
  return interaction2 && interaction2.enable !== false;
}
function enableDrillInteraction(options) {
  var interactions = options.interactions, drilldown = options.drilldown;
  return get(drilldown, "enabled") || enableInteraction(interactions, "treemap-drill-down");
}
function resetDrillDown(chart) {
  var drillDownInteraction = chart.interactions["drill-down"];
  if (!drillDownInteraction)
    return;
  var drillDownAction = drillDownInteraction.context.actions.find(function(i) {
    return i.name === "drill-down-action";
  });
  drillDownAction.reset();
}
function transformData$2(options) {
  var data2 = options.data, colorField = options.colorField, enableDrillDown = options.enableDrillDown, hierarchyConfig = options.hierarchyConfig;
  var nodes = treemap(data2, __assign$1(__assign$1({}, hierarchyConfig), {
    type: "hierarchy.treemap",
    field: "value",
    as: ["x", "y"]
  }));
  var result = [];
  nodes.forEach(function(node) {
    if (node.depth === 0) {
      return null;
    }
    if (enableDrillDown && node.depth !== 1) {
      return null;
    }
    if (!enableDrillDown && node.children) {
      return null;
    }
    var curPath = node.ancestors().map(function(n) {
      return {
        data: n.data,
        height: n.height,
        value: n.value
      };
    });
    var path2 = enableDrillDown && isArray$1(data2.path) ? curPath.concat(data2.path.slice(1)) : curPath;
    var nodeInfo = Object.assign({}, node.data, __assign$1({ x: node.x, y: node.y, depth: node.depth, value: node.value, path: path2 }, node));
    if (!node.data[colorField] && node.parent) {
      var ancestorNode = node.ancestors().find(function(n) {
        return n.data[colorField];
      });
      nodeInfo[colorField] = ancestorNode === null || ancestorNode === void 0 ? void 0 : ancestorNode.data[colorField];
    } else {
      nodeInfo[colorField] = node.data[colorField];
    }
    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig, colorField, enableDrillDown };
    result.push(nodeInfo);
  });
  return result;
}
function defaultOptions$2(params) {
  var options = params.options;
  var colorField = options.colorField;
  return deepAssign({
    options: {
      rawFields: ["value"],
      tooltip: {
        fields: ["name", "value", colorField, "path"],
        formatter: function(data2) {
          return {
            name: data2.name,
            value: data2.value
          };
        }
      }
    }
  }, params);
}
function geometry$2(params) {
  var chart = params.chart, options = params.options;
  var color2 = options.color, colorField = options.colorField, rectStyle = options.rectStyle, hierarchyConfig = options.hierarchyConfig, rawFields = options.rawFields;
  var data2 = transformData$2({
    data: options.data,
    colorField: options.colorField,
    enableDrillDown: enableDrillInteraction(options),
    hierarchyConfig
  });
  chart.data(data2);
  polygon(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField,
      rawFields,
      polygon: {
        color: color2,
        style: rectStyle
      }
    }
  }));
  chart.coordinate().reflect("y");
  return params;
}
function axis$2(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function adaptorInteraction$1(options) {
  var drilldown = options.drilldown, _a2 = options.interactions, interactions = _a2 === void 0 ? [] : _a2;
  var enableDrillDown = enableDrillInteraction(options);
  if (enableDrillDown) {
    return deepAssign({}, options, {
      interactions: __spreadArrays(interactions, [
        {
          type: "drill-down",
          cfg: { drillDownConfig: drilldown, transformData: transformData$2 }
        }
      ])
    });
  }
  return options;
}
function interaction$1(params) {
  var chart = params.chart, options = params.options;
  var interactions = options.interactions, drilldown = options.drilldown;
  interaction$6({
    chart,
    options: adaptorInteraction$1(options)
  });
  var viewZoomInteraction = findInteraction(interactions, "view-zoom");
  if (viewZoomInteraction) {
    if (viewZoomInteraction.enable !== false) {
      chart.getCanvas().on("mousewheel", function(ev) {
        ev.preventDefault();
      });
    } else {
      chart.getCanvas().off("mousewheel");
    }
  }
  var enableDrillDown = enableDrillInteraction(options);
  if (enableDrillDown) {
    chart.appendPadding = getAdjustAppendPadding(chart.appendPadding, get(drilldown, ["breadCrumb", "position"]));
  }
  return params;
}
function adaptor$5(params) {
  return flow(defaultOptions$2, theme$2, pattern("rectStyle"), geometry$2, axis$2, legend$g, tooltip$8, interaction$1, animation$5, annotation$2())(params);
}
var DEFAULT_OPTIONS$6 = {
  colorField: "name",
  rectStyle: {
    lineWidth: 1,
    stroke: "#fff"
  },
  hierarchyConfig: {
    tile: "treemapSquarify"
  },
  label: {
    fields: ["name"],
    layout: {
      type: "limit-in-shape"
    }
  },
  tooltip: {
    showMarkers: false,
    showTitle: false
  },
  drilldown: {
    enabled: false,
    breadCrumb: {
      position: "bottom-left",
      rootText: "\u521D\u59CB",
      dividerText: "/",
      textStyle: {
        fontSize: 12,
        fill: "rgba(0, 0, 0, 0.65)",
        cursor: "pointer"
      },
      activeTextStyle: {
        fill: "#87B5FF"
      }
    }
  }
};
(function(_super) {
  __extends$2(Treemap, _super);
  function Treemap() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "treemap";
    return _this;
  }
  Treemap.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$6;
  };
  Treemap.prototype.changeData = function(data2) {
    var _a2 = this.options, colorField = _a2.colorField, interactions = _a2.interactions, hierarchyConfig = _a2.hierarchyConfig;
    this.updateOption({ data: data2 });
    var transData = transformData$2({
      data: data2,
      colorField,
      enableDrillDown: enableInteraction(interactions, "treemap-drill-down"),
      hierarchyConfig
    });
    this.chart.changeData(transData);
    resetDrillDown(this.chart);
  };
  Treemap.prototype.getDefaultOptions = function() {
    return Treemap.getDefaultOptions();
  };
  Treemap.prototype.getSchemaAdaptor = function() {
    return adaptor$5;
  };
  return Treemap;
})(Plot);
function targetDepth(d) {
  return d.target.depth;
}
function left(node) {
  return node.depth;
}
function right(node, n) {
  return n - 1 - node.height;
}
function justify(node, n) {
  return node.sourceLinks.length ? node.depth : n - 1;
}
function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? minBy(node.sourceLinks, targetDepth) - 1 : 0;
}
function constant(x) {
  return function() {
    return x;
  };
}
function sumBy(arr, func) {
  var r = 0;
  for (var i = 0; i < arr.length; i++) {
    r += func(arr[i]);
  }
  return r;
}
function maxValueBy(arr, func) {
  var r = -Infinity;
  for (var i = 0; i < arr.length; i++) {
    r = Math.max(func(arr[i]), r);
  }
  return r;
}
function minValueBy(arr, func) {
  var r = Infinity;
  for (var i = 0; i < arr.length; i++) {
    r = Math.min(func(arr[i]), r);
  }
  return r;
}
function ascendingSourceBreadth(a, b) {
  return ascendingBreadth(a.source, b.source) || a.index - b.index;
}
function ascendingTargetBreadth(a, b) {
  return ascendingBreadth(a.target, b.target) || a.index - b.index;
}
function ascendingBreadth(a, b) {
  return a.y0 - b.y0;
}
function value(d) {
  return d.value;
}
function defaultId(d) {
  return d.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find(nodeById, id) {
  var node = nodeById.get(id);
  if (!node)
    throw new Error("missing: " + id);
  return node;
}
function computeLinkBreadths(_a2) {
  var nodes = _a2.nodes;
  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
    var node = nodes_1[_i];
    var y0 = node.y0;
    var y1 = y0;
    for (var _b = 0, _c = node.sourceLinks; _b < _c.length; _b++) {
      var link = _c[_b];
      link.y0 = y0 + link.width / 2;
      y0 += link.width;
    }
    for (var _d = 0, _e = node.targetLinks; _d < _e.length; _d++) {
      var link = _e[_d];
      link.y1 = y1 + link.width / 2;
      y1 += link.width;
    }
  }
}
function Sankey() {
  var x0 = 0, y0 = 0, x1 = 1, y1 = 1;
  var dx = 24;
  var dy = 8, py;
  var id = defaultId;
  var align = justify;
  var depth;
  var sort;
  var linkSort;
  var nodes = defaultNodes;
  var links = defaultLinks;
  var iterations = 6;
  function sankey(arg) {
    var graph = {
      nodes: nodes(arg),
      links: links(arg)
    };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_) {
    return arguments.length ? (id = typeof _ === "function" ? _ : constant(_), sankey) : id;
  };
  sankey.nodeAlign = function(_) {
    return arguments.length ? (align = typeof _ === "function" ? _ : constant(_), sankey) : align;
  };
  sankey.nodeDepth = function(_) {
    return arguments.length ? (depth = typeof _ === "function" ? _ : _, sankey) : depth;
  };
  sankey.nodeSort = function(_) {
    return arguments.length ? (sort = _, sankey) : sort;
  };
  sankey.nodeWidth = function(_) {
    return arguments.length ? (dx = +_, sankey) : dx;
  };
  sankey.nodePadding = function(_) {
    return arguments.length ? (dy = py = +_, sankey) : dy;
  };
  sankey.nodes = function(_) {
    return arguments.length ? (nodes = typeof _ === "function" ? _ : constant(_), sankey) : nodes;
  };
  sankey.links = function(_) {
    return arguments.length ? (links = typeof _ === "function" ? _ : constant(_), sankey) : links;
  };
  sankey.linkSort = function(_) {
    return arguments.length ? (linkSort = _, sankey) : linkSort;
  };
  sankey.size = function(_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];
  };
  sankey.extent = function(_) {
    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [
      [x0, y0],
      [x1, y1]
    ];
  };
  sankey.iterations = function(_) {
    return arguments.length ? (iterations = +_, sankey) : iterations;
  };
  function computeNodeLinks(_a2) {
    var nodes2 = _a2.nodes, links2 = _a2.links;
    nodes2.forEach(function(node, idx) {
      node.index = idx;
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    var nodeById = new Map(nodes2.map(function(d) {
      return [id(d), d];
    }));
    links2.forEach(function(link, idx) {
      link.index = idx;
      var source = link.source, target = link.target;
      if (typeof source !== "object")
        source = link.source = find(nodeById, source);
      if (typeof target !== "object")
        target = link.target = find(nodeById, target);
      source.sourceLinks.push(link);
      target.targetLinks.push(link);
    });
    if (linkSort != null) {
      for (var _i = 0, nodes_2 = nodes2; _i < nodes_2.length; _i++) {
        var _b = nodes_2[_i], sourceLinks = _b.sourceLinks, targetLinks = _b.targetLinks;
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues(_a2) {
    var nodes2 = _a2.nodes;
    for (var _i = 0, nodes_3 = nodes2; _i < nodes_3.length; _i++) {
      var node = nodes_3[_i];
      node.value = node.fixedValue === void 0 ? Math.max(sumBy(node.sourceLinks, value), sumBy(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths(_a2) {
    var nodes2 = _a2.nodes;
    var n = nodes2.length;
    var current = new Set(nodes2);
    var next = new Set();
    var x = 0;
    while (current.size) {
      current.forEach(function(node2) {
        node2.depth = x;
        for (var _i = 0, _a3 = node2.sourceLinks; _i < _a3.length; _i++) {
          var target = _a3[_i].target;
          next.add(target);
        }
      });
      if (++x > n)
        throw new Error("circular link");
      current = next;
      next = new Set();
    }
    if (depth) {
      var maxDepth = Math.max(maxValueBy(nodes2, function(d) {
        return d.depth;
      }) + 1, 0);
      var node = void 0;
      for (var i = 0; i < nodes2.length; i++) {
        node = nodes2[i];
        node.depth = depth.call(null, node, maxDepth);
      }
    }
  }
  function computeNodeHeights(_a2) {
    var nodes2 = _a2.nodes;
    var n = nodes2.length;
    var current = new Set(nodes2);
    var next = new Set();
    var x = 0;
    while (current.size) {
      current.forEach(function(node) {
        node.height = x;
        for (var _i = 0, _a3 = node.targetLinks; _i < _a3.length; _i++) {
          var source = _a3[_i].source;
          next.add(source);
        }
      });
      if (++x > n)
        throw new Error("circular link");
      current = next;
      next = new Set();
    }
  }
  function computeNodeLayers(_a2) {
    var nodes2 = _a2.nodes;
    var x = Math.max(maxValueBy(nodes2, function(d) {
      return d.depth;
    }) + 1, 0);
    var kx = (x1 - x0 - dx) / (x - 1);
    var columns = new Array(x).fill(0).map(function() {
      return [];
    });
    for (var _i = 0, nodes_4 = nodes2; _i < nodes_4.length; _i++) {
      var node = nodes_4[_i];
      var i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));
      node.layer = i;
      node.x0 = x0 + i * kx;
      node.x1 = node.x0 + dx;
      if (columns[i])
        columns[i].push(node);
      else
        columns[i] = [node];
    }
    if (sort)
      for (var _b = 0, columns_1 = columns; _b < columns_1.length; _b++) {
        var column = columns_1[_b];
        column.sort(sort);
      }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    var ky = minValueBy(columns, function(c) {
      return (y1 - y0 - (c.length - 1) * py) / sumBy(c, value);
    });
    for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {
      var nodes_6 = columns_2[_i];
      var y = y0;
      for (var _a2 = 0, nodes_5 = nodes_6; _a2 < nodes_5.length; _a2++) {
        var node = nodes_5[_a2];
        node.y0 = y;
        node.y1 = y + node.value * ky;
        y = node.y1 + py;
        for (var _b = 0, _c = node.sourceLinks; _b < _c.length; _b++) {
          var link = _c[_b];
          link.width = link.value * ky;
        }
      }
      y = (y1 - y + py) / (nodes_6.length + 1);
      for (var i = 0; i < nodes_6.length; ++i) {
        var node = nodes_6[i];
        node.y0 += y * (i + 1);
        node.y1 += y * (i + 1);
      }
      reorderLinks(nodes_6);
    }
  }
  function computeNodeBreadths(graph) {
    var columns = computeNodeLayers(graph);
    py = Math.min(dy, (y1 - y0) / (maxValueBy(columns, function(c) {
      return c.length;
    }) - 1));
    initializeNodeBreadths(columns);
    for (var i = 0; i < iterations; ++i) {
      var alpha = Math.pow(0.99, i);
      var beta = Math.max(1 - alpha, (i + 1) / iterations);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (var i = 1, n = columns.length; i < n; ++i) {
      var column = columns[i];
      for (var _i = 0, column_1 = column; _i < column_1.length; _i++) {
        var target = column_1[_i];
        var y = 0;
        var w = 0;
        for (var _a2 = 0, _b = target.targetLinks; _a2 < _b.length; _a2++) {
          var _c = _b[_a2], source = _c.source, value_1 = _c.value;
          var v = value_1 * (target.layer - source.layer);
          y += targetTop(source, target) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        var dy_1 = (y / w - target.y0) * alpha;
        target.y0 += dy_1;
        target.y1 += dy_1;
        reorderNodeLinks(target);
      }
      if (sort === void 0)
        column.sort(ascendingBreadth);
      if (column.length)
        resolveCollisions(column, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (var n = columns.length, i = n - 2; i >= 0; --i) {
      var column = columns[i];
      for (var _i = 0, column_2 = column; _i < column_2.length; _i++) {
        var source = column_2[_i];
        var y = 0;
        var w = 0;
        for (var _a2 = 0, _b = source.sourceLinks; _a2 < _b.length; _a2++) {
          var _c = _b[_a2], target = _c.target, value_2 = _c.value;
          var v = value_2 * (target.layer - source.layer);
          y += sourceTop(source, target) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        var dy_2 = (y / w - source.y0) * alpha;
        source.y0 += dy_2;
        source.y1 += dy_2;
        reorderNodeLinks(source);
      }
      if (sort === void 0)
        column.sort(ascendingBreadth);
      if (column.length)
        resolveCollisions(column, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    var i = nodes2.length >> 1;
    var subject = nodes2[i];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y1, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y0, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y, i, alpha) {
    for (; i < nodes2.length; ++i) {
      var node = nodes2[i];
      var dy_3 = (y - node.y0) * alpha;
      if (dy_3 > 1e-6)
        node.y0 += dy_3, node.y1 += dy_3;
      y = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y, i, alpha) {
    for (; i >= 0; --i) {
      var node = nodes2[i];
      var dy_4 = (node.y1 - y) * alpha;
      if (dy_4 > 1e-6)
        node.y0 -= dy_4, node.y1 -= dy_4;
      y = node.y0 - py;
    }
  }
  function reorderNodeLinks(_a2) {
    var sourceLinks = _a2.sourceLinks, targetLinks = _a2.targetLinks;
    if (linkSort === void 0) {
      for (var _i = 0, targetLinks_1 = targetLinks; _i < targetLinks_1.length; _i++) {
        var sourceLinks_2 = targetLinks_1[_i].source.sourceLinks;
        sourceLinks_2.sort(ascendingTargetBreadth);
      }
      for (var _b = 0, sourceLinks_1 = sourceLinks; _b < sourceLinks_1.length; _b++) {
        var targetLinks_2 = sourceLinks_1[_b].target.targetLinks;
        targetLinks_2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (var _i = 0, nodes_7 = nodes2; _i < nodes_7.length; _i++) {
        var _a2 = nodes_7[_i], sourceLinks = _a2.sourceLinks, targetLinks = _a2.targetLinks;
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    var y = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (var _i = 0, _a2 = source.sourceLinks; _i < _a2.length; _i++) {
      var _b = _a2[_i], node = _b.target, width = _b.width;
      if (node === target)
        break;
      y += width + py;
    }
    for (var _c = 0, _d = target.targetLinks; _c < _d.length; _c++) {
      var _e = _d[_c], node = _e.source, width = _e.width;
      if (node === source)
        break;
      y -= width;
    }
    return y;
  }
  function sourceTop(source, target) {
    var y = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (var _i = 0, _a2 = target.targetLinks; _i < _a2.length; _i++) {
      var _b = _a2[_i], node = _b.source, width = _b.width;
      if (node === source)
        break;
      y += width + py;
    }
    for (var _c = 0, _d = source.sourceLinks; _c < _d.length; _c++) {
      var _e = _d[_c], node = _e.target, width = _e.width;
      if (node === target)
        break;
      y -= width;
    }
    return y;
  }
  return sankey;
}
var ALIGN_METHOD = {
  left,
  right,
  center,
  justify
};
var DEFAULT_OPTIONS$5 = {
  nodeId: function(node) {
    return node.index;
  },
  nodeAlign: "justify",
  nodeWidth: 8e-3,
  nodePadding: 0.03,
  nodeSort: void 0
};
function getNodeAlignFunction(nodeAlign) {
  var func = isString(nodeAlign) ? ALIGN_METHOD[nodeAlign] : isFunction(nodeAlign) ? nodeAlign : null;
  return func || justify;
}
function getDefaultOptions$1(sankeyLayoutOptions) {
  return mix({}, DEFAULT_OPTIONS$5, sankeyLayoutOptions);
}
function sankeyLayout(sankeyLayoutOptions, data2) {
  var options = getDefaultOptions$1(sankeyLayoutOptions);
  var nodeId = options.nodeId, nodeSort = options.nodeSort, nodeAlign = options.nodeAlign, nodeWidth = options.nodeWidth, nodePadding = options.nodePadding, nodeDepth = options.nodeDepth;
  var sankeyProcessor = Sankey().nodeSort(nodeSort).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeDepth(nodeDepth).nodeAlign(getNodeAlignFunction(nodeAlign)).extent([
    [0, 0],
    [1, 1]
  ]).nodeId(nodeId);
  var layoutData = sankeyProcessor(data2);
  layoutData.nodes.forEach(function(node) {
    var x0 = node.x0, x1 = node.x1, y0 = node.y0, y1 = node.y1;
    node.x = [x0, x1, x1, x0];
    node.y = [y0, y0, y1, y1];
  });
  layoutData.links.forEach(function(edge2) {
    var source = edge2.source, target = edge2.target;
    var sx = source.x1;
    var tx = target.x0;
    edge2.x = [sx, sx, tx, tx];
    var offset = edge2.width / 2;
    edge2.y = [edge2.y0 + offset, edge2.y0 - offset, edge2.y1 + offset, edge2.y1 - offset];
  });
  return layoutData;
}
function getNodes(edges, sourceField, targetField) {
  var nodes = [];
  edges.forEach(function(e) {
    var source = e[sourceField];
    var target = e[targetField];
    if (!nodes.includes(source)) {
      nodes.push(source);
    }
    if (!nodes.includes(target)) {
      nodes.push(target);
    }
  });
  return nodes;
}
function getMatrix(edges, nodes, sourceField, targetField) {
  var graphMatrix = {};
  nodes.forEach(function(pre) {
    graphMatrix[pre] = {};
    nodes.forEach(function(next) {
      graphMatrix[pre][next] = 0;
    });
  });
  edges.forEach(function(edge2) {
    graphMatrix[edge2[sourceField]][edge2[targetField]] = 1;
  });
  return graphMatrix;
}
function cutoffCircle(edges, sourceField, targetField) {
  if (!isArray$1(edges))
    return [];
  var removedData = [];
  var nodes = getNodes(edges, sourceField, targetField);
  var graphMatrix = getMatrix(edges, nodes, sourceField, targetField);
  var visited = {};
  nodes.forEach(function(node) {
    visited[node] = 0;
  });
  function DFS(dfsNode) {
    visited[dfsNode] = 1;
    nodes.forEach(function(node) {
      if (graphMatrix[dfsNode][node] != 0) {
        if (visited[node] == 1) {
          removedData.push(dfsNode + "_" + node);
        } else if (visited[node] == -1) {
          return;
        } else {
          DFS(node);
        }
      }
    });
    visited[dfsNode] = -1;
  }
  nodes.forEach(function(node) {
    if (visited[node] == -1) {
      return;
    }
    DFS(node);
  });
  if (removedData.length !== 0) {
    console.warn("sankey data contains circle, " + removedData.length + " records removed.", removedData);
  }
  return edges.filter(function(edge2) {
    return removedData.findIndex(function(i) {
      return i === edge2[sourceField] + "_" + edge2[targetField];
    }) < 0;
  });
}
function getNodeWidthRatio(nodeWidth, nodeWidthRatio, width) {
  return isRealNumber(nodeWidth) ? nodeWidth / width : nodeWidthRatio;
}
function getNodePaddingRatio(nodePadding, nodePaddingRatio, height) {
  return isRealNumber(nodePadding) ? nodePadding / height : nodePaddingRatio;
}
function transformToViewsData(options, width, height) {
  var data2 = options.data, sourceField = options.sourceField, targetField = options.targetField, weightField = options.weightField, nodeAlign = options.nodeAlign, nodeSort = options.nodeSort, nodePadding = options.nodePadding, nodePaddingRatio = options.nodePaddingRatio, nodeWidth = options.nodeWidth, nodeWidthRatio = options.nodeWidthRatio, nodeDepth = options.nodeDepth, _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2;
  var sankeyLayoutInputData = transformDataToNodeLinkData(cutoffCircle(data2, sourceField, targetField), sourceField, targetField, weightField, rawFields);
  var _b = sankeyLayout({
    nodeAlign,
    nodePadding: getNodePaddingRatio(nodePadding, nodePaddingRatio, height),
    nodeWidth: getNodeWidthRatio(nodeWidth, nodeWidthRatio, width),
    nodeSort,
    nodeDepth
  }, sankeyLayoutInputData), nodes = _b.nodes, links = _b.links;
  return {
    nodes: nodes.map(function(node) {
      return __assign$1(__assign$1({}, pick(node, __spreadArrays(["x", "y", "name"], rawFields))), { isNode: true });
    }),
    edges: links.map(function(link) {
      return __assign$1(__assign$1({ source: link.source.name, target: link.target.name, name: link.source.name || link.target.name }, pick(link, __spreadArrays(["x", "y", "value"], rawFields))), { isNode: false });
    })
  };
}
var X_FIELD$1 = "x";
var Y_FIELD$1 = "y";
var COLOR_FIELD = "name";
var NODES_VIEW_ID = "nodes";
var EDGES_VIEW_ID = "edges";
function defaultOptions$1(params) {
  var options = params.options;
  var _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2;
  return deepAssign({}, {
    options: {
      tooltip: {
        fields: uniq$2(__spreadArrays(["name", "source", "target", "value", "isNode"], rawFields))
      },
      label: {
        fields: uniq$2(__spreadArrays(["x", "name"], rawFields))
      }
    }
  }, params);
}
function geometry$1(params) {
  var chart = params.chart, options = params.options;
  var color2 = options.color, nodeStyle = options.nodeStyle, edgeStyle = options.edgeStyle, label2 = options.label, tooltip2 = options.tooltip, nodeState = options.nodeState, edgeState = options.edgeState;
  chart.legend(false);
  chart.tooltip(tooltip2);
  chart.axis(false);
  chart.coordinate().reflect("y");
  var _a2 = transformToViewsData(options, chart.width, chart.height), nodes = _a2.nodes, edges = _a2.edges;
  var edgeView = chart.createView({ id: EDGES_VIEW_ID });
  edgeView.data(edges);
  edge({
    chart: edgeView,
    options: {
      xField: X_FIELD$1,
      yField: Y_FIELD$1,
      seriesField: COLOR_FIELD,
      edge: {
        color: color2,
        style: edgeStyle,
        shape: "arc"
      },
      tooltip: tooltip2,
      state: edgeState
    }
  });
  var nodeView = chart.createView({ id: NODES_VIEW_ID });
  nodeView.data(nodes);
  polygon({
    chart: nodeView,
    options: {
      xField: X_FIELD$1,
      yField: Y_FIELD$1,
      seriesField: COLOR_FIELD,
      polygon: {
        color: color2,
        style: nodeStyle
      },
      label: label2,
      tooltip: tooltip2,
      state: nodeState
    }
  });
  chart.interaction("element-active");
  chart.scale({
    x: { sync: true, nice: true, min: 0, max: 1, minLimit: 0, maxLimit: 1 },
    y: { sync: true, nice: true, min: 0, max: 1, minLimit: 0, maxLimit: 1 },
    name: { sync: "color", type: "cat" }
  });
  return params;
}
function animation$1(params) {
  var chart = params.chart, options = params.options;
  var animation2 = options.animation;
  if (typeof animation2 === "boolean") {
    chart.animate(animation2);
  } else {
    chart.animate(true);
  }
  var geometries = __spreadArrays(chart.views[0].geometries, chart.views[1].geometries);
  geometries.forEach(function(g) {
    g.animate(animation2);
  });
  return params;
}
function nodeDraggable(params) {
  var chart = params.chart, options = params.options;
  var nodeDraggable2 = options.nodeDraggable;
  var DRAG_INTERACTION = "sankey-node-draggable";
  if (nodeDraggable2) {
    chart.interaction(DRAG_INTERACTION);
  } else {
    chart.removeInteraction(DRAG_INTERACTION);
  }
  return params;
}
function adaptor$4(params) {
  return flow(defaultOptions$1, geometry$1, interaction$6, nodeDraggable, animation$1, theme$2)(params);
}
var SankeyNodeDragAction = function(_super) {
  __extends$2(SankeyNodeDragAction2, _super);
  function SankeyNodeDragAction2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.isDragging = false;
    return _this;
  }
  SankeyNodeDragAction2.prototype.isNodeElement = function() {
    var shape = get(this.context, "event.target");
    if (shape) {
      var element = shape.get("element");
      return element && element.getModel().data.isNode;
    }
    return false;
  };
  SankeyNodeDragAction2.prototype.getNodeView = function() {
    return findViewById(this.context.view, NODES_VIEW_ID);
  };
  SankeyNodeDragAction2.prototype.getEdgeView = function() {
    return findViewById(this.context.view, EDGES_VIEW_ID);
  };
  SankeyNodeDragAction2.prototype.getCurrentDatumIdx = function(element) {
    return this.getNodeView().geometries[0].elements.indexOf(element);
  };
  SankeyNodeDragAction2.prototype.start = function() {
    if (this.isNodeElement()) {
      this.prevPoint = {
        x: get(this.context, "event.x"),
        y: get(this.context, "event.y")
      };
      var element = this.context.event.target.get("element");
      var idx = this.getCurrentDatumIdx(element);
      if (idx === -1) {
        return;
      }
      this.currentElementIdx = idx;
      this.context.isDragging = true;
      this.isDragging = true;
      this.prevNodeAnimateCfg = this.getNodeView().getOptions().animate;
      this.prevEdgeAnimateCfg = this.getEdgeView().getOptions().animate;
      this.getNodeView().animate(false);
      this.getEdgeView().animate(false);
    }
  };
  SankeyNodeDragAction2.prototype.translate = function() {
    if (this.isDragging) {
      var chart = this.context.view;
      var currentPoint = {
        x: get(this.context, "event.x"),
        y: get(this.context, "event.y")
      };
      var x = currentPoint.x - this.prevPoint.x;
      var y = currentPoint.y - this.prevPoint.y;
      var nodeView = this.getNodeView();
      var element = nodeView.geometries[0].elements[this.currentElementIdx];
      if (element && element.getModel()) {
        var prevDatum = element.getModel().data;
        var data2 = nodeView.getOptions().data;
        var coordinate2 = nodeView.getCoordinate();
        var datumGap_1 = {
          x: x / coordinate2.getWidth(),
          y: y / coordinate2.getHeight()
        };
        var nextDatum = __assign$1(__assign$1({}, prevDatum), { x: prevDatum.x.map(function(x2) {
          return x2 += datumGap_1.x;
        }), y: prevDatum.y.map(function(y2) {
          return y2 += datumGap_1.y;
        }) });
        var newData = __spreadArrays(data2);
        newData[this.currentElementIdx] = nextDatum;
        nodeView.data(newData);
        var name_1 = prevDatum.name;
        var edgeView = this.getEdgeView();
        var edgeData = edgeView.getOptions().data;
        edgeData.forEach(function(datum) {
          if (datum.source === name_1) {
            datum.x[0] += datumGap_1.x;
            datum.x[1] += datumGap_1.x;
            datum.y[0] += datumGap_1.y;
            datum.y[1] += datumGap_1.y;
          }
          if (datum.target === name_1) {
            datum.x[2] += datumGap_1.x;
            datum.x[3] += datumGap_1.x;
            datum.y[2] += datumGap_1.y;
            datum.y[3] += datumGap_1.y;
          }
        });
        edgeView.data(edgeData);
        this.prevPoint = currentPoint;
        chart.render(true);
      }
    }
  };
  SankeyNodeDragAction2.prototype.end = function() {
    this.isDragging = false;
    this.context.isDragging = false;
    this.prevPoint = null;
    this.currentElementIdx = null;
    this.getNodeView().animate(this.prevNodeAnimateCfg);
    this.getEdgeView().animate(this.prevEdgeAnimateCfg);
  };
  return SankeyNodeDragAction2;
}(Action);
registerAction("sankey-node-drag", SankeyNodeDragAction);
registerInteraction("sankey-node-draggable", {
  showEnable: [
    { trigger: "polygon:mouseenter", action: "cursor:pointer" },
    { trigger: "polygon:mouseleave", action: "cursor:default" }
  ],
  start: [{ trigger: "polygon:mousedown", action: "sankey-node-drag:start" }],
  processing: [
    { trigger: "plot:mousemove", action: "sankey-node-drag:translate" },
    { isEnable: function(context) {
      return context.isDragging;
    }, trigger: "plot:mousemove", action: "cursor:move" }
  ],
  end: [{ trigger: "plot:mouseup", action: "sankey-node-drag:end" }]
});
(function(_super) {
  __extends$2(Sankey2, _super);
  function Sankey2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "sankey";
    return _this;
  }
  Sankey2.getDefaultOptions = function() {
    return {
      appendPadding: 8,
      syncViewPadding: true,
      nodeStyle: {
        opacity: 1,
        fillOpacity: 1,
        lineWidth: 1
      },
      edgeStyle: {
        opacity: 0.3,
        lineWidth: 0
      },
      edgeState: {
        active: {
          style: {
            opacity: 0.8,
            lineWidth: 0
          }
        }
      },
      label: {
        formatter: function(_a2) {
          var name = _a2.name;
          return name;
        },
        callback: function(x) {
          var isLast = x[1] === 1;
          return {
            style: {
              fill: "#545454",
              textAlign: isLast ? "end" : "start"
            },
            offsetX: isLast ? -8 : 8
          };
        },
        layout: [
          {
            type: "hide-overlap"
          }
        ]
      },
      tooltip: {
        showTitle: false,
        showMarkers: false,
        shared: false,
        showContent: function(items) {
          return !get(items, [0, "data", "isNode"]);
        },
        formatter: function(datum) {
          var source = datum.source, target = datum.target, value2 = datum.value;
          return {
            name: source + " -> " + target,
            value: value2
          };
        }
      },
      nodeWidthRatio: 8e-3,
      nodePaddingRatio: 0.01,
      animation: {
        appear: {
          animation: "wave-in"
        },
        enter: {
          animation: "wave-in"
        }
      }
    };
  };
  Sankey2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = transformToViewsData(this.options, this.chart.width, this.chart.height), nodes = _a2.nodes, edges = _a2.edges;
    var nodesView = findViewById(this.chart, NODES_VIEW_ID);
    var edgesView = findViewById(this.chart, EDGES_VIEW_ID);
    nodesView.changeData(nodes);
    edgesView.changeData(edges);
  };
  Sankey2.prototype.getSchemaAdaptor = function() {
    return adaptor$4;
  };
  Sankey2.prototype.getDefaultOptions = function() {
    return Sankey2.getDefaultOptions();
  };
  return Sankey2;
})(Plot);
var DEFAULT_OPTIONS$4 = {
  y: 0,
  nodeWidthRatio: 0.05,
  weight: false,
  nodePaddingRatio: 0.1,
  id: function(node) {
    return node.id;
  },
  source: function(edge2) {
    return edge2.source;
  },
  target: function(edge2) {
    return edge2.target;
  },
  sourceWeight: function(edge2) {
    return edge2.value || 1;
  },
  targetWeight: function(edge2) {
    return edge2.value || 1;
  },
  sortBy: null
};
function processGraph(nodeById, edges, options) {
  each$1(nodeById, function(node, id) {
    node.inEdges = edges.filter(function(edge2) {
      return "" + options.target(edge2) === "" + id;
    });
    node.outEdges = edges.filter(function(edge2) {
      return "" + options.source(edge2) === "" + id;
    });
    node.edges = node.outEdges.concat(node.inEdges);
    node.frequency = node.edges.length;
    node.value = 0;
    node.inEdges.forEach(function(edge2) {
      node.value += options.targetWeight(edge2);
    });
    node.outEdges.forEach(function(edge2) {
      node.value += options.sourceWeight(edge2);
    });
  });
}
function sortNodes(nodes, options) {
  var sortMethods = {
    weight: function(a, b) {
      return b.value - a.value;
    },
    frequency: function(a, b) {
      return b.frequency - a.frequency;
    },
    id: function(a, b) {
      return ("" + options.id(a)).localeCompare("" + options.id(b));
    }
  };
  var method = sortMethods[options.sortBy];
  if (!method && isFunction(options.sortBy)) {
    method = options.sortBy;
  }
  if (method) {
    nodes.sort(method);
  }
}
function layoutNodes(nodes, options) {
  var len = nodes.length;
  if (!len) {
    throw new TypeError("Invalid nodes: it's empty!");
  }
  if (options.weight) {
    var nodePaddingRatio_1 = options.nodePaddingRatio;
    if (nodePaddingRatio_1 < 0 || nodePaddingRatio_1 >= 1) {
      throw new TypeError("Invalid nodePaddingRatio: it must be in range [0, 1)!");
    }
    var margin_1 = nodePaddingRatio_1 / (2 * len);
    var nodeWidthRatio_1 = options.nodeWidthRatio;
    if (nodeWidthRatio_1 <= 0 || nodeWidthRatio_1 >= 1) {
      throw new TypeError("Invalid nodeWidthRatio: it must be in range (0, 1)!");
    }
    var totalValue_1 = 0;
    nodes.forEach(function(node) {
      totalValue_1 += node.value;
    });
    nodes.forEach(function(node) {
      node.weight = node.value / totalValue_1;
      node.width = node.weight * (1 - nodePaddingRatio_1);
      node.height = nodeWidthRatio_1;
    });
    nodes.forEach(function(node, index2) {
      var deltaX = 0;
      for (var i = index2 - 1; i >= 0; i--) {
        deltaX += nodes[i].width + 2 * margin_1;
      }
      var minX = node.minX = margin_1 + deltaX;
      var maxX = node.maxX = node.minX + node.width;
      var minY = node.minY = options.y - nodeWidthRatio_1 / 2;
      var maxY = node.maxY = minY + nodeWidthRatio_1;
      node.x = [minX, maxX, maxX, minX];
      node.y = [minY, minY, maxY, maxY];
    });
  } else {
    var deltaX_1 = 1 / len;
    nodes.forEach(function(node, index2) {
      node.x = (index2 + 0.5) * deltaX_1;
      node.y = options.y;
    });
  }
  return nodes;
}
function locatingEdges(nodeById, edges, options) {
  if (options.weight) {
    var valueById_1 = {};
    each$1(nodeById, function(node, id) {
      valueById_1[id] = node.value;
    });
    edges.forEach(function(edge2) {
      var sId = options.source(edge2);
      var tId = options.target(edge2);
      var sNode = nodeById[sId];
      var tNode = nodeById[tId];
      if (sNode && tNode) {
        var sValue = valueById_1[sId];
        var currentSValue = options.sourceWeight(edge2);
        var sStart = sNode.minX + (sNode.value - sValue) / sNode.value * sNode.width;
        var sEnd = sStart + currentSValue / sNode.value * sNode.width;
        valueById_1[sId] -= currentSValue;
        var tValue = valueById_1[tId];
        var currentTValue = options.targetWeight(edge2);
        var tStart = tNode.minX + (tNode.value - tValue) / tNode.value * tNode.width;
        var tEnd = tStart + currentTValue / tNode.value * tNode.width;
        valueById_1[tId] -= currentTValue;
        var y = options.y;
        edge2.x = [sStart, sEnd, tStart, tEnd];
        edge2.y = [y, y, y, y];
        edge2.source = sNode;
        edge2.target = tNode;
      }
    });
  } else {
    edges.forEach(function(edge2) {
      var sNode = nodeById[options.source(edge2)];
      var tNode = nodeById[options.target(edge2)];
      if (sNode && tNode) {
        edge2.x = [sNode.x, tNode.x];
        edge2.y = [sNode.y, tNode.y];
        edge2.source = sNode;
        edge2.target = tNode;
      }
    });
  }
  return edges;
}
function getDefaultOptions(options) {
  return mix({}, DEFAULT_OPTIONS$4, options);
}
function chordLayout(chordLayoutOptions, chordLayoutInputData) {
  var options = getDefaultOptions(chordLayoutOptions);
  var nodeById = {};
  var nodes = chordLayoutInputData.nodes;
  var links = chordLayoutInputData.links;
  nodes.forEach(function(node) {
    var id = options.id(node);
    nodeById[id] = node;
  });
  processGraph(nodeById, links, options);
  sortNodes(nodes, options);
  var outputNodes = layoutNodes(nodes, options);
  var outputLinks = locatingEdges(nodeById, links, options);
  return {
    nodes: outputNodes,
    links: outputLinks
  };
}
var X_FIELD = "x";
var Y_FIELD = "y";
var NODE_COLOR_FIELD = "name";
var EDGE_COLOR_FIELD = "source";
var DEFAULT_OPTIONS$3 = {
  nodeStyle: {
    opacity: 1,
    fillOpacity: 1,
    lineWidth: 1
  },
  edgeStyle: {
    opacity: 0.5,
    lineWidth: 2
  },
  label: {
    fields: ["x", "name"],
    callback: function(x, name) {
      var centerX = (x[0] + x[1]) / 2;
      var offsetX = centerX > 0.5 ? -4 : 4;
      return {
        labelEmit: true,
        style: {
          fill: "#8c8c8c"
        },
        offsetX,
        content: name
      };
    }
  },
  tooltip: {
    showTitle: false,
    showMarkers: false,
    fields: ["source", "target", "value", "isNode"],
    showContent: function(items) {
      return !get(items, [0, "data", "isNode"]);
    },
    formatter: function(datum) {
      var source = datum.source, target = datum.target, value2 = datum.value;
      return {
        name: source + " -> " + target,
        value: value2
      };
    }
  },
  interactions: [
    {
      type: "element-active"
    }
  ],
  weight: true,
  nodePaddingRatio: 0.1,
  nodeWidthRatio: 0.05
};
function transformData$1(params) {
  var options = params.options;
  var data2 = options.data, sourceField = options.sourceField, targetField = options.targetField, weightField = options.weightField, nodePaddingRatio = options.nodePaddingRatio, nodeWidthRatio = options.nodeWidthRatio, _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2;
  var chordLayoutInputData = transformDataToNodeLinkData(data2, sourceField, targetField, weightField);
  var _b = chordLayout({ weight: true, nodePaddingRatio, nodeWidthRatio }, chordLayoutInputData), nodes = _b.nodes, links = _b.links;
  var nodesData = nodes.map(function(node) {
    return __assign$1(__assign$1({}, pick(node, __spreadArrays(["id", "x", "y", "name"], rawFields))), { isNode: true });
  });
  var edgesData = links.map(function(link) {
    return __assign$1(__assign$1({ source: link.source.name, target: link.target.name, name: link.source.name || link.target.name }, pick(link, __spreadArrays(["x", "y", "value"], rawFields))), { isNode: false });
  });
  return __assign$1(__assign$1({}, params), { ext: __assign$1(__assign$1({}, params.ext), {
    chordData: { nodesData, edgesData }
  }) });
}
function scale(params) {
  var _a2;
  var chart = params.chart;
  chart.scale((_a2 = {
    x: { sync: true, nice: true },
    y: { sync: true, nice: true, max: 1 }
  }, _a2[NODE_COLOR_FIELD] = { sync: "color" }, _a2[EDGE_COLOR_FIELD] = { sync: "color" }, _a2));
  return params;
}
function axis$1(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function legend(params) {
  var chart = params.chart;
  chart.legend(false);
  return params;
}
function tooltip$1(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  chart.tooltip(tooltip2);
  return params;
}
function coordinate(params) {
  var chart = params.chart;
  chart.coordinate("polar").reflect("y");
  return params;
}
function nodeGeometry(params) {
  var chart = params.chart, options = params.options;
  var nodesData = params.ext.chordData.nodesData;
  var nodeStyle = options.nodeStyle, label2 = options.label, tooltip2 = options.tooltip;
  var nodeView = chart.createView();
  nodeView.data(nodesData);
  polygon({
    chart: nodeView,
    options: {
      xField: X_FIELD,
      yField: Y_FIELD,
      seriesField: NODE_COLOR_FIELD,
      polygon: {
        style: nodeStyle
      },
      label: label2,
      tooltip: tooltip2
    }
  });
  return params;
}
function edgeGeometry(params) {
  var chart = params.chart, options = params.options;
  var edgesData = params.ext.chordData.edgesData;
  var edgeStyle = options.edgeStyle, tooltip2 = options.tooltip;
  var edgeView = chart.createView();
  edgeView.data(edgesData);
  var edgeOptions = {
    xField: X_FIELD,
    yField: Y_FIELD,
    seriesField: EDGE_COLOR_FIELD,
    edge: {
      style: edgeStyle,
      shape: "arc"
    },
    tooltip: tooltip2
  };
  edge({
    chart: edgeView,
    options: edgeOptions
  });
  return params;
}
function animation(params) {
  var chart = params.chart, options = params.options;
  var animation2 = options.animation;
  if (typeof animation2 === "boolean") {
    chart.animate(animation2);
  } else {
    chart.animate(true);
  }
  each$1(getAllGeometriesRecursively(chart), function(g) {
    g.animate(animation2);
  });
  return params;
}
function adaptor$3(params) {
  return flow(theme$2, transformData$1, coordinate, scale, axis$1, legend, tooltip$1, edgeGeometry, nodeGeometry, interaction$6, state, animation)(params);
}
(function(_super) {
  __extends$2(Chord, _super);
  function Chord() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "chord";
    return _this;
  }
  Chord.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$3;
  };
  Chord.prototype.getDefaultOptions = function() {
    return Chord.getDefaultOptions();
  };
  Chord.prototype.getSchemaAdaptor = function() {
    return adaptor$3;
  };
  return Chord;
})(Plot);
var DEFAULT_OPTIONS$2 = {
  field: "value",
  as: ["x", "y", "r"],
  sort: function(a, b) {
    return b.value - a.value;
  }
};
function pack(data2, options) {
  options = mix({}, DEFAULT_OPTIONS$2, options);
  var as = options.as;
  if (!isArray$1(as) || as.length !== 3) {
    throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ "x", "y", "r" ])!');
  }
  var field2;
  try {
    field2 = getField(options);
  } catch (e) {
    console.warn(e);
  }
  var packLayout = function(data3) {
    return index$1().size(options.size).padding(options.padding)(hierarchy(data3).sum(function(d) {
      return d[field2];
    }).sort(options.sort));
  };
  var root = packLayout(data2);
  var x = as[0];
  var y = as[1];
  var r = as[2];
  root.each(function(node) {
    node[x] = node.x;
    node[y] = node.y;
    node[r] = node.r;
  });
  return getAllNodes(root);
}
function transformData(options) {
  var data2 = options.data, hierarchyConfig = options.hierarchyConfig, _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2, enableDrillDown = options.enableDrillDown;
  var nodes = pack(data2, __assign$1(__assign$1({}, hierarchyConfig), { field: "value", as: ["x", "y", "r"] }));
  var result = [];
  nodes.forEach(function(node) {
    var _a3;
    var path2 = node.data.name;
    var ancestorNode = __assign$1({}, node);
    while (ancestorNode.depth > 1) {
      path2 = ((_a3 = ancestorNode.parent.data) === null || _a3 === void 0 ? void 0 : _a3.name) + " / " + path2;
      ancestorNode = ancestorNode.parent;
    }
    if (enableDrillDown && node.depth > 2) {
      return null;
    }
    var nodeInfo = deepAssign({}, node.data, __assign$1(__assign$1(__assign$1({}, pick(node.data, rawFields)), { path: path2 }), node));
    nodeInfo.ext = hierarchyConfig;
    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig, rawFields, enableDrillDown };
    result.push(nodeInfo);
  });
  return result;
}
function resolvePaddingForCircle(padding2, appendPadding, containerSize) {
  var tempPadding = resolveAllPadding([padding2, appendPadding]);
  var top = tempPadding[0], right2 = tempPadding[1], bottom = tempPadding[2], left2 = tempPadding[3];
  var width = containerSize.width, height = containerSize.height;
  var wSize = width - (left2 + right2);
  var hSize = height - (top + bottom);
  var minSize = Math.min(wSize, hSize);
  var restWidthPadding = (wSize - minSize) / 2;
  var restHeightPadding = (hSize - minSize) / 2;
  var finalTop = top + restHeightPadding;
  var finalRight = right2 + restWidthPadding;
  var finalBottom = bottom + restHeightPadding;
  var finalLeft = left2 + restWidthPadding;
  var finalPadding = [finalTop, finalRight, finalBottom, finalLeft];
  var finalSize = minSize < 0 ? 0 : minSize;
  return { finalPadding, finalSize };
}
var RAW_FIELDS = ["x", "y", "r", "name", "value", "path", "depth"];
var DEFAULT_OPTIONS$1 = {
  colorField: "name",
  autoFit: true,
  pointStyle: {
    lineWidth: 0,
    stroke: "#fff"
  },
  legend: false,
  hierarchyConfig: {
    size: [1, 1],
    padding: 0
  },
  label: {
    fields: ["name"],
    layout: {
      type: "limit-in-shape"
    }
  },
  tooltip: {
    showMarkers: false,
    showTitle: false
  },
  drilldown: { enabled: false }
};
function defaultOptions(params) {
  var chart = params.chart;
  var diameter = Math.min(chart.viewBBox.width, chart.viewBBox.height);
  return deepAssign({
    options: {
      size: function(_a2) {
        var r = _a2.r;
        return r * diameter;
      }
    }
  }, params);
}
function padding(params) {
  var options = params.options, chart = params.chart;
  var containerSize = chart.viewBBox;
  var padding2 = options.padding, appendPadding = options.appendPadding, drilldown = options.drilldown;
  var tempAppendPadding = appendPadding;
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    var appendPaddingByDrilldown = getAdjustAppendPadding(chart.appendPadding, get(drilldown, ["breadCrumb", "position"]));
    tempAppendPadding = resolveAllPadding([appendPaddingByDrilldown, appendPadding]);
  }
  var finalPadding = resolvePaddingForCircle(padding2, tempAppendPadding, containerSize).finalPadding;
  chart.padding = finalPadding;
  chart.appendPadding = 0;
  return params;
}
function geometry(params) {
  var chart = params.chart, options = params.options;
  var padding2 = chart.padding, appendPadding = chart.appendPadding;
  var color2 = options.color, colorField = options.colorField, pointStyle = options.pointStyle, hierarchyConfig = options.hierarchyConfig, sizeField = options.sizeField, _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2, drilldown = options.drilldown;
  var data2 = transformData({
    data: options.data,
    hierarchyConfig,
    enableDrillDown: drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled,
    rawFields
  });
  chart.data(data2);
  var containerSize = chart.viewBBox;
  var finalSize = resolvePaddingForCircle(padding2, appendPadding, containerSize).finalSize;
  var circleSize = function(_a3) {
    var r = _a3.r;
    return r * finalSize;
  };
  if (sizeField) {
    circleSize = function(d) {
      return d[sizeField] * finalSize;
    };
  }
  point(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField,
      sizeField,
      rawFields: __spreadArrays(RAW_FIELDS, rawFields),
      point: {
        color: color2,
        style: pointStyle,
        shape: "circle",
        size: circleSize
      }
    }
  }));
  return params;
}
function meta(params) {
  return flow(scale$1({}, {
    x: { min: 0, max: 1, minLimit: 0, maxLimit: 1, nice: true },
    y: { min: 0, max: 1, minLimit: 0, maxLimit: 1, nice: true }
  }))(params);
}
function tooltip(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2 === false) {
    chart.tooltip(false);
  } else {
    var tooltipOptions = tooltip2;
    if (!get(tooltip2, "fields")) {
      tooltipOptions = deepAssign({}, {
        customItems: function(items) {
          return items.map(function(item) {
            var scales = get(chart.getOptions(), "scales");
            var nameFormatter = get(scales, ["name", "formatter"], function(v) {
              return v;
            });
            var valueFormatter = get(scales, ["value", "formatter"], function(v) {
              return v;
            });
            return __assign$1(__assign$1({}, item), { name: nameFormatter(item.data.name), value: valueFormatter(item.data.value) });
          });
        }
      }, tooltipOptions);
    }
    chart.tooltip(tooltipOptions);
  }
  return params;
}
function axis(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function adaptorInteraction(options) {
  var drilldown = options.drilldown, _a2 = options.interactions, interactions = _a2 === void 0 ? [] : _a2;
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    return deepAssign({}, options, {
      interactions: __spreadArrays(interactions, [
        {
          type: "drill-down",
          cfg: { drillDownConfig: drilldown, transformData, enableDrillDown: true }
        }
      ])
    });
  }
  return options;
}
function interaction(params) {
  var chart = params.chart, options = params.options;
  interaction$6({
    chart,
    options: adaptorInteraction(options)
  });
  return params;
}
function adaptor$2(params) {
  return flow(pattern("pointStyle"), defaultOptions, padding, theme$2, meta, geometry, axis, legend$g, tooltip, interaction, animation$5, annotation$2())(params);
}
(function(_super) {
  __extends$2(CirclePacking, _super);
  function CirclePacking() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "circle-packing";
    return _this;
  }
  CirclePacking.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$1;
  };
  CirclePacking.prototype.getDefaultOptions = function() {
    return CirclePacking.getDefaultOptions();
  };
  CirclePacking.prototype.getSchemaAdaptor = function() {
    return adaptor$2;
  };
  CirclePacking.prototype.triggerResize = function() {
    if (!this.chart.destroyed) {
      this.chart.forceFit();
      this.chart.clear();
      this.execAdaptor();
      this.chart.render(true);
    }
  };
  return CirclePacking;
})(Plot);
(function(_super) {
  __extends$2(P, _super);
  function P(container, options, adaptor2, defaultOptions2) {
    var _this = _super.call(this, container, deepAssign({}, defaultOptions2, options)) || this;
    _this.type = "g2-plot";
    _this.defaultOptions = defaultOptions2;
    _this.adaptor = adaptor2;
    return _this;
  }
  P.prototype.getDefaultOptions = function() {
    return this.defaultOptions;
  };
  P.prototype.getSchemaAdaptor = function() {
    return this.adaptor;
  };
  return P;
})(Plot);
var PLOT_ADAPTORS = {
  line: adaptor$y,
  pie: adaptor$u,
  column: adaptor$w,
  bar: adaptor$v,
  area: adaptor$x,
  gauge: adaptor$9,
  "tiny-line": adaptor$n,
  "tiny-column": adaptor$m,
  "tiny-area": adaptor$o,
  "ring-progress": adaptor$j,
  progress: adaptor$k,
  scatter: adaptor$r,
  histogram: adaptor$l,
  funnel: adaptor$d
};
var PLOT_CONSTRUCTOR = {
  line: Line,
  pie: Pie,
  column: Column,
  bar: Bar,
  area: Area,
  gauge: Gauge,
  "tiny-line": TinyLine,
  "tiny-column": TinyColumn,
  "tiny-area": TinyArea,
  "ring-progress": RingProgress,
  progress: Progress,
  scatter: Scatter,
  histogram: Histogram,
  funnel: Funnel
};
var DEFAULT_OPTIONS_MAP = {
  pie: { label: false },
  column: { tooltip: { showMarkers: false } },
  bar: { tooltip: { showMarkers: false } }
};
function execPlotAdaptor(plot, view, options) {
  var cls = PLOT_CONSTRUCTOR[plot];
  if (!cls) {
    console.error("could not find " + plot + " plot");
    return;
  }
  var module = PLOT_ADAPTORS[plot];
  module({
    chart: view,
    options: deepAssign({}, cls.getDefaultOptions(), get(DEFAULT_OPTIONS_MAP, plot, {}), options)
  });
}
function multiView(params) {
  var chart = params.chart, options = params.options;
  var views = options.views, legend2 = options.legend;
  each$1(views, function(v) {
    var region = v.region, data2 = v.data, meta2 = v.meta, axes = v.axes, coordinate2 = v.coordinate, interactions = v.interactions, annotations = v.annotations, tooltip2 = v.tooltip, geometries = v.geometries;
    var viewOfG2 = chart.createView({
      region
    });
    viewOfG2.data(data2);
    var scales = {};
    if (axes) {
      each$1(axes, function(axis2, field2) {
        scales[field2] = pick(axis2, AXIS_META_CONFIG_KEYS);
      });
    }
    scales = deepAssign({}, meta2, scales);
    viewOfG2.scale(scales);
    if (!axes) {
      viewOfG2.axis(false);
    } else {
      each$1(axes, function(axis2, field2) {
        viewOfG2.axis(field2, axis2);
      });
    }
    viewOfG2.coordinate(coordinate2);
    each$1(geometries, function(geometry2) {
      var ext = geometry$w({
        chart: viewOfG2,
        options: geometry2
      }).ext;
      var adjust2 = geometry2.adjust;
      if (adjust2) {
        ext.geometry.adjust(adjust2);
      }
    });
    each$1(interactions, function(interaction2) {
      if (interaction2.enable === false) {
        viewOfG2.removeInteraction(interaction2.type);
      } else {
        viewOfG2.interaction(interaction2.type, interaction2.cfg);
      }
    });
    each$1(annotations, function(annotation2) {
      viewOfG2.annotation()[annotation2.type](__assign$1({}, annotation2));
    });
    if (typeof v.animation === "boolean") {
      viewOfG2.animate(false);
    } else {
      viewOfG2.animate(true);
      each$1(viewOfG2.geometries, function(g) {
        g.animate(v.animation);
      });
    }
    if (tooltip2) {
      viewOfG2.interaction("tooltip");
      viewOfG2.tooltip(tooltip2);
    }
  });
  if (!legend2) {
    chart.legend(false);
  } else {
    each$1(legend2, function(l, field2) {
      chart.legend(field2, l);
    });
  }
  chart.tooltip(options.tooltip);
  return params;
}
function multiPlot(params) {
  var chart = params.chart, options = params.options;
  var plots = options.plots;
  each$1(plots, function(plot) {
    var type = plot.type, region = plot.region, _a2 = plot.options, options2 = _a2 === void 0 ? {} : _a2;
    var tooltip2 = options2.tooltip;
    var viewOfG2 = chart.createView(__assign$1({ region }, pick(options2, PLOT_CONTAINER_OPTIONS)));
    if (tooltip2) {
      viewOfG2.interaction("tooltip");
    }
    execPlotAdaptor(type, viewOfG2, options2);
  });
  return params;
}
function adaptor$1(params) {
  return flow(animation$5, multiView, multiPlot, interaction$6, animation$5, theme$2, tooltip$8)(params);
}
function getElementValue(element, field2) {
  var model = element.getModel();
  var record = model.data;
  var value2;
  if (isArray$1(record)) {
    value2 = record[0][field2];
  } else {
    value2 = record[field2];
  }
  return value2;
}
function clearHighlight(view) {
  var elements = getAllElements(view);
  each$1(elements, function(el) {
    if (el.hasState("active")) {
      el.setState("active", false);
    }
    if (el.hasState("selected")) {
      el.setState("selected", false);
    }
    if (el.hasState("inactive")) {
      el.setState("inactive", false);
    }
  });
}
var Association = function(_super) {
  __extends$2(Association2, _super);
  function Association2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Association2.prototype.getAssociationItems = function(views, params) {
    var _a2;
    var event = this.context.event;
    var _b = params || {}, linkField = _b.linkField, dim = _b.dim;
    var items = [];
    if ((_a2 = event.data) === null || _a2 === void 0 ? void 0 : _a2.data) {
      var data_1 = event.data.data;
      each$1(views, function(v) {
        var _a3, _b2;
        var field2 = linkField;
        if (dim === "x") {
          field2 = v.getXScale().field;
        } else if (dim === "y") {
          field2 = (_a3 = v.getYScales().find(function(s) {
            return s.field === field2;
          })) === null || _a3 === void 0 ? void 0 : _a3.field;
        } else if (!field2) {
          field2 = (_b2 = v.getGroupScales()[0]) === null || _b2 === void 0 ? void 0 : _b2.field;
        }
        if (!field2) {
          return;
        }
        var elements = map$2(getAllElements(v), function(ele) {
          var active = false;
          var inactive = false;
          var dataValue = isArray$1(data_1) ? get(data_1[0], field2) : get(data_1, field2);
          if (getElementValue(ele, field2) === dataValue) {
            active = true;
          } else {
            inactive = true;
          }
          return { element: ele, view: v, active, inactive };
        });
        items.push.apply(items, elements);
      });
    }
    return items;
  };
  Association2.prototype.showTooltip = function(params) {
    var siblings = getSiblingViews(this.context.view);
    var elements = this.getAssociationItems(siblings, params);
    each$1(elements, function(ele) {
      if (ele.active) {
        var box2 = ele.element.shape.getCanvasBBox();
        ele.view.showTooltip({ x: box2.minX + box2.width / 2, y: box2.minY + box2.height / 2 });
      }
    });
  };
  Association2.prototype.hideTooltip = function() {
    var siblings = getSiblingViews(this.context.view);
    each$1(siblings, function(sibling) {
      sibling.hideTooltip();
    });
  };
  Association2.prototype.active = function(params) {
    var views = getViews(this.context.view);
    var items = this.getAssociationItems(views, params);
    each$1(items, function(item) {
      var active = item.active, element = item.element;
      if (active) {
        element.setState("active", true);
      }
    });
  };
  Association2.prototype.selected = function(params) {
    var views = getViews(this.context.view);
    var items = this.getAssociationItems(views, params);
    each$1(items, function(item) {
      var active = item.active, element = item.element;
      if (active) {
        element.setState("selected", true);
      }
    });
  };
  Association2.prototype.highlight = function(params) {
    var views = getViews(this.context.view);
    var items = this.getAssociationItems(views, params);
    each$1(items, function(item) {
      var inactive = item.inactive, element = item.element;
      if (inactive) {
        element.setState("inactive", true);
      }
    });
  };
  Association2.prototype.reset = function() {
    var views = getViews(this.context.view);
    each$1(views, function(v) {
      clearHighlight(v);
    });
  };
  return Association2;
}(Action);
registerAction("association", Association);
registerInteraction("association-active", {
  start: [{ trigger: "element:mouseenter", action: "association:active" }],
  end: [{ trigger: "element:mouseleave", action: "association:reset" }]
});
registerInteraction("association-selected", {
  start: [{ trigger: "element:mouseenter", action: "association:selected" }],
  end: [{ trigger: "element:mouseleave", action: "association:reset" }]
});
registerInteraction("association-highlight", {
  start: [{ trigger: "element:mouseenter", action: "association:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "association:reset" }]
});
registerInteraction("association-tooltip", {
  start: [{ trigger: "element:mousemove", action: "association:showTooltip" }],
  end: [{ trigger: "element:mouseleave", action: "association:hideTooltip" }]
});
var Mix = function(_super) {
  __extends$2(Mix2, _super);
  function Mix2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "mix";
    return _this;
  }
  Mix2.prototype.getSchemaAdaptor = function() {
    return adaptor$1;
  };
  return Mix2;
}(Plot);
function execViewAdaptor(viewOfG2, options) {
  var data2 = options.data, coordinate2 = options.coordinate, interactions = options.interactions, annotations = options.annotations, animation2 = options.animation, tooltip2 = options.tooltip, axes = options.axes, meta2 = options.meta, geometries = options.geometries;
  if (data2) {
    viewOfG2.data(data2);
  }
  var scales = {};
  if (axes) {
    each$1(axes, function(axis2, field2) {
      scales[field2] = pick(axis2, AXIS_META_CONFIG_KEYS);
    });
  }
  scales = deepAssign({}, meta2, scales);
  viewOfG2.scale(scales);
  if (coordinate2) {
    viewOfG2.coordinate(coordinate2);
  }
  if (axes === false) {
    viewOfG2.axis(false);
  } else {
    each$1(axes, function(axis2, field2) {
      viewOfG2.axis(field2, axis2);
    });
  }
  each$1(geometries, function(geometry2) {
    var ext = geometry$w({
      chart: viewOfG2,
      options: geometry2
    }).ext;
    var adjust2 = geometry2.adjust;
    if (adjust2) {
      ext.geometry.adjust(adjust2);
    }
  });
  each$1(interactions, function(interaction2) {
    if (interaction2.enable === false) {
      viewOfG2.removeInteraction(interaction2.type);
    } else {
      viewOfG2.interaction(interaction2.type, interaction2.cfg);
    }
  });
  each$1(annotations, function(annotation2) {
    viewOfG2.annotation()[annotation2.type](__assign$1({}, annotation2));
  });
  if (typeof animation2 === "boolean") {
    viewOfG2.animate(false);
  } else {
    viewOfG2.animate(true);
    each$1(viewOfG2.geometries, function(g) {
      g.animate(animation2);
    });
  }
  if (tooltip2) {
    viewOfG2.interaction("tooltip");
    viewOfG2.tooltip(tooltip2);
  } else if (tooltip2 === false) {
    viewOfG2.removeInteraction("tooltip");
  }
}
function facetAdaptor(params) {
  var chart = params.chart, options = params.options;
  var facetType = options.type, data2 = options.data, fields = options.fields, eachView = options.eachView;
  var restFacetCfg = omit$1(options, [
    "type",
    "data",
    "fields",
    "eachView",
    "axes",
    "meta",
    "tooltip",
    "coordinate",
    "theme",
    "legend",
    "interactions",
    "annotations"
  ]);
  chart.data(data2);
  chart.facet(facetType, __assign$1(__assign$1({}, restFacetCfg), { fields, eachView: function(viewOfG2, facet) {
    var viewOptions = eachView(viewOfG2, facet);
    if (viewOptions.geometries) {
      execViewAdaptor(viewOfG2, viewOptions);
    } else {
      var plot = viewOptions;
      var plotOptions = plot.options;
      if (plotOptions.tooltip) {
        viewOfG2.interaction("tooltip");
      }
      execPlotAdaptor(plot.type, viewOfG2, plotOptions);
    }
  } }));
  return params;
}
function component(params) {
  var chart = params.chart, options = params.options;
  var axes = options.axes, meta2 = options.meta, tooltip2 = options.tooltip, coordinate2 = options.coordinate, theme2 = options.theme, legend2 = options.legend, interactions = options.interactions, annotations = options.annotations;
  var scales = {};
  if (axes) {
    each$1(axes, function(axis2, field2) {
      scales[field2] = pick(axis2, AXIS_META_CONFIG_KEYS);
    });
  }
  scales = deepAssign({}, meta2, scales);
  chart.scale(scales);
  chart.coordinate(coordinate2);
  if (!axes) {
    chart.axis(false);
  } else {
    each$1(axes, function(axis2, field2) {
      chart.axis(field2, axis2);
    });
  }
  if (tooltip2) {
    chart.interaction("tooltip");
    chart.tooltip(tooltip2);
  } else if (tooltip2 === false) {
    chart.removeInteraction("tooltip");
  }
  chart.legend(legend2);
  if (theme2) {
    chart.theme(theme2);
  }
  each$1(interactions, function(interaction2) {
    if (interaction2.enable === false) {
      chart.removeInteraction(interaction2.type);
    } else {
      chart.interaction(interaction2.type, interaction2.cfg);
    }
  });
  each$1(annotations, function(annotation2) {
    chart.annotation()[annotation2.type](__assign$1({}, annotation2));
  });
  return params;
}
function adaptor(params) {
  return flow(theme$2, facetAdaptor, component)(params);
}
var DEFAULT_OPTIONS = {
  title: {
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.65)"
    }
  },
  rowTitle: {
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.65)"
    }
  },
  columnTitle: {
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.65)"
    }
  }
};
(function(_super) {
  __extends$2(Facet2, _super);
  function Facet2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "area";
    return _this;
  }
  Facet2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS;
  };
  Facet2.prototype.getDefaultOptions = function() {
    return Facet2.getDefaultOptions();
  };
  Facet2.prototype.getSchemaAdaptor = function() {
    return adaptor;
  };
  return Facet2;
})(Plot);
var Stage;
(function(Stage2) {
  Stage2["DEV"] = "DEV";
  Stage2["BETA"] = "BETA";
  Stage2["STABLE"] = "STABLE";
})(Stage || (Stage = {}));
function notice(stage, plotType) {
  console.warn(stage === Stage.DEV ? "Plot '" + plotType + "' is in DEV stage, just give us issues." : stage === Stage.BETA ? "Plot '" + plotType + "' is in BETA stage, DO NOT use it in production env." : stage === Stage.STABLE ? "Plot '" + plotType + `' is in STABLE stage, import it by "import { ` + plotType + ` } from '@antv/g2plot'".` : "invalid Stage type.");
}
(function() {
  function Lab() {
  }
  Object.defineProperty(Lab, "MultiView", {
    get: function() {
      notice(Stage.STABLE, "MultiView");
      return Mix;
    },
    enumerable: false,
    configurable: true
  });
  return Lab;
})();
registerLocale("en-US", EN_US_LOCALE);
registerLocale("zh-CN", ZH_CN_LOCALE);
export { Chart as C, Liquid as L, measureTextWidth as m };
